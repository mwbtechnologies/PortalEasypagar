(self.webpackChunkyoha = self.webpackChunkyoha || []).push([[179], { 6217: (un, Je, L) => { "use strict"; L.d(Je, { nm: () => Ti }); var i = L(2122); L(4650), L(259); var ct = L(5861), Oe = L(9681), Ve = L(4859), Be = L(2090), nt = L(1877); const Ne = new Map, tt = { activated: !1, tokenObservers: [] }, Fe = { initialized: !1, enabled: !1 }; function Ue(ft) { return Ne.get(ft) || Object.assign({}, tt) } function ht() { return Fe } class fn { constructor(dt, Mt, hn, Sn, Yn) { if (this.operation = dt, this.retryPolicy = Mt, this.getWaitDuration = hn, this.lowerBound = Sn, this.upperBound = Yn, this.pending = null, this.nextErrorWaitInterval = Sn, Sn > Yn) throw new Error("Proactive refresh lower bound greater than upper bound!") } start() { this.nextErrorWaitInterval = this.lowerBound, this.process(!0).catch(() => { }) } stop() { this.pending && (this.pending.reject("cancelled"), this.pending = null) } isRunning() { return !!this.pending } process(dt) { var Mt = this; return (0, ct.Z)(function* () { Mt.stop(); try { Mt.pending = new Be.BH, yield function It(ft) { return new Promise(dt => { setTimeout(dt, ft) }) }(Mt.getNextRun(dt)), Mt.pending.resolve(), yield Mt.pending.promise, Mt.pending = new Be.BH, yield Mt.operation(), Mt.pending.resolve(), yield Mt.pending.promise, Mt.process(!0).catch(() => { }) } catch (hn) { Mt.retryPolicy(hn) ? Mt.process(!1).catch(() => { }) : Mt.stop() } })() } getNextRun(dt) { if (dt) return this.nextErrorWaitInterval = this.lowerBound, this.getWaitDuration(); { const Mt = this.nextErrorWaitInterval; return this.nextErrorWaitInterval *= 2, this.nextErrorWaitInterval > this.upperBound && (this.nextErrorWaitInterval = this.upperBound), Mt } } } const pt = new Be.LL("appCheck", "AppCheck", { "already-initialized": "You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.", "use-before-activation": "App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Masterservices.", "fetch-network-error": "Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", "fetch-parse-error": "Fetch client could not parse response. Original error: {$originalErrorMessage}.", "fetch-status-error": "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", "storage-open": "Error thrown when opening storage. Original error: {$originalErrorMessage}.", "storage-get": "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", "storage-set": "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", "recaptcha-error": "ReCAPTCHA error.", throttled: "Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}" }); function Ze(ft) { if (!Ue(ft).activated) throw pt.create("use-before-activation", { appName: ft.name }) } function Xe(ft, dt) { return kt.apply(this, arguments) } function kt() { return (kt = (0, ct.Z)(function* ({ url: ft, body: dt }, Mt) { const hn = { "Content-Type": "application/json" }, Sn = Mt.getImmediate({ optional: !0 }); if (Sn) { const Ds = yield Sn.getHeartbeatsHeader(); Ds && (hn["X-Firebase-Client"] = Ds) } const Yn = { method: "POST", body: JSON.stringify(dt), headers: hn }; let lr, wr; try { lr = yield fetch(ft, Yn) } catch (Ds) { throw pt.create("fetch-network-error", { originalErrorMessage: Ds?.message }) } if (200 !== lr.status) throw pt.create("fetch-status-error", { httpStatus: lr.status }); try { wr = yield lr.json() } catch (Ds) { throw pt.create("fetch-parse-error", { originalErrorMessage: Ds?.message }) } const Vr = wr.ttl.match(/^([\d.]+)(s)$/); if (!Vr || !Vr[2] || isNaN(Number(Vr[1]))) throw pt.create("fetch-parse-error", { originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration format: ${wr.ttl}` }); const Ai = 1e3 * Number(Vr[1]), Ts = Date.now(); return { token: wr.token, expireTimeMillis: Ts + Ai, issuedAtTimeMillis: Ts } })).apply(this, arguments) } function wn(ft, dt) { const { projectId: Mt, appId: hn, apiKey: Sn } = ft.options; return { url: `https://content-firebaseappcheck.googleapis.com/v1/projects/${Mt}/apps/${hn}:exchangeDebugToken?key=${Sn}`, body: { debug_token: dt } } } const Ht = "firebase-app-check-store"; let ue = null; function it() { return ue || (ue = new Promise((ft, dt) => { try { const Mt = indexedDB.open("firebase-app-check-database", 1); Mt.onsuccess = hn => { ft(hn.target.result) }, Mt.onerror = hn => { var Sn; dt(pt.create("storage-open", { originalErrorMessage: null === (Sn = hn.target.error) || void 0 === Sn ? void 0 : Sn.message })) }, Mt.onupgradeneeded = hn => { 0 === hn.oldVersion && hn.target.result.createObjectStore(Ht, { keyPath: "compositeKey" }) } } catch (Mt) { dt(pt.create("storage-open", { originalErrorMessage: Mt?.message })) } }), ue) } function pn() { return (pn = (0, ct.Z)(function* (ft, dt) { const hn = (yield it()).transaction(Ht, "readwrite"), Yn = hn.objectStore(Ht).put({ compositeKey: ft, value: dt }); return new Promise((lr, wr) => { Yn.onsuccess = Vr => { lr() }, hn.onerror = Vr => { var Ai; wr(pt.create("storage-set", { originalErrorMessage: null === (Ai = Vr.target.error) || void 0 === Ai ? void 0 : Ai.message })) } }) })).apply(this, arguments) } const ur = new nt.Yd("@firebase/app-check"); function vr(ft, dt) { return (0, Be.hl)() ? function Nt(ft, dt) { return function _r(ft, dt) { return pn.apply(this, arguments) }(function Qn(ft) { return `${ft.options.appId}-${ft.name}` }(ft), dt) }(ft, dt).catch(Mt => { ur.warn(`Failed to write token to IndexedDB. Error: ${Mt}`) }) : Promise.resolve() } function Ae() { return ht().enabled } function Et() { return Gt.apply(this, arguments) } function Gt() { return (Gt = (0, ct.Z)(function* () { const ft = ht(); if (ft.enabled && ft.token) return ft.token.promise; throw Error("\n            Can't get debug token in production mode.\n        ") })).apply(this, arguments) } const sn = { error: "UNKNOWN_ERROR" }; function Bt(ft) { return Be.US.encodeString(JSON.stringify(ft), !1) } function vt(ft) { return Le.apply(this, arguments) } function Le() { return (Le = (0, ct.Z)(function* (ft, dt = !1) { const Mt = ft.app; Ze(Mt); const hn = Ue(Mt); let Yn, Sn = hn.token; if (Sn && !Lt(Sn) && (hn.token = void 0, Sn = void 0), !Sn) { const Vr = yield hn.cachedTokenPromise; Vr && (Lt(Vr) ? Sn = Vr : yield vr(Mt, void 0)) } if (!dt && Sn && Lt(Sn)) return { token: Sn.token }; let wr, lr = !1; if (Ae()) { hn.exchangeTokenPromise || (hn.exchangeTokenPromise = Xe(wn(Mt, yield Et()), ft.heartbeatServiceProvider).finally(() => { hn.exchangeTokenPromise = void 0 }), lr = !0); const Vr = yield hn.exchangeTokenPromise; return yield vr(Mt, Vr), hn.token = Vr, { token: Vr.token } } try { hn.exchangeTokenPromise || (hn.exchangeTokenPromise = hn.provider.getToken().finally(() => { hn.exchangeTokenPromise = void 0 }), lr = !0), Sn = yield Ue(Mt).exchangeTokenPromise } catch (Vr) { "appCheck/throttled" === Vr.code ? ur.warn(Vr.message) : ur.error(Vr), Yn = Vr } return Sn ? Yn ? wr = Lt(Sn) ? { token: Sn.token, internalError: Yn } : mt(Yn) : (wr = { token: Sn.token }, hn.token = Sn, yield vr(Mt, Sn)) : wr = mt(Yn), lr && et(Mt, wr), wr })).apply(this, arguments) } function Zt(ft, dt) { const Mt = Ue(ft), hn = Mt.tokenObservers.filter(Sn => Sn.next !== dt); 0 === hn.length && Mt.tokenRefresher && Mt.tokenRefresher.isRunning() && Mt.tokenRefresher.stop(), Mt.tokenObservers = hn } function fe(ft) { const { app: dt } = ft, Mt = Ue(dt); let hn = Mt.tokenRefresher; hn || (hn = function ke(ft) { const { app: dt } = ft; return new fn((0, ct.Z)(function* () { let hn; if (hn = Ue(dt).token ? yield vt(ft, !0) : yield vt(ft), hn.error) throw hn.error; if (hn.internalError) throw hn.internalError }), () => !0, () => { const Mt = Ue(dt); if (Mt.token) { let hn = Mt.token.issuedAtTimeMillis + .5 * (Mt.token.expireTimeMillis - Mt.token.issuedAtTimeMillis) + 3e5; return hn = Math.min(hn, Mt.token.expireTimeMillis - 3e5), Math.max(0, hn - Date.now()) } return 0 }, 3e4, 96e4) }(ft), Mt.tokenRefresher = hn), !hn.isRunning() && Mt.isTokenAutoRefreshEnabled && hn.start() } function et(ft, dt) { const Mt = Ue(ft).tokenObservers; for (const hn of Mt) try { "EXTERNAL" === hn.type && null != dt.error ? hn.error(dt.error) : hn.next(dt) } catch { } } function Lt(ft) { return ft.expireTimeMillis - Date.now() > 0 } function mt(ft) { return { token: Bt(sn), error: ft } } class An { constructor(dt, Mt) { this.app = dt, this.heartbeatServiceProvider = Mt } _delete() { const { tokenObservers: dt } = Ue(this.app); for (const Mt of dt) Zt(this.app, Mt.next); return Promise.resolve() } } const pr = "app-check-internal"; !function ni() { (0, Oe._registerComponent)(new Ve.wA("app-check", ft => function ar(ft, dt) { return new An(ft, dt) }(ft.getProvider("app").getImmediate(), ft.getProvider("heartbeat")), "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((ft, dt, Mt) => { ft.getProvider(pr).initialize() })), (0, Oe._registerComponent)(new Ve.wA(pr, ft => function sr(ft) { return { getToken: dt => vt(ft, dt), addTokenListener: dt => function qe(ft, dt, Mt, hn) { const { app: Sn } = ft, Yn = Ue(Sn); if (Yn.tokenObservers = [...Yn.tokenObservers, { next: Mt, error: hn, type: dt }], Yn.token && Lt(Yn.token)) { const wr = Yn.token; Promise.resolve().then(() => { Mt({ token: wr.token }), fe(ft) }).catch(() => { }) } Yn.cachedTokenPromise.then(() => fe(ft)) }(ft, "INTERNAL", dt), removeTokenListener: dt => Zt(ft.app, dt) } }(ft.getProvider("app-check").getImmediate()), "PUBLIC").setInstantiationMode("EXPLICIT")), (0, Oe.registerVersion)("@firebase/app-check", "0.6.0") }(); class Ti { constructor() { return (0, i.vb)("app-check") } } typeof window < "u" && window }, 948: (un, Je, L) => { "use strict"; L.d(Je, { L6: () => Oe, Qv: () => ct, _Q: () => Ve, f7: () => Ne, lh: () => nt, nw: () => tt, rT: () => Be, ww: () => Ue, zQ: () => Fe }); var i = L(4650), m = L(7579), J = L(9646), ye = L(9751), Ce = L(8996), we = L(6451), Te = L(5363), Ee = L(3900), _e = L(4004), ae = L(4782), ve = L(590), xe = L(6304), gt = L(9468), Se = L(9300), rt = L(2122), wt = L(2011), De = L(6895), je = L(6217), _t = L(9260); const ct = new i.OlP("angularfire2.auth.use-emulator"), Oe = new i.OlP("angularfire2.auth.settings"), Ve = new i.OlP("angularfire2.auth.tenant-id"), Be = new i.OlP("angularfire2.auth.langugage-code"), nt = new i.OlP("angularfire2.auth.use-device-language"), Ne = new i.OlP("angularfire.auth.persistence"), tt = (st, ht, Kt, rn, On, qn, nr, kn) => (0, wt.cc)(`${st.name}.auth`, "AngularFireAuth", st.name, () => { const fn = ht.runOutsideAngular(() => st.auth()); if (Kt && fn.useEmulator(...Kt), rn && (fn.tenantId = rn), fn.languageCode = On, qn && fn.useDeviceLanguage(), nr) for (const [It, Yt] of Object.entries(nr)) fn.settings[It] = Yt; return kn && fn.setPersistence(kn), fn }, [Kt, rn, On, qn, nr, kn]); let Fe = (() => { class st { constructor(Kt, rn, On, qn, nr, kn, fn, It, Yt, pt, Pt, Ze) { const Ot = new m.x, le = (0, J.of)(void 0).pipe((0, Te.Q)(nr.outsideAngular), (0, Ee.w)(() => qn.runOutsideAngular(() => Promise.resolve().then(L.bind(L, 9169)))), (0, _e.U)(() => (0, wt.on)(Kt, qn, rn)), (0, _e.U)(Xe => tt(Xe, qn, kn, It, Yt, pt, fn, Pt)), (0, ae.d)({ bufferSize: 1, refCount: !1 })); if ((0, De.PM)(On)) this.authState = this.user = this.idToken = this.idTokenResult = this.credential = (0, J.of)(null); else { le.pipe((0, ve.P)()).subscribe(); const kt = le.pipe((0, Ee.w)(wn => wn.getRedirectResult().then(Jn => Jn, () => null)), rt.iC, (0, ae.d)({ bufferSize: 1, refCount: !1 })), an = le.pipe((0, Ee.w)(wn => new ye.y(Jn => ({ unsubscribe: qn.runOutsideAngular(() => wn.onAuthStateChanged(or => Jn.next(or), or => Jn.error(or), () => Jn.complete())) })))), jt = le.pipe((0, Ee.w)(wn => new ye.y(Jn => ({ unsubscribe: qn.runOutsideAngular(() => wn.onIdTokenChanged(or => Jn.next(or), or => Jn.error(or), () => Jn.complete())) })))); this.authState = kt.pipe((0, xe.c)(an), (0, gt.R)(nr.outsideAngular), (0, Te.Q)(nr.insideAngular)), this.user = kt.pipe((0, xe.c)(jt), (0, gt.R)(nr.outsideAngular), (0, Te.Q)(nr.insideAngular)), this.idToken = this.user.pipe((0, Ee.w)(wn => wn ? (0, Ce.D)(wn.getIdToken()) : (0, J.of)(null))), this.idTokenResult = this.user.pipe((0, Ee.w)(wn => wn ? (0, Ce.D)(wn.getIdTokenResult()) : (0, J.of)(null))), this.credential = (0, we.T)(kt, Ot, this.authState.pipe((0, Se.h)(wn => !wn))).pipe((0, _e.U)(wn => wn?.user ? wn : null), (0, gt.R)(nr.outsideAngular), (0, Te.Q)(nr.insideAngular)) } return (0, wt.pX)(this, le, qn, { spy: { apply: (Xe, kt, an) => { (Xe.startsWith("signIn") || Xe.startsWith("createUser")) && an.then(jt => Ot.next(jt)) } } }) } } return st.\u0275fac = function (Kt) { return new (Kt || st)(i.LFG(wt.Dh), i.LFG(wt.xv, 8), i.LFG(i.Lbi), i.LFG(i.R0b), i.LFG(rt.HU), i.LFG(ct, 8), i.LFG(Oe, 8), i.LFG(Ve, 8), i.LFG(Be, 8), i.LFG(nt, 8), i.LFG(Ne, 8), i.LFG(je.nm, 8)) }, st.\u0275prov = i.Yz7({ token: st, factory: st.\u0275fac, providedIn: "any" }), st })(), Ue = (() => { class st { constructor() { _t.Z.registerVersion("angularfire", rt.q4.full, "auth-compat") } } return st.\u0275fac = function (Kt) { return new (Kt || st) }, st.\u0275mod = i.oAB({ type: st }), st.\u0275inj = i.cJS({ providers: [Fe] }), st })() }, 2011: (un, Je, L) => { "use strict"; L.d(Je, { Dh: () => Ee, GT: () => we, cc: () => Se, hO: () => gt, on: () => ae, pX: () => Ce, xv: () => _e }); var i = L(4650), m = L(9260), J = L(2122); un = L.hmd(un); const ye = ["ngOnDestroy"], Ce = (je, _t, Qe, ct = {}) => new Proxy(je, { get: (Oe, Ve) => Qe.runOutsideAngular(() => { var Be; if (je[Ve]) return !(null === (Be = ct?.spy) || void 0 === Be) && Be.get && ct.spy.get(Ve, je[Ve]), je[Ve]; if (ye.indexOf(Ve) > -1) return () => { }; const nt = _t.toPromise().then(Ne => { const tt = Ne && Ne[Ve]; return "function" == typeof tt ? tt.bind(Ne) : tt && tt.then ? tt.then(Fe => Qe.run(() => Fe)) : Qe.run(() => tt) }); return new Proxy(() => { }, { get: (Ne, tt) => nt[tt], apply: (Ne, tt, Fe) => nt.then(Ue => { var st; const ht = Ue && Ue(...Fe); return !(null === (st = ct?.spy) || void 0 === st) && st.apply && ct.spy.apply(Ve, Fe, ht), ht }) }) }) }), we = (je, _t) => { _t.forEach(Qe => { Object.getOwnPropertyNames(Qe.prototype || Qe).forEach(ct => { Object.defineProperty(je.prototype, ct, Object.getOwnPropertyDescriptor(Qe.prototype || Qe, ct)) }) }) }; class Te { constructor(_t) { return _t } } const Ee = new i.OlP("angularfire2.app.options"), _e = new i.OlP("angularfire2.app.name"); function ae(je, _t, Qe) { const Oe = "object" == typeof Qe && Qe || {}; Oe.name = Oe.name || "string" == typeof Qe && Qe || "[DEFAULT]"; const Be = m.Z.apps.filter(nt => nt && nt.name === Oe.name)[0] || _t.runOutsideAngular(() => m.Z.initializeApp(je, Oe)); try { JSON.stringify(je) !== JSON.stringify(Be.options) && ve("error", `${Be.name} MasterApp already initialized with different options${un.hot ? ", you may need to reload as Masteris not HMR aware." : "."}`) } catch { } return new Te(Be) } const ve = (je, ..._t) => { (0, i.X6Q)() && typeof console < "u" && console[je](..._t) }, xe = { provide: Te, useFactory: ae, deps: [Ee, i.R0b, [new i.FiY, _e]] }; let gt = (() => { class je { constructor(Qe) { m.Z.registerVersion("angularfire", J.q4.full, "core"), m.Z.registerVersion("angularfire", J.q4.full, "app-compat"), m.Z.registerVersion("angular", i.q4F.full, Qe.toString()) } static initializeApp(Qe, ct) { return { ngModule: je, providers: [{ provide: Ee, useValue: Qe }, { provide: _e, useValue: ct }] } } } return je.\u0275fac = function (Qe) { return new (Qe || je)(i.LFG(i.Lbi)) }, je.\u0275mod = i.oAB({ type: je }), je.\u0275inj = i.cJS({ providers: [xe] }), je })(); function Se(je, _t, Qe, ct, Oe) { const [, Ve, Be] = globalThis.\u0275AngularfireInstanceCache.find(nt => nt[0] === je) || []; if (Ve) return function rt(je, _t) { try { return je.toString() === _t.toString() } catch { return je === _t } }(Oe, Be) || (De("error", `${_t} was already initialized on the ${Qe} MasterApp with different settings.${wt ? " You may need to reload as Masteris not HMR aware." : ""}`), De("warn", { is: Oe, was: Be })), Ve; { const nt = ct(); return globalThis.\u0275AngularfireInstanceCache.push([je, nt, Oe]), nt } } const wt = !!un.hot, De = (je, ..._t) => { (0, i.X6Q)() && typeof console < "u" && console[je](..._t) }; globalThis.\u0275AngularfireInstanceCache || (globalThis.\u0275AngularfireInstanceCache = []) }, 2122: (un, Je, L) => { "use strict"; L.d(Je, { q4: () => V, iC: () => aa, HU: () => bu, vb: () => Sr, JM: () => Gr }); var i = L(4650), m = L(259), J = L(5861), ye = L(9681), Ce = L(2090), we = L(4859), Te = L(1877), Ee = L(8766); const _e = "@firebase/installations", ae = "0.6.0", xe = `w:${ae}`, gt = "FIS_v2", _t = new Ce.LL("installations", "Installations", { "missing-app-config-values": 'Missing App configuration value: "{$valueName}"', "not-registered": "MasterInstallation is not registered.", "installation-not-found": "MasterInstallation not found.", "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"', "app-offline": "Could not process request. Application offline.", "delete-pending-registration": "Can't delete installation while there is a pending registration request." }); function Qe(W) { return W instanceof Ce.ZR && W.code.includes("request-failed") } function ct({ projectId: W }) { return `https://firebaseinstallations.googleapis.com/v1/projects/${W}/installations` } function Oe(W) { return { token: W.token, requestStatus: 2, expiresIn: Ue(W.expiresIn), creationTime: Date.now() } } function Ve(W, ee) { return Be.apply(this, arguments) } function Be() { return (Be = (0, J.Z)(function* (W, ee) { const We = (yield ee.json()).error; return _t.create("request-failed", { requestName: W, serverCode: We.code, serverMessage: We.message, serverStatus: We.status }) })).apply(this, arguments) } function nt({ apiKey: W }) { return new Headers({ "Content-Type": "application/json", Accept: "application/json", "x-goog-api-key": W }) } function Ne(W, { refreshToken: ee }) { const de = nt(W); return de.append("Authorization", function st(W) { return `${gt} ${W}` }(ee)), de } function tt(W) { return Fe.apply(this, arguments) } function Fe() { return (Fe = (0, J.Z)(function* (W) { const ee = yield W(); return ee.status >= 500 && ee.status < 600 ? W() : ee })).apply(this, arguments) } function Ue(W) { return Number(W.replace("s", "000")) } function ht(W, ee) { return Kt.apply(this, arguments) } function Kt() { return (Kt = (0, J.Z)(function* ({ appConfig: W, heartbeatServiceProvider: ee }, { fid: de }) { const We = ct(W), xt = nt(W), zt = ee.getImmediate({ optional: !0 }); if (zt) { const ir = yield zt.getHeartbeatsHeader(); ir && xt.append("x-firebase-client", ir) } const jn = { method: "POST", headers: xt, body: JSON.stringify({ fid: de, authVersion: gt, appId: W.appId, sdkVersion: xe }) }, er = yield tt(() => fetch(We, jn)); if (er.ok) { const ir = yield er.json(); return { fid: ir.fid || de, registrationStatus: 2, refreshToken: ir.refreshToken, authToken: Oe(ir.authToken) } } throw yield Ve("Create Installation", er) })).apply(this, arguments) } function rn(W) { return new Promise(ee => { setTimeout(ee, W) }) } const qn = /^[cdef][\w-]{21}$/; function kn() { try { const W = new Uint8Array(17); (self.crypto || self.msCrypto).getRandomValues(W), W[0] = 112 + W[0] % 16; const de = function fn(W) { return function On(W) { return btoa(String.fromCharCode(...W)).replace(/\+/g, "-").replace(/\//g, "_") }(W).substr(0, 22) }(W); return qn.test(de) ? de : "" } catch { return "" } } function It(W) { return `${W.appName}!${W.appId}` } const Yt = new Map; function pt(W, ee) { const de = It(W); Ot(de, ee), function le(W, ee) { const de = function kt() { return !Xe && "BroadcastChannel" in self && (Xe = new BroadcastChannel("[Firebase] FID Change"), Xe.onmessage = W => { Ot(W.data.key, W.data.fid) }), Xe }(); de && de.postMessage({ key: W, fid: ee }), function an() { 0 === Yt.size && Xe && (Xe.close(), Xe = null) }() }(de, ee) } function Ot(W, ee) { const de = Yt.get(W); if (de) for (const We of de) We(ee) } let Xe = null; const Jn = "firebase-installations-store"; let or = null; function Ht() { return or || (or = (0, Ee.X3)("firebase-installations-database", 1, { upgrade: (W, ee) => { 0 === ee && W.createObjectStore(Jn) } })), or } function dn(W, ee) { return ue.apply(this, arguments) } function ue() { return (ue = (0, J.Z)(function* (W, ee) { const de = It(W), xt = (yield Ht()).transaction(Jn, "readwrite"), zt = xt.objectStore(Jn), _n = yield zt.get(de); return yield zt.put(ee, de), yield xt.done, (!_n || _n.fid !== ee.fid) && pt(W, ee.fid), ee })).apply(this, arguments) } function it(W) { return lt.apply(this, arguments) } function lt() { return (lt = (0, J.Z)(function* (W) { const ee = It(W), We = (yield Ht()).transaction(Jn, "readwrite"); yield We.objectStore(Jn).delete(ee), yield We.done })).apply(this, arguments) } function Nt(W, ee) { return gn.apply(this, arguments) } function gn() { return (gn = (0, J.Z)(function* (W, ee) { const de = It(W), xt = (yield Ht()).transaction(Jn, "readwrite"), zt = xt.objectStore(Jn), _n = yield zt.get(de), jn = ee(_n); return void 0 === jn ? yield zt.delete(de) : yield zt.put(jn, de), yield xt.done, jn && (!_n || _n.fid !== jn.fid) && pt(W, jn.fid), jn })).apply(this, arguments) } function Hn(W) { return _r.apply(this, arguments) } function _r() { return (_r = (0, J.Z)(function* (W) { let ee; const de = yield Nt(W.appConfig, We => { const xt = pn(We), zt = Fn(W, xt); return ee = zt.registrationPromise, zt.installationEntry }); return "" === de.fid ? { installationEntry: yield ee } : { installationEntry: de, registrationPromise: ee } })).apply(this, arguments) } function pn(W) { return vr(W || { fid: kn(), registrationStatus: 0 }) } function Fn(W, ee) { if (0 === ee.registrationStatus) { if (!navigator.onLine) return { installationEntry: ee, registrationPromise: Promise.reject(_t.create("app-offline")) }; const de = { fid: ee.fid, registrationStatus: 1, registrationTime: Date.now() }, We = function yn(W, ee) { return Qn.apply(this, arguments) }(W, de); return { installationEntry: de, registrationPromise: We } } return 1 === ee.registrationStatus ? { installationEntry: ee, registrationPromise: ur(W) } : { installationEntry: ee } } function Qn() { return (Qn = (0, J.Z)(function* (W, ee) { try { const de = yield ht(W, ee); return dn(W.appConfig, de) } catch (de) { throw Qe(de) && 409 === de.customData.serverCode ? yield it(W.appConfig) : yield dn(W.appConfig, { fid: ee.fid, registrationStatus: 0 }), de } })).apply(this, arguments) } function ur(W) { return dr.apply(this, arguments) } function dr() { return (dr = (0, J.Z)(function* (W) { let ee = yield Kr(W.appConfig); for (; 1 === ee.registrationStatus;)yield rn(100), ee = yield Kr(W.appConfig); if (0 === ee.registrationStatus) { const { installationEntry: de, registrationPromise: We } = yield Hn(W); return We || de } return ee })).apply(this, arguments) } function Kr(W) { return Nt(W, ee => { if (!ee) throw _t.create("installation-not-found"); return vr(ee) }) } function vr(W) { return function At(W) { return 1 === W.registrationStatus && W.registrationTime + 1e4 < Date.now() }(W) ? { fid: W.fid, registrationStatus: 0 } : W } function ln(W, ee) { return Ae.apply(this, arguments) } function Ae() { return (Ae = (0, J.Z)(function* ({ appConfig: W, heartbeatServiceProvider: ee }, de) { const We = Et(W, de), xt = Ne(W, de), zt = ee.getImmediate({ optional: !0 }); if (zt) { const ir = yield zt.getHeartbeatsHeader(); ir && xt.append("x-firebase-client", ir) } const jn = { method: "POST", headers: xt, body: JSON.stringify({ installation: { sdkVersion: xe, appId: W.appId } }) }, er = yield tt(() => fetch(We, jn)); if (er.ok) return Oe(yield er.json()); throw yield Ve("Generate Auth Token", er) })).apply(this, arguments) } function Et(W, { fid: ee }) { return `${ct(W)}/${ee}/authTokens:generate` } function Gt(W) { return bn.apply(this, arguments) } function bn() { return (bn = (0, J.Z)(function* (W, ee = !1) { let de; const We = yield Nt(W.appConfig, zt => { if (!Zt(zt)) throw _t.create("not-registered"); const _n = zt.authToken; if (!ee && fe(_n)) return zt; if (1 === _n.requestStatus) return de = sn(W, ee), zt; { if (!navigator.onLine) throw _t.create("app-offline"); const jn = et(zt); return de = Le(W, jn), jn } }); return de ? yield de : We.authToken })).apply(this, arguments) } function sn(W, ee) { return Bt.apply(this, arguments) } function Bt() { return (Bt = (0, J.Z)(function* (W, ee) { let de = yield vt(W.appConfig); for (; 1 === de.authToken.requestStatus;)yield rn(100), de = yield vt(W.appConfig); const We = de.authToken; return 0 === We.requestStatus ? Gt(W, ee) : We })).apply(this, arguments) } function vt(W) { return Nt(W, ee => { if (!Zt(ee)) throw _t.create("not-registered"); return function Lt(W) { return 1 === W.requestStatus && W.requestTime + 1e4 < Date.now() }(ee.authToken) ? Object.assign(Object.assign({}, ee), { authToken: { requestStatus: 0 } }) : ee }) } function Le(W, ee) { return qe.apply(this, arguments) } function qe() { return (qe = (0, J.Z)(function* (W, ee) { try { const de = yield ln(W, ee), We = Object.assign(Object.assign({}, ee), { authToken: de }); return yield dn(W.appConfig, We), de } catch (de) { if (!Qe(de) || 401 !== de.customData.serverCode && 404 !== de.customData.serverCode) { const We = Object.assign(Object.assign({}, ee), { authToken: { requestStatus: 0 } }); yield dn(W.appConfig, We) } else yield it(W.appConfig); throw de } })).apply(this, arguments) } function Zt(W) { return void 0 !== W && 2 === W.registrationStatus } function fe(W) { return 2 === W.requestStatus && !function ke(W) { const ee = Date.now(); return ee < W.creationTime || W.creationTime + W.expiresIn < ee + 36e5 }(W) } function et(W) { const ee = { requestStatus: 1, requestTime: Date.now() }; return Object.assign(Object.assign({}, W), { authToken: ee }) } function An() { return (An = (0, J.Z)(function* (W) { const ee = W, { installationEntry: de, registrationPromise: We } = yield Hn(ee); return We ? We.catch(console.error) : Gt(ee).catch(console.error), de.fid })).apply(this, arguments) } function sr() { return (sr = (0, J.Z)(function* (W, ee = !1) { const de = W; return yield Fr(de), (yield Gt(de, ee)).token })).apply(this, arguments) } function Fr(W) { return ze.apply(this, arguments) } function ze() { return (ze = (0, J.Z)(function* (W) { const { registrationPromise: ee } = yield Hn(W); ee && (yield ee) })).apply(this, arguments) } function ss(W) { return _t.create("missing-app-config-values", { valueName: W }) } const Ps = "installations", Dr = W => { const ee = W.getProvider("app").getImmediate(), de = function Br(W) { if (!W || !W.options) throw ss("App Configuration"); if (!W.name) throw ss("App Name"); const ee = ["projectId", "apiKey", "appId"]; for (const de of ee) if (!W.options[de]) throw ss(de); return { appName: W.name, projectId: W.options.projectId, apiKey: W.options.apiKey, appId: W.options.appId } }(ee); return { app: ee, appConfig: de, heartbeatServiceProvider: (0, ye._getProvider)(ee, "heartbeat"), _delete: () => Promise.resolve() } }, Bi = W => { const ee = W.getProvider("app").getImmediate(), de = (0, ye._getProvider)(ee, Ps).getImmediate(); return { getId: () => function mt(W) { return An.apply(this, arguments) }(de), getToken: xt => function ar(W) { return sr.apply(this, arguments) }(de, xt) } }; (function _a() { (0, ye._registerComponent)(new we.wA(Ps, Dr, "PUBLIC")), (0, ye._registerComponent)(new we.wA("installations-internal", Bi, "PRIVATE")) })(), (0, ye.registerVersion)(_e, ae), (0, ye.registerVersion)(_e, ae, "esm2017"); const ya = "@firebase/remote-config", Gi = new Ce.LL("remoteconfig", "Remote Config", { "registration-window": "Undefined window object. This SDK only supports usage in a browser environment.", "registration-project-id": "Undefined project identifier. Check Masterapp initialization.", "registration-api-key": "Undefined API key. Check Masterapp initialization.", "registration-app-id": "Undefined app identifier. Check Masterapp initialization.", "storage-open": "Error thrown when opening storage. Original error: {$originalErrorMessage}.", "storage-get": "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", "storage-set": "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", "storage-delete": "Error thrown when deleting from storage. Original error: {$originalErrorMessage}.", "fetch-client-network": "Fetch client failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", "fetch-timeout": 'The config fetch request timed out.  Configure timeout using "fetchTimeoutMillis" SDK setting.', "fetch-throttle": 'The config fetch request timed out while in an exponential backoff state. Configure timeout using "fetchTimeoutMillis" SDK setting. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.', "fetch-client-parse": "Fetch client could not parse response. Original error: {$originalErrorMessage}.", "fetch-status": "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", "indexed-db-unavailable": "Indexed DB is not supported by current browser" }); class no { constructor(ee, de, We, xt) { this.client = ee, this.storage = de, this.storageCache = We, this.logger = xt } isCachedDataFresh(ee, de) { if (!de) return this.logger.debug("Config fetch cache check. Cache unpopulated."), !1; const We = Date.now() - de, xt = We <= ee; return this.logger.debug(`Config fetch cache check. Cache age millis: ${We}. Cache max age millis (minimumFetchIntervalMillis setting): ${ee}. Is cache hit: ${xt}.`), xt } fetch(ee) { var de = this; return (0, J.Z)(function* () { const [We, xt] = yield Promise.all([de.storage.getLastSuccessfulFetchTimestampMillis(), de.storage.getLastSuccessfulFetchResponse()]); if (xt && de.isCachedDataFresh(ee.cacheMaxAgeMillis, We)) return xt; ee.eTag = xt && xt.eTag; const zt = yield de.client.fetch(ee), _n = [de.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())]; return 200 === zt.status && _n.push(de.storage.setLastSuccessfulFetchResponse(zt)), yield Promise.all(_n), zt })() } } function Fs(W = navigator) { return W.languages && W.languages[0] || W.language } class cs { constructor(ee, de, We, xt, zt, _n) { this.firebaseInstallations = ee, this.sdkVersion = de, this.namespace = We, this.projectId = xt, this.apiKey = zt, this.appId = _n } fetch(ee) { var de = this; return (0, J.Z)(function* () { const [We, xt] = yield Promise.all([de.firebaseInstallations.getId(), de.firebaseInstallations.getToken()]), _n = `${window.FIREBASE_REMOTE_CONFIG_URL_BASE || "https://firebaseremoteconfig.googleapis.com"}/v1/projects/${de.projectId}/namespaces/${de.namespace}:fetch?key=${de.apiKey}`, jn = { "Content-Type": "application/json", "Content-Encoding": "gzip", "If-None-Match": ee.eTag || "*" }, er = { sdk_version: de.sdkVersion, app_instance_id: We, app_instance_id_token: xt, app_id: de.appId, language_code: Fs() }, ir = { method: "POST", headers: jn, body: JSON.stringify(er) }, Ir = fetch(_n, ir), Pr = new Promise((nl, nc) => { ee.signal.addEventListener(() => { const eu = new Error("The operation was aborted."); eu.name = "AbortError", nc(eu) }) }); let ca; try { yield Promise.race([Ir, Pr]), ca = yield Ir } catch (nl) { let nc = "fetch-client-network"; throw "AbortError" === nl?.name && (nc = "fetch-timeout"), Gi.create(nc, { originalErrorMessage: nl?.message }) } let Ws = ca.status; const Vl = ca.headers.get("ETag") || void 0; let Uu, _l; if (200 === ca.status) { let nl; try { nl = yield ca.json() } catch (nc) { throw Gi.create("fetch-client-parse", { originalErrorMessage: nc?.message }) } Uu = nl.entries, _l = nl.state } if ("INSTANCE_STATE_UNSPECIFIED" === _l ? Ws = 500 : "NO_CHANGE" === _l ? Ws = 304 : ("NO_TEMPLATE" === _l || "EMPTY_CONFIG" === _l) && (Uu = {}), 304 !== Ws && 200 !== Ws) throw Gi.create("fetch-status", { httpStatus: Ws }); return { status: Ws, eTag: Vl, config: Uu } })() } } class dt { constructor(ee, de) { this.client = ee, this.storage = de } fetch(ee) { var de = this; return (0, J.Z)(function* () { const We = (yield de.storage.getThrottleMetadata()) || { backoffCount: 0, throttleEndTimeMillis: Date.now() }; return de.attemptFetch(ee, We) })() } attemptFetch(ee, { throttleEndTimeMillis: de, backoffCount: We }) { var xt = this; return (0, J.Z)(function* () { yield function ro(W, ee) { return new Promise((de, We) => { const xt = Math.max(ee - Date.now(), 0), zt = setTimeout(de, xt); W.addEventListener(() => { clearTimeout(zt), We(Gi.create("fetch-throttle", { throttleEndTimeMillis: ee })) }) }) }(ee.signal, de); try { const zt = yield xt.client.fetch(ee); return yield xt.storage.deleteThrottleMetadata(), zt } catch (zt) { if (!function ft(W) { if (!(W instanceof Ce.ZR && W.customData)) return !1; const ee = Number(W.customData.httpStatus); return 429 === ee || 500 === ee || 503 === ee || 504 === ee }(zt)) throw zt; const _n = { throttleEndTimeMillis: Date.now() + (0, Ce.$s)(We), backoffCount: We + 1 }; return yield xt.storage.setThrottleMetadata(_n), xt.attemptFetch(ee, _n) } })() } } class Sn { constructor(ee, de, We, xt, zt) { this.app = ee, this._client = de, this._storageCache = We, this._storage = xt, this._logger = zt, this._isInitializationComplete = !1, this.settings = { fetchTimeoutMillis: 6e4, minimumFetchIntervalMillis: 432e5 }, this.defaultConfig = {} } get fetchTimeMillis() { return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1 } get lastFetchStatus() { return this._storageCache.getLastFetchStatus() || "no-fetch-yet" } } function Yn(W, ee) { const de = W.target.error || void 0; return Gi.create(ee, { originalErrorMessage: de && de?.message }) } const lr = "app_namespace_store"; class Ts { constructor(ee, de, We, xt = function Ai() { return new Promise((W, ee) => { try { const de = indexedDB.open("firebase_remote_config", 1); de.onerror = We => { ee(Yn(We, "storage-open")) }, de.onsuccess = We => { W(We.target.result) }, de.onupgradeneeded = We => { 0 === We.oldVersion && We.target.result.createObjectStore(lr, { keyPath: "compositeKey" }) } } catch (de) { ee(Gi.create("storage-open", { originalErrorMessage: de?.message })) } }) }()) { this.appId = ee, this.appName = de, this.namespace = We, this.openDbPromise = xt } getLastFetchStatus() { return this.get("last_fetch_status") } setLastFetchStatus(ee) { return this.set("last_fetch_status", ee) } getLastSuccessfulFetchTimestampMillis() { return this.get("last_successful_fetch_timestamp_millis") } setLastSuccessfulFetchTimestampMillis(ee) { return this.set("last_successful_fetch_timestamp_millis", ee) } getLastSuccessfulFetchResponse() { return this.get("last_successful_fetch_response") } setLastSuccessfulFetchResponse(ee) { return this.set("last_successful_fetch_response", ee) } getActiveConfig() { return this.get("active_config") } setActiveConfig(ee) { return this.set("active_config", ee) } getActiveConfigEtag() { return this.get("active_config_etag") } setActiveConfigEtag(ee) { return this.set("active_config_etag", ee) } getThrottleMetadata() { return this.get("throttle_metadata") } setThrottleMetadata(ee) { return this.set("throttle_metadata", ee) } deleteThrottleMetadata() { return this.delete("throttle_metadata") } get(ee) { var de = this; return (0, J.Z)(function* () { const We = yield de.openDbPromise; return new Promise((xt, zt) => { const jn = We.transaction([lr], "readonly").objectStore(lr), er = de.createCompositeKey(ee); try { const ir = jn.get(er); ir.onerror = Ir => { zt(Yn(Ir, "storage-get")) }, ir.onsuccess = Ir => { const Pr = Ir.target.result; xt(Pr ? Pr.value : void 0) } } catch (ir) { zt(Gi.create("storage-get", { originalErrorMessage: ir?.message })) } }) })() } set(ee, de) { var We = this; return (0, J.Z)(function* () { const xt = yield We.openDbPromise; return new Promise((zt, _n) => { const er = xt.transaction([lr], "readwrite").objectStore(lr), ir = We.createCompositeKey(ee); try { const Ir = er.put({ compositeKey: ir, value: de }); Ir.onerror = Pr => { _n(Yn(Pr, "storage-set")) }, Ir.onsuccess = () => { zt() } } catch (Ir) { _n(Gi.create("storage-set", { originalErrorMessage: Ir?.message })) } }) })() } delete(ee) { var de = this; return (0, J.Z)(function* () { const We = yield de.openDbPromise; return new Promise((xt, zt) => { const jn = We.transaction([lr], "readwrite").objectStore(lr), er = de.createCompositeKey(ee); try { const ir = jn.delete(er); ir.onerror = Ir => { zt(Yn(Ir, "storage-delete")) }, ir.onsuccess = () => { xt() } } catch (ir) { zt(Gi.create("storage-delete", { originalErrorMessage: ir?.message })) } }) })() } createCompositeKey(ee) { return [this.appId, this.appName, this.namespace, ee].join() } } class Ds { constructor(ee) { this.storage = ee } getLastFetchStatus() { return this.lastFetchStatus } getLastSuccessfulFetchTimestampMillis() { return this.lastSuccessfulFetchTimestampMillis } getActiveConfig() { return this.activeConfig } loadFromStorage() { var ee = this; return (0, J.Z)(function* () { const de = ee.storage.getLastFetchStatus(), We = ee.storage.getLastSuccessfulFetchTimestampMillis(), xt = ee.storage.getActiveConfig(), zt = yield de; zt && (ee.lastFetchStatus = zt); const _n = yield We; _n && (ee.lastSuccessfulFetchTimestampMillis = _n); const jn = yield xt; jn && (ee.activeConfig = jn) })() } setLastFetchStatus(ee) { return this.lastFetchStatus = ee, this.storage.setLastFetchStatus(ee) } setLastSuccessfulFetchTimestampMillis(ee) { return this.lastSuccessfulFetchTimestampMillis = ee, this.storage.setLastSuccessfulFetchTimestampMillis(ee) } setActiveConfig(ee) { return this.activeConfig = ee, this.storage.setActiveConfig(ee) } } function bo() { return Jr.apply(this, arguments) } function Jr() { return (Jr = (0, J.Z)(function* () { if (!(0, Ce.hl)()) return !1; try { return yield (0, Ce.eu)() } catch { return !1 } })).apply(this, arguments) } !function gr() { (0, ye._registerComponent)(new we.wA("remote-config", function W(ee, { instanceIdentifier: de }) { const We = ee.getProvider("app").getImmediate(), xt = ee.getProvider("installations-internal").getImmediate(); if (typeof window > "u") throw Gi.create("registration-window"); if (!(0, Ce.hl)()) throw Gi.create("indexed-db-unavailable"); const { projectId: zt, apiKey: _n, appId: jn } = We.options; if (!zt) throw Gi.create("registration-project-id"); if (!_n) throw Gi.create("registration-api-key"); if (!jn) throw Gi.create("registration-app-id"); const er = new Ts(jn, We.name, de = de || "firebase"), ir = new Ds(er), Ir = new Te.Yd(ya); Ir.logLevel = Te.in.ERROR; const Pr = new cs(xt, ye.SDK_VERSION, de, zt, _n, jn), ca = new dt(Pr, er), Ws = new no(ca, er, ir, Ir), Vl = new Sn(We, Ws, ir, er, Ir); return function Di(W) { const ee = (0, Ce.m9)(W); ee._initializePromise || (ee._initializePromise = ee._storageCache.loadFromStorage().then(() => { ee._isInitializationComplete = !0 })) }(Vl), Vl }, "PUBLIC").setMultipleInstances(!0)), (0, ye.registerVersion)(ya, "0.4.0"), (0, ye.registerVersion)(ya, "0.4.0", "esm2017") }(); const Io = "/firebase-messaging-sw.js", Xn = "/firebase-cloud-messaging-push-scope", uo = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4", ka = "google.c.a.c_id", io = "google.c.a.c_l", Wl = "google.c.a.ts", zo = "google.c.a.e"; var Go = (() => { return (W = Go || (Go = {})).PUSH_RECEIVED = "push-received", W.NOTIFICATION_CLICKED = "notification-clicked", Go; var W })(); function so(W) { const ee = new Uint8Array(W); return btoa(String.fromCharCode(...ee)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_") } function jo(W) { const de = (W + "=".repeat((4 - W.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"), We = atob(de), xt = new Uint8Array(We.length); for (let zt = 0; zt < We.length; ++zt)xt[zt] = We.charCodeAt(zt); return xt } const na = "fcm_token_details_db", pi = "fcm_token_object_Store"; function Ss(W) { return $o.apply(this, arguments) } function $o() { return $o = (0, J.Z)(function* (W) { if ("databases" in indexedDB && !(yield indexedDB.databases()).map(zt => zt.name).includes(na)) return null; let ee = null; return (yield (0, Ee.X3)(na, 5, { upgrade: (We = (0, J.Z)(function* (xt, zt, _n, jn) { var er; if (zt < 2 || !xt.objectStoreNames.contains(pi)) return; const ir = jn.objectStore(pi), Ir = yield ir.index("fcmSenderId").get(W); if (yield ir.clear(), Ir) if (2 === zt) { const Pr = Ir; if (!Pr.auth || !Pr.p256dh || !Pr.endpoint) return; ee = { token: Pr.fcmToken, createTime: null !== (er = Pr.createTime) && void 0 !== er ? er : Date.now(), subscriptionOptions: { auth: Pr.auth, p256dh: Pr.p256dh, endpoint: Pr.endpoint, swScope: Pr.swScope, vapidKey: "string" == typeof Pr.vapidKey ? Pr.vapidKey : so(Pr.vapidKey) } } } else if (3 === zt) { const Pr = Ir; ee = { token: Pr.fcmToken, createTime: Pr.createTime, subscriptionOptions: { auth: so(Pr.auth), p256dh: so(Pr.p256dh), endpoint: Pr.endpoint, swScope: Pr.swScope, vapidKey: so(Pr.vapidKey) } } } else if (4 === zt) { const Pr = Ir; ee = { token: Pr.fcmToken, createTime: Pr.createTime, subscriptionOptions: { auth: so(Pr.auth), p256dh: so(Pr.p256dh), endpoint: Pr.endpoint, swScope: Pr.swScope, vapidKey: so(Pr.vapidKey) } } } }), function (zt, _n, jn, er) { return We.apply(this, arguments) }) })).close(), yield (0, Ee.Lj)(na), yield (0, Ee.Lj)("fcm_vapid_details_db"), yield (0, Ee.Lj)("undefined"), wo(ee) ? ee : null; var We }), $o.apply(this, arguments) } function wo(W) { if (!W || !W.subscriptionOptions) return !1; const { subscriptionOptions: ee } = W; return "number" == typeof W.createTime && W.createTime > 0 && "string" == typeof W.token && W.token.length > 0 && "string" == typeof ee.auth && ee.auth.length > 0 && "string" == typeof ee.p256dh && ee.p256dh.length > 0 && "string" == typeof ee.endpoint && ee.endpoint.length > 0 && "string" == typeof ee.swScope && ee.swScope.length > 0 && "string" == typeof ee.vapidKey && ee.vapidKey.length > 0 } const rs = "firebase-messaging-store"; let Is = null; function Wo() { return Is || (Is = (0, Ee.X3)("firebase-messaging-database", 1, { upgrade: (W, ee) => { 0 === ee && W.createObjectStore(rs) } })), Is } function Za(W) { return fo.apply(this, arguments) } function fo() { return (fo = (0, J.Z)(function* (W) { const ee = xo(W), We = yield (yield Wo()).transaction(rs).objectStore(rs).get(ee); if (We) return We; { const xt = yield Ss(W.appConfig.senderId); if (xt) return yield As(W, xt), xt } })).apply(this, arguments) } function As(W, ee) { return Pa.apply(this, arguments) } function Pa() { return (Pa = (0, J.Z)(function* (W, ee) { const de = xo(W), xt = (yield Wo()).transaction(rs, "readwrite"); return yield xt.objectStore(rs).put(ee, de), yield xt.done, ee })).apply(this, arguments) } function Ks(W) { return Ls.apply(this, arguments) } function Ls() { return (Ls = (0, J.Z)(function* (W) { const ee = xo(W), We = (yield Wo()).transaction(rs, "readwrite"); yield We.objectStore(rs).delete(ee), yield We.done })).apply(this, arguments) } function xo({ appConfig: W }) { return W.appId } const Ui = new Ce.LL("messaging", "Messaging", { "missing-app-config-values": 'Missing App configuration value: "{$valueName}"', "only-available-in-window": "This method is available in a Window context.", "only-available-in-sw": "This method is available in a service worker context.", "permission-default": "The notification permission was not granted and dismissed instead.", "permission-blocked": "The notification permission was not granted and blocked instead.", "unsupported-browser": "This browser doesn't support the API's required to use the MasterSDK.", "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)", "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}", "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}", "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.", "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}", "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}", "token-update-no-token": "FCM returned no token when updating the user to push.", "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.", "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.", "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.", "invalid-vapid-key": "The public VAPID key must be a string.", "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used." }); function Js(W, ee) { return ds.apply(this, arguments) } function ds() { return (ds = (0, J.Z)(function* (W, ee) { const de = yield Qs(W), We = oo(ee), xt = { method: "POST", headers: de, body: JSON.stringify(We) }; let zt; try { zt = yield (yield fetch(wa(W.appConfig), xt)).json() } catch (_n) { throw Ui.create("token-subscribe-failed", { errorInfo: _n?.toString() }) } if (zt.error) throw Ui.create("token-subscribe-failed", { errorInfo: zt.error.message }); if (!zt.token) throw Ui.create("token-subscribe-no-token"); return zt.token })).apply(this, arguments) } function Mo(W, ee) { return Ra.apply(this, arguments) } function Ra() { return (Ra = (0, J.Z)(function* (W, ee) { const de = yield Qs(W), We = oo(ee.subscriptionOptions), xt = { method: "PATCH", headers: de, body: JSON.stringify(We) }; let zt; try { zt = yield (yield fetch(`${wa(W.appConfig)}/${ee.token}`, xt)).json() } catch (_n) { throw Ui.create("token-update-failed", { errorInfo: _n?.toString() }) } if (zt.error) throw Ui.create("token-update-failed", { errorInfo: zt.error.message }); if (!zt.token) throw Ui.create("token-update-no-token"); return zt.token })).apply(this, arguments) } function gi(W, ee) { return Ml.apply(this, arguments) } function Ml() { return (Ml = (0, J.Z)(function* (W, ee) { const We = { method: "DELETE", headers: yield Qs(W) }; try { const zt = yield (yield fetch(`${wa(W.appConfig)}/${ee}`, We)).json(); if (zt.error) throw Ui.create("token-unsubscribe-failed", { errorInfo: zt.error.message }) } catch (xt) { throw Ui.create("token-unsubscribe-failed", { errorInfo: xt?.toString() }) } })).apply(this, arguments) } function wa({ projectId: W }) { return `https://fcmregistrations.googleapis.com/v1/projects/${W}/registrations` } function Qs(W) { return Zr.apply(this, arguments) } function Zr() { return (Zr = (0, J.Z)(function* ({ appConfig: W, installations: ee }) { const de = yield ee.getToken(); return new Headers({ "Content-Type": "application/json", Accept: "application/json", "x-goog-api-key": W.apiKey, "x-goog-firebase-installations-auth": `FIS ${de}` }) })).apply(this, arguments) } function oo({ p256dh: W, auth: ee, endpoint: de, vapidKey: We }) { const xt = { web: { endpoint: de, auth: ee, p256dh: W } }; return We !== uo && (xt.web.applicationPubKey = We), xt } const xs = 6048e5; function Oo(W) { return Hi.apply(this, arguments) } function Hi() { return (Hi = (0, J.Z)(function* (W) { const ee = yield $(W.swRegistration, W.vapidKey), de = { vapidKey: W.vapidKey, swScope: W.swRegistration.scope, endpoint: ee.endpoint, auth: so(ee.getKey("auth")), p256dh: so(ee.getKey("p256dh")) }, We = yield Za(W.firebaseDependencies); if (We) { if (Rt(We.subscriptionOptions, de)) return Date.now() >= We.createTime + xs ? hr(W, { token: We.token, createTime: Date.now(), subscriptionOptions: de }) : We.token; try { yield gi(W.firebaseDependencies, We.token) } catch (xt) { console.warn(xt) } return Q(W.firebaseDependencies, de) } return Q(W.firebaseDependencies, de) })).apply(this, arguments) } function qa(W) { return ys.apply(this, arguments) } function ys() { return (ys = (0, J.Z)(function* (W) { const ee = yield Za(W.firebaseDependencies); ee && (yield gi(W.firebaseDependencies, ee.token), yield Ks(W.firebaseDependencies)); const de = yield W.swRegistration.pushManager.getSubscription(); return !de || de.unsubscribe() })).apply(this, arguments) } function hr(W, ee) { return Xs.apply(this, arguments) } function Xs() { return (Xs = (0, J.Z)(function* (W, ee) { try { const de = yield Mo(W.firebaseDependencies, ee), We = Object.assign(Object.assign({}, ee), { token: de, createTime: Date.now() }); return yield As(W.firebaseDependencies, We), de } catch (de) { throw yield qa(W), de } })).apply(this, arguments) } function Q(W, ee) { return q.apply(this, arguments) } function q() { return (q = (0, J.Z)(function* (W, ee) { const We = { token: yield Js(W, ee), createTime: Date.now(), subscriptionOptions: ee }; return yield As(W, We), We.token })).apply(this, arguments) } function $(W, ee) { return me.apply(this, arguments) } function me() { return (me = (0, J.Z)(function* (W, ee) { return (yield W.pushManager.getSubscription()) || W.pushManager.subscribe({ userVisibleOnly: !0, applicationServerKey: jo(ee) }) })).apply(this, arguments) } function Rt(W, ee) { return ee.vapidKey === W.vapidKey && ee.endpoint === W.endpoint && ee.auth === W.auth && ee.p256dh === W.p256dh } function Bn(W) { const ee = { from: W.from, collapseKey: W.collapse_key, messageId: W.fcmMessageId }; return function wi(W, ee) { if (!ee.notification) return; W.notification = {}; const de = ee.notification.title; de && (W.notification.title = de); const We = ee.notification.body; We && (W.notification.body = We); const xt = ee.notification.image; xt && (W.notification.image = xt); const zt = ee.notification.icon; zt && (W.notification.icon = zt) }(ee, W), function Jt(W, ee) { ee.data && (W.data = ee.data) }(ee, W), function zr(W, ee) { var de, We, xt, zt, _n; if (!(ee.fcmOptions || null !== (de = ee.notification) && void 0 !== de && de.click_action)) return; W.fcmOptions = {}; const jn = null !== (xt = null === (We = ee.fcmOptions) || void 0 === We ? void 0 : We.link) && void 0 !== xt ? xt : null === (zt = ee.notification) || void 0 === zt ? void 0 : zt.click_action; jn && (W.fcmOptions.link = jn); const er = null === (_n = ee.fcmOptions) || void 0 === _n ? void 0 : _n.analytics_label; er && (W.fcmOptions.analyticsLabel = er) }(ee, W), ee } function ll(W) { return "object" == typeof W && !!W && ka in W } function qc(W, ee) { const de = []; for (let We = 0; We < W.length; We++)de.push(W.charAt(We)), We < ee.length && de.push(ee.charAt(We)); return de.join("") } function ql(W) { return Ui.create("missing-app-config-values", { valueName: W }) } qc("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o"), qc("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4"); class cl { constructor(ee, de, We) { this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1; const xt = function vs(W) { if (!W || !W.options) throw ql("App Configuration Object"); if (!W.name) throw ql("App Name"); const ee = ["projectId", "apiKey", "appId", "messagingSenderId"], { options: de } = W; for (const We of ee) if (!de[We]) throw ql(We); return { appName: W.name, projectId: de.projectId, apiKey: de.apiKey, appId: de.appId, senderId: de.messagingSenderId } }(ee); this.firebaseDependencies = { app: ee, appConfig: xt, installations: de, analyticsProvider: We } } _delete() { return Promise.resolve() } } function po(W) { return Fa.apply(this, arguments) } function Fa() { return (Fa = (0, J.Z)(function* (W) { try { W.swRegistration = yield navigator.serviceWorker.register(Io, { scope: Xn }), W.swRegistration.update().catch(() => { }) } catch (ee) { throw Ui.create("failed-service-worker-registration", { browserErrorMessage: ee?.message }) } })).apply(this, arguments) } function ul(W, ee) { return Yl.apply(this, arguments) } function Yl() { return (Yl = (0, J.Z)(function* (W, ee) { if (!ee && !W.swRegistration && (yield po(W)), ee || !W.swRegistration) { if (!(ee instanceof ServiceWorkerRegistration)) throw Ui.create("invalid-sw-registration"); W.swRegistration = ee } })).apply(this, arguments) } function Kl(W, ee) { return dl.apply(this, arguments) } function dl() { return (dl = (0, J.Z)(function* (W, ee) { ee ? W.vapidKey = ee : W.vapidKey || (W.vapidKey = uo) })).apply(this, arguments) } function hs() { return (hs = (0, J.Z)(function* (W, ee) { if (!navigator) throw Ui.create("only-available-in-window"); if ("default" === Notification.permission && (yield Notification.requestPermission()), "granted" !== Notification.permission) throw Ui.create("permission-blocked"); return yield Kl(W, ee?.vapidKey), yield ul(W, ee?.serviceWorkerRegistration), Oo(W) })).apply(this, arguments) } function Ca(W, ee, de) { return hl.apply(this, arguments) } function hl() { return (hl = (0, J.Z)(function* (W, ee, de) { const We = Co(ee); (yield W.firebaseDependencies.analyticsProvider.get()).logEvent(We, { message_id: de[ka], message_name: de[io], message_time: de[Wl], message_device_time: Math.floor(Date.now() / 1e3) }) })).apply(this, arguments) } function Co(W) { switch (W) { case Go.NOTIFICATION_CLICKED: return "notification_open"; case Go.PUSH_RECEIVED: return "notification_foreground"; default: throw new Error } } function Ea() { return (Ea = (0, J.Z)(function* (W, ee) { const de = ee.data; if (!de.isFirebaseMessaging) return; W.onMessageHandler && de.messageType === Go.PUSH_RECEIVED && ("function" == typeof W.onMessageHandler ? W.onMessageHandler(Bn(de)) : W.onMessageHandler.next(Bn(de))); const We = de.data; ll(We) && "1" === We[zo] && (yield Ca(W, de.messageType, We)) })).apply(this, arguments) } const Jl = "@firebase/messaging", Ql = W => { const ee = new cl(W.getProvider("app").getImmediate(), W.getProvider("installations-internal").getImmediate(), W.getProvider("analytics-internal")); return navigator.serviceWorker.addEventListener("message", de => function bc(W, ee) { return Ea.apply(this, arguments) }(ee, de)), ee }, No = W => { const ee = W.getProvider("messaging").getImmediate(); return { getToken: We => function Ms(W, ee) { return hs.apply(this, arguments) }(ee, We) } }; function fl() { return mu.apply(this, arguments) } function mu() { return (mu = (0, J.Z)(function* () { try { yield (0, Ce.eu)() } catch { return !1 } return typeof window < "u" && (0, Ce.hl)() && (0, Ce.zI)() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey") })).apply(this, arguments) } !function Cc() { (0, ye._registerComponent)(new we.wA("messaging", Ql, "PUBLIC")), (0, ye._registerComponent)(new we.wA("messaging-internal", No, "PRIVATE")), (0, ye.registerVersion)(Jl, "0.12.0"), (0, ye.registerVersion)(Jl, "0.12.0", "esm2017") }(); const Ka = "analytics", Eo = "firebase_id", Ja = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig", ec = "https://www.googletagmanager.com/gtag/js", yi = new Te.Yd("@firebase/analytics"); function Da(W) { return Promise.all(W.map(ee => ee.catch(de => de))) } function Nl(W, ee) { const de = document.createElement("script"); de.src = `${ec}?l=${W}&id=${ee}`, de.async = !0, document.head.appendChild(de) } function kl(W, ee, de, We, xt, zt) { return z.apply(this, arguments) } function z() { return (z = (0, J.Z)(function* (W, ee, de, We, xt, zt) { const _n = We[xt]; try { if (_n) yield ee[_n]; else { const er = (yield Da(de)).find(ir => ir.measurementId === xt); er && (yield ee[er.appId]) } } catch (jn) { yi.error(jn) } W("config", xt, zt) })).apply(this, arguments) } function re(W, ee, de, We, xt) { return Z.apply(this, arguments) } function Z() { return (Z = (0, J.Z)(function* (W, ee, de, We, xt) { try { let zt = []; if (xt && xt.send_to) { let _n = xt.send_to; Array.isArray(_n) || (_n = [_n]); const jn = yield Da(de); for (const er of _n) { const ir = jn.find(Pr => Pr.measurementId === er), Ir = ir && ee[ir.appId]; if (!Ir) { zt = []; break } zt.push(Ir) } } 0 === zt.length && (zt = Object.values(ee)), yield Promise.all(zt), W("event", We, xt || {}) } catch (zt) { yi.error(zt) } })).apply(this, arguments) } function Ft(W) { const ee = window.document.getElementsByTagName("script"); for (const de of Object.values(ee)) if (de.src && de.src.includes(ec) && de.src.includes(W)) return de; return null } const Nn = new Ce.LL("analytics", "Analytics", { "already-exists": "A MasterAnalytics instance with the appId {$id}  already exists. Only one MasterAnalytics instance can be created for each appId.", "already-initialized": "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.", "already-initialized-settings": "MasterAnalytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.", "interop-component-reg-failed": "MasterAnalytics Interop Component failed to instantiate: {$reason}", "invalid-analytics-context": "MasterAnalytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", "indexeddb-unavailable": "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", "fetch-throttle": "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.", "config-fetch-failed": "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}", "no-api-key": 'The "apiKey" field is empty in the local Masterconfig. MasterAnalytics requires this field tocontain a valid API key.', "no-app-id": 'The "appId" field is empty in the local Masterconfig. MasterAnalytics requires this field tocontain a valid app ID.' }), Or = new class kr { constructor(ee = {}, de = 1e3) { this.throttleMetadata = ee, this.intervalMillis = de } getThrottleMetadata(ee) { return this.throttleMetadata[ee] } setThrottleMetadata(ee, de) { this.throttleMetadata[ee] = de } deleteThrottleMetadata(ee) { delete this.throttleMetadata[ee] } }; function fs(W) { return new Headers({ Accept: "application/json", "x-goog-api-key": W }) } function xr(W) { return Os.apply(this, arguments) } function Os() { return (Os = (0, J.Z)(function* (W) { var ee; const { appId: de, apiKey: We } = W, xt = { method: "GET", headers: fs(We) }, zt = Ja.replace("{app-id}", de), _n = yield fetch(zt, xt); if (200 !== _n.status && 304 !== _n.status) { let jn = ""; try { const er = yield _n.json(); null !== (ee = er.error) && void 0 !== ee && ee.message && (jn = er.error.message) } catch { } throw Nn.create("config-fetch-failed", { httpStatus: _n.status, responseMessage: jn }) } return _n.json() })).apply(this, arguments) } function mi(W) { return bs.apply(this, arguments) } function bs() { return (bs = (0, J.Z)(function* (W, ee = Or, de) { const { appId: We, apiKey: xt, measurementId: zt } = W.options; if (!We) throw Nn.create("no-app-id"); if (!xt) { if (zt) return { measurementId: zt, appId: We }; throw Nn.create("no-api-key") } const _n = ee.getThrottleMetadata(We) || { backoffCount: 0, throttleEndTimeMillis: Date.now() }, jn = new xi; return setTimeout((0, J.Z)(function* () { jn.abort() }), void 0 !== de ? de : 6e4), To({ appId: We, apiKey: xt, measurementId: zt }, _n, jn, ee) })).apply(this, arguments) } function To(W, ee, de) { return go.apply(this, arguments) } function go() { return (go = (0, J.Z)(function* (W, { throttleEndTimeMillis: ee, backoffCount: de }, We, xt = Or) { var zt; const { appId: _n, measurementId: jn } = W; try { yield Ba(We, ee) } catch (er) { if (jn) return yi.warn(`Timed out fetching this Masterapp's measurement ID from the server. Falling back to the measurement ID ${jn} provided in the "measurementId" field in the local Masterconfig. [${er?.message}]`), { appId: _n, measurementId: jn }; throw er } try { const er = yield xr(W); return xt.deleteThrottleMetadata(_n), er } catch (er) { const ir = er; if (!Va(ir)) { if (xt.deleteThrottleMetadata(_n), jn) return yi.warn(`Failed to fetch this Masterapp's measurement ID from the server. Falling back to the measurement ID ${jn} provided in the "measurementId" field in the local Masterconfig. [${ir?.message}]`), { appId: _n, measurementId: jn }; throw er } const Ir = 503 === Number(null === (zt = ir?.customData) || void 0 === zt ? void 0 : zt.httpStatus) ? (0, Ce.$s)(de, xt.intervalMillis, 30) : (0, Ce.$s)(de, xt.intervalMillis), Pr = { throttleEndTimeMillis: Date.now() + Ir, backoffCount: de + 1 }; return xt.setThrottleMetadata(_n, Pr), yi.debug(`Calling attemptFetch again in ${Ir} millis`), To(W, Pr, We, xt) } })).apply(this, arguments) } function Ba(W, ee) { return new Promise((de, We) => { const xt = Math.max(ee - Date.now(), 0), zt = setTimeout(de, xt); W.addEventListener(() => { clearTimeout(zt), We(Nn.create("fetch-throttle", { throttleEndTimeMillis: ee })) }) }) } function Va(W) { if (!(W instanceof Ce.ZR && W.customData)) return !1; const ee = Number(W.customData.httpStatus); return 429 === ee || 500 === ee || 503 === ee || 504 === ee } class xi { constructor() { this.listeners = [] } addEventListener(ee) { this.listeners.push(ee) } abort() { this.listeners.forEach(ee => ee()) } } let Dc, Qa; function Zo() { return (Zo = (0, J.Z)(function* (W, ee, de, We, xt) { if (xt && xt.global) W("event", de, We); else { const zt = yield ee; W("event", de, Object.assign(Object.assign({}, We), { send_to: zt })) } })).apply(this, arguments) } function Xa(W) { Qa = W } function Kc(W) { Dc = W } function Sc() { return Jc.apply(this, arguments) } function Jc() { return (Jc = (0, J.Z)(function* () { if (!(0, Ce.hl)()) return yi.warn(Nn.create("indexeddb-unavailable", { errorInfo: "IndexedDB is not available in this environment." }).message), !1; try { yield (0, Ce.eu)() } catch (W) { return yi.warn(Nn.create("indexeddb-unavailable", { errorInfo: W?.toString() }).message), !1 } return !0 })).apply(this, arguments) } function yu() { return (yu = (0, J.Z)(function* (W, ee, de, We, xt, zt, _n) { var jn; const er = mi(W); er.then(Ws => { de[Ws.measurementId] = Ws.appId, W.options.measurementId && Ws.measurementId !== W.options.measurementId && yi.warn(`The measurement ID in the local Masterconfig (${W.options.measurementId}) does not match the measurement ID fetched from the server (${Ws.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`) }).catch(Ws => yi.error(Ws)), ee.push(er); const ir = Sc().then(Ws => { if (Ws) return We.getId() }), [Ir, Pr] = yield Promise.all([er, ir]); Ft(zt) || Nl(zt, Ir.measurementId), Qa && (xt("consent", "default", Qa), Xa(void 0)), xt("js", new Date); const ca = null !== (jn = _n?.config) && void 0 !== jn ? jn : {}; return ca.origin = "firebase", ca.update = !0, null != Pr && (ca[Eo] = Pr), xt("config", Ir.measurementId, ca), Dc && (xt("set", Dc), Kc(void 0)), Ir.measurementId })).apply(this, arguments) } class Lu { constructor(ee) { this.app = ee } _delete() { return delete eo[this.app.options.appId], Promise.resolve() } } let eo = {}, Ic = []; const ra = {}; let el, Yo, ia = "dataLayer", Ko = !1; function Sa(W, ee, de) { !function Qc() { const W = []; if ((0, Ce.ru)() && W.push("This is a browser extension environment."), (0, Ce.zI)() || W.push("Cookies are not available."), W.length > 0) { const ee = W.map((We, xt) => `(${xt + 1}) ${We}`).join(" "), de = Nn.create("invalid-analytics-context", { errorInfo: ee }); yi.warn(de.message) } }(); const We = W.options.appId; if (!We) throw Nn.create("no-app-id"); if (!W.options.apiKey) { if (!W.options.measurementId) throw Nn.create("no-api-key"); yi.warn(`The "apiKey" field is empty in the local Masterconfig. This is needed to fetch the latest measurement ID for this Masterapp. Falling back to the measurement ID ${W.options.measurementId} provided in the "measurementId" field in the local Masterconfig.`) } if (null != eo[We]) throw Nn.create("already-exists", { id: We }); if (!Ko) { !function _u(W) { let ee = []; Array.isArray(window[W]) ? ee = window[W] : window[W] = ee }(ia); const { wrappedGtag: zt, gtagCore: _n } = function $e(W, ee, de, We, xt) { let zt = function (..._n) { window[We].push(arguments) }; return window[xt] && "function" == typeof window[xt] && (zt = window[xt]), window[xt] = function he(W, ee, de, We) { function zt() { return (zt = (0, J.Z)(function* (_n, jn, er) { try { "event" === _n ? yield re(W, ee, de, jn, er) : "config" === _n ? yield kl(W, ee, de, We, jn, er) : "consent" === _n ? W("consent", "update", er) : W("set", jn) } catch (ir) { yi.error(ir) } })).apply(this, arguments) } return function xt(_n, jn, er) { return zt.apply(this, arguments) } }(zt, W, ee, de), { gtagCore: zt, wrappedGtag: window[xt] } }(eo, Ic, ra, ia, "gtag"); Yo = zt, el = _n, Ko = !0 } return eo[We] = function Ll(W, ee, de, We, xt, zt, _n) { return yu.apply(this, arguments) }(W, Ic, ra, ee, el, ia, de), new Lu(W) } function Vu() { return Ia.apply(this, arguments) } function Ia() { return (Ia = (0, J.Z)(function* () { if ((0, Ce.ru)() || !(0, Ce.zI)() || !(0, Ce.hl)()) return !1; try { return yield (0, Ce.eu)() } catch { return !1 } })).apply(this, arguments) } const Mi = "@firebase/analytics"; !function Oc() { (0, ye._registerComponent)(new we.wA(Ka, (ee, { options: de }) => Sa(ee.getProvider("app").getImmediate(), ee.getProvider("installations-internal").getImmediate(), de), "PUBLIC")), (0, ye._registerComponent)(new we.wA("analytics-internal", function W(ee) { try { const de = ee.getProvider(Ka).getImmediate(); return { logEvent: (We, xt, zt) => function ci(W, ee, de, We) { W = (0, Ce.m9)(W), function Yc(W, ee, de, We, xt) { return Zo.apply(this, arguments) }(Yo, eo[W.app.options.appId], ee, de, We).catch(xt => yi.error(xt)) }(de, We, xt, zt) } } catch (de) { throw Nn.create("interop-component-reg-failed", { reason: de }) } }, "PRIVATE")), (0, ye.registerVersion)(Mi, "0.9.0"), (0, ye.registerVersion)(Mi, "0.9.0", "esm2017") }(); var cn = L(4408), Pe = L(7565); const ml = new class Jo extends Pe.v { }(class tl extends cn.o { constructor(ee, de) { super(ee, de), this.scheduler = ee, this.work = de } schedule(ee, de = 0) { return de > 0 ? super.schedule(ee, de) : (this.delay = de, this.state = ee, this.scheduler.flush(this), this) } execute(ee, de) { return de > 0 || this.closed ? super.execute(ee, de) : this._execute(ee, de) } requestAsyncId(ee, de, We = 0) { return null != We && We > 0 || null == We && this.delay > 0 ? super.requestAsyncId(ee, de, We) : (ee.flush(this), 0) } }); var Bl = L(4986), Xc = L(8505), ji = L(9468), R = L(5363); const V = new i.GfV("7.5.0"), M = "__angularfire_symbol__analyticsIsSupportedValue", G = "__angularfire_symbol__analyticsIsSupported", X = "__angularfire_symbol__remoteConfigIsSupportedValue", ce = "__angularfire_symbol__remoteConfigIsSupported", be = "__angularfire_symbol__messagingIsSupportedValue", St = "__angularfire_symbol__messagingIsSupported"; function Gr(W, ee, de) { if (ee) { if (1 === ee.length) return ee[0]; const zt = ee.filter(_n => _n.app === de); if (1 === zt.length) return zt[0] } return de.container.getProvider(W).getImmediate({ optional: !0 }) } globalThis[G] || (globalThis[G] = Vu().then(W => globalThis[M] = W).catch(() => globalThis[M] = !1)), globalThis[St] || (globalThis[St] = fl().then(W => globalThis[be] = W).catch(() => globalThis[be] = !1)), globalThis[ce] || (globalThis[ce] = bo().then(W => globalThis[X] = W).catch(() => globalThis[X] = !1)); const Sr = (W, ee) => { const de = ee ? [ee] : (0, m.C6)(), We = []; return de.forEach(xt => { xt.container.getProvider(W).instances.forEach(_n => { We.includes(_n) || We.push(_n) }) }), We }; function $i() { } class Wi { constructor(ee, de = ml) { this.zone = ee, this.delegate = de } now() { return this.delegate.now() } schedule(ee, de, We) { const xt = this.zone; return this.delegate.schedule(function (_n) { xt.runGuarded(() => { ee.apply(this, [_n]) }) }, de, We) } } class sa { constructor(ee) { this.zone = ee, this.task = null } call(ee, de) { const We = this.unscheduleTask.bind(this); return this.task = this.zone.run(() => Zone.current.scheduleMacroTask("firebaseZoneBlock", $i, {}, $i, $i)), de.pipe((0, Xc.b)({ next: We, complete: We, error: We })).subscribe(ee).add(We) } unscheduleTask() { setTimeout(() => { null != this.task && "scheduled" === this.task.state && (this.task.invoke(), this.task = null) }, 10) } } let bu = (() => { class W { constructor(de) { this.ngZone = de, this.outsideAngular = de.runOutsideAngular(() => new Wi(Zone.current)), this.insideAngular = de.run(() => new Wi(Zone.current, Bl.z)), globalThis.\u0275AngularFireScheduler || (globalThis.\u0275AngularFireScheduler = this) } } return W.\u0275fac = function (de) { return new (de || W)(i.LFG(i.R0b)) }, W.\u0275prov = i.Yz7({ token: W, factory: W.\u0275fac, providedIn: "root" }), W })(); function lo() { const W = globalThis.\u0275AngularFireScheduler; if (!W) throw new Error("Either AngularFireModule has not been provided in your AppModule (this can be done manually or implictly using\nprovideFirebaseApp) or you're calling an AngularFire method outside of an NgModule (which is not supported)."); return W } function aa(W) { return lo(), function la(W) { return function (de) { return (de = de.lift(new sa(W.ngZone))).pipe((0, ji.R)(W.outsideAngular), (0, R.Q)(W.insideAngular)) } }(lo())(W) } }, 2090: (un, Je, L) => { "use strict"; L.d(Je, { $s: () => vt, BH: () => nr, DV: () => Jn, Dv: () => ur, G6: () => Ve, GJ: () => jt, L: () => Ee, LL: () => Yt, Pz: () => qn, Sg: () => kn, UG: () => rt, UI: () => Ht, US: () => we, Wj: () => vr, Wl: () => Ot, Yr: () => Oe, ZB: () => ve, ZR: () => It, aH: () => On, b$: () => je, cI: () => Ze, dS: () => ln, eu: () => nt, g5: () => J, gK: () => dr, gQ: () => Hn, h$: () => Te, hl: () => Be, hu: () => m, jU: () => wt, lb: () => At, m9: () => Zt, ne: () => _r, p$: () => ae, pd: () => gn, r3: () => wn, ru: () => De, tV: () => _e, uI: () => Se, ug: () => Ae, vZ: () => dn, w1: () => Qe, w9: () => an, xO: () => lt, xb: () => or, z$: () => gt, zI: () => Ne, zd: () => Nt }); const m = function (fe, ke) { if (!fe) throw J(ke) }, J = function (fe) { return new Error("MasterDatabase (${JSCORE_VERSION}) INTERNAL ASSERT FAILED: " + fe) }, ye = function (fe) { const ke = []; let et = 0; for (let Lt = 0; Lt < fe.length; Lt++) { let mt = fe.charCodeAt(Lt); mt < 128 ? ke[et++] = mt : mt < 2048 ? (ke[et++] = mt >> 6 | 192, ke[et++] = 63 & mt | 128) : 55296 == (64512 & mt) && Lt + 1 < fe.length && 56320 == (64512 & fe.charCodeAt(Lt + 1)) ? (mt = 65536 + ((1023 & mt) << 10) + (1023 & fe.charCodeAt(++Lt)), ke[et++] = mt >> 18 | 240, ke[et++] = mt >> 12 & 63 | 128, ke[et++] = mt >> 6 & 63 | 128, ke[et++] = 63 & mt | 128) : (ke[et++] = mt >> 12 | 224, ke[et++] = mt >> 6 & 63 | 128, ke[et++] = 63 & mt | 128) } return ke }, we = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: "function" == typeof atob, encodeByteArray(fe, ke) { if (!Array.isArray(fe)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const et = ke ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, Lt = []; for (let mt = 0; mt < fe.length; mt += 3) { const An = fe[mt], ar = mt + 1 < fe.length, sr = ar ? fe[mt + 1] : 0, Fr = mt + 2 < fe.length, ze = Fr ? fe[mt + 2] : 0; let Ct = (15 & sr) << 2 | ze >> 6, nn = 63 & ze; Fr || (nn = 64, ar || (Ct = 64)), Lt.push(et[An >> 2], et[(3 & An) << 4 | sr >> 4], et[Ct], et[nn]) } return Lt.join("") }, encodeString(fe, ke) { return this.HAS_NATIVE_SUPPORT && !ke ? btoa(fe) : this.encodeByteArray(ye(fe), ke) }, decodeString(fe, ke) { return this.HAS_NATIVE_SUPPORT && !ke ? atob(fe) : function (fe) { const ke = []; let et = 0, Lt = 0; for (; et < fe.length;) { const mt = fe[et++]; if (mt < 128) ke[Lt++] = String.fromCharCode(mt); else if (mt > 191 && mt < 224) { const An = fe[et++]; ke[Lt++] = String.fromCharCode((31 & mt) << 6 | 63 & An) } else if (mt > 239 && mt < 365) { const Fr = ((7 & mt) << 18 | (63 & fe[et++]) << 12 | (63 & fe[et++]) << 6 | 63 & fe[et++]) - 65536; ke[Lt++] = String.fromCharCode(55296 + (Fr >> 10)), ke[Lt++] = String.fromCharCode(56320 + (1023 & Fr)) } else { const An = fe[et++], ar = fe[et++]; ke[Lt++] = String.fromCharCode((15 & mt) << 12 | (63 & An) << 6 | 63 & ar) } } return ke.join("") }(this.decodeStringToByteArray(fe, ke)) }, decodeStringToByteArray(fe, ke) { this.init_(); const et = ke ? this.charToByteMapWebSafe_ : this.charToByteMap_, Lt = []; for (let mt = 0; mt < fe.length;) { const An = et[fe.charAt(mt++)], sr = mt < fe.length ? et[fe.charAt(mt)] : 0; ++mt; const ze = mt < fe.length ? et[fe.charAt(mt)] : 64; ++mt; const Ie = mt < fe.length ? et[fe.charAt(mt)] : 64; if (++mt, null == An || null == sr || null == ze || null == Ie) throw Error(); Lt.push(An << 2 | sr >> 4), 64 !== ze && (Lt.push(sr << 4 & 240 | ze >> 2), 64 !== Ie && Lt.push(ze << 6 & 192 | Ie)) } return Lt }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let fe = 0; fe < this.ENCODED_VALS.length; fe++)this.byteToCharMap_[fe] = this.ENCODED_VALS.charAt(fe), this.charToByteMap_[this.byteToCharMap_[fe]] = fe, this.byteToCharMapWebSafe_[fe] = this.ENCODED_VALS_WEBSAFE.charAt(fe), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[fe]] = fe, fe >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(fe)] = fe, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(fe)] = fe) } } }, Te = function (fe) { const ke = ye(fe); return we.encodeByteArray(ke, !0) }, Ee = function (fe) { return Te(fe).replace(/\./g, "") }, _e = function (fe) { try { return we.decodeString(fe, !0) } catch (ke) { console.error("base64Decode failed: ", ke) } return null }; function ae(fe) { return ve(void 0, fe) } function ve(fe, ke) { if (!(ke instanceof Object)) return ke; switch (ke.constructor) { case Date: return new Date(ke.getTime()); case Object: void 0 === fe && (fe = {}); break; case Array: fe = []; break; default: return ke }for (const et in ke) !ke.hasOwnProperty(et) || !xe(et) || (fe[et] = ve(fe[et], ke[et])); return fe } function xe(fe) { return "__proto__" !== fe } function gt() { return typeof navigator < "u" && "string" == typeof navigator.userAgent ? navigator.userAgent : "" } function Se() { return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(gt()) } function rt() { try { return "[object process]" === Object.prototype.toString.call(global.process) } catch { return !1 } } function wt() { return "object" == typeof self && self.self === self } function De() { const fe = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0; return "object" == typeof fe && void 0 !== fe.id } function je() { return "object" == typeof navigator && "ReactNative" === navigator.product } function Qe() { const fe = gt(); return fe.indexOf("MSIE ") >= 0 || fe.indexOf("Trident/") >= 0 } function Oe() { return !1 } function Ve() { return !rt() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome") } function Be() { try { return "object" == typeof indexedDB } catch { return !1 } } function nt() { return new Promise((fe, ke) => { try { let et = !0; const Lt = "validate-browser-context-for-indexeddb-analytics-module", mt = self.indexedDB.open(Lt); mt.onsuccess = () => { mt.result.close(), et || self.indexedDB.deleteDatabase(Lt), fe(!0) }, mt.onupgradeneeded = () => { et = !1 }, mt.onerror = () => { var An; ke((null === (An = mt.error) || void 0 === An ? void 0 : An.message) || "") } } catch (et) { ke(et) } }) } function Ne() { return !(typeof navigator > "u" || !navigator.cookieEnabled) } const ht = () => { try { return function tt() { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("Unable to locate global object.") }().__FIREBASE_DEFAULTS__ || (() => { if (typeof process > "u" || typeof process.env > "u") return; const fe = process.env.__FIREBASE_DEFAULTS__; return fe ? JSON.parse(fe) : void 0 })() || (() => { if (typeof document > "u") return; let fe; try { fe = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch { return } const ke = fe && _e(fe[1]); return ke && JSON.parse(ke) })() } catch (fe) { return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${fe}`) } }, On = () => { var fe; return null === (fe = ht()) || void 0 === fe ? void 0 : fe.config }, qn = fe => { var ke; return null === (ke = ht()) || void 0 === ke ? void 0 : ke[`_${fe}`] }; class nr { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise((ke, et) => { this.resolve = ke, this.reject = et }) } wrapCallback(ke) { return (et, Lt) => { et ? this.reject(et) : this.resolve(Lt), "function" == typeof ke && (this.promise.catch(() => { }), 1 === ke.length ? ke(et) : ke(et, Lt)) } } } function kn(fe, ke) { if (fe.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for MasterAuth User ID.'); const Lt = ke || "demo-project", mt = fe.iat || 0, An = fe.sub || fe.user_id; if (!An) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!"); const ar = Object.assign({ iss: `https://securetoken.google.com/${Lt}`, aud: Lt, iat: mt, exp: mt + 3600, auth_time: mt, sub: An, user_id: An, firebase: { sign_in_provider: "custom", identities: {} } }, fe); return [Ee(JSON.stringify({ alg: "none", type: "JWT" })), Ee(JSON.stringify(ar)), ""].join(".") } class It extends Error { constructor(ke, et, Lt) { super(et), this.code = ke, this.customData = Lt, this.name = "FirebaseError", Object.setPrototypeOf(this, It.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Yt.prototype.create) } } class Yt { constructor(ke, et, Lt) { this.service = ke, this.serviceName = et, this.errors = Lt } create(ke, ...et) { const Lt = et[0] || {}, mt = `${this.service}/${ke}`, An = this.errors[ke], ar = An ? function pt(fe, ke) { return fe.replace(Pt, (et, Lt) => { const mt = ke[Lt]; return null != mt ? String(mt) : `<${Lt}?>` }) }(An, Lt) : "Error"; return new It(mt, `${this.serviceName}: ${ar} (${mt}).`, Lt) } } const Pt = /\{\$([^}]+)}/g; function Ze(fe) { return JSON.parse(fe) } function Ot(fe) { return JSON.stringify(fe) } const le = function (fe) { let ke = {}, et = {}, Lt = {}, mt = ""; try { const An = fe.split("."); ke = Ze(_e(An[0]) || ""), et = Ze(_e(An[1]) || ""), mt = An[2], Lt = et.d || {}, delete et.d } catch { } return { header: ke, claims: et, data: Lt, signature: mt } }, an = function (fe) { const et = le(fe).claims; return !!et && "object" == typeof et && et.hasOwnProperty("iat") }, jt = function (fe) { const ke = le(fe).claims; return "object" == typeof ke && !0 === ke.admin }; function wn(fe, ke) { return Object.prototype.hasOwnProperty.call(fe, ke) } function Jn(fe, ke) { if (Object.prototype.hasOwnProperty.call(fe, ke)) return fe[ke] } function or(fe) { for (const ke in fe) if (Object.prototype.hasOwnProperty.call(fe, ke)) return !1; return !0 } function Ht(fe, ke, et) { const Lt = {}; for (const mt in fe) Object.prototype.hasOwnProperty.call(fe, mt) && (Lt[mt] = ke.call(et, fe[mt], mt, fe)); return Lt } function dn(fe, ke) { if (fe === ke) return !0; const et = Object.keys(fe), Lt = Object.keys(ke); for (const mt of et) { if (!Lt.includes(mt)) return !1; const An = fe[mt], ar = ke[mt]; if (ue(An) && ue(ar)) { if (!dn(An, ar)) return !1 } else if (An !== ar) return !1 } for (const mt of Lt) if (!et.includes(mt)) return !1; return !0 } function ue(fe) { return null !== fe && "object" == typeof fe } function lt(fe) { const ke = []; for (const [et, Lt] of Object.entries(fe)) Array.isArray(Lt) ? Lt.forEach(mt => { ke.push(encodeURIComponent(et) + "=" + encodeURIComponent(mt)) }) : ke.push(encodeURIComponent(et) + "=" + encodeURIComponent(Lt)); return ke.length ? "&" + ke.join("&") : "" } function Nt(fe) { const ke = {}; return fe.replace(/^\?/, "").split("&").forEach(Lt => { if (Lt) { const [mt, An] = Lt.split("="); ke[decodeURIComponent(mt)] = decodeURIComponent(An) } }), ke } function gn(fe) { const ke = fe.indexOf("?"); if (!ke) return ""; const et = fe.indexOf("#", ke); return fe.substring(ke, et > 0 ? et : void 0) } class Hn { constructor() { this.chain_ = [], this.buf_ = [], this.W_ = [], this.pad_ = [], this.inbuf_ = 0, this.total_ = 0, this.blockSize = 64, this.pad_[0] = 128; for (let ke = 1; ke < this.blockSize; ++ke)this.pad_[ke] = 0; this.reset() } reset() { this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0 } compress_(ke, et) { et || (et = 0); const Lt = this.W_; if ("string" == typeof ke) for (let Ie = 0; Ie < 16; Ie++)Lt[Ie] = ke.charCodeAt(et) << 24 | ke.charCodeAt(et + 1) << 16 | ke.charCodeAt(et + 2) << 8 | ke.charCodeAt(et + 3), et += 4; else for (let Ie = 0; Ie < 16; Ie++)Lt[Ie] = ke[et] << 24 | ke[et + 1] << 16 | ke[et + 2] << 8 | ke[et + 3], et += 4; for (let Ie = 16; Ie < 80; Ie++) { const Ct = Lt[Ie - 3] ^ Lt[Ie - 8] ^ Lt[Ie - 14] ^ Lt[Ie - 16]; Lt[Ie] = 4294967295 & (Ct << 1 | Ct >>> 31) } let ze, Ye, mt = this.chain_[0], An = this.chain_[1], ar = this.chain_[2], sr = this.chain_[3], Fr = this.chain_[4]; for (let Ie = 0; Ie < 80; Ie++) { Ie < 40 ? Ie < 20 ? (ze = sr ^ An & (ar ^ sr), Ye = 1518500249) : (ze = An ^ ar ^ sr, Ye = 1859775393) : Ie < 60 ? (ze = An & ar | sr & (An | ar), Ye = 2400959708) : (ze = An ^ ar ^ sr, Ye = 3395469782); const Ct = (mt << 5 | mt >>> 27) + ze + Fr + Ye + Lt[Ie] & 4294967295; Fr = sr, sr = ar, ar = 4294967295 & (An << 30 | An >>> 2), An = mt, mt = Ct } this.chain_[0] = this.chain_[0] + mt & 4294967295, this.chain_[1] = this.chain_[1] + An & 4294967295, this.chain_[2] = this.chain_[2] + ar & 4294967295, this.chain_[3] = this.chain_[3] + sr & 4294967295, this.chain_[4] = this.chain_[4] + Fr & 4294967295 } update(ke, et) { if (null == ke) return; void 0 === et && (et = ke.length); const Lt = et - this.blockSize; let mt = 0; const An = this.buf_; let ar = this.inbuf_; for (; mt < et;) { if (0 === ar) for (; mt <= Lt;)this.compress_(ke, mt), mt += this.blockSize; if ("string" == typeof ke) { for (; mt < et;)if (An[ar] = ke.charCodeAt(mt), ++ar, ++mt, ar === this.blockSize) { this.compress_(An), ar = 0; break } } else for (; mt < et;)if (An[ar] = ke[mt], ++ar, ++mt, ar === this.blockSize) { this.compress_(An), ar = 0; break } } this.inbuf_ = ar, this.total_ += et } digest() { const ke = []; let et = 8 * this.total_; this.update(this.pad_, this.inbuf_ < 56 ? 56 - this.inbuf_ : this.blockSize - (this.inbuf_ - 56)); for (let mt = this.blockSize - 1; mt >= 56; mt--)this.buf_[mt] = 255 & et, et /= 256; this.compress_(this.buf_); let Lt = 0; for (let mt = 0; mt < 5; mt++)for (let An = 24; An >= 0; An -= 8)ke[Lt] = this.chain_[mt] >> An & 255, ++Lt; return ke } } function _r(fe, ke) { const et = new pn(fe, ke); return et.subscribe.bind(et) } class pn { constructor(ke, et) { this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = et, this.task.then(() => { ke(this) }).catch(Lt => { this.error(Lt) }) } next(ke) { this.forEachObserver(et => { et.next(ke) }) } error(ke) { this.forEachObserver(et => { et.error(ke) }), this.close(ke) } complete() { this.forEachObserver(ke => { ke.complete() }), this.close() } subscribe(ke, et, Lt) { let mt; if (void 0 === ke && void 0 === et && void 0 === Lt) throw new Error("Missing Observer."); mt = function yn(fe, ke) { if ("object" != typeof fe || null === fe) return !1; for (const et of ke) if (et in fe && "function" == typeof fe[et]) return !0; return !1 }(ke, ["next", "error", "complete"]) ? ke : { next: ke, error: et, complete: Lt }, void 0 === mt.next && (mt.next = Qn), void 0 === mt.error && (mt.error = Qn), void 0 === mt.complete && (mt.complete = Qn); const An = this.unsubscribeOne.bind(this, this.observers.length); return this.finalized && this.task.then(() => { try { this.finalError ? mt.error(this.finalError) : mt.complete() } catch { } }), this.observers.push(mt), An } unsubscribeOne(ke) { void 0 === this.observers || void 0 === this.observers[ke] || (delete this.observers[ke], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this)) } forEachObserver(ke) { if (!this.finalized) for (let et = 0; et < this.observers.length; et++)this.sendOne(et, ke) } sendOne(ke, et) { this.task.then(() => { if (void 0 !== this.observers && void 0 !== this.observers[ke]) try { et(this.observers[ke]) } catch (Lt) { typeof console < "u" && console.error && console.error(Lt) } }) } close(ke) { this.finalized || (this.finalized = !0, void 0 !== ke && (this.finalError = ke), this.task.then(() => { this.observers = void 0, this.onNoObservers = void 0 })) } } function Qn() { } const ur = function (fe, ke, et, Lt) { let mt; if (Lt < ke ? mt = "at least " + ke : Lt > et && (mt = 0 === et ? "none" : "no more than " + et), mt) throw new Error(fe + " failed: Was called with " + Lt + (1 === Lt ? " argument." : " arguments.") + " Expects " + mt + ".") }; function dr(fe, ke) { return `${fe} failed: ${ke} argument ` } function vr(fe, ke, et, Lt) { if ((!Lt || et) && "function" != typeof et) throw new Error(dr(fe, ke) + "must be a valid function.") } function At(fe, ke, et, Lt) { if ((!Lt || et) && ("object" != typeof et || null === et)) throw new Error(dr(fe, ke) + "must be a valid context object.") } const ln = function (fe) { const ke = []; let et = 0; for (let Lt = 0; Lt < fe.length; Lt++) { let mt = fe.charCodeAt(Lt); if (mt >= 55296 && mt <= 56319) { const An = mt - 55296; Lt++, m(Lt < fe.length, "Surrogate pair missing trail surrogate."), mt = 65536 + (An << 10) + (fe.charCodeAt(Lt) - 56320) } mt < 128 ? ke[et++] = mt : mt < 2048 ? (ke[et++] = mt >> 6 | 192, ke[et++] = 63 & mt | 128) : mt < 65536 ? (ke[et++] = mt >> 12 | 224, ke[et++] = mt >> 6 & 63 | 128, ke[et++] = 63 & mt | 128) : (ke[et++] = mt >> 18 | 240, ke[et++] = mt >> 12 & 63 | 128, ke[et++] = mt >> 6 & 63 | 128, ke[et++] = 63 & mt | 128) } return ke }, Ae = function (fe) { let ke = 0; for (let et = 0; et < fe.length; et++) { const Lt = fe.charCodeAt(et); Lt < 128 ? ke++ : Lt < 2048 ? ke += 2 : Lt >= 55296 && Lt <= 56319 ? (ke += 4, et++) : ke += 3 } return ke }; function vt(fe, ke = 1e3, et = 2) { const Lt = ke * Math.pow(et, fe), mt = Math.round(.5 * Lt * (Math.random() - .5) * 2); return Math.min(144e5, Lt + mt) } function Zt(fe) { return fe && fe._delegate ? fe._delegate : fe } }, 2: (un, Je, L) => { "use strict"; L.d(Je, { k: () => m, w: () => J }); var i = L(4968); function m() { let ye = document.querySelector(".slide-left"), Ce = document.querySelector(".slide-right"); function we() { let Te = document.querySelectorAll(".slide"), Ee = document.querySelectorAll(".slide-menu"); Te.forEach((_e, ae) => { 1 == _e.classList.contains("is-expanded") && _e.classList.remove("is-expanded") }), Ee.forEach((_e, ae) => { 1 == _e.classList.contains("open") && (_e.classList.remove("open"), _e.style.display = "none") }) } (0, i.R)(ye, "click").subscribe(() => { we() }), (0, i.R)(Ce, "click").subscribe(() => { we() }), J(), (0, i.R)(ye, "click").subscribe(() => { let Te = document.querySelector(".side-menu"), Ee = document.querySelector(".main-sidemenu"), _e = Math.ceil(Number(window.getComputedStyle(Te).marginLeft.split("px")[0])), ae = Math.ceil(Number(window.getComputedStyle(Te).marginRight.split("px")[0])), ve = Ee.offsetWidth; Te.scrollWidth > Ee.offsetWidth && (document.body.classList.contains("rtl") ? ae < 0 && !(Math.abs(ae) < ve) ? (Te.style.marginLeft = 0, Te.style.marginRight = Number(Te.style.marginRight.split("px")[0]) + Math.abs(ve) + "px", Ce.classList.remove("d-none")) : (Te.style.marginRight = "0px", ye.classList.add("d-none"), Ce.classList.remove("d-none")) : _e < 0 && !(Math.abs(_e) < ve) ? (Te.style.marginRight = 0, Te.style.marginLeft = Number(Te.style.marginLeft.split("px")[0]) + Math.abs(ve) + "px", Ce.classList.remove("d-none")) : (Te.style.marginLeft = "0px", ye.classList.add("d-none"), Ce.classList.remove("d-none"))), we() }), (0, i.R)(Ce, "click").subscribe(() => { let Te = document.querySelector(".side-menu"), Ee = document.querySelector(".main-sidemenu"), _e = Math.ceil(Number(window.getComputedStyle(Te).marginLeft.split("px")[0])), ae = Math.ceil(Number(window.getComputedStyle(Te).marginRight.split("px")[0])), ve = Te.scrollWidth - Ee.offsetWidth, xe = Ee.offsetWidth; Te.scrollWidth > Ee.offsetWidth && (document.body.classList.contains("rtl") ? Math.abs(ve) > Math.abs(ae) && (Te.style.marginLeft = 0, Math.abs(ve) > Math.abs(ae) + xe || (xe = Math.abs(ve) - Math.abs(ae), Ce.classList.add("d-none")), Te.style.marginRight = Number(Te.style.marginRight.split("px")[0]) - Math.abs(xe) + "px", ye.classList.remove("d-none")) : Math.abs(ve) > Math.abs(_e) && (Te.style.marginRight = 0, Math.abs(ve) > Math.abs(_e) + xe || (xe = Math.abs(ve) - Math.abs(_e), Ce.classList.add("d-none")), Te.style.marginLeft = Number(Te.style.marginLeft.split("px")[0]) - Math.abs(xe) + "px", ye.classList.remove("d-none"))), we() }) } function J() { let ye = document.querySelector(".side-menu"), Ce = document.querySelector(".main-sidemenu"), we = document.querySelector(".slide-left"), Te = document.querySelector(".slide-right"), Ee = Math.ceil(Number(window.getComputedStyle(ye).marginLeft.split("px")[0])), _e = Math.ceil(Number(window.getComputedStyle(ye).marginRight.split("px")[0])), ae = ye.scrollWidth - Ce.offsetWidth; setTimeout(() => { ye.scrollWidth > Ce.offsetWidth ? (Te.classList.remove("d-none"), we.classList.add("d-none")) : (Te.classList.add("d-none"), we.classList.add("d-none"), ye.style.marginLeft = "0px", ye.style.marginRight = "0px"), 0 == Ee || 0 == _e ? we.classList.add("d-none") : we.classList.remove("d-none"), document.body.classList.contains("rtl") ? ye.scrollWidth > Ce.offsetWidth && (console.log(ye.scrollWidth, Ce.offsetWidth), Math.abs(ae) < Math.abs(_e) && (ye.style.marginRight = -ae + "px", we.classList.remove("d-none"), Te.classList.add("d-none"))) : ye.scrollWidth > Ce.offsetWidth && Math.abs(ae) < Math.abs(Ee) && (ye.style.marginLeft = -ae + "px", we.classList.remove("d-none"), Te.classList.add("d-none")), (0 != Ee || 0 != _e) && we.classList.remove("d-none") }, 500) } }, 9: (un, Je, L) => { "use strict"; L.d(Je, { Fe: () => xe, ME: () => J, YL: () => wt, c3: () => gt, cy: () => Se, os: () => ve, ql: () => ae }); var i = L(4968), m = L(2); function J() { let De = document.querySelector("html")?.style, je = document.querySelector("body"); if (null !== localStorage.getItem("Yohalight-primary-color") && (je?.classList.add("light-mode"), document.getElementById("myonoffswitch1").checked = !0, je?.classList.remove("dark-mode"), De?.setProperty("--primary-bg-color", localStorage.getItem("Yohalight-primary-color")), De?.setProperty("--primary-bg-hover", localStorage.getItem("Yohalight-primary-hover")), De?.setProperty("--primary-bg-border", localStorage.getItem("Yohalight-primary-border"))), null !== localStorage.getItem("Yohadark-primary-color") && (je?.classList.add("dark-mode"), document.getElementById("myonoffswitch2").checked = !0, je?.classList.remove("light-mode"), De?.setProperty("--primary-bg-color", localStorage.getItem("Yohadark-primary-color")), De?.setProperty("--primary-bg-hover", localStorage.getItem("Yohadark-primary-hover")), De?.setProperty("--primary-bg-border", localStorage.getItem("Yohadark-primary-border"))), null !== localStorage.getItem("Yohadark-body") && (je?.classList.add("dark-mode"), document.getElementById("myonoffswitch2").checked = !0, je?.classList.remove("light-mode"), De?.setProperty("--dark-body", localStorage.getItem("Yohadark-body"))), null !== localStorage.getItem("YohalightTheme") && (je?.classList.add("light-mode"), document.getElementById("myonoffswitch1").checked = !0), null !== localStorage.getItem("YohadarkTheme") && (je?.classList.add("dark-mode"), document.getElementById("myonoffswitch2").checked = !0), null !== localStorage.getItem("Yohatransparent-bg-color") && (je?.classList.add("light-mode"), document.getElementById("myonoffswitch2").checked = !0, je?.classList.remove("dark-mode"), De?.setProperty("--dark-body", localStorage.getItem("Yohatransparent-bg-color")), De?.setProperty("--dark-theme", localStorage.getItem("Yohatransparent-primary-hover")), De?.setProperty("--primary-bg-border", localStorage.getItem("Yohatransparent-primary-border"))), localStorage.getItem("Yohartl")) { document.getElementById("myonoffswitch55").checked = !0; let Qe = document.querySelector("#style"); document.querySelector("body")?.classList.add("rtl"), document.querySelector("html")?.setAttribute("dir", "rtl"), Qe?.setAttribute("href", "assets/plugins/bootstrap/css/bootstrap.rtl.css"), je?.classList.remove("ltr"), m.w() } if (null !== localStorage.getItem("Yohahorizontal")) { document.getElementById("myonoffswitch35").checked = !0; let Qe = document.querySelector(".main-content"), ct = document.querySelectorAll(".main-container"), Oe = document.querySelector(".app-sidebar"), Ve = document.querySelector(".header"), Be = document.querySelector(".main-sidemenu"), nt = document.querySelector(".horizontal .side-menu"); je?.classList.add("horizontal"), Qe?.classList.add("hor-content"), ct.forEach(tt => { tt.classList.add("container") }), Ve?.classList.add("hor-header"), Oe?.classList.add("horizontal-main"), Be?.classList.add("container"), nt?.classList.add("flex-nowrap"), nt?.classList.remove("flex-wrap"), Qe?.classList.remove("app-content"), ct.forEach(tt => { tt.classList.remove("container-fluid") }), Ve?.classList.remove("app-header"), je?.classList.remove("sidebar-mini"), je?.classList.remove("sidenav-toggled"), je?.classList.remove("horizontal-hover"), document.querySelectorAll(".side-menu li").forEach((tt, Fe) => { tt.classList.remove("is-expanded") }), m.w(), document.querySelector(".slide-leftRTL")?.classList.add("d-none"), document.querySelector(".slide-rightRTL")?.classList.add("d-none") } if (null !== localStorage.getItem("YohahorizontalHover")) { document.getElementById("myonoffswitch111").checked = !0; let Qe = document.querySelector(".main-content"), ct = document.querySelectorAll(".main-container"), Oe = document.querySelector(".app-sidebar"), Ve = document.querySelector(".header"), Be = document.querySelector(".main-sidemenu"), nt = document.querySelector(".horizontal .side-menu"); je?.classList.add("horizontal"), je?.classList.add("horizontal-hover"), Qe?.classList.add("hor-content"), ct.forEach(tt => { tt.classList.add("container") }), Ve?.classList.add("hor-header"), Oe?.classList.add("horizontal-main"), Be?.classList.add("container"), nt?.classList.add("flex-wrap"), nt?.classList.remove("flex-nowrap"), Qe?.classList.remove("app-content"), ct.forEach(tt => { tt.classList.remove("container-fluid") }), Ve?.classList.remove("app-header"), je?.classList.remove("sidebar-mini"), je?.classList.remove("sidenav-toggled"), document.querySelectorAll(".side-menu li").forEach((tt, Fe) => { tt.classList.remove("is-expanded") }), m.w() } } function ye(De) { const je = document.querySelector(":root"); Object.keys(De).forEach(Qe => { je.style.setProperty(Qe, De[Qe]) }) } const Te = De => parseInt(De.repeat(2 / De.length), 16); function _e(De, je = 1) { if (!(De => /^#([A-Fa-f0-9]{3,4}){1,2}$/.test(De))(De)) return null; const _t = Math.floor((De.length - 1) / 3), Qe = ((De, je) => De.match(new RegExp(`.{${je}}`, "g")))(De.slice(1), _t), [ct, Oe, Ve, Be] = Qe.map(Te); return `rgba(${ct}, ${Oe}, ${Ve}, ${((De, je) => typeof De < "u" ? De / 255 : "number" != typeof je || je < 0 || je > 1 ? 1 : je)(Be, je)})` } function ae() { let De = document.querySelector("body"), je = document.querySelector("html"), _t = document.querySelectorAll("#myonoffswitch54"), Qe = document.querySelectorAll("#myonoffswitch55"), ct = document.querySelectorAll("#myonoffswitch34"), Oe = document.querySelectorAll("#myonoffswitch35"), Ve = document.querySelectorAll("#myonoffswitch111"), Be = document.querySelectorAll(".main-container"), nt = document.querySelector("#myonoffswitch9"), Ne = document.querySelector("#myonoffswitch10"), tt = document.querySelector("#myonoffswitch11"), Fe = document.querySelector("#myonoffswitch12"), Ue = document.querySelector(".main-content"), st = document.querySelector(".app-sidebar"), ht = document.querySelector(".header"), Kt = document.querySelector(".main-sidemenu"), rn = document.getElementById("myonoffswitch1"), On = document.getElementById("myonoffswitch2"), qn = document.querySelector(".horizontal .side-menu"), nr = document.querySelector("#myonoffswitch3"), kn = document.querySelector("#myonoffswitch4"), fn = document.querySelector("#myonoffswitch5"), It = document.querySelector("#myonoffswitch25"), Yt = document.querySelector("#myonoffswitch6"), pt = document.querySelector("#myonoffswitch8"), Pt = document.querySelector("#myonoffswitch26"), Ze = document.querySelector("#myonoffswitch7"), Ot = document.querySelector("#style"); (0, i.R)(_t, "click").subscribe(() => { De?.classList.add("ltr"), je?.setAttribute("dir", "ltr"), Ot?.setAttribute("href", "assets/plugins/bootstrap/css/bootstrap.css"), De?.classList.remove("rtl"), m.w(), localStorage.setItem("Yohaltr", "true"), localStorage.removeItem("Yohartl") }), (0, i.R)(Qe, "click").subscribe(() => { De?.classList.add("rtl"), je?.setAttribute("dir", "rtl"), Ot?.setAttribute("href", "assets/plugins/bootstrap/css/bootstrap.rtl.css"), De?.classList.remove("ltr"), m.w(), localStorage.setItem("Yohartl", "true"), localStorage.removeItem("Yohaltr") }), (0, i.R)(ct, "click").subscribe(() => { Ue?.classList.add("app-content"), Be.forEach(le => { le.classList.add("container-fluid") }), ht?.classList.add("app-header"), De?.classList.add("sidebar-mini"), De?.classList.remove("horizontal"), De?.classList.remove("horizontal-hover"), st?.classList.remove("horizontal-main"), Ue?.classList.remove("hor-content"), ht?.classList.remove("hor-header"), Be.forEach(le => { le.classList.remove("container") }), document.querySelector(".slide-left")?.classList.add("d-none"), document.querySelector(".slide-right")?.classList.add("d-none"), document.querySelector(".slide-leftRTL")?.classList.add("d-none"), document.querySelector(".slide-rightRTL")?.classList.add("d-none"), localStorage.setItem("YohasidebarMini", "true"), localStorage.removeItem("Yohahorizontal"), localStorage.removeItem("YohahorizontalHover") }), (0, i.R)(Oe, "click").subscribe(() => { De?.classList.add("horizontal"), Ue?.classList.add("hor-content"), Be.forEach(Xe => { Xe.classList.add("container") }), ht?.classList.add("hor-header"), st?.classList.add("horizontal-main"), Kt?.classList.add("container"), qn?.classList.add("flex-nowrap"), qn?.classList.remove("flex-wrap"), Ue?.classList.remove("app-content"), Be.forEach(Xe => { Xe.classList.remove("container-fluid") }), ht?.classList.remove("app-header"), De?.classList.remove("sidebar-mini"), De?.classList.remove("sidenav-toggled"), De?.classList.remove("horizontal-hover"), document.querySelectorAll(".side-menu li").forEach((Xe, kt) => { Xe.classList.remove("is-expanded") }), m.w(), localStorage.setItem("Yohahorizontal", "true"), localStorage.removeItem("YohahorizontalHorizontal"), localStorage.removeItem("YohasidebarMini") }), (0, i.R)(Ve, "click").subscribe(() => { De?.classList.add("horizontal"), De?.classList.add("horizontal-hover"), Ue?.classList.add("hor-content"), Be.forEach(Xe => { Xe.classList.add("container") }), ht?.classList.add("hor-header"), st?.classList.add("horizontal-main"), Kt?.classList.add("container"), qn?.classList.add("flex-nowrap"), qn?.classList.remove("flex-wrap"), Ue?.classList.remove("app-content"), Be.forEach(Xe => { Xe.classList.remove("container-fluid") }), ht?.classList.remove("app-header"), De?.classList.remove("sidebar-mini"), De?.classList.remove("sidenav-toggled"), document.querySelectorAll(".side-menu li").forEach((Xe, kt) => { Xe.classList.remove("is-expanded") }), m.w(), localStorage.setItem("YohahorizontalHover", "true"), localStorage.removeItem("Yohahorizontal"), localStorage.removeItem("YohasidebarMini") }), (0, i.R)(rn, "click").subscribe(() => { localStorage.removeItem("Yohatransparent-primary-border"), document.getElementById("myonoffswitch3").checked = !0, document.getElementById("myonoffswitch6").checked = !0, rn.checked = !0, document.documentElement.style.setProperty("--primary-bg-color", "var(--primary)"), document.documentElement.style.setProperty("--primary02", "rgba(var(--primary),0.2)"), document.documentElement.style.setProperty("--primary0", "var(--primary)"), document.querySelector("body")?.classList.add("light-mode"), document.querySelector("body")?.classList.remove("dark-mode"), localStorage.setItem("Yohalight-mode", "true"), localStorage.removeItem("Yohadark-mode") }), (0, i.R)(On, "click").subscribe(() => { document.getElementById("myonoffswitch8").checked = !0, document.getElementById("myonoffswitch5").checked = !0, On.checked = !0, document.documentElement.style.setProperty("--primary-bg-color", "var(--primary)"), document.documentElement.style.setProperty("--primary02", "rgba(var(--primary),0.2)"), document.documentElement.style.setProperty("--primary0", "var(--primary)"), localStorage.removeItem("Yohalight-primary-border"), document.querySelector("body")?.classList.add("dark-mode"), document.querySelector("body")?.classList.remove("light-mode"), localStorage.setItem("Yohadark-mode", "true"), localStorage.removeItem("Yohalight-mode") }), (0, i.R)(nt, "click").subscribe(() => { De?.classList.add("layout-fullwidth"), De?.classList.remove("layout-boxed"), m.w() }), (0, i.R)(Ne, "click").subscribe(() => { De?.classList.add("layout-boxed"), De?.classList.remove("layout-fullwidth"), m.w() }), (0, i.R)(tt, "click").subscribe(() => { De?.classList.add("fixed-layout"), De?.classList.remove("scrollable-layout") }), (0, i.R)(Fe, "click").subscribe(() => { De?.classList.add("scrollable-layout"), De?.classList.remove("fixed-layout") }), (0, i.R)(nr, "click").subscribe(() => { De?.classList.add("light-menu"), De?.classList.remove("color-menu"), De?.classList.remove("dark-menu"), De?.classList.remove("gradient-menu") }), (0, i.R)(kn, "click").subscribe(() => { De?.classList.add("color-menu"), De?.classList.remove("light-menu"), De?.classList.remove("dark-menu"), De?.classList.remove("gradient-menu") }), (0, i.R)(fn, "click").subscribe(() => { De?.classList.add("dark-menu"), De?.classList.remove("color-menu"), De?.classList.remove("light-menu"), De?.classList.remove("gradient-menu") }), (0, i.R)(It, "click").subscribe(() => { De?.classList.add("gradient-menu"), De?.classList.remove("color-menu"), De?.classList.remove("light-menu"), De?.classList.remove("dark-menu") }), (0, i.R)(Yt, "click").subscribe(() => { De?.classList.add("header-light"), De?.classList.remove("color-header"), De?.classList.remove("gradient-header"), De?.classList.remove("dark-header") }), (0, i.R)(pt, "click").subscribe(() => { De?.classList.add("dark-header"), De?.classList.remove("header-light"), De?.classList.remove("color-header"), De?.classList.remove("gradient-header") }), (0, i.R)(Ze, "click").subscribe(() => { De?.classList.add("color-header"), De?.classList.remove("header-light"), De?.classList.remove("gradient-header"), De?.classList.remove("dark-header") }), (0, i.R)(Pt, "click").subscribe(() => { De?.classList.add("gradient-header"), De?.classList.remove("header-light"), De?.classList.remove("color-header"), De?.classList.remove("dark-header") }) } function ve() { document.querySelector("body")?.classList.contains("header-light") && document.querySelector("body")?.classList.remove("header-light"), document.querySelector("body")?.classList.contains("color-header") && document.querySelector("body")?.classList.remove("color-header"), document.querySelector("body")?.classList.contains("gradient-header") && document.querySelector("body")?.classList.remove("gradient-header"), document.querySelector("body")?.classList.contains("dark-header") && document.querySelector("body")?.classList.remove("dark-header"), document.querySelector("body")?.classList.contains("light-menu") && document.querySelector("body")?.classList.remove("light-menu"), document.querySelector("body")?.classList.contains("color-menu") && document.querySelector("body")?.classList.remove("color-menu"), document.querySelector("body")?.classList.contains("gradient-menu") && document.querySelector("body")?.classList.remove("gradient-menu"), document.querySelector("body")?.classList.contains("dark-menu") && document.querySelector("body")?.classList.remove("dark-menu") } function xe() { document.querySelector("body")?.classList.contains("header-light") && (document.getElementById("myonoffswitch6").checked = !0), document.querySelector("body")?.classList.contains("color-header") && (document.getElementById("myonoffswitch7").checked = !0), document.querySelector("body")?.classList.contains("gradient-header") && (document.getElementById("myonoffswitch26").checked = !0), document.querySelector("body")?.classList.contains("dark-header") && (document.getElementById("myonoffswitch8").checked = !0), document.querySelector("body")?.classList.contains("light-menu") && (document.getElementById("myonoffswitch3").checked = !0), document.querySelector("body")?.classList.contains("color-menu") && (document.getElementById("myonoffswitch4").checked = !0), document.querySelector("body")?.classList.contains("gradient-menu") && (document.getElementById("myonoffswitch25").checked = !0), document.querySelector("body")?.classList.contains("dark-menu") && (document.getElementById("myonoffswitch5").checked = !0) } function gt(De, je) { De.forEach(_t => { const Qe = `--primary-${_t.getAttribute("data-id")}`, ct = `--primary-${_t.getAttribute("data-id1")}`, Oe = `--primary-${_t.getAttribute("data-id2")}`, Ve = `--primary-${_t.getAttribute("data-id9")}`; ye({ [Qe]: _e(je), [ct]: _e(je), [Oe]: _e(je), [Ve]: _e(je) }) }) } function Se(De, je) { De.forEach(_t => { const Qe = `--dark-${_t.getAttribute("data-id5")}`, ct = `--dark-${_t.getAttribute("data-id6")}`; ye({ [Qe]: _e(je, .9), [ct]: _e(je, 1.2) }) }) } let rt; function wt() { let De = getComputedStyle(document.documentElement).getPropertyValue("--primary-bg-color").trim(); rt = localStorage.getItem("Yohalight-primary-color") || localStorage.getItem("Yohadark-primary-color") || localStorage.getItem("Yohatransparent-primary-color") || De; let je = _e(rt, .1); document.querySelector("html")?.style.setProperty("--primary01", je); let _t = _e(rt, .2); document.querySelector("html")?.style.setProperty("--primary02", _t); let Qe = _e(rt, .3); document.querySelector("html")?.style.setProperty("--primary03", Qe); let ct = _e(rt, .3); document.querySelector("html")?.style.setProperty("--primary05", ct); let Oe = _e(rt, .6); document.querySelector("html")?.style.setProperty("--primary06", Oe); let Ve = _e(rt, .3); document.querySelector("html")?.style.setProperty("--primary07", Ve); let Be = _e(rt, .6); document.querySelector("html")?.style.setProperty("--primary08", Be); let nt = _e(rt, .7); document.querySelector("html")?.style.setProperty("--primary09", nt) } wt() }, 3603: (un, Je, L) => { "use strict"; L.d(Je, { a: () => J }); var i = L(7579), m = L(4650); let J = (() => { class ye { constructor() { this.emitChangeSource = new i.x, this.changeEmitted = this.emitChangeSource.asObservable(), this.emitHoverChangeSource = new i.x, this.changeHoverEmitted = this.emitHoverChangeSource.asObservable() } emitChange(we) { this.emitChangeSource.next(we) } emitHoverChange(we) { this.emitHoverChangeSource.next(we) } } return ye.\u0275fac = function (we) { return new (we || ye) }, ye.\u0275prov = m.Yz7({ token: ye, factory: ye.\u0275fac, providedIn: "root" }), ye })() }, 5087: (un, Je, L) => { "use strict"; var i = L(1481), m = L(4650), J = L(8988), ye = L(3603), Ce = L(7579), we = L(1135), Te = L(4968), Ee = L(8372), _e = L(2722); let ae = (() => { class n { constructor(t, r) { this.router = t, this.route = r, this.unsubscriber = new Ce.x, this.screenWidth = new we.X(window.innerWidth), this.collapseSidebar = window.innerWidth < 991, this.MENUITEMS = [{ headTitle: "MAIN" }, { title: "Dashboard", selected: !1, icon: "home", type: "sub", Menusub: !0, active: !1, children: [{ path: "/dashboard/sales-dashboard", title: "Sales Dashboard", type: "link", selected: !1 }, { path: "/dashboard/marketing-dashboard", title: "Marketing Dashboard", type: "link", selected: !1 }, { path: "/dashboard/app-dashboard", title: "App Dashboard", type: "link", selected: !1 }, { path: "/dashboard/lms-dashboard", title: "Lms Dashboard", type: "link", selected: !1 }, { path: "/dashboard/analytics-dashboard", title: "Analytics Dashboard", type: "link", selected: !1 }] }, { headTitle: "Apps" }, { title: "Apps", selected: !1, icon: "download", type: "sub", Menusub: !0, active: !1, children: [{ path: "/apps/widgets", title: "Widgets", type: "link", selected: !1 }, { path: "/switchercontent/switcher", title: "Switcher", type: "link", selected: !1 }, { title: "Maps", type: "sub", active: !1, Menusub: !0, children: [{ path: "/apps/maps/leaflet-maps", title: "Leaflet Maps", type: "link" }] }, { title: "Mails", type: "sub", active: !1, Menusub: !0, children: [{ path: "/apps/mails/mail-compose", title: "Mail-Compose", type: "link" }, { path: "/apps/mails/mail-inbox", title: "Mail-inbox", type: "link" }, { path: "/apps/mails/view-mail", title: "View-mail", type: "link" }] }] }, { headTitle: "ELEMENTS" }, { title: "Components", selected: !1, icon: "compass", type: "sub", Menusub: !0, active: !1, children: [{ path: "/components/cards-design", title: "Cards design", type: "link", selected: !1 }, { path: "/components/default-calendar", title: "Default calendar", type: "link", selected: !1 }, { path: "/components/full-calendar", title: "Full calendar", type: "link", selected: !1 }, { path: "/components/contacts", title: "Contacts", type: "link", selected: !1 }, { path: "/components/collapse", title: "collapse", type: "link", selected: !1 }, { path: "/components/default-chat", title: "Default chat", type: "link", selected: !1 }, { path: "/components/notifications", title: "Notifications", type: "link", selected: !1 }, { path: "/components/sweet-alerts", title: "Sweet alerts", type: "link", selected: !1 }, { path: "/components/range-slider", title: "Range slider", type: "link", selected: !1 }, { path: "/components/content-scroll-bar", title: "content scroll bar", type: "link", selected: !1 }, { path: "/components/loaders", title: "Loaders", type: "link", selected: !1 }, { path: "/components/counters", title: "Counters", type: "link", selected: !1 }, { path: "/components/rating", title: "Rating", type: "link", selected: !1 }, { path: "/components/timeline", title: "Timeline", type: "link", selected: !1 }, { path: "/components/treeview", title: "Treeview", type: "link", selected: !1 }] }, { title: "Elements", selected: !1, icon: "database", type: "sub", Menusub: !0, active: !1, children: [{ path: "/elements/alerts", title: "Alerts", type: "link", selected: !1 }, { path: "/elements/buttons", title: "Buttons", type: "link", selected: !1 }, { path: "/elements/dropdowns", title: "Dropdowns", type: "link", selected: !1 }, { path: "/elements/colors", title: "Colors", type: "link", selected: !1 }, { path: "/elements/avatar-square", title: "Avatar-Square", type: "link", selected: !1 }, { path: "/elements/avatar-rounded", title: "Avatar-Rounded", type: "link", selected: !1 }, { path: "/elements/avatar-radius", title: "Avatar-Radius", type: "link", selected: !1 }, { path: "/elements/list-listgroups", title: "List&Listgroups", type: "link", selected: !1 }, { path: "/elements/tags", title: "Tags", type: "link", selected: !1 }, { path: "/elements/toast", title: "Toast", type: "link", selected: !1 }, { path: "/elements/offcanvas", title: "Offcanvas", type: "link", selected: !1 }, { path: "/elements/pagination", title: "Pagination", type: "link", selected: !1 }, { path: "/elements/navigation", title: "Navigation", type: "link", selected: !1 }, { path: "/elements/typography", title: "Typography", type: "link", selected: !1 }, { path: "/elements/breadcrumbs", title: "Breadcrumbs", type: "link", selected: !1 }, { path: "/elements/badges", title: "Badges", type: "link", selected: !1 }, { path: "/elements/panels", title: "Panels", type: "link", selected: !1 }, { path: "/elements/thumbnails", title: "Thumnails", type: "link", selected: !1 }] }, { title: "Advanced UI", selected: !1, icon: "box", type: "sub", Menusub: !0, active: !1, children: [{ path: "/advanced-ui/media-object", title: "Media object", type: "link", selected: !1 }, { path: "/advanced-ui/accordions", title: "Accordions", type: "link", selected: !1 }, { path: "/advanced-ui/tabs", title: "Tabs", type: "link", selected: !1 }, { path: "/advanced-ui/modal", title: "Modal", type: "link", selected: !1 }, { path: "/advanced-ui/tooltip-and-popover", title: "Tooltip and popover", type: "link", selected: !1 }, { path: "/advanced-ui/progress", title: "Progress", type: "link", selected: !1 }, { path: "/advanced-ui/carousels", title: "Carousels", type: "link", selected: !1 }, { path: "/advanced-ui/footers", title: "Footers", type: "link", selected: !1 }, { path: "/advanced-ui/user-list", title: "User list", type: "link", selected: !1 }, { path: "/advanced-ui/search", title: "Search", type: "link", selected: !1 }, { path: "/advanced-ui/crypto-currencies", title: "Crypto-currencies", type: "link", selected: !1 }] }, { headTitle: "ICONS" }, { title: "Icons", selected: !1, icon: "wind", type: "sub", Menusub: !0, active: !1, children: [{ path: "/icons/font-awesome", title: "Font Awesome", type: "link", selected: !1 }, { path: "/icons/material-design-icons", title: "Material Design Icons", type: "link", selected: !1 }, { path: "/icons/simple-line-icons", title: "Simple Line Icons", type: "link", selected: !1 }, { path: "/icons/feather-icons", title: "Feather Icons", type: "link", selected: !1 }, { path: "/icons/lonic-icons", title: "lonic-Icons", type: "link", selected: !1 }, { path: "/icons/flag-icons", title: "Flag Icons", type: "link", selected: !1 }, { path: "/icons/pe7icons", title: "pe7 Icons", type: "link", selected: !1 }, { path: "/icons/themify-icons", title: "Themify Icons", type: "link", selected: !1 }, { path: "/icons/typicons-icons", title: "Typicons Icons", type: "link", selected: !1 }, { path: "/icons/weather-icons", title: "Weather Icons", type: "link", selected: !1 }, { path: "/icons/bootstrap-icons", title: "Bootstrap Icons", type: "link", selected: !1 }] }, { headTitle: "PAGES" }, { title: "Pages", selected: !1, icon: "layers", type: "sub", Menusub: !0, active: !1, children: [{ path: "/pages/profile", title: "Profile", type: "link", selected: !1 }, { path: "/pages/gallery", title: "Gallery", type: "link", selected: !1 }, { path: "/pages/about-company", title: "About Company", type: "link", selected: !1 }, { path: "/pages/services", title: "Services", type: "link", selected: !1 }, { path: "/pages/faqs", title: "FAQS", type: "link", selected: !1 }, { path: "/pages/terms", title: "Terms", type: "link", selected: !1 }, { path: "/pages/invoice", title: "Invoice", type: "link", selected: !1 }, { path: "/pages/pricing-tables", title: "Pricing  Tables", type: "link", selected: !1 }, { path: "/pages/settings", title: "Settings", type: "link", selected: !1 }, { title: "Blog", selected: !1, icon: "slack", type: "sub", Menusub: !0, active: !1, children: [{ path: "/pages/blog/blog-page", title: "Blog-page", type: "link", selected: !1 }, { path: "/pages/blog/blog-details", title: "Blog-details", type: "link", selected: !1 }, { path: "/pages/blog/blog-post", title: "Blog-post", type: "link", selected: !1 }] }, { title: "Charts", selected: !1, icon: "slack", type: "sub", Menusub: !0, active: !1, children: [{ path: "/pages/charts/apexcharts", title: "Apexcharts", type: "link", selected: !1 }, { path: "/pages/charts/chartjs", title: "Chart-js", type: "link", selected: !1 }, { path: "/pages/charts/echarts", title: "Echarts", type: "link", selected: !1 }] }, { title: "Tables", selected: !1, icon: "slack", type: "sub", Menusub: !0, active: !1, children: [{ path: "/pages/tables/default-table", title: "Default table", type: "link", selected: !1 }, { path: "/pages/tables/data-tables", title: "Data tables", type: "link", selected: !1 }, { path: "/pages/tables/edit-tables", title: "Edit tables", type: "link", selected: !1 }] }, { title: "Forms", selected: !1, icon: "slack", type: "sub", Menusub: !0, active: !1, children: [{ path: "/pages/forms/form-elements", title: "Form Elements", type: "link", selected: !1 }, { path: "/pages/forms/form-layouts", title: "Form Layouts", type: "link", selected: !1 }, { path: "/pages/forms/form-editor", title: "Form Editor", type: "link", selected: !1 }, { path: "/pages/forms/form-wizard", title: "Form wizard", type: "link", selected: !1 }, { path: "/pages/forms/form-validation", title: "Form Validation", type: "link", selected: !1 }, { path: "/pages/forms/form-element-sizes", title: "Form Element sizes", type: "link", selected: !1 }] }, { title: "File Manager", selected: !1, icon: "slack", type: "sub", Menusub: !0, active: !1, children: [{ path: "/pages/file-manager/file-manager", title: "File Manager", type: "link", selected: !1 }, { path: "/pages/file-manager/file-manager-list", title: "File Manager List", type: "link", selected: !1 }, { path: "/pages/file-manager/file-details", title: "File Details", type: "link", selected: !1 }, { path: "/pages/file-manager/file-attachments", title: "File Attachments", type: "link", selected: !1 }] }, { path: "/pages/empty-page", title: "Empty Page", type: "link", selected: !1 }] }, { headTitle: "E-COMMERCE" }, { title: "E-commerce", selected: !1, icon: "shopping-cart", type: "sub", Menusub: !0, active: !1, children: [{ path: "/e-commerce/shop", title: "Shop", type: "link", selected: !1 }, { path: "/e-commerce/product-details", title: "Product Details", type: "link", selected: !1 }, { path: "/e-commerce/shopping-cart", title: "Shopping Cart", type: "link", selected: !1 }, { path: "/e-commerce/add-product", title: "Add Product", type: "link", selected: !1 }, { path: "/e-commerce/wish-list", title: "Wish List", type: "link", selected: !1 }, { path: "/e-commerce/checkout", title: "Checkout", type: "link", selected: !1 }] }, { headTitle: "CUSTOM & ERROR PAGES" }, { title: "Custom Pages", selected: !1, icon: "target", type: "sub", Menusub: !0, active: !1, children: [{ path: "/custom-pages/login", title: "Login", type: "link", selected: !1 }, { path: "/custom-pages/register", title: "Register", type: "link", selected: !1 }, { path: "/custom-pages/forgot-password", title: "Forgot Password", type: "link", selected: !1 }, { path: "/custom-pages/lock-screen", title: "Lock-screen", type: "link", selected: !1 }, { path: "/custom-pages/under-construction", title: "Under Construction", type: "link", selected: !1 }] }, { title: "Error Pages", selected: !1, icon: "alert-circle", type: "sub", Menusub: !0, active: !1, children: [{ path: "/error-pages/error400", title: "error400", type: "link", selected: !1 }, { path: "/error-pages/error401", title: "error401", type: "link", selected: !1 }, { path: "/error-pages/error403", title: "error403", type: "link", selected: !1 }, { path: "/error-pages/error404", title: "error404", type: "link", selected: !1 }, { path: "/error-pages/error500", title: "error500", type: "link", selected: !1 }, { path: "/error-pages/error503", title: "error503", type: "link", selected: !1 }] }], this.items = new we.X(this.MENUITEMS), this.setScreenWidth(window.innerWidth), (0, Te.R)(window, "resize").pipe((0, Ee.b)(1e3), (0, _e.R)(this.unsubscriber)).subscribe(a => { this.setScreenWidth(a.target.innerWidth), a.target.innerWidth < 991 && (this.collapseSidebar = !0) }), window.innerWidth < 991 && this.router.events.subscribe(a => { this.collapseSidebar = !0 }) } ngOnDestroy() { this.unsubscriber.complete() } setScreenWidth(t) { this.screenWidth.next(t) } } return n.\u0275fac = function (t) { return new (t || n)(m.LFG(J.F0), m.LFG(J.gz)) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), ve = (() => { class n { constructor() { } ngOnInit() { } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-footer"]], decls: 13, vars: 0, consts: [[1, "footer"], [1, "container"], [1, "row", "align-items-center", "flex-row-reverse"], [1, "col-md-12", "col-sm-12", "text-center"], ["href", "javascript:void(0);"], [1, "fa", "fa-heart", "text-danger"]], template: function (t, r) { 1 & t && (m.TgZ(0, "footer", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3), m._uU(4, " Copyright \xa9 2023 "), m.TgZ(5, "a", 4), m._uU(6, "Yoha"), m.qZA(), m._uU(7, ". Designed with "), m._UZ(8, "span", 5), m._uU(9, " by "), m.TgZ(10, "a", 4), m._uU(11, " Spruko "), m.qZA(), m._uU(12, " All rights reserved. "), m.qZA()()()()) } }), n })(), xe = (() => { class n { constructor() { this.emitSidebarNofitSource = new Ce.x, this.SidebarNotifyChangeEmitted = this.emitSidebarNofitSource.asObservable(), this.emitSwitcherSource = new Ce.x, this.SwitcherChangeEmitted = this.emitSwitcherSource.asObservable() } emitSidebarNotifyChange(t) { this.emitSidebarNofitSource.next(t) } emitSwitcherChange(t) { this.emitSwitcherSource.next(t) } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); var gt = L(3314); let Se = (() => { class n { constructor() { this.allData = [{ id: "1", name: "Candy Pure Rose Water", offer_price: "$16,599", photo: "assets/images/pngs/9.jpg", price: "$19,799", Quantity: 1 }] } gettingData(t) { return this.allData.push(...t), t } retunData() { return this.allData } addingQuantity(t) { this.allData[0].Quantity++ } decreaseQuantity(t) { this.allData[0].Quantity > 0 && this.allData[0].Quantity-- } delectItem(t) { var r = this.allData.filter(a => a.id != t); this.allData = r } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); var rt = L(6895), wt = L(4006); let De = (() => { class n { constructor() { this.body = document.querySelector("body") } toggleTheme() { this.body != !this.body && (this.body.classList.toggle("dark-mode"), this.body.classList.remove("bg-img1"), this.body.classList.remove("bg-img2"), this.body.classList.remove("bg-img3"), this.body.classList.remove("bg-img4")) } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275dir = m.lG2({ type: n, selectors: [["", "appToggleTheme", ""]], hostBindings: function (t, r) { 1 & t && m.NdJ("click", function () { return r.toggleTheme() }) } }), n })(), je = (() => { class n { constructor(t) { this.document = t, this.fullScreen = !1 } ngOnInit() { this.elem = document.documentElement } onClick() { this.fullScreen = !this.fullScreen, this.fullScreen ? this.elem.requestFullscreen ? this.elem.requestFullscreen() : this.elem.mozRequestFullScreen ? this.elem.mozRequestFullScreen() : this.elem.webkitRequestFullscreen ? this.elem.webkitRequestFullscreen() : this.elem.msRequestFullscreen && this.elem.msRequestFullscreen() : this.document.exitFullscreen ? this.document.mozCancelFullScreen ? this.document.mozCancelFullScreen() : this.document.webkitExitFullscreen ? this.document.webkitExitFullscreen() : this.document.msExitFullscreen && this.document.msExitFullscreen() : this.document.exitFullscreen() } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(rt.K0)) }, n.\u0275dir = m.lG2({ type: n, selectors: [["", "appFullscreen", ""]], hostBindings: function (t, r) { 1 & t && m.NdJ("click", function () { return r.onClick() }) } }), n })(); function _t(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "li", 114), m.NdJ("click", function () { m.CHM(t); const a = m.oxw(2); return m.KtG(a.clearSearch()) }), m._UZ(1, "i", 115), m._uU(2), m.qZA() } if (2 & n) { const t = e.$implicit; m.Q6J("routerLink", null == t ? null : t.path), m.xp6(2), m.hij("", null == t ? null : t.title, " ") } } function Qe(n, e) { if (1 & n && (m.TgZ(0, "div", 109)(1, "div", 110)(2, "h4", 111), m._uU(3), m.qZA(), m.TgZ(4, "small"), m._uU(5, " limit dropdown 5 only"), m.qZA()(), m.TgZ(6, "ul", 112), m.YNc(7, _t, 3, 2, "li", 113), m.ALo(8, "slice"), m.qZA()()), 2 & n) { const t = m.oxw(); m.xp6(3), m.hij('Search result of "', t.text, '" '), m.xp6(4), m.Q6J("ngForOf", m.Dn7(8, 2, t.menuItems, 0, 5)) } } const ct = function (n) { return { show: n } }; function Oe(n, e) { if (1 & n && (m.TgZ(0, "ul", 116)(1, "li", 117), m._UZ(2, "i", 118), m._uU(3), m.qZA()()), 2 & n) { const t = m.oxw(); m.xp6(1), m.Q6J("ngClass", m.VKq(2, ct, t.SearchResultEmpty)), m.xp6(2), m.hij('No Search Result Found with "', t.text, '" ') } } const Ve = function () { return { standalone: !0 } }; let Be = (() => { class n { constructor(t, r, a, d, _, E) { this.layoutService = t, this.navServices = r, this.modalService = a, this.SwitcherService = d, this.ShopService = _, this.router = E, this.isCollapsed = !0, this.SearchResultEmpty = !1 } ngOnInit() { this.navServices.items.subscribe(t => { this.items = t }) } toggleSidebar() { (this.navServices.collapseSidebar = !0) && document.querySelector("body")?.classList.toggle("sidenav-toggled") } toggleSidebarNotification() { this.layoutService.emitSidebarNotifyChange(!0) } toggleSwitcher() { this.SwitcherService.emitChange(!0), document.querySelector("body")?.classList.remove("sidenav-toggled-open") } Search(t) { if (!t) return this.menuItems = []; let r = []; t = t.toLowerCase().trim(), this.items.filter(a => !(!a?.title || ("link" === a.type && a.title.toLowerCase().includes(t) && a.title.toLowerCase().startsWith(t) && r.push(a), !a.children)) && (a.children.filter(d => { if ("link" === d.type && d.title.toLowerCase().includes(t) && d.title.toLowerCase().startsWith(t) && r.push(d), !d.children) return !1; d.children.filter(_ => { _.title.toLowerCase().includes(t) && _.title.toLowerCase().startsWith(t) && r.push(_) }) }), this.menuItems = r)), this.SearchResultEmpty = !r.length } clearSearch() { return this.text = "", this.menuItems = [], this.SearchResultEmpty = !1, this.menuItems } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(xe), m.Y36(ae), m.Y36(gt.FF), m.Y36(ye.a), m.Y36(Se), m.Y36(J.F0)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-header"]], decls: 200, vars: 8, consts: [[1, "app-header", "header", "sticky"], [1, "container-fluid", "main-container"], [1, "d-flex", "align-items-center"], ["aria-label", "Hide Sidebar", "data-bs-toggle", "sidebar", 1, "app-sidebar__toggle", 3, "click"], ["aria-hidden", "true", 1, "fe", "fe-menu"], ["href", "index.html", 1, "logo-horizontal"], ["src", "assets/images/brand/logo.png", "alt", "logo", 1, "header-brand-img", "desktop-logo"], ["routerLink", "/components/default-chat/dashboard/sales-dashboard", "src", "assets/images/brand/logo-3.png", "alt", "logo", 1, "header-brand-img", "light-logo1"], [1, "header-search", "d-none", "d-lg-flex"], [1, "form-inline"], [1, "search-element"], ["type", "search", "placeholder", "Search\u2026", "aria-label", "Search", "tabindex", "1", "autocomplete", "off", 1, "form-control", "header-search", 3, "ngModel", "ngModelOptions", "ngModelChange", "keyup"], [1, "btn", "btn-primary-color"], ["aria-hidden", "true", 1, "fe", "fe-search"], ["class", "search-result p-absolute w-100 card border mt-1", 4, "ngIf", "ngIfElse"], ["elseBlock", ""], [1, "d-flex", "order-lg-2", "ms-auto", "header-right-icons", "header-search-icon"], ["type", "button", "aria-controls", "collapseExample", 1, "navbar-toggler", "navresponsive-toggler", "d-lg-none", "ms-auto", "collapsed", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "height", "24", "viewBox", "0 0 24 24", "width", "24", 1, "navbar-toggler-icon"], ["d", "M0 0h24v24H0V0z", "fill", "none"], ["d", "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"], [1, "navbar", "navbar-collapse", "responsive-navbar", "p-0"], ["id", "navbarSupportedContent-4", 1, "collapse", "navbar-collapse", 3, "ngbCollapse", "horizontal", "ngbCollapseChange"], ["collapse", "ngbCollapse"], [1, "d-flex"], [1, "d-flex", "country"], ["appToggleTheme", "", 1, "nav-link", "icon"], [1, "dark-layout"], [1, "fe", "fe-moon"], [1, "light-layout"], [1, "fe", "fe-sun"], [1, "dropdown", "d-flex"], ["appFullscreen", "", 1, "nav-link", "icon", "full-screen-link", "nav-link-bg"], [1, "fe", "fe-minimize", "fullscreen-button"], ["ngbDropdown", "", 1, "dropdown", "d-flex", "notifications"], ["ngbDropdownToggle", "", "data-bs-toggle", "dropdown", 1, "nav-link", "icon", "caret"], [1, "fe", "fe-bell"], [1, "pulse1", "bg-success"], ["ngbDropdownMenu", "", 1, "dropdown-menu", "dropdown-menu-end", "dropdown-menu-arrow"], ["ngbDropdownItem", "", 1, "p-4", "border-bottom"], [1, "border-bottom-0", "mb-0", "fs-16", "font-weight-semibold"], [1, "notifications-menu"], ["routerLink", "/apps/mails/mail-inbox", 1, "d-flex"], [1, "me-3", "notifyimg", "bg-primary", "brround", "box-shadow-primary"], [1, "fe", "fe-mail"], [1, "w-80"], [1, "notification-label", "mb-0", "text-wrap"], [1, "notification-subtext", "text-muted", "fs-12"], ["routerLink", "/apps/mails/mail-inbox", 1, "dropdown-item", "d-flex"], [1, "me-3", "notifyimg", "bg-secondary", "brround", "box-shadow-secondary"], [1, "fe", "fe-download"], [1, "me-3", "notifyimg", "bg-warning", "brround", "box-shadow-warning"], [1, "fe", "fe-user"], [1, "me-3", "notifyimg", "bg-danger", "brround", "box-shadow-danger"], [1, "fe", "fe-shopping-cart"], [1, "me-3", "notifyimg", "bg-info", "brround", "box-shadow-info"], [1, "fe", "fe-server"], [1, "dropdown-divider"], ["routerLink", "/apps/mails/mail-inbox", 1, "dropdown-item", "text-center", "pt-2", "mb-2"], ["ngbDropdown", "", 1, "dropdown", "d-flex", "message"], ["ngbDropdownToggle", "", "data-bs-toggle", "dropdown", 1, "nav-link", "icon"], [1, "fe", "fe-message-square"], [1, "nav-unread", "badge", "bg-danger", "rounded-pill", "pulse"], [1, "message-menu", "message-menu-scroll", "message-menu"], [1, "dropdown-item", "d-flex"], ["data-bs-image-src", "assets/images/users/1.jpg", 1, "avatar", "brround", "me-3", "cover-image", 2, "background", "url('assets/images/users/1.jpg') center\n                            center"], [1, "w-90"], [1, "my-1", "text-break"], [1, "text-muted", "ms-auto", "text-wrap", "fs-12"], [1, "text-muted", "fs-13"], ["routerlink", "/components/default-chat", 1, "dropdown-item", "d-flex"], ["data-bs-image-src", "assets/images/users/2.jpg", 1, "avatar", "brround", "me-3", "cover-image", 2, "background", "url('assets/images/users/2.jpg') center\n                            center"], ["data-bs-image-src", "assets/images/users/9.jpg", 1, "avatar", "brround", "me-3", "cover-image", 2, "background", "url('assets/images/users/9.jpg') center\n                            center"], ["data-bs-image-src", "assets/images/users/10.jpg", 1, "avatar", "brround", "me-3", "cover-image", 2, "background", "url('assets/images/users/10.jpg')\n                            center center"], [1, "dropdown-divider", "m-0"], ["href", "javascript:void(0);", 1, "dropdown-item", "text-center"], ["ngbDropdown", "", 1, "dropdown", "d-flex", "country-selector"], ["ngbDropdownToggle", "", "href", "javascript:void(0);", "data-bs-toggle", "dropdown", "aria-expanded", "true", 1, "d-flex", "nav-link", "icon", "leading-none"], ["src", "assets/images/flags/us_flag.jpg", "alt", "img", 1, "align-self-center"], ["ngbDropdownMenu", "", 1, "dropdown-menu"], ["ngbDropdownItem", "", "href", "javascript:void(0);", 1, "dropdown-item", "d-flex", "pb-2", "px-4"], ["src", "assets/images/flags/french_flag.jpg", "alt", "flag-img", 1, "avatar", "me-3", "align-self-center"], [1, "countries"], ["src", "assets/images/flags/germany_flag.jpg", "alt", "flag-img", 1, "avatar", "me-3", "align-self-center"], ["src", "assets/images/flags/italy_flag.jpg", "alt", "flag-img", 1, "avatar", "me-3", "align-self-center"], ["src", "assets/images/flags/russia_flag.jpg", "alt", "flag-img", 1, "avatar", "me-3", "align-self-center"], ["src", "assets/images/flags/spain_flag.jpg", "alt", "flag-img", 1, "avatar", "me-3", "align-self-center"], ["ngbDropdown", "", 1, "dropdown", "profile-1", "d-flex"], ["ngbDropdownToggle", "", "href", "javascript:void(0);", "data-bs-toggle", "dropdown", 1, "nav-link", "icon", "leading-none", "d-flex"], ["src", "assets/images/users/4.jpg", "alt", "profile-user", 1, "avatar", "profile-user", "brround", "cover-image"], ["ngbDropdownItem", "", "routerLink", "/pages/profile"], [1, "dropdown-icon", "mdi", "mdi-account-outline"], [1, "dropdown-icon", "zmdi", "zmdi-edit"], ["ngbDropdownItem", "", "routerLink", "/pages/settings"], [1, "dropdown-icon", "mdi", "mdi-settings"], ["ngbDropdownItem", "", "routerLink", "/apps/mails/mail-inbox"], [1, "float-end"], [1, "dropdown-icon", "mdi", "mdi-message-outline"], ["ngbDropdownItem", "", "routerLink", "/apps/mails/mail-compose"], [1, "dropdown-icon", "mdi", "mdi-comment-check-outline"], ["ngbDropdownItem", "", "routerLink", "/pages/faqs"], [1, "dropdown-icon", "mdi", "mdi-compass-outline"], ["ngbDropdownItem", "", "routerLink", "auth/login"], [1, "dropdown-icon", "mdi", "mdi-logout-variant"], [1, "dropdown", "d-flex", "header-settings"], ["href", "javascript:void(0);", "data-bs-toggle", "sidebar-right", "data-bs-target", ".sidebar-right", 1, "nav-link", "icon", 3, "click"], [1, "fe", "fe-align-right"], [1, "switch-icon", "nav-link", "icon", 3, "click"], [1, "fe", "fe-settings", "fa-spin", "text_primary"], [1, "search-result", "p-absolute", "w-100", "card", "border", "mt-1"], [1, "card-header"], [1, "card-title", "me-2"], [1, "list-group", "text-break"], ["class", "list-group-item header-list-group border-start-end-top-0 br-0", 3, "routerLink", "click", 4, "ngFor", "ngForOf"], [1, "list-group-item", "header-list-group", "border-start-end-top-0", "br-0", 3, "routerLink", "click"], ["aria-hidden", "true", 1, "fa", "fa-angle-double-right", "me-2"], [1, "list-group", "p-absolute", "w-100", "mt-1", "serach-result-empty", "text-break"], [1, "list-group-item", "no-result", 3, "ngClass"], ["aria-hidden", "true", 1, "fa", "fa-frown-o", "text-primary", "me-2"]], template: function (t, r) { if (1 & t) { const a = m.EpF(); m.TgZ(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "a", 3), m.NdJ("click", function () { return r.toggleSidebar() }), m._UZ(4, "i", 4), m.qZA(), m.TgZ(5, "a", 5), m._UZ(6, "img", 6)(7, "img", 7), m.qZA(), m.TgZ(8, "div", 8)(9, "div", 9)(10, "div", 10)(11, "input", 11), m.NdJ("ngModelChange", function (_) { return r.text = _ })("keyup", function () { return r.Search(r.text) }), m.qZA(), m.TgZ(12, "button", 12), m._UZ(13, "i", 13), m.qZA(), m.YNc(14, Qe, 9, 6, "div", 14), m.YNc(15, Oe, 4, 4, "ng-template", null, 15, m.W1O), m.qZA()()(), m.TgZ(17, "div", 16)(18, "button", 17), m.NdJ("click", function () { m.CHM(a); const _ = m.MAs(24); return m.KtG(_.toggle()) }), m.O4$(), m.TgZ(19, "svg", 18), m._UZ(20, "path", 19)(21, "path", 20), m.qZA()(), m.kcU(), m.TgZ(22, "div", 21)(23, "div", 22, 23), m.NdJ("ngbCollapseChange", function (_) { return r.isCollapsed = _ }), m.TgZ(25, "div", 24)(26, "div", 25)(27, "a", 26)(28, "span", 27), m._UZ(29, "i", 28), m.qZA(), m.TgZ(30, "span", 29), m._UZ(31, "i", 30), m.qZA()()(), m.TgZ(32, "div", 31)(33, "a", 32), m._UZ(34, "i", 33), m.qZA()(), m.TgZ(35, "div", 34)(36, "a", 35), m._UZ(37, "i", 36)(38, "span", 37), m.qZA(), m.TgZ(39, "div", 38)(40, "div", 39)(41, "h5", 40), m._uU(42, " Notifications "), m.qZA()(), m.TgZ(43, "div", 41)(44, "a", 42)(45, "div", 43), m._UZ(46, "i", 44), m.qZA(), m.TgZ(47, "div", 45)(48, "h6", 46), m._uU(49, " Commented on your post "), m.qZA(), m.TgZ(50, "span", 47), m._uU(51, "3 days ago"), m.qZA()()(), m.TgZ(52, "a", 48)(53, "div", 49), m._UZ(54, "i", 50), m.qZA(), m.TgZ(55, "div", 45)(56, "h6", 46), m._uU(57, " New file has been Uploaded "), m.qZA(), m.TgZ(58, "span", 47), m._uU(59, "3 days ago"), m.qZA()()(), m.TgZ(60, "a", 48)(61, "div", 51), m._UZ(62, "i", 52), m.qZA(), m.TgZ(63, "div", 45)(64, "h6", 46), m._uU(65, " User account has Updated "), m.qZA(), m.TgZ(66, "span", 47), m._uU(67, "2 days ago"), m.qZA()()(), m.TgZ(68, "a", 48)(69, "div", 53), m._UZ(70, "i", 54), m.qZA(), m.TgZ(71, "div", 45)(72, "h6", 46), m._uU(73, " New Order Recevied "), m.qZA(), m.TgZ(74, "span", 47), m._uU(75, "1 hour ago"), m.qZA()()(), m.TgZ(76, "a", 48)(77, "div", 55), m._UZ(78, "i", 56), m.qZA(), m.TgZ(79, "div", 45)(80, "h6", 46), m._uU(81, " Server Rebooted "), m.qZA(), m.TgZ(82, "span", 47), m._uU(83, "2 hour ago"), m.qZA()()()(), m._UZ(84, "div", 57), m.TgZ(85, "a", 58), m._uU(86, "View all Notification"), m.qZA()()(), m.TgZ(87, "div", 59)(88, "a", 60), m._UZ(89, "i", 61), m.TgZ(90, "span", 62), m._uU(91, "3"), m.qZA()(), m.TgZ(92, "div", 38)(93, "div", 39)(94, "h5", 40), m._uU(95, " Messages "), m.qZA()(), m.TgZ(96, "div", 63)(97, "a", 64), m._UZ(98, "span", 65), m.TgZ(99, "div", 66)(100, "div", 24)(101, "h6", 67), m._uU(102, "Madeleine"), m.qZA(), m.TgZ(103, "span", 68), m._uU(104, " 35 sec ago "), m.qZA()(), m.TgZ(105, "span", 69), m._uU(106, "Hey! there I' am available.."), m.qZA()()(), m.TgZ(107, "a", 70), m._UZ(108, "span", 71), m.TgZ(109, "div", 66)(110, "div", 24)(111, "h6", 67), m._uU(112, "Anthony"), m.qZA(), m.TgZ(113, "span", 68), m._uU(114, " 15 mins ago "), m.qZA()(), m.TgZ(115, "span", 69), m._uU(116, "New product Launching..."), m.qZA()()(), m.TgZ(117, "a", 70), m._UZ(118, "span", 72), m.TgZ(119, "div", 66)(120, "div", 24)(121, "h6", 67), m._uU(122, "Olivia"), m.qZA(), m.TgZ(123, "span", 68), m._uU(124, " 2 hrs ago "), m.qZA()(), m.TgZ(125, "span", 69), m._uU(126, "New Schedule Realease..."), m.qZA()()(), m.TgZ(127, "a", 70), m._UZ(128, "span", 73), m.TgZ(129, "div", 66)(130, "div", 24)(131, "h6", 67), m._uU(132, "Sanderson"), m.qZA(), m.TgZ(133, "span", 68), m._uU(134, " 4 hrs ago "), m.qZA()(), m.TgZ(135, "span", 69), m._uU(136, "New Schedule Realease..."), m.qZA()()()(), m._UZ(137, "div", 74), m.TgZ(138, "a", 75), m._uU(139, "See all Messages"), m.qZA()()(), m.TgZ(140, "div", 76)(141, "a", 77), m._UZ(142, "img", 78), m.qZA(), m.TgZ(143, "div", 79)(144, "a", 80), m._UZ(145, "img", 81), m.TgZ(146, "div", 82)(147, "strong"), m._uU(148, "French"), m.qZA()()(), m.TgZ(149, "a", 80), m._UZ(150, "img", 83), m.TgZ(151, "div", 82)(152, "strong"), m._uU(153, "Germany"), m.qZA()()(), m.TgZ(154, "a", 80), m._UZ(155, "img", 84), m.TgZ(156, "div", 82)(157, "strong"), m._uU(158, "Italy"), m.qZA()()(), m.TgZ(159, "a", 80), m._UZ(160, "img", 85), m.TgZ(161, "div", 82)(162, "strong"), m._uU(163, "Russia"), m.qZA()()(), m.TgZ(164, "a", 80), m._UZ(165, "img", 86), m.TgZ(166, "div", 82)(167, "strong"), m._uU(168, "Spain"), m.qZA()()()()(), m.TgZ(169, "div", 87)(170, "a", 88), m._UZ(171, "img", 89), m.qZA(), m.TgZ(172, "div", 38)(173, "a", 90), m._UZ(174, "i", 91), m._uU(175, " My Profile "), m.qZA(), m.TgZ(176, "a", 90), m._UZ(177, "i", 92), m._uU(178, " Edit Profile "), m.qZA(), m.TgZ(179, "a", 93), m._UZ(180, "i", 94), m._uU(181, " Settings "), m.qZA(), m.TgZ(182, "a", 95), m._UZ(183, "span", 96)(184, "i", 97), m._uU(185, " Inbox "), m.qZA(), m.TgZ(186, "a", 98), m._UZ(187, "i", 99), m._uU(188, " Message "), m.qZA(), m.TgZ(189, "a", 100), m._UZ(190, "i", 101), m._uU(191, " Need help? "), m.qZA(), m.TgZ(192, "a", 102), m._UZ(193, "i", 103), m._uU(194, " Sign out "), m.qZA()()(), m.TgZ(195, "div", 104)(196, "a", 105), m.NdJ("click", function () { return r.toggleSidebarNotification() }), m._UZ(197, "i", 106), m.qZA()()()()(), m.TgZ(198, "div", 107), m.NdJ("click", function () { return r.toggleSwitcher() }), m._UZ(199, "i", 108), m.qZA()()()()() } if (2 & t) { const a = m.MAs(16); m.xp6(11), m.Q6J("ngModel", r.text)("ngModelOptions", m.DdM(7, Ve)), m.xp6(3), m.Q6J("ngIf", null == r.menuItems ? null : r.menuItems.length)("ngIfElse", a), m.xp6(4), m.uIk("aria-expanded", !r.isCollapsed), m.xp6(5), m.Q6J("ngbCollapse", r.isCollapsed)("horizontal", !0) } }, dependencies: [rt.mk, rt.sg, rt.O5, J.rH, wt.Fj, wt.JJ, wt.On, gt._D, gt.jt, gt.iD, gt.Vi, gt.TH, gt.M2, De, je, rt.OU], styles: [".dropdown-toggle[_ngcontent-%COMP%]:after{display:none}.search-result[_ngcontent-%COMP%]   .header-list-group[_ngcontent-%COMP%]:hover{background-color:var(--primary-bg-color);color:#fff}.list-group-item.no-result[_ngcontent-%COMP%]{display:none}.list-group-item.no-result.show[_ngcontent-%COMP%]{display:block}.p-absolute[_ngcontent-%COMP%]{position:absolute}.border-start-end-top-0[_ngcontent-%COMP%]{border-left:0!important;border-top:0!important;border-right:0!important}.br-0[_ngcontent-%COMP%]{border-radius:0!important}.list-group[_ngcontent-%COMP%]   .list-group-item[_ngcontent-%COMP%]:last-child{border-bottom-right-radius:.25rem!important;border-bottom-left-radius:.25rem!important}.serach-result-empty[_ngcontent-%COMP%]{z-index:99}input[_ngcontent-%COMP%]:not(.dark-mode)::placeholder{color:#f1eeee}.search-result[_ngcontent-%COMP%]{z-index:9999}"] }), n })(), nt = (() => { class n { constructor() { } ngOnInit() { } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-loader"]], decls: 0, vars: 0, template: function (t, r) { } }), n })(); const Ne = ["rightsidebar"]; let tt = (() => { class n { constructor(t, r, a) { this.renderer = t, this.layoutService = r, this.modalService = a, this.isOpen = !1, this.layoutSub = r.SidebarNotifyChangeEmitted.subscribe(d => { this.isOpen ? (this.renderer.removeClass(this.sidebar.nativeElement, "sidebar-open"), this.isOpen = !1) : (this.renderer.addClass(this.sidebar.nativeElement, "sidebar-open"), this.isOpen = !0) }) } ngOnInit() { } ngOnDestroy() { this.layoutSub && this.layoutSub.unsubscribe() } onClose() { this.renderer.removeClass(this.sidebar.nativeElement, "sidebar-open"), this.isOpen = !1 } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(m.Qsj), m.Y36(xe), m.Y36(gt.FF)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-right-sidebar"]], viewQuery: function (t, r) { if (1 & t && m.Gf(Ne, 5), 2 & t) { let a; m.iGM(a = m.CRH()) && (r.sidebar = a.first) } }, decls: 110, vars: 0, consts: [[1, "sidebar", "sidebar-right", "sidebar-animate"], ["rightsidebar", ""], [1, ""], ["href", "javascript:void(0);", "data-bs-toggle", "sidebar-right", "data-bs-target", ".sidebar-right", 1, "sidebar-icon", "text-end", "float-end", 3, "click"], [1, "fe", "fe-x"], [1, "p-3", "border-bottom"], [1, "border-bottom-0", "mb-0"], [1, "p-4"], [1, "switch-settings"], [1, "d-flex", "mb-2"], [1, "me-auto", "fs-15"], [1, "custom-switch"], ["type", "checkbox", "name", "custom-switch-checkbox", 1, "custom-switch-input"], [1, "custom-switch-indicator"], [1, "progress-wrapper"], [1, "mb-3"], [1, "mb-2"], [1, "float-end", "text-muted", "font-weight-normal"], [1, "progress", "h-1"], ["role", "progressbar", 1, "progress-bar", "bg-primary", "w-80"], [1, "progress-wrapper", "pt-2"], ["role", "progressbar", 1, "progress-bar", "bg-secondary", "w-60"], ["role", "progressbar", 1, "progress-bar", "bg-success", "w-50"], ["role", "progressbar", 1, "progress-bar", "bg-warning", "w-45"], ["role", "progressbar", 1, "progress-bar", "bg-danger", "w-75"], ["role", "progressbar", 1, "progress-bar", "bg-teal", "w-70"]], template: function (t, r) { 1 & t && (m.TgZ(0, "div", 0, 1)(2, "div", 2)(3, "a", 3), m.NdJ("click", function () { return r.onClose() }), m._UZ(4, "i", 4), m.qZA()(), m.TgZ(5, "div", 5)(6, "h5", 6), m._uU(7, "General Settings"), m.qZA()(), m.TgZ(8, "div", 7)(9, "div", 8)(10, "div", 9)(11, "span", 10), m._uU(12, "Notifications"), m.qZA(), m.TgZ(13, "label", 11), m._UZ(14, "input", 12)(15, "span", 13), m.qZA()(), m.TgZ(16, "div", 9)(17, "span", 10), m._uU(18, "Show your emails"), m.qZA(), m.TgZ(19, "label", 11), m._UZ(20, "input", 12)(21, "span", 13), m.qZA()(), m.TgZ(22, "div", 9)(23, "span", 10), m._uU(24, "Show Task statistics"), m.qZA(), m.TgZ(25, "label", 11), m._UZ(26, "input", 12)(27, "span", 13), m.qZA()(), m.TgZ(28, "div", 9)(29, "span", 10), m._uU(30, "Show recent activity"), m.qZA(), m.TgZ(31, "label", 11), m._UZ(32, "input", 12)(33, "span", 13), m.qZA()(), m.TgZ(34, "div", 9)(35, "span", 10), m._uU(36, "System Logs"), m.qZA(), m.TgZ(37, "label", 11), m._UZ(38, "input", 12)(39, "span", 13), m.qZA()(), m.TgZ(40, "div", 9)(41, "span", 10), m._uU(42, "Error Reporting"), m.qZA(), m.TgZ(43, "label", 11), m._UZ(44, "input", 12)(45, "span", 13), m.qZA()(), m.TgZ(46, "div", 9)(47, "span", 10), m._uU(48, "Show your status to all"), m.qZA(), m.TgZ(49, "label", 11), m._UZ(50, "input", 12)(51, "span", 13), m.qZA()(), m.TgZ(52, "div", 9)(53, "span", 10), m._uU(54, "Keep up to date"), m.qZA(), m.TgZ(55, "label", 11), m._UZ(56, "input", 12)(57, "span", 13), m.qZA()()()(), m.TgZ(58, "div", 5)(59, "h5", 6), m._uU(60, "Overview"), m.qZA()(), m.TgZ(61, "div", 7)(62, "div", 14)(63, "div", 15)(64, "p", 16), m._uU(65, "Achieves"), m.TgZ(66, "span", 17), m._uU(67, "80%"), m.qZA()(), m.TgZ(68, "div", 18), m._UZ(69, "div", 19), m.qZA()()(), m.TgZ(70, "div", 20)(71, "div", 15)(72, "p", 16), m._uU(73, "Projects"), m.TgZ(74, "span", 17), m._uU(75, "60%"), m.qZA()(), m.TgZ(76, "div", 18), m._UZ(77, "div", 21), m.qZA()()(), m.TgZ(78, "div", 20)(79, "div", 15)(80, "p", 16), m._uU(81, "Earnings"), m.TgZ(82, "span", 17), m._uU(83, "50%"), m.qZA()(), m.TgZ(84, "div", 18), m._UZ(85, "div", 22), m.qZA()()(), m.TgZ(86, "div", 20)(87, "div", 15)(88, "p", 16), m._uU(89, "Balance"), m.TgZ(90, "span", 17), m._uU(91, "45%"), m.qZA()(), m.TgZ(92, "div", 18), m._UZ(93, "div", 23), m.qZA()()(), m.TgZ(94, "div", 20)(95, "div", 15)(96, "p", 16), m._uU(97, "Toatal Profits"), m.TgZ(98, "span", 17), m._uU(99, "75%"), m.qZA()(), m.TgZ(100, "div", 18), m._UZ(101, "div", 24), m.qZA()()(), m.TgZ(102, "div", 20)(103, "div", 15)(104, "p", 16), m._uU(105, "Total Likes"), m.TgZ(106, "span", 17), m._uU(107, "70%"), m.qZA()(), m.TgZ(108, "div", 18), m._UZ(109, "div", 25), m.qZA()()()()()) } }), n })(); var Fe = L(2), Ue = L(2289), st = L(4365); function ht(n, e) { if (1 & n && (m.TgZ(0, "h3", 25), m._uU(1), m.qZA()), 2 & n) { const t = m.oxw().$implicit; m.xp6(1), m.hij(" ", t.headTitle, " ") } } const Kt = function (n) { return [n] }; function rn(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 26), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(); return m.KtG(d.toggleNavActive(a)) }), m._UZ(1, "span", 27)(2, "span", 28), m.TgZ(3, "span", 29), m._UZ(4, "i"), m.qZA(), m.TgZ(5, "span", 30), m._uU(6), m.qZA(), m.TgZ(7, "span"), m._uU(8), m.qZA()() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? m.VKq(9, Kt, t.path) : null), m.xp6(4), m.Gre("fa fa-", t.icon, " "), m.xp6(2), m.Oqu(t.title), m.xp6(1), m.Gre("badge side-badge bg-", t.badgeClass, " "), m.xp6(1), m.Oqu(t.badgeValue) } } function On(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 31), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(); return m.KtG(d.toggleNavActive(a)) }), m._UZ(1, "span", 27)(2, "span", 28), m.TgZ(3, "span", 29), m._UZ(4, "i"), m.qZA(), m.TgZ(5, "span"), m._uU(6), m.qZA(), m.TgZ(7, "span", 30), m._uU(8), m.qZA()() } if (2 & n) { const t = m.oxw().$implicit; m.xp6(4), m.Gre("fa fa-", t.icon, " "), m.xp6(1), m.Gre("badge side-badge bg-", t.badgeClass, " "), m.xp6(1), m.Oqu(t.badgeValue), m.xp6(2), m.Oqu(t.title) } } function qn(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 32), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(); return m.KtG(d.toggleNavActive(a)) }), m.TgZ(1, "span", 29), m._UZ(2, "i"), m.qZA(), m.TgZ(3, "span", 30), m._uU(4), m.qZA(), m.TgZ(5, "span"), m._uU(6), m.qZA()() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? m.VKq(9, Kt, t.path) : null), m.xp6(2), m.Gre("fa fa-", t.icon, " "), m.xp6(2), m.Oqu(t.title), m.xp6(1), m.Gre("badge side-badge bg-", t.badgeClass, " "), m.xp6(1), m.Oqu(t.badgeValue) } } function nr(n, e) { if (1 & n && (m.TgZ(0, "span"), m._uU(1), m.qZA()), 2 & n) { const t = m.oxw(2).$implicit; m.Gre("badge side-badge bg-", t.badgeClass, " "), m.xp6(1), m.hij(" ", t.badgeValue, " ") } } const kn = function (n) { return { active: n } }, fn = function (n) { return { "d-none": n } }; function It(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 33), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(); return m.KtG(d.toggleNavActive(a)) }), m._UZ(1, "span", 27)(2, "span", 28), m.TgZ(3, "span", 29), m._UZ(4, "i"), m.qZA(), m.TgZ(5, "span", 30), m._uU(6), m.qZA(), m.YNc(7, nr, 2, 4, "span", 34), m._UZ(8, "i", 35), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? null : m.VKq(8, Kt, t.path))("ngClass", m.VKq(10, kn, t.selected)), m.xp6(4), m.Gre("fa fa-", t.icon, " "), m.xp6(2), m.Oqu(t.title), m.xp6(1), m.Q6J("ngIf", t.badgeClass && t.badgeValue), m.xp6(1), m.Q6J("ngClass", m.VKq(12, fn, t.badgeClass)) } } function Yt(n, e) { if (1 & n && (m.TgZ(0, "span"), m._uU(1), m.qZA()), 2 & n) { const t = m.oxw(2).$implicit; m.Tol(t.badgeClass), m.xp6(1), m.hij(" ", t.badgeValue, " ") } } function pt(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 33), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(); return m.KtG(d.toggleNavActive(a)) }), m._UZ(1, "span", 27)(2, "span", 28), m.TgZ(3, "span", 29), m._UZ(4, "i"), m.qZA(), m.TgZ(5, "span", 30), m._uU(6), m.qZA(), m.YNc(7, Yt, 2, 4, "span", 34), m._UZ(8, "i", 35), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? null : m.VKq(8, Kt, t.path))("ngClass", m.VKq(10, kn, t.selected)), m.xp6(4), m.Gre("fa fa-", t.icon, " "), m.xp6(2), m.Oqu(t.title), m.xp6(1), m.Q6J("ngIf", t.badgeClass && t.badgeValue), m.xp6(1), m.Q6J("ngClass", m.VKq(12, fn, t.badgeClass)) } } function Pt(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 43), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(3); return m.KtG(d.toggleNavActive(a)) }), m._uU(1), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? m.VKq(2, Kt, t.path) : null), m.xp6(1), m.hij(" ", t.title, " ") } } function Ze(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 44), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(3); return m.KtG(d.toggleNavActive(a)) }), m._uU(1), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.xp6(1), m.hij(" ", t.title, " ") } } function Ot(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 45), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(3); return m.KtG(d.toggleNavActive(a)) }), m.TgZ(1, "span", 46), m._uU(2), m.qZA(), m._UZ(3, "i", 47), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? null : m.VKq(2, Kt, t.path)), m.xp6(2), m.hij(" ", t.title, "") } } function le(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 53), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(5); return m.KtG(d.toggleNavActive(a)) }), m._uU(1), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? m.VKq(2, Kt, t.path) : null), m.xp6(1), m.hij(" ", t.title, " ") } } function Xe(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 54), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(5); return m.KtG(d.toggleNavActive(a)) }), m._uU(1), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.xp6(1), m.hij(" ", t.title, " ") } } function kt(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "a", 55), m.NdJ("click", function () { m.CHM(t); const a = m.oxw().$implicit, d = m.oxw(5); return m.KtG(d.toggleNavActive(a)) }), m.TgZ(1, "span", 56), m._uU(2), m.qZA(), m._UZ(3, "i", 57), m.qZA() } if (2 & n) { const t = m.oxw().$implicit; m.Q6J("ngClass", m.VKq(3, kn, t.selected))("routerLink", t.type ? null : m.VKq(5, Kt, t.path)), m.xp6(2), m.hij(" ", t.title, " ") } } function an(n, e) { if (1 & n && (m.TgZ(0, "a", 62), m._uU(1), m.qZA()), 2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? m.VKq(2, Kt, t.path) : null), m.xp6(1), m.hij(" ", t.title, "") } } const jt = function (n) { return { "is-expanded": n } }; function wn(n, e) { if (1 & n && (m.TgZ(0, "li", 60), m.YNc(1, an, 2, 4, "a", 61), m.qZA()), 2 & n) { const t = e.$implicit; m.Q6J("ngClass", m.VKq(2, jt, t.active)), m.xp6(1), m.Q6J("ngIf", "link" === t.type) } } const Jn = function (n) { return { open: n } }; function or(n, e) { if (1 & n && (m.TgZ(0, "ul", 58), m.YNc(1, wn, 2, 4, "li", 59), m.qZA()), 2 & n) { const t = m.oxw().$implicit; m.Q6J("ngClass", m.VKq(2, Jn, t.active)), m.xp6(1), m.Q6J("ngForOf", t.children) } } function Ht(n, e) { if (1 & n && (m.TgZ(0, "li", 38), m.YNc(1, le, 2, 4, "a", 49), m.YNc(2, Xe, 2, 1, "a", 50), m.YNc(3, kt, 4, 7, "a", 51), m.YNc(4, or, 2, 4, "ul", 52), m.qZA()), 2 & n) { const t = e.$implicit; m.Q6J("ngClass", m.VKq(5, jt, t.active)), m.xp6(1), m.Q6J("ngIf", "link" === t.type), m.xp6(1), m.Q6J("ngIf", "empty" === t.type), m.xp6(1), m.Q6J("ngIf", "sub" === t.type), m.xp6(1), m.Q6J("ngIf", t.children) } } function dn(n, e) { if (1 & n && (m.TgZ(0, "ul", 48), m.YNc(1, Ht, 5, 7, "li", 37), m.qZA()), 2 & n) { const t = m.oxw().$implicit; m.Q6J("ngClass", m.VKq(3, Jn, t.active))("ngClass", m.VKq(5, Jn, t.active)), m.xp6(1), m.Q6J("ngForOf", t.children) } } const ue = function (n, e, t) { return { "is-expanded": n, active: e, "sub-slide": t } }; function it(n, e) { if (1 & n && (m.TgZ(0, "li", 38), m.YNc(1, Pt, 2, 4, "a", 39), m.YNc(2, Ze, 2, 1, "a", 40), m.YNc(3, Ot, 4, 4, "a", 41), m.YNc(4, dn, 2, 7, "ul", 42), m.qZA()), 2 & n) { const t = e.$implicit; m.Q6J("ngClass", m.kEZ(5, ue, t.active, t.selected, t.Menusub)), m.xp6(1), m.Q6J("ngIf", "link" === t.type), m.xp6(1), m.Q6J("ngIf", "empty" === t.type), m.xp6(1), m.Q6J("ngIf", "sub" === t.type), m.xp6(1), m.Q6J("ngIf", t.children) } } function lt(n, e) { if (1 & n && (m.TgZ(0, "ul", 36), m.YNc(1, it, 5, 9, "li", 37), m.qZA()), 2 & n) { const t = m.oxw().$implicit; m.Q6J("ngClass", m.VKq(2, Jn, t.active)), m.xp6(1), m.Q6J("ngForOf", t.children) } } function Nt(n, e) { if (1 & n && (m.TgZ(0, "a", 67), m._uU(1), m.qZA()), 2 & n) { const t = m.oxw().$implicit; m.Q6J("routerLink", t.type ? m.VKq(2, Kt, t.path) : null), m.xp6(1), m.hij(" ", t.title, "") } } function gn(n, e) { if (1 & n && (m.TgZ(0, "li"), m.YNc(1, Nt, 2, 4, "a", 66), m.qZA()), 2 & n) { const t = e.$implicit; m.xp6(1), m.Q6J("ngIf", "link" === t.type) } } function Hn(n, e) { if (1 & n && (m.TgZ(0, "div")(1, "ul"), m.YNc(2, gn, 2, 1, "li", 65), m.qZA()()), 2 & n) { const t = e.$implicit; m.xp6(2), m.Q6J("ngForOf", t.items) } } function _r(n, e) { if (1 & n && (m.TgZ(0, "ul", 63)(1, "div", 64), m.YNc(2, Hn, 3, 1, "div", 65), m.qZA()()), 2 & n) { const t = m.oxw().$implicit; m.Q6J("ngClass", m.VKq(2, Jn, t.active)), m.xp6(2), m.Q6J("ngForOf", t.children) } } const pn = function (n, e, t, r, a) { return { slide: n, active: e, "side-item": t, show: r, "is-expanded": a } }; function Fn(n, e) { if (1 & n && (m.TgZ(0, "li", 17), m.YNc(1, ht, 2, 1, "h3", 18), m.YNc(2, rn, 9, 11, "a", 19), m.YNc(3, On, 9, 8, "a", 20), m.YNc(4, qn, 7, 11, "a", 21), m.YNc(5, It, 9, 14, "a", 22), m.YNc(6, pt, 9, 14, "a", 22), m.YNc(7, lt, 2, 4, "ul", 23), m.YNc(8, _r, 3, 4, "ul", 24), m.qZA()), 2 & n) { const t = e.$implicit; m.Q6J("ngClass", m.qbA(9, pn, t.title, t.selected, t.type, t.active, t.active)), m.xp6(1), m.Q6J("ngIf", t.headTitle), m.xp6(1), m.Q6J("ngIf", "link" === t.type), m.xp6(1), m.Q6J("ngIf", "empty" === t.type), m.xp6(1), m.Q6J("ngIf", "external" === t.type), m.xp6(1), m.Q6J("ngIf", "sub" === t.type), m.xp6(1), m.Q6J("ngIf", "mega-menu" === t.type), m.xp6(1), m.Q6J("ngIf", t.children && "sub" === t.type), m.xp6(1), m.Q6J("ngIf", t.children && "mega-menu" === t.type) } } let yn = (() => { class n { constructor(t, r, a, d) { this.router = t, this.navServices = r, this.elRef = a, this.breakpointObserver = d, this.options = { autoHide: !1, scrollbarMinSize: 100 }, this.scrolled = !1, this.checkNavActiveOnLoad() } checkNavActiveOnLoad() { this.navServices.items.subscribe(t => { this.menuItems = t, this.router.events.subscribe(r => { if (r instanceof J.OD) { let a = location.pathname.split("/"), d = r.url.split("/"); if (a[a.length - 2] !== d[d.length - 2]) { this.closeNavActive(); let _ = document.querySelectorAll(".side-item.active"), E = document.querySelectorAll(".slide-item.active"), x = document.querySelectorAll(".sub-side-menu__item.active"); _.forEach(B => B.classList.remove("active")), E.forEach(B => B.classList.remove("active")), x.forEach(B => B.classList.remove("active")) } } r instanceof J.m2 && (t.filter(a => { if (a.path === r.url && this.setNavActive(a), !a.children) return !1; a.children.filter(d => { if (d.path === r.url && this.setNavActive(d), !d.children) return !1; d.children.filter(_ => { if (_.path === r.url && this.setNavActive(_), !_.children) return !1; _?.children.filter(E => { if (E.path === r.url && this.setNavActive(E), !E.children) return !1 }) }) }) }), setTimeout(() => { document.querySelector("body")?.classList.contains("horizontal-hover") && window.innerWidth > 992 && this.closeNavActive() }, 200)) }) }) } checkCurrentActive() { this.navServices.items.subscribe(t => { this.menuItems = t; let r = this.router.url; t.filter(a => { if (a.path === r && this.setNavActive(a), !a.children) return !1; a.children.filter(d => { if (d.path === r && this.setNavActive(d), !d.children) return !1; d.children.filter(_ => { _.path === r && this.setNavActive(_) }) }) }) }) } setNavActive(t) { this.menuItems.filter(r => { r !== t && (r.active = !1, this.navServices.collapseSidebar = !1), r.children && r.children.includes(t) && (r.active = !0), r.children && r.children.filter(a => { a.children && a.children.includes(t) && (r.active = !0, a.active = !0), a.children && a.children.forEach(d => { d.children && d.children.includes(t) && (r.active = !0, a.active = !0, d.active = !0) }) }) }) } toggleNavActive(t) { t.active || this.menuItems.forEach(r => { if (this.menuItems.includes(t) && (r.active = !1), !r.children) return !1; r.children.forEach(a => { if (r.children.includes(t) && (a.active = !1), !a.children) return !1; a.children.forEach(d => { if (a.children.includes(t) && (d.active = !1), !d.children) return !1 }) }) }), t.active = !t.active } closeNavActive() { this.menuItems.forEach(t => { if (this.menuItems && (t.active = !1), !t.children) return !1; t.children.forEach(r => { if (t.children && (r.active = !1), !r.children) return !1; r.children.forEach(a => { if (r.children && (a.active = !1), !a.children) return !1 }) }) }) } ngOnInit() { (0, Fe.k)(), (0, Te.R)(window, "resize").subscribe(() => { window.innerWidth >= 992 && document.querySelector("body.horizontal")?.classList.remove("sidenav-toggled"), document.querySelector("body")?.classList.contains("horizontal-hover") && window.innerWidth > 992 && document.querySelectorAll(".side-menu li").forEach((x, B) => { x.classList.remove("is-expanded") }) }), this.breakpointObserver.observe(["(max-width: 992px)"]).subscribe(E => { E.matches ? this.checkCurrentActive() : (document.querySelector("body.horizontal")?.classList.remove("main-sidebar-show"), document.querySelector(".horizontal:not(.horizontal-hover)") && (this.closeNavActive(), setTimeout(() => { }, 100))) }); let t = document.querySelectorAll("#myonoffswitch34"), r = document.querySelectorAll("#myonoffswitch35"), a = document.querySelectorAll("#myonoffswitch111"); (0, Te.R)(t, "click").subscribe(() => { this.checkCurrentActive() }), (0, Te.R)(r, "click").subscribe(() => { this.closeNavActive() }), (0, Te.R)(a, "click").subscribe(() => { this.closeNavActive() }); const d = (0, Te.R)(window, "resize"); this.windowSubscribe$ = d.subscribe(() => { (0, Fe.w)() }); let _ = document.querySelectorAll(".main-content"); (0, Te.R)(_, "click").subscribe(() => { document.querySelector("body")?.classList.contains("horizontal") && this.closeNavActive() }) } sidebarClose() { (this.navServices.collapseSidebar = !0) && (document.querySelector(".app")?.classList.remove("sidenav-toggled"), this.navServices.collapseSidebar = !1) } onWindowScroll() { this.scrolled = window.scrollY > 64 } ngOnDestroy() { this.windowSubscribe$.unsubscribe() } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(J.F0), m.Y36(ae), m.Y36(m.SBq), m.Y36(Ue.Yg)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-sidebar"]], hostBindings: function (t, r) { 1 & t && m.NdJ("scroll", function () { return r.onWindowScroll() }, !1, m.Jf7) }, decls: 19, vars: 1, consts: [[1, "sticky"], [1, "app-sidebar__overlay", "main-sidebar", "main-sidebar-sticky", "sidemenu-scroll", 3, "click"], [1, "app-sidebar", "active"], [1, "side-header"], ["routerLink", "/dashboard/sales-dashboard", 1, "header-brand1"], ["src", "assets/images/brand/logo.png", "alt", "YohaLogo", 1, "header-brand-img", "desktop-logo"], ["src", "assets/images/brand/logo-1.png", "alt", "YohaLogo", 1, "header-brand-img", "toggle-logo"], ["src", "assets/images/brand/mwblogo.png", "alt", "YohaLogo", 1, "header-brand-img", "light-logo"], ["src", "assets/images/brand/logo-3.png", "alt", "YohaLogo", 1, "header-brand-img", "light-logo1"], [1, "main-sidemenu", "is-expanded", "container"], ["id", "slide-left", 1, "slide-left", "disabled", "active"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "#7b8191", "width", "24", "height", "24", "viewBox", "0 0 24 24"], ["d", "M13.293 6.293 7.586 12l5.707 5.707 1.414-1.414L10.414 12l4.293-4.293z"], [1, "side-menu", "open", "flex-nowrap"], ["class", "side-item", 3, "ngClass", 4, "ngFor", "ngForOf"], ["id", "slide-right", 1, "slide-right"], ["d", "M10.707 17.707 16.414 12l-5.707-5.707-1.414 1.414L13.586 12l-4.293 4.293z"], [1, "side-item", 3, "ngClass"], ["class", "sub-category", 4, "ngIf"], ["class", "side-menu__item has__link", "routerLinkActive", "active", 3, "routerLink", "click", 4, "ngIf"], ["class", "side-menu__item has__link", "href", "javascript:;", "routerLinkActive", "active", 3, "click", 4, "ngIf"], ["class", "side-menu__item has__link", "routerLinkActive", "active", "target", "_blank", 3, "routerLink", "click", 4, "ngIf"], ["class", "side-menu__item", 3, "routerLink", "ngClass", "click", 4, "ngIf"], ["class", "slide-menu", 3, "ngClass", 4, "ngIf"], ["class", "slide-menu mega-slide-menu", 3, "ngClass", 4, "ngIf"], [1, "sub-category"], ["routerLinkActive", "active", 1, "side-menu__item", "has__link", 3, "routerLink", "click"], [1, "shape1"], [1, "shape2"], [1, "side-menu__icon"], [1, "side-menu__label"], ["href", "javascript:;", "routerLinkActive", "active", 1, "side-menu__item", "has__link", 3, "click"], ["routerLinkActive", "active", "target", "_blank", 1, "side-menu__item", "has__link", 3, "routerLink", "click"], [1, "side-menu__item", 3, "routerLink", "ngClass", "click"], [3, "class", 4, "ngIf"], [1, "angle", "fe", "fe-chevron-right", 3, "ngClass"], [1, "slide-menu", 3, "ngClass"], [3, "ngClass", 4, "ngFor", "ngForOf"], [3, "ngClass"], ["class", "slide-item", "routerLinkActive", "active", 3, "routerLink", "click", 4, "ngIf"], ["class", "slide-item", "routerLinkActive", "active", "href", "javascript:;", 3, "click", 4, "ngIf"], ["href", "javascript:;", "class", "sub-side-menu__item", 3, "routerLink", "click", 4, "ngIf"], ["class", "sub-slide-menu", 3, "ngClass", 4, "ngIf"], ["routerLinkActive", "active", 1, "slide-item", 3, "routerLink", "click"], ["routerLinkActive", "active", "href", "javascript:;", 1, "slide-item", 3, "click"], ["href", "javascript:;", 1, "sub-side-menu__item", 3, "routerLink", "click"], [1, "sub-side-menu__label"], [1, "sub-angle", "fe", "fe-chevron-right"], [1, "sub-slide-menu", 3, "ngClass"], ["class", "sub-slide-item", "routerLinkActive", "active", 3, "routerLink", "click", 4, "ngIf"], ["class", "sub-slide-item", "href", "javascript:;", 3, "click", 4, "ngIf"], ["class", "sub-slide-item", "href", "javascript:;", 3, "ngClass", "routerLink", "click", 4, "ngIf"], ["class", "sub-slide-menu2", 3, "ngClass", 4, "ngIf"], ["routerLinkActive", "active", 1, "sub-slide-item", 3, "routerLink", "click"], ["href", "javascript:;", 1, "sub-slide-item", 3, "click"], ["href", "javascript:;", 1, "sub-slide-item", 3, "ngClass", "routerLink", "click"], [1, "sub-side-menu__label2"], [1, "sub-angle2", "fe", "fe-chevron-right"], [1, "sub-slide-menu2", 3, "ngClass"], ["class", " ", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "", 3, "ngClass"], ["class", "sub-slide-item2", "routerLinkActive", "active", 3, "routerLink", 4, "ngIf"], ["routerLinkActive", "active", 1, "sub-slide-item2", 3, "routerLink"], [1, "slide-menu", "mega-slide-menu", 3, "ngClass"], [1, "mega-menu"], [4, "ngFor", "ngForOf"], ["routerLinkActive", "active", "class", "slide-item", 3, "routerLink", 4, "ngIf"], ["routerLinkActive", "active", 1, "slide-item", 3, "routerLink"]], template: function (t, r) { 1 & t && (m.TgZ(0, "div", 0)(1, "div", 1), m.NdJ("click", function () { return r.sidebarClose() }), m.qZA(), m.TgZ(2, "div", 2)(3, "div", 3)(4, "a", 4), m._UZ(5, "img", 5)(6, "img", 6)(7, "img", 7)(8, "img", 8), m.qZA()(), m.TgZ(9, "ng-scrollbar")(10, "div", 9)(11, "div", 10), m.O4$(), m.TgZ(12, "svg", 11), m._UZ(13, "path", 12), m.qZA()(), m.kcU(), m.TgZ(14, "ul", 13), m.YNc(15, Fn, 9, 15, "li", 14), m.qZA(), m.TgZ(16, "div", 15), m.O4$(), m.TgZ(17, "svg", 11), m._UZ(18, "path", 16), m.qZA()()()()()()), 2 & t && (m.xp6(15), m.Q6J("ngForOf", r.menuItems)) }, dependencies: [rt.mk, rt.sg, rt.O5, J.rH, J.Od, st.KC], styles: [".horizontal .hor-header li.side-item .has__link{min-width:max-content}"] }), n })(); var Qn = L(9), ur = L(8769); const dr = ["switcher"]; function Kr(n, e) { if (1 & n) { const t = m.EpF(); m.TgZ(0, "div", 70)(1, "div", 71)(2, "div", 72)(3, "div", 73)(4, "h3", 74), m._uU(5, "Licenses"), m.qZA(), m.TgZ(6, "button", 75)(7, "span", 76), m.NdJ("click", function () { const d = m.CHM(t).$implicit; return m.KtG(d.dismiss("Cross click")) }), m._uU(8, "\xd7"), m.qZA()(), m.TgZ(9, "div", 77)(10, "div", 78)(11, "div", 79)(12, "div", 80), m._UZ(13, "img", 81), m.TgZ(14, "div", 82)(15, "div", 83)(16, "span", 84), m._uU(17, "Regular"), m.qZA(), m._uU(18, " Licenses"), m.qZA(), m.TgZ(19, "p", 85), m._uU(20, "You "), m.TgZ(21, "span", 86), m._uU(22, "can't charge "), m.qZA(), m._uU(23, " from your "), m._UZ(24, "br"), m.TgZ(25, "span", 87), m._uU(26, "End Product End Users"), m.qZA()(), m.TgZ(27, "div", 88)(28, "button", 89), m._uU(29, " Buy Now "), m.qZA(), m.TgZ(30, "ul", 90)(31, "a", 91)(32, "div")(33, "p", 92), m._uU(34, "Buy Now"), m.qZA(), m.TgZ(35, "span", 93), m._uU(36, "6 months support"), m.qZA()()(), m.TgZ(37, "a", 94)(38, "div")(39, "p", 92), m._uU(40, "Buy Now"), m.qZA(), m.TgZ(41, "span", 93), m._uU(42, "12 months support"), m.qZA()()()()()()()()()(), m.TgZ(43, "div", 77)(44, "div", 95)(45, "div", 96)(46, "div", 80), m._UZ(47, "img", 97), m.TgZ(48, "div", 82)(49, "div", 83)(50, "span", 84), m._uU(51, "Extended"), m.qZA(), m._uU(52, " Licenses"), m.qZA(), m.TgZ(53, "p", 85), m._uU(54, "You "), m.TgZ(55, "span", 98), m._uU(56, "can charge"), m.qZA(), m._uU(57, " from your "), m._UZ(58, "br"), m.TgZ(59, "span", 87), m._uU(60, "End Product End Users"), m.qZA()(), m.TgZ(61, "div", 88)(62, "button", 89), m._uU(63, " Buy Now "), m.qZA(), m.TgZ(64, "ul", 90)(65, "a", 99)(66, "div")(67, "p", 92), m._uU(68, "Buy Now"), m.qZA(), m.TgZ(69, "span", 93), m._uU(70, "6 months support"), m.qZA()()(), m.TgZ(71, "a", 100)(72, "div")(73, "p", 92), m._uU(74, "Buy Now"), m.qZA(), m.TgZ(75, "span", 93), m._uU(76, "12 months support"), m.qZA()()()()()()()()()(), m.TgZ(77, "div", 101)(78, "a", 102), m._uU(79, "View license details"), m.qZA()()()()()() } } let vr = (() => { class n { constructor(t, r, a) { this.renderer = t, this.switcherServic = r, this.modalService = a, this.body = document.querySelector("body"), this.color1 = "#3b46e6", this.color2 = "#dc3545", this.color3 = "#6c5ffc", this.color4 = "#262d47", this.color13 = "#6c5ffc", this.closeResult = "", this.layoutSub = r.changeEmitted.subscribe(d => { d ? (this.renderer.addClass(this.switcher.nativeElement.firstElementChild, "active"), this.renderer.setStyle(this.switcher.nativeElement.firstElementChild, "right", "0px"), d = !0) : (this.renderer.removeClass(this.switcher.nativeElement.firstElementChild, "active"), this.renderer.setStyle(this.switcher.nativeElement.firstElementChild, "right", "-270px"), d = !1), document.querySelector(".slide-leftRTL")?.classList.add("d-none"), document.querySelector(".slide-rightRTL")?.classList.add("d-none") }) } ngOnInit() { Qn.ME(), Qn.ql(), Qn.YL(), document.body.classList.contains("transparent-mode") || document.body.classList.contains("dark-mode") ? document.getElementById("myonoffswitch1").checked = !1 : document.getElementById("myonoffswitch1").checked = !0 } reset() { document.getElementById("myonoffswitch1").checked = !0, document.getElementById("myonoffswitch3").checked = !0, document.getElementById("myonoffswitch34").checked = !0, document.getElementById("myonoffswitch54").checked = !0, document.getElementById("myonoffswitch6").checked = !0, document.getElementById("myonoffswitch9").checked = !0, document.getElementById("myonoffswitch11").checked = !0, localStorage.clear(); let B = document.querySelector("html"), K = document.querySelector("body"); B.style = "", K?.classList.remove("rtl"), K?.classList.remove("dark-mode"), K?.classList.remove("light-header"), K?.classList.remove("dark-header"), K?.classList.remove("color-header"), K?.classList.remove("gradient-header"), K?.classList.remove("light-menu"), K?.classList.remove("color-menu"), K?.classList.remove("dark-menu"), K?.classList.remove("gradient-menu"), K?.classList.remove("layout-boxed"), K?.classList.remove("scrollable-layout"), K?.classList.remove("transparent-mode"), Qn.YL(), Qn.Fe(), B.setAttribute("dir", "ltr"), document.querySelector("#style")?.setAttribute("href", "assets/plugins/bootstrap/css/bootstrap.css"), localStorage.removeItem("Yohahorizontal"), localStorage.removeItem("YohahorizontalHover"); let Me = document.querySelector(".main-content"), ot = document.querySelectorAll(".main-container"), bt = document.querySelector(".app-sidebar"), qt = document.querySelector(".header"), Tn = document.querySelector(".main-sidemenu"); Me?.classList.add("app-content"), ot.forEach(cr => { cr.classList.add("container-fluid") }), qt?.classList.add("app-header"), K?.classList.add("sidebar-mini"), K?.classList.remove("horizontal"), K?.classList.remove("horizontal-hover"), bt?.classList.remove("horizontal-main"), Tn?.classList.remove("container"), Me?.classList.remove("hor-content"), qt?.classList.remove("hor-header"), ot.forEach(cr => { cr.classList.remove("container") }), document.querySelector(".slide-left")?.classList.add("d-none"), document.querySelector(".slide-right")?.classList.add("d-none"), document.querySelector(".slide-leftRTL")?.classList.add("d-none"), document.querySelector(".slide-rightRTL")?.classList.add("d-none") } dynamicBgPrimary(t) { this.color3 = t; const r = document.querySelectorAll(".color-primary-Bg"); Qn.c3(r, this.color3), localStorage.setItem("Yohatransparent-primary-color", this.color3), localStorage.setItem("Yohatransparent-primary-hover", this.color3), localStorage.setItem("Yohatransparent-primary-border", this.color3), document.getElementById("myonoffswitch1").checked = !0, this.body?.classList.add("dark-mode"), localStorage.setItem("YohadarkTheme", "true"), this.body?.classList.remove("dark-mode"), this.body?.classList.remove("light-mode"), localStorage.removeItem("YohaDarkTheme"), localStorage.removeItem("YohaLightTheme"), this.body?.classList.remove("light-header"), this.body?.classList.remove("dark-header"), this.body?.classList.remove("color-header"), this.body?.classList.remove("gradient-header"), this.body?.classList.remove("light-menu"), this.body?.classList.remove("color-menu"), this.body?.classList.remove("dark-menu"), this.body?.classList.remove("gradient-menu"), document.querySelector(".app-header")?.classList.add("hor-header", "fixed-header", "visible-title", "stickyClass"), localStorage.removeItem("Yohalight-primary-color"), localStorage.removeItem("Yohalight-primary-hover"), localStorage.removeItem("Yohalight-primary-border"), localStorage.removeItem("Yohadark-primary-color"), localStorage.removeItem("Yohadark-primary-hover"), localStorage.removeItem("Yohadark-primary-border"), localStorage.removeItem("Yohadark-body"), Qn.os(), Qn.YL() } dynamicBgDarkPrimary(t) { document.body.classList.add("dark-mode"), this.color4 = t; const r = document.querySelectorAll(".color-bg-Dark"); Qn.cy(r, this.color4), localStorage.setItem("Yohatransparent-bg-color", this.color4), document.getElementById("myonoffswitch2").checked = !1, localStorage.removeItem("YohaLightTheme"), this.body?.classList.remove("light-mode"), this.body?.classList.remove("light-header"), this.body?.classList.remove("dark-header"), this.body?.classList.remove("color-header"), this.body?.classList.remove("gradient-header"), this.body?.classList.remove("light-menu"), this.body?.classList.remove("color-menu"), this.body?.classList.remove("dark-menu"), this.body?.classList.remove("gradient-menu"), document.querySelector(".app-header")?.classList.add("hor-header", "fixed-header", "visible-title", "stickyClass"), localStorage.removeItem("Yohalight-primary-color"), localStorage.removeItem("Yohalight-primary-hover"), localStorage.removeItem("Yohalight-primary-border"), localStorage.removeItem("Yohadark-primary-color"), localStorage.removeItem("YohaBgImage"), Qn.os(), Qn.YL() } open(t) { this.modalService.open(t, { ariaLabelledBy: "modal-basic-title" }).result.then(r => { this.closeResult = `Closed with: ${r}` }, r => { }) } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(m.Qsj), m.Y36(ye.a), m.Y36(gt.FF)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-switcher"]], viewQuery: function (t, r) { if (1 & t && m.Gf(dr, 7), 2 & t) { let a; m.iGM(a = m.CRH()) && (r.switcher = a.first) } }, decls: 188, vars: 2, consts: [[1, "switcher-wrapper"], ["switcher", ""], [1, "demo_changer"], [1, "form_holder", "sidebar-right1", "ps", "ps--active-y"], [1, "row"], [1, "predefined_styles"], [1, "swichermainleft", "text-center"], [1, "p-3", "d-grid", "gap-2"], ["href", "https://angular.spruko.com/yoha/", 1, "btn", "ripple", "btn-primary", "mt-0"], [1, "btn", "ripple", "btn-secondary", 3, "click"], ["href", "https://themeforest.net/user/spruko/portfolio", 1, "btn", "ripple", "btn-pink"], [1, "swichermainleft"], [1, "skin-body"], [1, "switch_section"], [1, "switch-toggle", "d-flex"], [1, "me-auto"], [1, "onoffswitch2", "my-0"], ["type", "radio", "name", "onoffswitch15", "id", "myonoffswitch34", "checked", "", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch34", 1, "onoffswitch2-label"], [1, "switch-toggle", "d-flex", "mt-2"], ["type", "radio", "name", "onoffswitch15", "id", "myonoffswitch35", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch35", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch15", "id", "myonoffswitch111", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch111", 1, "onoffswitch2-label"], [1, "onoffswitch2"], ["type", "radio", "name", "onoffswitch25", "id", "myonoffswitch54", "checked", "", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch54", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch25", "id", "myonoffswitch55", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch55", 1, "onoffswitch2-label", "active"], ["type", "radio", "name", "onoffswitch1", "id", "myonoffswitch1", "checked", "", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch1", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch1", "id", "myonoffswitch2", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch2", 1, "onoffswitch2-label"], [1, ""], ["ngx-colors-trigger", "", "acceptLabel", "Select", "data-id", "bg-color", "data-id1", "bg-hover", "data-id2", "bg-border", "data-id9", "transparentcolor", 1, "color-primary-Bg", 3, "ngModel", "ngModelChange"], ["ngx-colors-trigger", "", "acceptLabel", "Select", "data-id5", "body", "data-id6", "theme", 1, "color-bg-Dark", 3, "ngModel", "ngModelChange", "input"], [1, "switch-toggle", "lightMenu", "d-flex"], ["type", "radio", "name", "onoffswitch2", "id", "myonoffswitch3", "checked", "true", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch3", 1, "onoffswitch2-label"], [1, "switch-toggle", "colorMenu", "d-flex", "mt-2"], ["type", "radio", "name", "onoffswitch2", "id", "myonoffswitch4", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch4", 1, "onoffswitch2-label"], [1, "switch-toggle", "darkMenu", "d-flex", "mt-2"], ["type", "radio", "name", "onoffswitch2", "id", "myonoffswitch5", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch5", 1, "onoffswitch2-label"], [1, "switch-toggle", "gradientMenu", "d-flex", "mt-2"], ["type", "radio", "name", "onoffswitch2", "id", "myonoffswitch25", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch25", 1, "onoffswitch2-label"], [1, "switch-toggle", "lightHeader", "d-flex"], ["type", "radio", "name", "onoffswitch3", "id", "myonoffswitch6", "checked", "true", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch6", 1, "onoffswitch2-label"], [1, "switch-toggle", "colorHeader", "d-flex", "mt-2"], ["type", "radio", "name", "onoffswitch3", "id", "myonoffswitch7", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch7", 1, "onoffswitch2-label"], [1, "switch-toggle", "darkHeader", "d-flex", "mt-2"], ["type", "radio", "name", "onoffswitch3", "id", "myonoffswitch8", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch8", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch3", "id", "myonoffswitch26", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch26", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch4", "id", "myonoffswitch9", "checked", "", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch9", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch4", "id", "myonoffswitch10", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch10", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch5", "id", "myonoffswitch11", "checked", "", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch11", 1, "onoffswitch2-label"], ["type", "radio", "name", "onoffswitch5", "id", "myonoffswitch12", 1, "onoffswitch2-checkbox"], ["for", "myonoffswitch12", 1, "onoffswitch2-label"], [1, "switch_section", "my-4"], ["type", "button", 1, "btn", "btn-danger", "btn-block", 3, "click"], ["content", ""], ["role", "document", 1, "buynow"], ["data-bs-image-src", "assets/switcher/img/16.jpg", 1, "modal-content-demo", "buynow-bg", 2, "background", 'url("assets/switcher/img/16.jpg") center center'], [1, "modal-body", "px-0"], [1, "row", "justify-content-center", "py-4", "px-0", "mx-3", "Licenses-img"], [1, "text-center", "mb-4", "text-white"], ["aria-label", "Close", "data-bs-dismiss", "modal", "type", "button", 1, "btn-close"], ["aria-hidden", "true", 3, "click"], [1, "col-sm-10", "col-md-8", "col-xl-5", "col-lg-5"], [1, "card", "border-0", "regular-license"], ["data-bs-image-src", "assets/switcher/img/14.jpg", 1, "card-body", "imag-list", "cover-image", 2, "background", 'url("assets/switcher/img/14.jpg;) center center;'], [1, "text-white"], ["src", "assets/switcher/img/free.png", "alt", "", 1, "w-55", "free-img"], [1, "text-center"], [1, "tx-26"], [1, "fw-medium"], [1, "fw-semi-bold", "mb-sm-2", "mb-0"], [1, "text-success", "fw-semibold"], [1, "op-8"], ["ngbDropdown", "", 1, "dropdown"], ["ngbDropdownToggle", "", "type", "button", "data-bs-toggle", "dropdown", "aria-expanded", "false", 1, "btn", "btn-info", "w-lg", "dropdown-toggle", "mt-1"], ["ngbDropdownMenu", "", 1, "dropdown-menu", "py-0"], ["ngbDropdownItem", "", "target", "_blank", "href", "https://1.envato.market/jWxq0M", 1, "dropdown-item", "border-bottom", "px-3"], [1, "tx-14", "mb-0", "lh-xs", "fw-semibold"], [1, "tx-12", "op-7"], ["ngbDropdownItem", "", "target", "_blank", "href", "https://1.envato.market/DV946b", 1, "dropdown-item", "px-3"], [1, "card", "border-0"], ["data-bs-image-src", "assets/switcher/img/15.jpg", 1, "card-body", "imag-list", "cover-image", 2, "background", 'url("assets/switcher/img/15.jpg") center center'], ["src", "assets/switcher/img/money-bag.png", "alt", "", 1, "w-55", "free-img"], [1, "text-warning", "fw-semibold"], ["ngbDropdownItem", "", "target", "_blank", "href", "https://1.envato.market/5b24db", 1, "dropdown-item", "border-bottom", "px-3"], ["ngbDropdownItem", "", "target", "_blank", "href", "https://1.envato.market/rnk5KD", 1, "dropdown-item", "px-3"], [1, "license-view"], ["href", "https://spruko.com/licenses", "target", "_blank", 1, "modal-title", "text-center", "mb-3", "tx-14", "text-white"]], template: function (t, r) { if (1 & t) { const a = m.EpF(); m.TgZ(0, "div", 0, 1)(2, "div", 2)(3, "div", 3)(4, "ng-scrollbar")(5, "div", 4)(6, "div", 5)(7, "div", 6)(8, "div", 7)(9, "a", 8), m._uU(10, "View Demo"), m.qZA(), m.TgZ(11, "a", 9), m.NdJ("click", function () { m.CHM(a); const _ = m.MAs(187); return m.KtG(r.open(_)) }), m._uU(12, "Buy Now"), m.qZA(), m.TgZ(13, "a", 10), m._uU(14, "Our Portfolio"), m.qZA()()(), m.TgZ(15, "div", 11)(16, "h4"), m._uU(17, "Navigation Style"), m.qZA(), m.TgZ(18, "div", 12)(19, "div", 13)(20, "div", 14)(21, "span", 15), m._uU(22, "Vertical Menu"), m.qZA(), m.TgZ(23, "p", 16), m._UZ(24, "input", 17)(25, "label", 18), m.qZA()(), m.TgZ(26, "div", 19)(27, "span", 15), m._uU(28, "Horizontal Click Menu"), m.qZA(), m.TgZ(29, "p", 16), m._UZ(30, "input", 20)(31, "label", 21), m.qZA()(), m.TgZ(32, "div", 19)(33, "span", 15), m._uU(34, "Horizontal Hover Menu"), m.qZA(), m.TgZ(35, "p", 16), m._UZ(36, "input", 22)(37, "label", 23), m.qZA()()()()(), m.TgZ(38, "div", 11)(39, "h4"), m._uU(40, "LTR and RTL VERSIONS"), m.qZA(), m.TgZ(41, "div", 12)(42, "div", 13)(43, "div", 14)(44, "span", 15), m._uU(45, "LTR Version"), m.qZA(), m.TgZ(46, "p", 24), m._UZ(47, "input", 25)(48, "label", 26), m.qZA()(), m.TgZ(49, "div", 19)(50, "span", 15), m._uU(51, "RTL Version"), m.qZA(), m.TgZ(52, "p", 24), m._UZ(53, "input", 27)(54, "label", 28), m.qZA()()()()(), m.TgZ(55, "div", 11)(56, "h4"), m._uU(57, "Theme Style"), m.qZA(), m.TgZ(58, "div", 12)(59, "div", 13)(60, "div", 14)(61, "span", 15), m._uU(62, "Light Theme"), m.qZA(), m.TgZ(63, "p", 24), m._UZ(64, "input", 29)(65, "label", 30), m.qZA()(), m.TgZ(66, "div", 19)(67, "span", 15), m._uU(68, "Dark Theme"), m.qZA(), m.TgZ(69, "p", 24), m._UZ(70, "input", 31)(71, "label", 32), m.qZA()()()()(), m.TgZ(72, "div", 11)(73, "h4"), m._uU(74, "Theme Color"), m.qZA(), m.TgZ(75, "div", 12)(76, "div", 13)(77, "div", 14)(78, "span", 15), m._uU(79, "Primary"), m.qZA(), m.TgZ(80, "div", 33)(81, "ngx-colors", 34), m.NdJ("ngModelChange", function (_) { return r.color1 = _ })("ngModelChange", function (_) { return r.dynamicBgPrimary(_) }), m.qZA()()(), m.TgZ(82, "div", 19)(83, "span", 15), m._uU(84, "Background Color"), m.qZA(), m.TgZ(85, "div", 33)(86, "ngx-colors", 35), m.NdJ("ngModelChange", function (_) { return r.color4 = _ })("input", function (_) { return r.dynamicBgDarkPrimary(_) }), m.qZA()()()()()(), m.TgZ(87, "div", 11)(88, "h4"), m._uU(89, "Menu Styles"), m.qZA(), m.TgZ(90, "div", 12)(91, "div", 13)(92, "div", 36)(93, "span", 15), m._uU(94, "Light Menu"), m.qZA(), m.TgZ(95, "p", 24), m._UZ(96, "input", 37)(97, "label", 38), m.qZA()(), m.TgZ(98, "div", 39)(99, "span", 15), m._uU(100, "Color Menu"), m.qZA(), m.TgZ(101, "p", 24), m._UZ(102, "input", 40)(103, "label", 41), m.qZA()(), m.TgZ(104, "div", 42)(105, "span", 15), m._uU(106, "Dark Menu"), m.qZA(), m.TgZ(107, "p", 24), m._UZ(108, "input", 43)(109, "label", 44), m.qZA()(), m.TgZ(110, "div", 45)(111, "span", 15), m._uU(112, "Gradient Menu"), m.qZA(), m.TgZ(113, "p", 24), m._UZ(114, "input", 46)(115, "label", 47), m.qZA()()()()(), m.TgZ(116, "div", 11)(117, "h4"), m._uU(118, "Header Styles"), m.qZA(), m.TgZ(119, "div", 12)(120, "div", 13)(121, "div", 48)(122, "span", 15), m._uU(123, "Light Header"), m.qZA(), m.TgZ(124, "p", 24), m._UZ(125, "input", 49)(126, "label", 50), m.qZA()(), m.TgZ(127, "div", 51)(128, "span", 15), m._uU(129, "Color Header"), m.qZA(), m.TgZ(130, "p", 24), m._UZ(131, "input", 52)(132, "label", 53), m.qZA()(), m.TgZ(133, "div", 54)(134, "span", 15), m._uU(135, "Dark Header"), m.qZA(), m.TgZ(136, "p", 24), m._UZ(137, "input", 55)(138, "label", 56), m.qZA()(), m.TgZ(139, "div", 54)(140, "span", 15), m._uU(141, "Gradient Header"), m.qZA(), m.TgZ(142, "p", 24), m._UZ(143, "input", 57)(144, "label", 58), m.qZA()()()()(), m.TgZ(145, "div", 11)(146, "h4"), m._uU(147, "Layout Width Styles"), m.qZA(), m.TgZ(148, "div", 12)(149, "div", 13)(150, "div", 14)(151, "span", 15), m._uU(152, "Full Width"), m.qZA(), m.TgZ(153, "p", 24), m._UZ(154, "input", 59)(155, "label", 60), m.qZA()(), m.TgZ(156, "div", 19)(157, "span", 15), m._uU(158, "Boxed"), m.qZA(), m.TgZ(159, "p", 24), m._UZ(160, "input", 61)(161, "label", 62), m.qZA()()()()(), m.TgZ(162, "div", 11)(163, "h4"), m._uU(164, "Layout Positions"), m.qZA(), m.TgZ(165, "div", 12)(166, "div", 13)(167, "div", 14)(168, "span", 15), m._uU(169, "Fixed"), m.qZA(), m.TgZ(170, "p", 24), m._UZ(171, "input", 63)(172, "label", 64), m.qZA()(), m.TgZ(173, "div", 19)(174, "span", 15), m._uU(175, "Scrollable"), m.qZA(), m.TgZ(176, "p", 24), m._UZ(177, "input", 65)(178, "label", 66), m.qZA()()()()(), m.TgZ(179, "div", 11)(180, "h4"), m._uU(181, "Reset All Styles"), m.qZA(), m.TgZ(182, "div", 12)(183, "div", 67)(184, "button", 68), m.NdJ("click", function () { return r.reset() }), m._uU(185, " Reset All "), m.qZA()()()()()()()()()(), m.YNc(186, Kr, 80, 0, "ng-template", null, 69, m.W1O) } 2 & t && (m.xp6(81), m.Q6J("ngModel", r.color1), m.xp6(5), m.Q6J("ngModel", r.color4)) }, dependencies: [wt.JJ, wt.On, ur.qZ, ur.u_, gt.jt, gt.iD, gt.Vi, gt.TH, st.KC] }), n })(); const At = function (n) { return { display: n } }; let ln = (() => { class n { constructor(t) { this.viewScroller = t, this.show = !1 } ngOnInit() { } onWindowScroll() { this.show = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0) > 400 } taptotop() { this.viewScroller.scrollToPosition([0, 0]) } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(rt.EM)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-tab-to-top"]], hostBindings: function (t, r) { 1 & t && m.NdJ("scroll", function () { return r.onWindowScroll() }, !1, m.Jf7) }, decls: 2, vars: 3, consts: [["href", "javascript:void(0)", "id", "back-to-top", 3, "ngStyle", "click"], [1, "fa", "fa-angle-up"]], template: function (t, r) { 1 & t && (m.TgZ(0, "a", 0), m.NdJ("click", function () { return r.taptotop() }), m._UZ(1, "i", 1), m.qZA()), 2 & t && m.Q6J("ngStyle", m.VKq(1, At, r.show ? "block" : "none")) }, dependencies: [rt.PC] }), n })(), Ae = (() => { class n { constructor(t, r) { this.eleRef = t, this.render = r } onHover() { window.innerWidth > 768 && document.querySelector(".sidenav-toggled")?.classList.add("sidenav-toggled-open") } onLeave() { window.innerWidth > 768 && document.querySelector(".sidenav-toggled")?.classList.remove("sidenav-toggled-open") } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(m.SBq), m.Y36(m.Qsj)) }, n.\u0275dir = m.lG2({ type: n, selectors: [["", "appHoverEffectSidebar", ""]], hostBindings: function (t, r) { 1 & t && m.NdJ("mouseover", function () { return r.onHover() })("mouseleave", function () { return r.onLeave() }) } }), n })(); const Le = [{ path: "", redirectTo: "auth/login", pathMatch: "full" }, { path: "", loadChildren: () => L.e(473).then(L.bind(L, 2473)).then(n => n.AuthenticationModule) }, { path: "", redirectTo: "/dashboard/sales-dashboard", pathMatch: "full" }, { path: "", component: (() => { class n { constructor(t, r) { this.SwitcherService = t, this.navServices = r, this.scrolled = !1, this.navServices.items.subscribe(a => { this.menuItems = a }) } ngOnInit() { document.querySelector(".slide-leftRTL")?.classList.add("d-none"), document.querySelector(".slide-rightRTL")?.classList.add("d-none") } ngOnDestroy() { location.reload() } toggleSwitcherBody() { this.SwitcherService.emitChange(!1) } onWindowScroll() { this.scrolled = window.scrollY > 70 } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(ye.a), m.Y36(ae)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-content-layout"]], hostBindings: function (t, r) { 1 & t && m.NdJ("scroll", function () { return r.onWindowScroll() }, !1, m.Jf7) }, decls: 13, vars: 0, consts: [[1, "horizontalMenucontainer"], [1, "page"], [1, "page-main"], ["appHoverEffectSidebar", ""], [1, "main-content", "app-content", "mt-0"], [1, "main-container", "container-fluid", 3, "click"]], template: function (t, r) { 1 & t && (m.TgZ(0, "div", 0)(1, "div", 1), m._UZ(2, "app-header")(3, "app-switcher"), m.TgZ(4, "div", 2), m._UZ(5, "app-sidebar", 3), m.TgZ(6, "div", 4), m._UZ(7, "app-loader"), m.TgZ(8, "div", 5), m.NdJ("click", function () { return r.toggleSwitcherBody() }), m._UZ(9, "router-outlet"), m.qZA()()(), m._UZ(10, "app-right-sidebar")(11, "app-footer"), m.qZA(), m._UZ(12, "app-tab-to-top"), m.qZA()) }, dependencies: [J.lC, ve, Be, nt, tt, yn, vr, ln, Ae] }), n })(), children: [{ path: "dashboard", loadChildren: () => Promise.all([L.e(205), L.e(520), L.e(592), L.e(350)]).then(L.bind(L, 6479)).then(n => n.DashboardModule) }, { path: "apps", loadChildren: () => Promise.all([L.e(677), L.e(184), L.e(205), L.e(741), L.e(592), L.e(357)]).then(L.bind(L, 4357)).then(n => n.AppsModule) }, { path: "components", loadChildren: () => Promise.all([L.e(677), L.e(608), L.e(226), L.e(126), L.e(563)]).then(L.bind(L, 1563)).then(n => n.ComponentsModule) }, { path: "elements", loadChildren: () => L.e(958).then(L.bind(L, 7958)).then(n => n.ElementsModule) }, { path: "advanced-ui", loadChildren: () => Promise.all([L.e(677), L.e(184), L.e(741), L.e(137)]).then(L.bind(L, 3137)).then(n => n.AdvancedUiModule) }, { path: "icons", loadChildren: () => L.e(870).then(L.bind(L, 1870)).then(n => n.IconsModule) }, { path: "pages", loadChildren: () => Promise.all([L.e(677), L.e(184), L.e(205), L.e(608), L.e(741), L.e(419), L.e(520), L.e(126), L.e(160)]).then(L.bind(L, 8160)).then(n => n.PagesModule) }, { path: "e-commerce", loadChildren: () => Promise.all([L.e(677), L.e(184), L.e(608), L.e(419), L.e(226), L.e(707)]).then(L.bind(L, 9668)).then(n => n.ECommerceModule) }] }, { path: "", component: (() => { class n { constructor(t) { this.SwitcherService = t, document.body.classList.add("login-img") } ngOnInit() { } toggleSwitcher() { this.SwitcherService.emitChange(!0), document.querySelector("body")?.classList.remove("sidenav-toggled-open") } ngOnDestroy() { document.body.classList.remove("login-img"), location.reload() } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(ye.a)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-error-layout"]], decls: 3, vars: 0, consts: [[1, "error-image"], [1, "dropdown", "float-end", "custom-layout"]], template: function (t, r) { 1 & t && (m.TgZ(0, "div", 0), m._UZ(1, "div", 1)(2, "router-outlet"), m.qZA()) }, dependencies: [J.lC] }), n })(), children: [{ path: "", loadChildren: () => L.e(613).then(L.bind(L, 7613)).then(n => n.CustomPagesModule) }] }, { path: "", component: (() => { class n { constructor(t) { this.SwitcherService = t } ngOnDestroy() { location.reload() } hoverEffect(t) { this.mainSidebarOpen = "mouseover" == t.type ? "sidenav-toggled-open" : "" } } return n.\u0275fac = function (t) { return new (t || n)(m.Y36(ye.a)) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-switcherlayout"]], decls: 11, vars: 0, consts: [[1, "horizontalMenucontainer"], [1, "page", "custom-index"], ["appHoverEffectSidebar", ""], [1, "main-content", "app-content"], [1, "main-container", "container-fluid"]], template: function (t, r) { 1 & t && (m.TgZ(0, "div", 0)(1, "div", 1), m._UZ(2, "app-header")(3, "app-sidebar", 2), m.TgZ(4, "div", 3)(5, "div", 4)(6, "router-outlet"), m._UZ(7, "app-loader"), m.qZA()()()(), m._UZ(8, "app-right-sidebar")(9, "app-footer"), m.qZA(), m._UZ(10, "app-tab-to-top")) }, dependencies: [J.lC, ve, Be, nt, tt, yn, ln, Ae] }), n })(), children: [{ path: "switchercontent", loadChildren: () => Promise.all([L.e(677), L.e(184), L.e(205), L.e(741), L.e(592), L.e(357)]).then(L.bind(L, 4357)).then(n => n.AppsModule) }] }, { path: "", loadChildren: () => L.e(466).then(L.bind(L, 4466)).then(n => n.SharedModule) }]; let qe = (() => { class n { } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275mod = m.oAB({ type: n }), n.\u0275inj = m.cJS({ imports: [J.Bz.forRoot(Le), J.Bz] }), n })(), Zt = (() => { class n { constructor() { this.title = "yoha" } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275cmp = m.Xpm({ type: n, selectors: [["app-root"]], decls: 1, vars: 0, template: function (t, r) { 1 & t && m._UZ(0, "router-outlet") }, dependencies: [J.lC] }), n })(); var fe = L(7340); function et(n) { return new m.vHH(3e3, !1) } function Di() { return typeof window < "u" && typeof window.document < "u" } function Rs() { return typeof process < "u" && "[object process]" === {}.toString.call(process) } function js(n) { switch (n.length) { case 0: return new fe.ZN; case 1: return n[0]; default: return new fe.ZE(n) } } function Mr(n, e, t, r, a = new Map, d = new Map) { const _ = [], E = []; let x = -1, B = null; if (r.forEach(K => { const oe = K.get("offset"), Me = oe == x, ot = Me && B || new Map; K.forEach((bt, qt) => { let Tn = qt, cr = bt; if ("offset" !== qt) switch (Tn = e.normalizePropertyName(Tn, _), cr) { case fe.k1: cr = a.get(qt); break; case fe.l3: cr = d.get(qt); break; default: cr = e.normalizeStyleValue(qt, Tn, cr, _) }ot.set(Tn, cr) }), Me || E.push(ot), B = ot, x = oe }), _.length) throw function Hr(n) { return new m.vHH(3502, !1) }(); return E } function ba(n, e, t, r) { switch (e) { case "start": n.onStart(() => r(t && So(t, "start", n))); break; case "done": n.onDone(() => r(t && So(t, "done", n))); break; case "destroy": n.onDestroy(() => r(t && So(t, "destroy", n))) } } function So(n, e, t) { const d = al(n.element, n.triggerName, n.fromState, n.toState, e || n.phaseName, t.totalTime ?? n.totalTime, !!t.disabled), _ = n._data; return null != _ && (d._data = _), d } function al(n, e, t, r, a = "", d = 0, _) { return { element: n, triggerName: e, fromState: t, toState: r, phaseName: a, totalTime: d, disabled: !!_ } } function Vi(n, e, t) { let r = n.get(e); return r || n.set(e, r = t), r } function ls(n) { const e = n.indexOf(":"); return [n.substring(1, e), n.slice(e + 1)] } let Ho = (n, e) => !1, no = (n, e, t) => [], Fs = null; function cs(n) { const e = n.parentNode || n.host; return e === Fs ? null : e } (Rs() || typeof Element < "u") && (Di() ? (Fs = (() => document.documentElement)(), Ho = (n, e) => { for (; e;) { if (e === n) return !0; e = cs(e) } return !1 }) : Ho = (n, e) => n.contains(e), no = (n, e, t) => { if (t) return Array.from(n.querySelectorAll(e)); const r = n.querySelector(e); return r ? [r] : [] }); let dt = null, Mt = !1; const lr = Ho, wr = no; let Ai = (() => { class n { validateStyleProperty(t) { return function hn(n) { dt || (dt = function Yn() { return typeof document < "u" ? document.body : null }() || {}, Mt = !!dt.style && "WebkitAppearance" in dt.style); let e = !0; return dt.style && !function ft(n) { return "ebkit" == n.substring(1, 6) }(n) && (e = n in dt.style, !e && Mt && (e = "Webkit" + n.charAt(0).toUpperCase() + n.slice(1) in dt.style)), e }(t) } matchesElement(t, r) { return !1 } containsElement(t, r) { return lr(t, r) } getParentElement(t) { return cs(t) } query(t, r, a) { return wr(t, r, a) } computeStyle(t, r, a) { return a || "" } animate(t, r, a, d, _, E = [], x) { return new fe.ZN(a, d) } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac }), n })(), Ts = (() => { class n { } return n.NOOP = new Ai, n })(); const us = "ng-enter", bo = "ng-leave", Jr = "ng-trigger", Io = ".ng-trigger", Xn = "ng-animating", uo = ".ng-animating"; function Si(n) { if ("number" == typeof n) return n; const e = n.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : ka(parseFloat(e[1]), e[2]) } function ka(n, e) { return "s" === e ? 1e3 * n : n } function io(n, e, t) { return n.hasOwnProperty("duration") ? n : function Wl(n, e, t) { let a, d = 0, _ = ""; if ("string" == typeof n) { const E = n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === E) return e.push(et()), { duration: 0, delay: 0, easing: "" }; a = ka(parseFloat(E[1]), E[2]); const x = E[3]; null != x && (d = ka(parseFloat(x), E[4])); const B = E[5]; B && (_ = B) } else a = n; if (!t) { let E = !1, x = e.length; a < 0 && (e.push(function Lt() { return new m.vHH(3100, !1) }()), E = !0), d < 0 && (e.push(function mt() { return new m.vHH(3101, !1) }()), E = !0), E && e.splice(x, 0, et()) } return { duration: a, delay: d, easing: _ } }(n, e, t) } function zo(n, e = {}) { return Object.keys(n).forEach(t => { e[t] = n[t] }), e } function Ys(n) { const e = new Map; return Object.keys(n).forEach(t => { e.set(t, n[t]) }), e } function jo(n, e = new Map, t) { if (t) for (let [r, a] of t) e.set(r, a); for (let [r, a] of n) e.set(r, a); return e } function na(n, e, t) { return t ? e + ":" + t + ";" : "" } function Zl(n) { let e = ""; for (let t = 0; t < n.style.length; t++) { const r = n.style.item(t); e += na(0, r, n.style.getPropertyValue(r)) } for (const t in n.style) n.style.hasOwnProperty(t) && !t.startsWith("_") && (e += na(0, fo(t), n.style[t])); n.setAttribute("style", e) } function pi(n, e, t) { n.style && (e.forEach((r, a) => { const d = Za(a); t && !t.has(a) && t.set(a, n.style[d]), n.style[d] = r }), Rs() && Zl(n)) } function Ss(n, e) { n.style && (e.forEach((t, r) => { const a = Za(r); n.style[a] = "" }), Rs() && Zl(n)) } function $o(n) { return Array.isArray(n) ? 1 == n.length ? n[0] : (0, fe.vP)(n) : n } const ho = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function Ao(n) { let e = []; if ("string" == typeof n) { let t; for (; t = ho.exec(n);)e.push(t[1]); ho.lastIndex = 0 } return e } function rs(n, e, t) { const r = n.toString(), a = r.replace(ho, (d, _) => { let E = e[_]; return null == E && (t.push(function ar(n) { return new m.vHH(3003, !1) }()), E = ""), E.toString() }); return a == r ? n : a } function Is(n) { const e = []; let t = n.next(); for (; !t.done;)e.push(t.value), t = n.next(); return e } const Wo = /-+([a-z0-9])/g; function Za(n) { return n.replace(Wo, (...e) => e[1].toUpperCase()) } function fo(n) { return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function Ks(n, e, t) { switch (e.type) { case 7: return n.visitTrigger(e, t); case 0: return n.visitState(e, t); case 1: return n.visitTransition(e, t); case 2: return n.visitSequence(e, t); case 3: return n.visitGroup(e, t); case 4: return n.visitAnimate(e, t); case 5: return n.visitKeyframes(e, t); case 6: return n.visitStyle(e, t); case 8: return n.visitReference(e, t); case 9: return n.visitAnimateChild(e, t); case 10: return n.visitAnimateRef(e, t); case 11: return n.visitQuery(e, t); case 12: return n.visitStagger(e, t); default: throw function sr(n) { return new m.vHH(3004, !1) }() } } function Ls(n, e) { return window.getComputedStyle(n)[e] } function Ml(n, e) { const t = []; return "string" == typeof n ? n.split(/\s*,\s*/).forEach(r => function wa(n, e, t) { if (":" == n[0]) { const x = function Qs(n, e) { switch (n) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, r) => parseFloat(r) > parseFloat(t); case ":decrement": return (t, r) => parseFloat(r) < parseFloat(t); default: return e.push(function Bi(n) { return new m.vHH(3016, !1) }()), "* => *" } }(n, t); if ("function" == typeof x) return void e.push(x); n = x } const r = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return t.push(function Dr(n) { return new m.vHH(3015, !1) }()), e; const a = r[1], d = r[2], _ = r[3]; e.push(xs(a, _)); "<" == d[0] && !("*" == a && "*" == _) && e.push(xs(_, a)) }(r, t, e)) : t.push(n), t } const Zr = new Set(["true", "1"]), oo = new Set(["false", "0"]); function xs(n, e) { const t = Zr.has(n) || oo.has(n), r = Zr.has(e) || oo.has(e); return (a, d) => { let _ = "*" == n || n == a, E = "*" == e || e == d; return !_ && t && "boolean" == typeof a && (_ = a ? Zr.has(n) : oo.has(n)), !E && r && "boolean" == typeof d && (E = d ? Zr.has(e) : oo.has(e)), _ && E } } const Hi = new RegExp("s*:selfs*,?", "g"); function qa(n, e, t, r) { return new hr(n).build(e, t, r) } class hr { constructor(e) { this._driver = e } build(e, t, r) { const a = new q(t); return this._resetContextStyleTimingState(a), Ks(this, $o(e), a) } _resetContextStyleTimingState(e) { e.currentQuerySelector = "", e.collectedStyles = new Map, e.collectedStyles.set("", new Map), e.currentTime = 0 } visitTrigger(e, t) { let r = t.queryCount = 0, a = t.depCount = 0; const d = [], _ = []; return "@" == e.name.charAt(0) && t.errors.push(function ze() { return new m.vHH(3006, !1) }()), e.definitions.forEach(E => { if (this._resetContextStyleTimingState(t), 0 == E.type) { const x = E, B = x.name; B.toString().split(/\s*,\s*/).forEach(K => { x.name = K, d.push(this.visitState(x, t)) }), x.name = B } else if (1 == E.type) { const x = this.visitTransition(E, t); r += x.queryCount, a += x.depCount, _.push(x) } else t.errors.push(function Ye() { return new m.vHH(3007, !1) }()) }), { type: 7, name: e.name, states: d, transitions: _, queryCount: r, depCount: a, options: null } } visitState(e, t) { const r = this.visitStyle(e.styles, t), a = e.options && e.options.params || null; if (r.containsDynamicStyles) { const d = new Set, _ = a || {}; r.styles.forEach(E => { E instanceof Map && E.forEach(x => { Ao(x).forEach(B => { _.hasOwnProperty(B) || d.add(B) }) }) }), d.size && (Is(d.values()), t.errors.push(function Ie(n, e) { return new m.vHH(3008, !1) }())) } return { type: 0, name: e.name, style: r, options: a ? { params: a } : null } } visitTransition(e, t) { t.queryCount = 0, t.depCount = 0; const r = Ks(this, $o(e.animation), t); return { type: 1, matchers: Ml(e.expr, t.errors), animation: r, queryCount: t.queryCount, depCount: t.depCount, options: Rt(e.options) } } visitSequence(e, t) { return { type: 2, steps: e.steps.map(r => Ks(this, r, t)), options: Rt(e.options) } } visitGroup(e, t) { const r = t.currentTime; let a = 0; const d = e.steps.map(_ => { t.currentTime = r; const E = Ks(this, _, t); return a = Math.max(a, t.currentTime), E }); return t.currentTime = a, { type: 3, steps: d, options: Rt(e.options) } } visitAnimate(e, t) { const r = function me(n, e) { if (n.hasOwnProperty("duration")) return n; if ("number" == typeof n) return Bn(io(n, e).duration, 0, ""); const t = n; if (t.split(/\s+/).some(d => "{" == d.charAt(0) && "{" == d.charAt(1))) { const d = Bn(0, 0, ""); return d.dynamic = !0, d.strValue = t, d } const a = io(t, e); return Bn(a.duration, a.delay, a.easing) }(e.timings, t.errors); t.currentAnimateTimings = r; let a, d = e.styles ? e.styles : (0, fe.oB)({}); if (5 == d.type) a = this.visitKeyframes(d, t); else { let _ = e.styles, E = !1; if (!_) { E = !0; const B = {}; r.easing && (B.easing = r.easing), _ = (0, fe.oB)(B) } t.currentTime += r.duration + r.delay; const x = this.visitStyle(_, t); x.isEmptyStep = E, a = x } return t.currentAnimateTimings = null, { type: 4, timings: r, style: a, options: null } } visitStyle(e, t) { const r = this._makeStyleAst(e, t); return this._validateStyleAst(r, t), r } _makeStyleAst(e, t) { const r = [], a = Array.isArray(e.styles) ? e.styles : [e.styles]; for (let E of a) "string" == typeof E ? E === fe.l3 ? r.push(E) : t.errors.push(new m.vHH(3002, !1)) : r.push(Ys(E)); let d = !1, _ = null; return r.forEach(E => { if (E instanceof Map && (E.has("easing") && (_ = E.get("easing"), E.delete("easing")), !d)) for (let x of E.values()) if (x.toString().indexOf("{{") >= 0) { d = !0; break } }), { type: 6, styles: r, easing: _, offset: e.offset, containsDynamicStyles: d, options: null } } _validateStyleAst(e, t) { const r = t.currentAnimateTimings; let a = t.currentTime, d = t.currentTime; r && d > 0 && (d -= r.duration + r.delay), e.styles.forEach(_ => { "string" != typeof _ && _.forEach((E, x) => { const B = t.collectedStyles.get(t.currentQuerySelector), K = B.get(x); let oe = !0; K && (d != a && d >= K.startTime && a <= K.endTime && (t.errors.push(function xn(n, e, t, r, a) { return new m.vHH(3010, !1) }()), oe = !1), d = K.startTime), oe && B.set(x, { startTime: d, endTime: a }), t.options && function wo(n, e, t) { const r = e.params || {}, a = Ao(n); a.length && a.forEach(d => { r.hasOwnProperty(d) || t.push(function An(n) { return new m.vHH(3001, !1) }()) }) }(E, t.options, t.errors) }) }) } visitKeyframes(e, t) { const r = { type: 5, styles: [], options: null }; if (!t.currentAnimateTimings) return t.errors.push(function zn() { return new m.vHH(3011, !1) }()), r; let d = 0; const _ = []; let E = !1, x = !1, B = 0; const K = e.steps.map(cr => { const $r = this._makeStyleAst(cr, t); let Rr = null != $r.offset ? $r.offset : function $(n) { if ("string" == typeof n) return null; let e = null; if (Array.isArray(n)) n.forEach(t => { if (t instanceof Map && t.has("offset")) { const r = t; e = parseFloat(r.get("offset")), r.delete("offset") } }); else if (n instanceof Map && n.has("offset")) { const t = n; e = parseFloat(t.get("offset")), t.delete("offset") } return e }($r.styles), Li = 0; return null != Rr && (d++, Li = $r.offset = Rr), x = x || Li < 0 || Li > 1, E = E || Li < B, B = Li, _.push(Li), $r }); x && t.errors.push(function ti() { return new m.vHH(3012, !1) }()), E && t.errors.push(function Br() { return new m.vHH(3200, !1) }()); const oe = e.steps.length; let Me = 0; d > 0 && d < oe ? t.errors.push(function ss() { return new m.vHH(3202, !1) }()) : 0 == d && (Me = 1 / (oe - 1)); const ot = oe - 1, bt = t.currentTime, qt = t.currentAnimateTimings, Tn = qt.duration; return K.forEach((cr, $r) => { const Rr = Me > 0 ? $r == ot ? 1 : Me * $r : _[$r], Li = Rr * Tn; t.currentTime = bt + qt.delay + Li, qt.duration = Li, this._validateStyleAst(cr, t), cr.offset = Rr, r.styles.push(cr) }), r } visitReference(e, t) { return { type: 8, animation: Ks(this, $o(e.animation), t), options: Rt(e.options) } } visitAnimateChild(e, t) { return t.depCount++, { type: 9, options: Rt(e.options) } } visitAnimateRef(e, t) { return { type: 10, animation: this.visitReference(e.animation, t), options: Rt(e.options) } } visitQuery(e, t) { const r = t.currentQuerySelector, a = e.options || {}; t.queryCount++, t.currentQuery = e; const [d, _] = function Xs(n) { const e = !!n.split(/\s*,\s*/).find(t => ":self" == t); return e && (n = n.replace(Hi, "")), n = n.replace(/@\*/g, Io).replace(/@\w+/g, t => Io + "-" + t.slice(1)).replace(/:animating/g, uo), [n, e] }(e.selector); t.currentQuerySelector = r.length ? r + " " + d : d, Vi(t.collectedStyles, t.currentQuerySelector, new Map); const E = Ks(this, $o(e.animation), t); return t.currentQuery = null, t.currentQuerySelector = r, { type: 11, selector: d, limit: a.limit || 0, optional: !!a.optional, includeSelf: _, animation: E, originalSelector: e.selector, options: Rt(e.options) } } visitStagger(e, t) { t.currentQuery || t.errors.push(function Ps() { return new m.vHH(3013, !1) }()); const r = "full" === e.timings ? { duration: 0, delay: 0, easing: "full" } : io(e.timings, t.errors, !0); return { type: 12, animation: Ks(this, $o(e.animation), t), timings: r, options: null } } } class q { constructor(e) { this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set } } function Rt(n) { return n ? (n = zo(n)).params && (n.params = function Q(n) { return n ? zo(n) : null }(n.params)) : n = {}, n } function Bn(n, e, t) { return { duration: n, delay: e, easing: t } } function wi(n, e, t, r, a, d, _ = null, E = !1) { return { type: 1, element: n, keyframes: e, preStyleProps: t, postStyleProps: r, duration: a, delay: d, totalTime: a + d, easing: _, subTimeline: E } } class Jt { constructor() { this._map = new Map } get(e) { return this._map.get(e) || [] } append(e, t) { let r = this._map.get(e); r || this._map.set(e, r = []), r.push(...t) } has(e) { return this._map.has(e) } clear() { this._map.clear() } } const qc = new RegExp(":enter", "g"), ql = new RegExp(":leave", "g"); function cl(n, e, t, r, a, d = new Map, _ = new Map, E, x, B = []) { return (new po).buildKeyframes(n, e, t, r, a, d, _, E, x, B) } class po { buildKeyframes(e, t, r, a, d, _, E, x, B, K = []) { B = B || new Jt; const oe = new ul(e, t, B, a, d, K, []); oe.options = x; const Me = x.delay ? Si(x.delay) : 0; oe.currentTimeline.delayNextStep(Me), oe.currentTimeline.setStyles([_], null, oe.errors, x), Ks(this, r, oe); const ot = oe.timelines.filter(bt => bt.containsAnimation()); if (ot.length && E.size) { let bt; for (let qt = ot.length - 1; qt >= 0; qt--) { const Tn = ot[qt]; if (Tn.element === t) { bt = Tn; break } } bt && !bt.allowOnlyTimelineStyles() && bt.setStyles([E], null, oe.errors, x) } return ot.length ? ot.map(bt => bt.buildKeyframes()) : [wi(t, [], [], [], 0, Me, "", !1)] } visitTrigger(e, t) { } visitState(e, t) { } visitTransition(e, t) { } visitAnimateChild(e, t) { const r = t.subInstructions.get(t.element); if (r) { const a = t.createSubContext(e.options), d = t.currentTimeline.currentTime, _ = this._visitSubInstructions(r, a, a.options); d != _ && t.transformIntoNewTimeline(_) } t.previousNode = e } visitAnimateRef(e, t) { const r = t.createSubContext(e.options); r.transformIntoNewTimeline(), this._applyAnimationRefDelays([e.options, e.animation.options], t, r), this.visitReference(e.animation, r), t.transformIntoNewTimeline(r.currentTimeline.currentTime), t.previousNode = e } _applyAnimationRefDelays(e, t, r) { for (const a of e) { const d = a?.delay; if (d) { const _ = "number" == typeof d ? d : Si(rs(d, a?.params ?? {}, t.errors)); r.delayNextStep(_) } } } _visitSubInstructions(e, t, r) { let d = t.currentTimeline.currentTime; const _ = null != r.duration ? Si(r.duration) : null, E = null != r.delay ? Si(r.delay) : null; return 0 !== _ && e.forEach(x => { const B = t.appendInstructionToTimeline(x, _, E); d = Math.max(d, B.duration + B.delay) }), d } visitReference(e, t) { t.updateOptions(e.options, !0), Ks(this, e.animation, t), t.previousNode = e } visitSequence(e, t) { const r = t.subContextCount; let a = t; const d = e.options; if (d && (d.params || d.delay) && (a = t.createSubContext(d), a.transformIntoNewTimeline(), null != d.delay)) { 6 == a.previousNode.type && (a.currentTimeline.snapshotCurrentStyles(), a.previousNode = Fa); const _ = Si(d.delay); a.delayNextStep(_) } e.steps.length && (e.steps.forEach(_ => Ks(this, _, a)), a.currentTimeline.applyStylesToKeyframe(), a.subContextCount > r && a.transformIntoNewTimeline()), t.previousNode = e } visitGroup(e, t) { const r = []; let a = t.currentTimeline.currentTime; const d = e.options && e.options.delay ? Si(e.options.delay) : 0; e.steps.forEach(_ => { const E = t.createSubContext(e.options); d && E.delayNextStep(d), Ks(this, _, E), a = Math.max(a, E.currentTimeline.currentTime), r.push(E.currentTimeline) }), r.forEach(_ => t.currentTimeline.mergeTimelineCollectedStyles(_)), t.transformIntoNewTimeline(a), t.previousNode = e } _visitTiming(e, t) { if (e.dynamic) { const r = e.strValue; return io(t.params ? rs(r, t.params, t.errors) : r, t.errors) } return { duration: e.duration, delay: e.delay, easing: e.easing } } visitAnimate(e, t) { const r = t.currentAnimateTimings = this._visitTiming(e.timings, t), a = t.currentTimeline; r.delay && (t.incrementTime(r.delay), a.snapshotCurrentStyles()); const d = e.style; 5 == d.type ? this.visitKeyframes(d, t) : (t.incrementTime(r.duration), this.visitStyle(d, t), a.applyStylesToKeyframe()), t.currentAnimateTimings = null, t.previousNode = e } visitStyle(e, t) { const r = t.currentTimeline, a = t.currentAnimateTimings; !a && r.hasCurrentStyleProperties() && r.forwardFrame(); const d = a && a.easing || e.easing; e.isEmptyStep ? r.applyEmptyStep(d) : r.setStyles(e.styles, d, t.errors, t.options), t.previousNode = e } visitKeyframes(e, t) { const r = t.currentAnimateTimings, a = t.currentTimeline.duration, d = r.duration, E = t.createSubContext().currentTimeline; E.easing = r.easing, e.styles.forEach(x => { E.forwardTime((x.offset || 0) * d), E.setStyles(x.styles, x.easing, t.errors, t.options), E.applyStylesToKeyframe() }), t.currentTimeline.mergeTimelineCollectedStyles(E), t.transformIntoNewTimeline(a + d), t.previousNode = e } visitQuery(e, t) { const r = t.currentTimeline.currentTime, a = e.options || {}, d = a.delay ? Si(a.delay) : 0; d && (6 === t.previousNode.type || 0 == r && t.currentTimeline.hasCurrentStyleProperties()) && (t.currentTimeline.snapshotCurrentStyles(), t.previousNode = Fa); let _ = r; const E = t.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!a.optional, t.errors); t.currentQueryTotal = E.length; let x = null; E.forEach((B, K) => { t.currentQueryIndex = K; const oe = t.createSubContext(e.options, B); d && oe.delayNextStep(d), B === t.element && (x = oe.currentTimeline), Ks(this, e.animation, oe), oe.currentTimeline.applyStylesToKeyframe(), _ = Math.max(_, oe.currentTimeline.currentTime) }), t.currentQueryIndex = 0, t.currentQueryTotal = 0, t.transformIntoNewTimeline(_), x && (t.currentTimeline.mergeTimelineCollectedStyles(x), t.currentTimeline.snapshotCurrentStyles()), t.previousNode = e } visitStagger(e, t) { const r = t.parentContext, a = t.currentTimeline, d = e.timings, _ = Math.abs(d.duration), E = _ * (t.currentQueryTotal - 1); let x = _ * t.currentQueryIndex; switch (d.duration < 0 ? "reverse" : d.easing) { case "reverse": x = E - x; break; case "full": x = r.currentStaggerTime }const K = t.currentTimeline; x && K.delayNextStep(x); const oe = K.currentTime; Ks(this, e.animation, t), t.previousNode = e, r.currentStaggerTime = a.currentTime - oe + (a.startTime - r.currentTimeline.startTime) } } const Fa = {}; class ul { constructor(e, t, r, a, d, _, E, x) { this._driver = e, this.element = t, this.subInstructions = r, this._enterClassName = a, this._leaveClassName = d, this.errors = _, this.timelines = E, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Fa, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = x || new Yl(this._driver, t, 0), E.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(e, t) { if (!e) return; const r = e; let a = this.options; null != r.duration && (a.duration = Si(r.duration)), null != r.delay && (a.delay = Si(r.delay)); const d = r.params; if (d) { let _ = a.params; _ || (_ = this.options.params = {}), Object.keys(d).forEach(E => { (!t || !_.hasOwnProperty(E)) && (_[E] = rs(d[E], _, this.errors)) }) } } _copyOptions() { const e = {}; if (this.options) { const t = this.options.params; if (t) { const r = e.params = {}; Object.keys(t).forEach(a => { r[a] = t[a] }) } } return e } createSubContext(e = null, t, r) { const a = t || this.element, d = new ul(this._driver, a, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(a, r || 0)); return d.previousNode = this.previousNode, d.currentAnimateTimings = this.currentAnimateTimings, d.options = this._copyOptions(), d.updateOptions(e), d.currentQueryIndex = this.currentQueryIndex, d.currentQueryTotal = this.currentQueryTotal, d.parentContext = this, this.subContextCount++, d } transformIntoNewTimeline(e) { return this.previousNode = Fa, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(e, t, r) { const a = { duration: t ?? e.duration, delay: this.currentTimeline.currentTime + (r ?? 0) + e.delay, easing: "" }, d = new Kl(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, a, e.stretchStartingKeyframe); return this.timelines.push(d), a } incrementTime(e) { this.currentTimeline.forwardTime(this.currentTimeline.duration + e) } delayNextStep(e) { e > 0 && this.currentTimeline.delayNextStep(e) } invokeQuery(e, t, r, a, d, _) { let E = []; if (a && E.push(this.element), e.length > 0) { e = (e = e.replace(qc, "." + this._enterClassName)).replace(ql, "." + this._leaveClassName); let B = this._driver.query(this.element, e, 1 != r); 0 !== r && (B = r < 0 ? B.slice(B.length + r, B.length) : B.slice(0, r)), E.push(...B) } return !d && 0 == E.length && _.push(function vo(n) { return new m.vHH(3014, !1) }()), E } } class Yl { constructor(e, t, r, a) { this._driver = e, this.element = t, this.startTime = r, this._elementTimelineStylesLookup = a, this.duration = 0, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(t), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(t, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.hasCurrentStyleProperties(); default: return !0 } } hasCurrentStyleProperties() { return this._currentKeyframe.size > 0 } get currentTime() { return this.startTime + this.duration } delayNextStep(e) { const t = 1 === this._keyframes.size && this._pendingStyles.size; this.duration || t ? (this.forwardTime(this.currentTime + e), t && this.snapshotCurrentStyles()) : this.startTime += e } fork(e, t) { return this.applyStylesToKeyframe(), new Yl(this._driver, e, t || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(e) { this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe() } _updateStyle(e, t) { this._localTimelineStyles.set(e, t), this._globalTimelineStyles.set(e, t), this._styleSummary.set(e, { time: this.currentTime, value: t }) } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(e) { e && this._previousKeyframe.set("easing", e); for (let [t, r] of this._globalTimelineStyles) this._backFill.set(t, r || fe.l3), this._currentKeyframe.set(t, fe.l3); this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(e, t, r, a) { t && this._previousKeyframe.set("easing", t); const d = a && a.params || {}, _ = function Ms(n, e) { const t = new Map; let r; return n.forEach(a => { if ("*" === a) { r = r || e.keys(); for (let d of r) t.set(d, fe.l3) } else jo(a, t) }), t }(e, this._globalTimelineStyles); for (let [E, x] of _) { const B = rs(x, d, r); this._pendingStyles.set(E, B), this._localTimelineStyles.has(E) || this._backFill.set(E, this._globalTimelineStyles.get(E) ?? fe.l3), this._updateStyle(E, B) } } applyStylesToKeyframe() { 0 != this._pendingStyles.size && (this._pendingStyles.forEach((e, t) => { this._currentKeyframe.set(t, e) }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((e, t) => { this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e) })) } snapshotCurrentStyles() { for (let [e, t] of this._localTimelineStyles) this._pendingStyles.set(e, t), this._updateStyle(e, t) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const e = []; for (let t in this._currentKeyframe) e.push(t); return e } mergeTimelineCollectedStyles(e) { e._styleSummary.forEach((t, r) => { const a = this._styleSummary.get(r); (!a || t.time > a.time) && this._updateStyle(r, t.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const e = new Set, t = new Set, r = 1 === this._keyframes.size && 0 === this.duration; let a = []; this._keyframes.forEach((E, x) => { const B = jo(E, new Map, this._backFill); B.forEach((K, oe) => { K === fe.k1 ? e.add(oe) : K === fe.l3 && t.add(oe) }), r || B.set("offset", x / this.duration), a.push(B) }); const d = e.size ? Is(e.values()) : [], _ = t.size ? Is(t.values()) : []; if (r) { const E = a[0], x = new Map(E); E.set("offset", 0), x.set("offset", 1), a = [E, x] } return wi(this.element, a, d, _, this.duration, this.startTime, this.easing, !1) } } class Kl extends Yl { constructor(e, t, r, a, d, _, E = !1) { super(e, t, _.delay), this.keyframes = r, this.preStyleProps = a, this.postStyleProps = d, this._stretchStartingKeyframe = E, this.timings = { duration: _.duration, delay: _.delay, easing: _.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let e = this.keyframes, { delay: t, duration: r, easing: a } = this.timings; if (this._stretchStartingKeyframe && t) { const d = [], _ = r + t, E = t / _, x = jo(e[0]); x.set("offset", 0), d.push(x); const B = jo(e[0]); B.set("offset", dl(E)), d.push(B); const K = e.length - 1; for (let oe = 1; oe <= K; oe++) { let Me = jo(e[oe]); const ot = Me.get("offset"); Me.set("offset", dl((t + ot * r) / _)), d.push(Me) } r = _, t = 0, a = "", e = d } return wi(this.element, e, this.preStyleProps, this.postStyleProps, r, t, a, !0) } } function dl(n, e = 3) { const t = Math.pow(10, e - 1); return Math.round(n * t) / t } class Ca { } const Co = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]); class bc extends Ca { normalizePropertyName(e, t) { return Za(e) } normalizeStyleValue(e, t, r, a) { let d = ""; const _ = r.toString().trim(); if (Co.has(t) && 0 !== r && "0" !== r) if ("number" == typeof r) d = "px"; else { const E = r.match(/^[+-]?[\d\.]+([a-z]*)$/); E && 0 == E[1].length && a.push(function Fr(n, e) { return new m.vHH(3005, !1) }()) } return _ + d } } function Ea(n, e, t, r, a, d, _, E, x, B, K, oe, Me) { return { type: 0, element: n, triggerName: e, isRemovalTransition: a, fromState: t, fromStyles: d, toState: r, toStyles: _, timelines: E, queriedElements: x, preStyleProps: B, postStyleProps: K, totalTime: oe, errors: Me } } const Jl = {}; class wc { constructor(e, t, r) { this._triggerName = e, this.ast = t, this._stateStyles = r } match(e, t, r, a) { return function No(n, e, t, r, a) { return n.some(d => d(e, t, r, a)) }(this.ast.matchers, e, t, r, a) } buildStyles(e, t, r) { let a = this._stateStyles.get("*"); return void 0 !== e && (a = this._stateStyles.get(e?.toString()) || a), a ? a.buildStyles(t, r) : new Map } build(e, t, r, a, d, _, E, x, B, K) { const oe = [], Me = this.ast.options && this.ast.options.params || Jl, bt = this.buildStyles(r, E && E.params || Jl, oe), qt = x && x.params || Jl, Tn = this.buildStyles(a, qt, oe), cr = new Set, $r = new Map, Rr = new Map, Li = "void" === a, Ki = { params: Cc(qt, Me), delay: this.ast.options?.delay }, Pi = K ? [] : cl(e, t, this.ast.animation, d, _, bt, Tn, Ki, B, oe); let Es = 0; if (Pi.forEach(dg => { Es = Math.max(dg.duration + dg.delay, Es) }), oe.length) return Ea(t, this._triggerName, r, a, Li, bt, Tn, [], [], $r, Rr, Es, oe); Pi.forEach(dg => { const hg = dg.element, kx = Vi($r, hg, new Set); dg.preStyleProps.forEach(iy => kx.add(iy)); const Vw = Vi(Rr, hg, new Set); dg.postStyleProps.forEach(iy => Vw.add(iy)), hg !== t && cr.add(hg) }); const cd = Is(cr.values()); return Ea(t, this._triggerName, r, a, Li, bt, Tn, Pi, cd, $r, Rr, Es) } } function Cc(n, e) { const t = zo(e); for (const r in n) n.hasOwnProperty(r) && null != n[r] && (t[r] = n[r]); return t } class fl { constructor(e, t, r) { this.styles = e, this.defaultParams = t, this.normalizer = r } buildStyles(e, t) { const r = new Map, a = zo(this.defaultParams); return Object.keys(e).forEach(d => { const _ = e[d]; null !== _ && (a[d] = _) }), this.styles.styles.forEach(d => { "string" != typeof d && d.forEach((_, E) => { _ && (_ = rs(_, a, t)); const x = this.normalizer.normalizePropertyName(E, t); _ = this.normalizer.normalizeStyleValue(E, x, _, t), r.set(E, _) }) }), r } } class Ta { constructor(e, t, r) { this.name = e, this.ast = t, this._normalizer = r, this.transitionFactories = [], this.states = new Map, t.states.forEach(a => { this.states.set(a.name, new fl(a.style, a.options && a.options.params || {}, r)) }), Ol(this.states, "true", "1"), Ol(this.states, "false", "0"), t.transitions.forEach(a => { this.transitionFactories.push(new wc(e, a, this.states)) }), this.fallbackTransition = function Ec(n, e, t) { return new wc(n, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(_, E) => !0], options: null, queryCount: 0, depCount: 0 }, e) }(e, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(e, t, r, a) { return this.transitionFactories.find(_ => _.match(e, t, r, a)) || null } matchStyles(e, t, r) { return this.fallbackTransition.buildStyles(e, t, r) } } function Ol(n, e, t) { n.has(e) ? n.has(t) || n.set(t, n.get(e)) : n.has(t) && n.set(e, n.get(t)) } const Ya = new Jt; class Tc { constructor(e, t, r) { this.bodyNode = e, this._driver = t, this._normalizer = r, this._animations = new Map, this._playersById = new Map, this.players = [] } register(e, t) { const r = [], d = qa(this._driver, t, r, []); if (r.length) throw function Ji(n) { return new m.vHH(3503, !1) }(); this._animations.set(e, d) } _buildPlayer(e, t, r) { const a = e.element, d = Mr(0, this._normalizer, 0, e.keyframes, t, r); return this._driver.animate(a, d, e.duration, e.delay, e.easing, [], !0) } create(e, t, r = {}) { const a = [], d = this._animations.get(e); let _; const E = new Map; if (d ? (_ = cl(this._driver, t, d, us, bo, new Map, new Map, r, Ya, a), _.forEach(K => { const oe = Vi(E, K.element, new Map); K.postStyleProps.forEach(Me => oe.set(Me, null)) })) : (a.push(function Ei() { return new m.vHH(3300, !1) }()), _ = []), a.length) throw function Gi(n) { return new m.vHH(3504, !1) }(); E.forEach((K, oe) => { K.forEach((Me, ot) => { K.set(ot, this._driver.computeStyle(oe, ot, fe.l3)) }) }); const B = js(_.map(K => { const oe = E.get(K.element); return this._buildPlayer(K, new Map, oe) })); return this._playersById.set(e, B), B.onDestroy(() => this.destroy(e)), this.players.push(B), B } destroy(e) { const t = this._getPlayer(e); t.destroy(), this._playersById.delete(e); const r = this.players.indexOf(t); r >= 0 && this.players.splice(r, 1) } _getPlayer(e) { const t = this._playersById.get(e); if (!t) throw function Qi(n) { return new m.vHH(3301, !1) }(); return t } listen(e, t, r, a) { const d = al(t, "", "", ""); return ba(this._getPlayer(e), r, d, a), () => { } } command(e, t, r, a) { if ("register" == r) return void this.register(e, a[0]); if ("create" == r) return void this.create(e, t, a[0] || {}); const d = this._getPlayer(e); switch (r) { case "play": d.play(); break; case "pause": d.pause(); break; case "reset": d.reset(); break; case "restart": d.restart(); break; case "finish": d.finish(); break; case "init": d.init(); break; case "setPosition": d.setPosition(parseFloat(a[0])); break; case "destroy": this.destroy(e) } } } const Xl = "ng-animate-queued", pl = "ng-animate-disabled", es = [], Ja = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, ec = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, yi = "__ng_removed"; class Da { get params() { return this.options.params } constructor(e, t = "") { this.namespaceId = t; const r = e && e.hasOwnProperty("value"); if (this.value = function he(n) { return n ?? null }(r ? e.value : e), r) { const d = zo(e); delete d.value, this.options = d } else this.options = {}; this.options.params || (this.options.params = {}) } absorbOptions(e) { const t = e.params; if (t) { const r = this.options.params; Object.keys(t).forEach(a => { null == r[a] && (r[a] = t[a]) }) } } } const Nl = "void", _u = new Da(Nl); class kl { constructor(e, t, r) { this.id = e, this.hostElement = t, this._engine = r, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, Nr(t, this._hostClassName) } listen(e, t, r, a) { if (!this._triggers.has(t)) throw function Gs(n, e) { return new m.vHH(3302, !1) }(); if (null == r || 0 == r.length) throw function Ln(n) { return new m.vHH(3303, !1) }(); if (!function Ft(n) { return "start" == n || "done" == n }(r)) throw function pr(n, e) { return new m.vHH(3400, !1) }(); const d = Vi(this._elementListeners, e, []), _ = { name: t, phase: r, callback: a }; d.push(_); const E = Vi(this._engine.statesByElement, e, new Map); return E.has(t) || (Nr(e, Jr), Nr(e, Jr + "-" + t), E.set(t, _u)), () => { this._engine.afterFlush(() => { const x = d.indexOf(_); x >= 0 && d.splice(x, 1), this._triggers.has(t) || E.delete(t) }) } } register(e, t) { return !this._triggers.has(e) && (this._triggers.set(e, t), !0) } _getTrigger(e) { const t = this._triggers.get(e); if (!t) throw function ni(n) { return new m.vHH(3401, !1) }(); return t } trigger(e, t, r, a = !0) { const d = this._getTrigger(t), _ = new re(this.id, t, e); let E = this._engine.statesByElement.get(e); E || (Nr(e, Jr), Nr(e, Jr + "-" + t), this._engine.statesByElement.set(e, E = new Map)); let x = E.get(t); const B = new Da(r, this.id); if (!(r && r.hasOwnProperty("value")) && x && B.absorbOptions(x.options), E.set(t, B), x || (x = _u), B.value !== Nl && x.value === B.value) { if (!function Os(n, e) { const t = Object.keys(n), r = Object.keys(e); if (t.length != r.length) return !1; for (let a = 0; a < t.length; a++) { const d = t[a]; if (!e.hasOwnProperty(d) || n[d] !== e[d]) return !1 } return !0 }(x.params, B.params)) { const qt = [], Tn = d.matchStyles(x.value, x.params, qt), cr = d.matchStyles(B.value, B.params, qt); qt.length ? this._engine.reportError(qt) : this._engine.afterFlush(() => { Ss(e, Tn), pi(e, cr) }) } return } const Me = Vi(this._engine.playersByElement, e, []); Me.forEach(qt => { qt.namespaceId == this.id && qt.triggerName == t && qt.queued && qt.destroy() }); let ot = d.matchTransition(x.value, B.value, e, B.params), bt = !1; if (!ot) { if (!a) return; ot = d.fallbackTransition, bt = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: t, transition: ot, fromState: x, toState: B, player: _, isFallbackTransition: bt }), bt || (Nr(e, Xl), _.onStart(() => { kr(e, Xl) })), _.onDone(() => { let qt = this.players.indexOf(_); qt >= 0 && this.players.splice(qt, 1); const Tn = this._engine.playersByElement.get(e); if (Tn) { let cr = Tn.indexOf(_); cr >= 0 && Tn.splice(cr, 1) } }), this.players.push(_), Me.push(_), _ } deregister(e) { this._triggers.delete(e), this._engine.statesByElement.forEach(t => t.delete(e)), this._elementListeners.forEach((t, r) => { this._elementListeners.set(r, t.filter(a => a.name != e)) }) } clearElementCache(e) { this._engine.statesByElement.delete(e), this._elementListeners.delete(e); const t = this._engine.playersByElement.get(e); t && (t.forEach(r => r.destroy()), this._engine.playersByElement.delete(e)) } _signalRemovalForInnerTriggers(e, t) { const r = this._engine.driver.query(e, Io, !0); r.forEach(a => { if (a[yi]) return; const d = this._engine.fetchNamespacesByElement(a); d.size ? d.forEach(_ => _.triggerLeaveAnimation(a, t, !1, !0)) : this.clearElementCache(a) }), this._engine.afterFlushAnimationsDone(() => r.forEach(a => this.clearElementCache(a))) } triggerLeaveAnimation(e, t, r, a) { const d = this._engine.statesByElement.get(e), _ = new Map; if (d) { const E = []; if (d.forEach((x, B) => { if (_.set(B, x.value), this._triggers.has(B)) { const K = this.trigger(e, B, Nl, a); K && E.push(K) } }), E.length) return this._engine.markElementAsRemoved(this.id, e, !0, t, _), r && js(E).onDone(() => this._engine.processLeaveNode(e)), !0 } return !1 } prepareLeaveAnimationListeners(e) { const t = this._elementListeners.get(e), r = this._engine.statesByElement.get(e); if (t && r) { const a = new Set; t.forEach(d => { const _ = d.name; if (a.has(_)) return; a.add(_); const x = this._triggers.get(_).fallbackTransition, B = r.get(_) || _u, K = new Da(Nl), oe = new re(this.id, _, e); this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: _, transition: x, fromState: B, toState: K, player: oe, isFallbackTransition: !0 }) }) } } removeNode(e, t) { const r = this._engine; if (e.childElementCount && this._signalRemovalForInnerTriggers(e, t), this.triggerLeaveAnimation(e, t, !0)) return; let a = !1; if (r.totalAnimations) { const d = r.players.length ? r.playersByQueriedElement.get(e) : []; if (d && d.length) a = !0; else { let _ = e; for (; _ = _.parentNode;)if (r.statesByElement.get(_)) { a = !0; break } } } if (this.prepareLeaveAnimationListeners(e), a) r.markElementAsRemoved(this.id, e, !1, t); else { const d = e[yi]; (!d || d === Ja) && (r.afterFlush(() => this.clearElementCache(e)), r.destroyInnerAnimations(e), r._onRemovalComplete(e, t)) } } insertNode(e, t) { Nr(e, this._hostClassName) } drainQueuedTransitions(e) { const t = []; return this._queue.forEach(r => { const a = r.player; if (a.destroyed) return; const d = r.element, _ = this._elementListeners.get(d); _ && _.forEach(E => { if (E.name == r.triggerName) { const x = al(d, r.triggerName, r.fromState.value, r.toState.value); x._data = e, ba(r.player, E.phase, x, E.callback) } }), a.markedForDestroy ? this._engine.afterFlush(() => { a.destroy() }) : t.push(r) }), this._queue = [], t.sort((r, a) => { const d = r.transition.ast.depCount, _ = a.transition.ast.depCount; return 0 == d || 0 == _ ? d - _ : this._engine.driver.containsElement(r.element, a.element) ? 1 : -1 }) } destroy(e) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e) } elementContainsData(e) { let t = !1; return this._elementListeners.has(e) && (t = !0), t = !!this._queue.find(r => r.element === e) || t, t } } class z { _onRemovalComplete(e, t) { this.onRemovalComplete(e, t) } constructor(e, t, r) { this.bodyNode = e, this.driver = t, this._normalizer = r, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (a, d) => { } } get queuedPlayers() { const e = []; return this._namespaceList.forEach(t => { t.players.forEach(r => { r.queued && e.push(r) }) }), e } createNamespace(e, t) { const r = new kl(e, t, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, t) ? this._balanceNamespaceList(r, t) : (this.newHostElements.set(t, r), this.collectEnterElement(t)), this._namespaceLookup[e] = r } _balanceNamespaceList(e, t) { const r = this._namespaceList, a = this.namespacesByHostElement; if (r.length - 1 >= 0) { let _ = !1, E = this.driver.getParentElement(t); for (; E;) { const x = a.get(E); if (x) { const B = r.indexOf(x); r.splice(B + 1, 0, e), _ = !0; break } E = this.driver.getParentElement(E) } _ || r.unshift(e) } else r.push(e); return a.set(t, e), e } register(e, t) { let r = this._namespaceLookup[e]; return r || (r = this.createNamespace(e, t)), r } registerTrigger(e, t, r) { let a = this._namespaceLookup[e]; a && a.register(t, r) && this.totalAnimations++ } destroy(e, t) { if (!e) return; const r = this._fetchNamespace(e); this.afterFlush(() => { this.namespacesByHostElement.delete(r.hostElement), delete this._namespaceLookup[e]; const a = this._namespaceList.indexOf(r); a >= 0 && this._namespaceList.splice(a, 1) }), this.afterFlushAnimationsDone(() => r.destroy(t)) } _fetchNamespace(e) { return this._namespaceLookup[e] } fetchNamespacesByElement(e) { const t = new Set, r = this.statesByElement.get(e); if (r) for (let a of r.values()) if (a.namespaceId) { const d = this._fetchNamespace(a.namespaceId); d && t.add(d) } return t } trigger(e, t, r, a) { if ($e(t)) { const d = this._fetchNamespace(e); if (d) return d.trigger(t, r, a), !0 } return !1 } insertNode(e, t, r, a) { if (!$e(t)) return; const d = t[yi]; if (d && d.setForRemoval) { d.setForRemoval = !1, d.setForMove = !0; const _ = this.collectedLeaveElements.indexOf(t); _ >= 0 && this.collectedLeaveElements.splice(_, 1) } if (e) { const _ = this._fetchNamespace(e); _ && _.insertNode(t, r) } a && this.collectEnterElement(t) } collectEnterElement(e) { this.collectedEnterElements.push(e) } markElementAsDisabled(e, t) { t ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), Nr(e, pl)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), kr(e, pl)) } removeNode(e, t, r, a) { if ($e(t)) { const d = e ? this._fetchNamespace(e) : null; if (d ? d.removeNode(t, a) : this.markElementAsRemoved(e, t, !1, a), r) { const _ = this.namespacesByHostElement.get(t); _ && _.id !== e && _.removeNode(t, a) } } else this._onRemovalComplete(t, a) } markElementAsRemoved(e, t, r, a, d) { this.collectedLeaveElements.push(t), t[yi] = { namespaceId: e, setForRemoval: a, hasAnimation: r, removedBeforeQueried: !1, previousTriggersValues: d } } listen(e, t, r, a, d) { return $e(t) ? this._fetchNamespace(e).listen(t, r, a, d) : () => { } } _buildInstruction(e, t, r, a, d) { return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, r, a, e.fromState.options, e.toState.options, t, d) } destroyInnerAnimations(e) { let t = this.driver.query(e, Io, !0); t.forEach(r => this.destroyActiveAnimationsForElement(r)), 0 != this.playersByQueriedElement.size && (t = this.driver.query(e, uo, !0), t.forEach(r => this.finishActiveQueriedAnimationOnElement(r))) } destroyActiveAnimationsForElement(e) { const t = this.playersByElement.get(e); t && t.forEach(r => { r.queued ? r.markedForDestroy = !0 : r.destroy() }) } finishActiveQueriedAnimationOnElement(e) { const t = this.playersByQueriedElement.get(e); t && t.forEach(r => r.finish()) } whenRenderingDone() { return new Promise(e => { if (this.players.length) return js(this.players).onDone(() => e()); e() }) } processLeaveNode(e) { const t = e[yi]; if (t && t.setForRemoval) { if (e[yi] = Ja, t.namespaceId) { this.destroyInnerAnimations(e); const r = this._fetchNamespace(t.namespaceId); r && r.clearElementCache(e) } this._onRemovalComplete(e, t.setForRemoval) } e.classList?.contains(pl) && this.markElementAsDisabled(e, !1), this.driver.query(e, ".ng-animate-disabled", !0).forEach(r => { this.markElementAsDisabled(r, !1) }) } flush(e = -1) { let t = []; if (this.newHostElements.size && (this.newHostElements.forEach((r, a) => this._balanceNamespaceList(r, a)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let r = 0; r < this.collectedEnterElements.length; r++)Nr(this.collectedEnterElements[r], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const r = []; try { t = this._flushAnimations(r, e) } finally { for (let a = 0; a < r.length; a++)r[a]() } } else for (let r = 0; r < this.collectedLeaveElements.length; r++)this.processLeaveNode(this.collectedLeaveElements[r]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(r => r()), this._flushFns = [], this._whenQuietFns.length) { const r = this._whenQuietFns; this._whenQuietFns = [], t.length ? js(t).onDone(() => { r.forEach(a => a()) }) : r.forEach(a => a()) } } reportError(e) { throw function as(n) { return new m.vHH(3402, !1) }() } _flushAnimations(e, t) { const r = new Jt, a = [], d = new Map, _ = [], E = new Map, x = new Map, B = new Map, K = new Set; this.disabledNodes.forEach(Tr => { K.add(Tr); const Wr = this.driver.query(Tr, ".ng-animate-queued", !0); for (let li = 0; li < Wr.length; li++)K.add(Wr[li]) }); const oe = this.bodyNode, Me = Array.from(this.statesByElement.keys()), ot = ri(Me, this.collectedEnterElements), bt = new Map; let qt = 0; ot.forEach((Tr, Wr) => { const li = us + qt++; bt.set(Wr, li), Tr.forEach(zs => Nr(zs, li)) }); const Tn = [], cr = new Set, $r = new Set; for (let Tr = 0; Tr < this.collectedLeaveElements.length; Tr++) { const Wr = this.collectedLeaveElements[Tr], li = Wr[yi]; li && li.setForRemoval && (Tn.push(Wr), cr.add(Wr), li.hasAnimation ? this.driver.query(Wr, ".ng-star-inserted", !0).forEach(zs => cr.add(zs)) : $r.add(Wr)) } const Rr = new Map, Li = ri(Me, Array.from(cr)); Li.forEach((Tr, Wr) => { const li = bo + qt++; Rr.set(Wr, li), Tr.forEach(zs => Nr(zs, li)) }), e.push(() => { ot.forEach((Tr, Wr) => { const li = bt.get(Wr); Tr.forEach(zs => kr(zs, li)) }), Li.forEach((Tr, Wr) => { const li = Rr.get(Wr); Tr.forEach(zs => kr(zs, li)) }), Tn.forEach(Tr => { this.processLeaveNode(Tr) }) }); const Ki = [], Pi = []; for (let Tr = this._namespaceList.length - 1; Tr >= 0; Tr--)this._namespaceList[Tr].drainQueuedTransitions(t).forEach(li => { const zs = li.player, Zc = li.element; if (Ki.push(zs), this.collectedEnterElements.length) { const Fu = Zc[yi]; if (Fu && Fu.setForMove) { if (Fu.previousTriggersValues && Fu.previousTriggersValues.has(li.triggerName)) { const sy = Fu.previousTriggersValues.get(li.triggerName), Vh = this.statesByElement.get(li.element); if (Vh && Vh.has(li.triggerName)) { const VE = Vh.get(li.triggerName); VE.value = sy, Vh.set(li.triggerName, VE) } } return void zs.destroy() } } const up = !oe || !this.driver.containsElement(oe, Zc), dh = Rr.get(Zc), bm = bt.get(Zc), Wa = this._buildInstruction(li, r, bm, dh, up); if (Wa.errors && Wa.errors.length) return void Pi.push(Wa); if (up) return zs.onStart(() => Ss(Zc, Wa.fromStyles)), zs.onDestroy(() => pi(Zc, Wa.toStyles)), void a.push(zs); if (li.isFallbackTransition) return zs.onStart(() => Ss(Zc, Wa.fromStyles)), zs.onDestroy(() => pi(Zc, Wa.toStyles)), void a.push(zs); const Fx = []; Wa.timelines.forEach(Fu => { Fu.stretchStartingKeyframe = !0, this.disabledNodes.has(Fu.element) || Fx.push(Fu) }), Wa.timelines = Fx, r.append(Zc, Wa.timelines), _.push({ instruction: Wa, player: zs, element: Zc }), Wa.queriedElements.forEach(Fu => Vi(E, Fu, []).push(zs)), Wa.preStyleProps.forEach((Fu, sy) => { if (Fu.size) { let Vh = x.get(sy); Vh || x.set(sy, Vh = new Set), Fu.forEach((VE, QS) => Vh.add(QS)) } }), Wa.postStyleProps.forEach((Fu, sy) => { let Vh = B.get(sy); Vh || B.set(sy, Vh = new Set), Fu.forEach((VE, QS) => Vh.add(QS)) }) }); if (Pi.length) { const Tr = []; Pi.forEach(Wr => { Tr.push(function Ti(n, e) { return new m.vHH(3505, !1) }()) }), Ki.forEach(Wr => Wr.destroy()), this.reportError(Tr) } const Es = new Map, cd = new Map; _.forEach(Tr => { const Wr = Tr.element; r.has(Wr) && (cd.set(Wr, Wr), this._beforeAnimationBuild(Tr.player.namespaceId, Tr.instruction, Es)) }), a.forEach(Tr => { const Wr = Tr.element; this._getPreviousPlayers(Wr, !1, Tr.namespaceId, Tr.triggerName, null).forEach(zs => { Vi(Es, Wr, []).push(zs), zs.destroy() }) }); const dg = Tn.filter(Tr => mi(Tr, x, B)), hg = new Map; Nn(hg, this.driver, $r, B, fe.l3).forEach(Tr => { mi(Tr, x, B) && dg.push(Tr) }); const Vw = new Map; ot.forEach((Tr, Wr) => { Nn(Vw, this.driver, new Set(Tr), x, fe.k1) }), dg.forEach(Tr => { const Wr = hg.get(Tr), li = Vw.get(Tr); hg.set(Tr, new Map([...Array.from(Wr?.entries() ?? []), ...Array.from(li?.entries() ?? [])])) }); const iy = [], Px = [], Rx = {}; _.forEach(Tr => { const { element: Wr, player: li, instruction: zs } = Tr; if (r.has(Wr)) { if (K.has(Wr)) return li.onDestroy(() => pi(Wr, zs.toStyles)), li.disabled = !0, li.overrideTotalTime(zs.totalTime), void a.push(li); let Zc = Rx; if (cd.size > 1) { let dh = Wr; const bm = []; for (; dh = dh.parentNode;) { const Wa = cd.get(dh); if (Wa) { Zc = Wa; break } bm.push(dh) } bm.forEach(Wa => cd.set(Wa, Zc)) } const up = this._buildAnimation(li.namespaceId, zs, Es, d, Vw, hg); if (li.setRealPlayer(up), Zc === Rx) iy.push(li); else { const dh = this.playersByElement.get(Zc); dh && dh.length && (li.parentPlayer = js(dh)), a.push(li) } } else Ss(Wr, zs.fromStyles), li.onDestroy(() => pi(Wr, zs.toStyles)), Px.push(li), K.has(Wr) && a.push(li) }), Px.forEach(Tr => { const Wr = d.get(Tr.element); if (Wr && Wr.length) { const li = js(Wr); Tr.setRealPlayer(li) } }), a.forEach(Tr => { Tr.parentPlayer ? Tr.syncPlayerEvents(Tr.parentPlayer) : Tr.destroy() }); for (let Tr = 0; Tr < Tn.length; Tr++) { const Wr = Tn[Tr], li = Wr[yi]; if (kr(Wr, bo), li && li.hasAnimation) continue; let zs = []; if (E.size) { let up = E.get(Wr); up && up.length && zs.push(...up); let dh = this.driver.query(Wr, uo, !0); for (let bm = 0; bm < dh.length; bm++) { let Wa = E.get(dh[bm]); Wa && Wa.length && zs.push(...Wa) } } const Zc = zs.filter(up => !up.destroyed); Zc.length ? Or(this, Wr, Zc) : this.processLeaveNode(Wr) } return Tn.length = 0, iy.forEach(Tr => { this.players.push(Tr), Tr.onDone(() => { Tr.destroy(); const Wr = this.players.indexOf(Tr); this.players.splice(Wr, 1) }), Tr.play() }), iy } elementContainsData(e, t) { let r = !1; const a = t[yi]; return a && a.setForRemoval && (r = !0), this.playersByElement.has(t) && (r = !0), this.playersByQueriedElement.has(t) && (r = !0), this.statesByElement.has(t) && (r = !0), this._fetchNamespace(e).elementContainsData(t) || r } afterFlush(e) { this._flushFns.push(e) } afterFlushAnimationsDone(e) { this._whenQuietFns.push(e) } _getPreviousPlayers(e, t, r, a, d) { let _ = []; if (t) { const E = this.playersByQueriedElement.get(e); E && (_ = E) } else { const E = this.playersByElement.get(e); if (E) { const x = !d || d == Nl; E.forEach(B => { B.queued || !x && B.triggerName != a || _.push(B) }) } } return (r || a) && (_ = _.filter(E => !(r && r != E.namespaceId || a && a != E.triggerName))), _ } _beforeAnimationBuild(e, t, r) { const d = t.element, _ = t.isRemovalTransition ? void 0 : e, E = t.isRemovalTransition ? void 0 : t.triggerName; for (const x of t.timelines) { const B = x.element, K = B !== d, oe = Vi(r, B, []); this._getPreviousPlayers(B, K, _, E, t.toState).forEach(ot => { const bt = ot.getRealPlayer(); bt.beforeDestroy && bt.beforeDestroy(), ot.destroy(), oe.push(ot) }) } Ss(d, t.fromStyles) } _buildAnimation(e, t, r, a, d, _) { const E = t.triggerName, x = t.element, B = [], K = new Set, oe = new Set, Me = t.timelines.map(bt => { const qt = bt.element; K.add(qt); const Tn = qt[yi]; if (Tn && Tn.removedBeforeQueried) return new fe.ZN(bt.duration, bt.delay); const cr = qt !== x, $r = function fs(n) { const e = []; return xr(n, e), e }((r.get(qt) || es).map(Es => Es.getRealPlayer())).filter(Es => !!Es.element && Es.element === qt), Rr = d.get(qt), Li = _.get(qt), Ki = Mr(0, this._normalizer, 0, bt.keyframes, Rr, Li), Pi = this._buildPlayer(bt, Ki, $r); if (bt.subTimeline && a && oe.add(qt), cr) { const Es = new re(e, E, qt); Es.setRealPlayer(Pi), B.push(Es) } return Pi }); B.forEach(bt => { Vi(this.playersByQueriedElement, bt.element, []).push(bt), bt.onDone(() => function Z(n, e, t) { let r = n.get(e); if (r) { if (r.length) { const a = r.indexOf(t); r.splice(a, 1) } 0 == r.length && n.delete(e) } return r }(this.playersByQueriedElement, bt.element, bt)) }), K.forEach(bt => Nr(bt, Xn)); const ot = js(Me); return ot.onDestroy(() => { K.forEach(bt => kr(bt, Xn)), pi(x, t.toStyles) }), oe.forEach(bt => { Vi(a, bt, []).push(ot) }), ot } _buildPlayer(e, t, r) { return t.length > 0 ? this.driver.animate(e.element, t, e.duration, e.delay, e.easing, r) : new fe.ZN(e.duration, e.delay) } } class re { constructor(e, t, r) { this.namespaceId = e, this.triggerName = t, this.element = r, this._player = new fe.ZN, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(e) { this._containsRealPlayer || (this._player = e, this._queuedCallbacks.forEach((t, r) => { t.forEach(a => ba(e, r, void 0, a)) }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(e) { this.totalTime = e } syncPlayerEvents(e) { const t = this._player; t.triggerCallback && e.onStart(() => t.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy()) } _queueEvent(e, t) { Vi(this._queuedCallbacks, e, []).push(t) } onDone(e) { this.queued && this._queueEvent("done", e), this._player.onDone(e) } onStart(e) { this.queued && this._queueEvent("start", e), this._player.onStart(e) } onDestroy(e) { this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(e) { this.queued || this._player.setPosition(e) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(e) { const t = this._player; t.triggerCallback && t.triggerCallback(e) } } function $e(n) { return n && 1 === n.nodeType } function Xt(n, e) { const t = n.style.display; return n.style.display = e ?? "none", t } function Nn(n, e, t, r, a) { const d = []; t.forEach(x => d.push(Xt(x))); const _ = []; r.forEach((x, B) => { const K = new Map; x.forEach(oe => { const Me = e.computeStyle(B, oe, a); K.set(oe, Me), (!Me || 0 == Me.length) && (B[yi] = ec, _.push(B)) }), n.set(B, K) }); let E = 0; return t.forEach(x => Xt(x, d[E++])), _ } function ri(n, e) { const t = new Map; if (n.forEach(E => t.set(E, [])), 0 == e.length) return t; const a = new Set(e), d = new Map; function _(E) { if (!E) return 1; let x = d.get(E); if (x) return x; const B = E.parentNode; return x = t.has(B) ? B : a.has(B) ? 1 : _(B), d.set(E, x), x } return e.forEach(E => { const x = _(E); 1 !== x && t.get(x).push(E) }), t } function Nr(n, e) { n.classList?.add(e) } function kr(n, e) { n.classList?.remove(e) } function Or(n, e, t) { js(t).onDone(() => n.processLeaveNode(e)) } function xr(n, e) { for (let t = 0; t < n.length; t++) { const r = n[t]; r instanceof fe.ZE ? xr(r.players, e) : e.push(r) } } function mi(n, e, t) { const r = t.get(n); if (!r) return !1; let a = e.get(n); return a ? r.forEach(d => a.add(d)) : e.set(n, r), t.delete(n), !0 } class bs { constructor(e, t, r) { this.bodyNode = e, this._driver = t, this._normalizer = r, this._triggerCache = {}, this.onRemovalComplete = (a, d) => { }, this._transitionEngine = new z(e, t, r), this._timelineEngine = new Tc(e, t, r), this._transitionEngine.onRemovalComplete = (a, d) => this.onRemovalComplete(a, d) } registerTrigger(e, t, r, a, d) { const _ = e + "-" + a; let E = this._triggerCache[_]; if (!E) { const x = [], K = qa(this._driver, d, x, []); if (x.length) throw function va(n, e) { return new m.vHH(3404, !1) }(); E = function mu(n, e, t) { return new Ta(n, e, t) }(a, K, this._normalizer), this._triggerCache[_] = E } this._transitionEngine.registerTrigger(t, a, E) } register(e, t) { this._transitionEngine.register(e, t) } destroy(e, t) { this._transitionEngine.destroy(e, t) } onInsert(e, t, r, a) { this._transitionEngine.insertNode(e, t, r, a) } onRemove(e, t, r, a) { this._transitionEngine.removeNode(e, t, a || !1, r) } disableAnimations(e, t) { this._transitionEngine.markElementAsDisabled(e, t) } process(e, t, r, a) { if ("@" == r.charAt(0)) { const [d, _] = ls(r); this._timelineEngine.command(d, t, _, a) } else this._transitionEngine.trigger(e, t, r, a) } listen(e, t, r, a, d) { if ("@" == r.charAt(0)) { const [_, E] = ls(r); return this._timelineEngine.listen(_, t, E, d) } return this._transitionEngine.listen(e, t, r, a, d) } flush(e = -1) { this._transitionEngine.flush(e) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } let go = (() => { class n { constructor(t, r, a) { this._element = t, this._startStyles = r, this._endStyles = a, this._state = 0; let d = n.initialStylesByElement.get(t); d || n.initialStylesByElement.set(t, d = new Map), this._initialStyles = d } start() { this._state < 1 && (this._startStyles && pi(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (pi(this._element, this._initialStyles), this._endStyles && (pi(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (n.initialStylesByElement.delete(this._element), this._startStyles && (Ss(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Ss(this._element, this._endStyles), this._endStyles = null), pi(this._element, this._initialStyles), this._state = 3) } } return n.initialStylesByElement = new WeakMap, n })(); function Ba(n) { let e = null; return n.forEach((t, r) => { (function Va(n) { return "display" === n || "position" === n })(r) && (e = e || new Map, e.set(r, t)) }), e } class xi { constructor(e, t, r, a) { this.element = e, this.keyframes = t, this.options = r, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = r.duration, this._delay = r.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const e = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : new Map, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _convertKeyframesToObject(e) { const t = []; return e.forEach(r => { t.push(Object.fromEntries(r)) }), t } _triggerWebAnimation(e, t, r) { return e.animate(this._convertKeyframesToObject(t), r) } onStart(e) { this._originalOnStartFns.push(e), this._onStartFns.push(e) } onDone(e) { this._originalOnDoneFns.push(e), this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } setPosition(e) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = e * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const e = new Map; this.hasStarted() && this._finalKeyframe.forEach((r, a) => { "offset" !== a && e.set(a, this._finished ? r : Ls(this.element, a)) }), this.currentSnapshot = e } triggerCallback(e) { const t = "start" === e ? this._onStartFns : this._onDoneFns; t.forEach(r => r()), t.length = 0 } } class Dc { validateStyleProperty(e) { return !0 } validateAnimatableStyleProperty(e) { return !0 } matchesElement(e, t) { return !1 } containsElement(e, t) { return lr(e, t) } getParentElement(e) { return cs(e) } query(e, t, r) { return wr(e, t, r) } computeStyle(e, t, r) { return window.getComputedStyle(e)[t] } animate(e, t, r, a, d, _ = []) { const x = { duration: r, delay: a, fill: 0 == a ? "both" : "forwards" }; d && (x.easing = d); const B = new Map, K = _.filter(ot => ot instanceof xi); (function As(n, e) { return 0 === n || 0 === e })(r, a) && K.forEach(ot => { ot.currentSnapshot.forEach((bt, qt) => B.set(qt, bt)) }); let oe = function Go(n) { return n.length ? n[0] instanceof Map ? n : n.map(e => Ys(e)) : [] }(t).map(ot => jo(ot)); oe = function Pa(n, e, t) { if (t.size && e.length) { let r = e[0], a = []; if (t.forEach((d, _) => { r.has(_) || a.push(_), r.set(_, d) }), a.length) for (let d = 1; d < e.length; d++) { let _ = e[d]; a.forEach(E => _.set(E, Ls(n, E))) } } return e }(e, oe, B); const Me = function To(n, e) { let t = null, r = null; return Array.isArray(e) && e.length ? (t = Ba(e[0]), e.length > 1 && (r = Ba(e[e.length - 1]))) : e instanceof Map && (t = Ba(e)), t || r ? new go(n, t, r) : null }(e, oe); return new xi(e, oe, x, Me) } } let Yc = (() => { class n extends fe._j { constructor(t, r) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(r.body, { id: "0", encapsulation: m.ifc.None, styles: [], data: { animation: [] } }) } build(t) { const r = this._nextAnimationId.toString(); this._nextAnimationId++; const a = Array.isArray(t) ? (0, fe.vP)(t) : t; return gl(this._renderer, null, r, "register", [a]), new Zo(r, this._renderer) } } return n.\u0275fac = function (t) { return new (t || n)(m.LFG(m.FYo), m.LFG(rt.K0)) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac }), n })(); class Zo extends fe.LC { constructor(e, t) { super(), this._id = e, this._renderer = t } create(e, t) { return new qo(this._id, e, t || {}, this._renderer) } } class qo { constructor(e, t, r, a) { this.id = e, this.element = t, this._renderer = a, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", r) } _listen(e, t) { return this._renderer.listen(this.element, `@@${this.id}:${e}`, t) } _command(e, ...t) { return gl(this._renderer, this.element, this.id, e, t) } onDone(e) { this._listen("done", e) } onStart(e) { this._listen("start", e) } onDestroy(e) { this._listen("destroy", e) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(e) { this._command("setPosition", e) } getPosition() { return this._renderer.engine.players[+this.id]?.getPosition() ?? 0 } } function gl(n, e, t, r, a) { return n.setProperty(e, `@@${t}:${r}`, a) } const Pl = "@.disabled"; let Rl = (() => { class n { constructor(t, r, a) { this.delegate = t, this.engine = r, this._zone = a, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), r.onRemovalComplete = (d, _) => { const E = _?.parentNode(d); E && _.removeChild(E, d) } } createRenderer(t, r) { const d = this.delegate.createRenderer(t, r); if (!(t && r && r.data && r.data.animation)) { let K = this._rendererCache.get(d); return K || (K = new $s("", d, this.engine, () => this._rendererCache.delete(d)), this._rendererCache.set(d, K)), K } const _ = r.id, E = r.id + "-" + this._currentId; this._currentId++, this.engine.register(E, t); const x = K => { Array.isArray(K) ? K.forEach(x) : this.engine.registerTrigger(_, E, t, K.name, K) }; return r.data.animation.forEach(x), new Fl(this, E, d, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, r, a) { t >= 0 && t < this._microtaskId ? this._zone.run(() => r(a)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(d => { const [_, E] = d; _(E) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([r, a])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return n.\u0275fac = function (t) { return new (t || n)(m.LFG(m.FYo), m.LFG(bs), m.LFG(m.R0b)) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac }), n })(); class $s { constructor(e, t, r, a) { this.namespaceId = e, this.delegate = t, this.engine = r, this._onDestroy = a, this.destroyNode = this.delegate.destroyNode ? d => t.destroyNode(d) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy(), this._onDestroy?.() } createElement(e, t) { return this.delegate.createElement(e, t) } createComment(e) { return this.delegate.createComment(e) } createText(e) { return this.delegate.createText(e) } appendChild(e, t) { this.delegate.appendChild(e, t), this.engine.onInsert(this.namespaceId, t, e, !1) } insertBefore(e, t, r, a = !0) { this.delegate.insertBefore(e, t, r), this.engine.onInsert(this.namespaceId, t, e, a) } removeChild(e, t, r) { this.engine.onRemove(this.namespaceId, t, this.delegate, r) } selectRootElement(e, t) { return this.delegate.selectRootElement(e, t) } parentNode(e) { return this.delegate.parentNode(e) } nextSibling(e) { return this.delegate.nextSibling(e) } setAttribute(e, t, r, a) { this.delegate.setAttribute(e, t, r, a) } removeAttribute(e, t, r) { this.delegate.removeAttribute(e, t, r) } addClass(e, t) { this.delegate.addClass(e, t) } removeClass(e, t) { this.delegate.removeClass(e, t) } setStyle(e, t, r, a) { this.delegate.setStyle(e, t, r, a) } removeStyle(e, t, r) { this.delegate.removeStyle(e, t, r) } setProperty(e, t, r) { "@" == t.charAt(0) && t == Pl ? this.disableAnimations(e, !!r) : this.delegate.setProperty(e, t, r) } setValue(e, t) { this.delegate.setValue(e, t) } listen(e, t, r) { return this.delegate.listen(e, t, r) } disableAnimations(e, t) { this.engine.disableAnimations(e, t) } } class Fl extends $s { constructor(e, t, r, a, d) { super(t, r, a, d), this.factory = e, this.namespaceId = t } setProperty(e, t, r) { "@" == t.charAt(0) ? "." == t.charAt(1) && t == Pl ? this.disableAnimations(e, r = void 0 === r || !!r) : this.engine.process(this.namespaceId, e, t.slice(1), r) : this.delegate.setProperty(e, t, r) } listen(e, t, r) { if ("@" == t.charAt(0)) { const a = function Bs(n) { switch (n) { case "body": return document.body; case "document": return document; case "window": return window; default: return n } }(e); let d = t.slice(1), _ = ""; return "@" != d.charAt(0) && ([d, _] = function Qa(n) { const e = n.indexOf("."); return [n.substring(0, e), n.slice(e + 1)] }(d)), this.engine.listen(this.namespaceId, a, d, _, E => { this.factory.scheduleListenerCallback(E._data || -1, r, E) }) } return this.delegate.listen(e, t, r) } } let Xa = (() => { class n extends bs { constructor(t, r, a, d) { super(t.body, r, a) } ngOnDestroy() { this.flush() } } return n.\u0275fac = function (t) { return new (t || n)(m.LFG(rt.K0), m.LFG(Ts), m.LFG(Ca), m.LFG(m.z2F)) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac }), n })(); const Jc = [{ provide: fe._j, useClass: Yc }, { provide: Ca, useFactory: function Kc() { return new bc } }, { provide: bs, useClass: Xa }, { provide: m.FYo, useFactory: function Sc(n, e, t) { return new Rl(n, e, t) }, deps: [i.se, bs, m.R0b] }], Ll = [{ provide: Ts, useFactory: () => new Dc }, { provide: m.QbO, useValue: "BrowserAnimations" }, ...Jc], yu = [{ provide: Ts, useClass: Ai }, { provide: m.QbO, useValue: "NoopAnimations" }, ...Jc]; let Lu = (() => { class n { static withConfig(t) { return { ngModule: n, providers: t.disableAnimations ? yu : Ll } } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275mod = m.oAB({ type: n }), n.\u0275inj = m.cJS({ providers: Ll, imports: [i.b2] }), n })(); var ia = L(529), Ac = L(7185), el = L(2851), Yo = L(5869), Ko = L(4986), Bu = L(9751), Qc = L(9646), Sa = L(6451), ao = L(4004), xc = L(3099), Vu = L(3900), Ia = L(2940), Vs = L(1884), ii = L(1365), tc = L(4482), ud = L(5403), ci = L(2122), Aa = L(2011), Mc = (L(9169), L(3942)), Oc = L(4859), cn = L(5861), tl = L(9681), Pe = L(2090), Jo = L(1877); const ml = "@firebase/database"; let Bl = ""; function Xc(n) { Bl = n } class ji { constructor(e) { this.domStorage_ = e, this.prefix_ = "firebase:" } set(e, t) { null == t ? this.domStorage_.removeItem(this.prefixedName_(e)) : this.domStorage_.setItem(this.prefixedName_(e), (0, Pe.Wl)(t)) } get(e) { const t = this.domStorage_.getItem(this.prefixedName_(e)); return null == t ? null : (0, Pe.cI)(t) } remove(e) { this.domStorage_.removeItem(this.prefixedName_(e)) } prefixedName_(e) { return this.prefix_ + e } toString() { return this.domStorage_.toString() } } class R { constructor() { this.cache_ = {}, this.isInMemoryStorage = !0 } set(e, t) { null == t ? delete this.cache_[e] : this.cache_[e] = t } get(e) { return (0, Pe.r3)(this.cache_, e) ? this.cache_[e] : null } remove(e) { delete this.cache_[e] } } const V = function (n) { try { if (typeof window < "u" && typeof window[n] < "u") { const e = window[n]; return e.setItem("firebase:sentinel", "cache"), e.removeItem("firebase:sentinel"), new ji(e) } } catch { } return new R }, M = V("localStorage"), G = V("localStorage"), X = new Jo.Yd("@firebase/database"), ce = function () { let n = 1; return function () { return n++ } }(), be = function (n) { const e = (0, Pe.dS)(n), t = new Pe.gQ; t.update(e); const r = t.digest(); return Pe.US.encodeByteArray(r) }, St = function (...n) { let e = ""; for (let t = 0; t < n.length; t++) { const r = n[t]; Array.isArray(r) || r && "object" == typeof r && "number" == typeof r.length ? e += St.apply(null, r) : e += "object" == typeof r ? (0, Pe.Wl)(r) : r, e += " " } return e }; let on = null, Kn = !0; const Vn = function (n, e) { (0, Pe.hu)(!e || !0 === n || !1 === n, "Can't turn on custom loggers persistently."), !0 === n ? (X.logLevel = Jo.in.VERBOSE, on = X.log.bind(X), e && G.set("logging_enabled", !0)) : "function" == typeof n ? on = n : (on = null, G.remove("logging_enabled")) }, Lr = function (...n) { if (!0 === Kn && (Kn = !1, null === on && !0 === G.get("logging_enabled") && Vn(!0)), on) { const e = St.apply(null, n); on(e) } }, Gr = function (n) { return function (...e) { Lr(n, ...e) } }, Sr = function (...n) { const e = "MasterINTERNAL ERROR: " + St(...n); X.error(e) }, $i = function (...n) { const e = `MasterFATAL ERROR: ${St(...n)}`; throw X.error(e), new Error(e) }, Wi = function (...n) { const e = "MasterWARNING: " + St(...n); X.warn(e) }, bu = function (n) { return "number" == typeof n && (n != n || n === Number.POSITIVE_INFINITY || n === Number.NEGATIVE_INFINITY) }, oa = "[MIN_NAME]", Ns = "[MAX_NAME]", kc = function (n, e) { if (n === e) return 0; if (n === oa || e === Ns) return -1; if (e === oa || n === Ns) return 1; { const t = jn(n), r = jn(e); return null !== t ? null !== r ? t - r == 0 ? n.length - e.length : t - r : -1 : null !== r ? 1 : n < e ? -1 : 1 } }, Qo = function (n, e) { return n === e ? 0 : n < e ? -1 : 1 }, aa = function (n, e) { if (e && n in e) return e[n]; throw new Error("Missing required key (" + n + ") in object: " + (0, Pe.Wl)(e)) }, la = function (n) { if ("object" != typeof n || null === n) return (0, Pe.Wl)(n); const e = []; for (const r in n) e.push(r); e.sort(); let t = "{"; for (let r = 0; r < e.length; r++)0 !== r && (t += ","), t += (0, Pe.Wl)(e[r]), t += ":", t += la(n[e[r]]); return t += "}", t }, ps = function (n, e) { const t = n.length; if (t <= e) return [n]; const r = []; for (let a = 0; a < t; a += e)r.push(n.substring(a, a + e > t ? t : a + e)); return r }; function vi(n, e) { for (const t in n) n.hasOwnProperty(t) && e(t, n[t]) } const W = function (n) { (0, Pe.hu)(!bu(n), "Invalid JSON number"); const r = 1023; let a, d, _, E, x; 0 === n ? (d = 0, _ = 0, a = 1 / n == -1 / 0 ? 1 : 0) : (a = n < 0, (n = Math.abs(n)) >= Math.pow(2, 1 - r) ? (E = Math.min(Math.floor(Math.log(n) / Math.LN2), r), d = E + r, _ = Math.round(n * Math.pow(2, 52 - E) - Math.pow(2, 52))) : (d = 0, _ = Math.round(n / Math.pow(2, -1074)))); const B = []; for (x = 52; x; x -= 1)B.push(_ % 2 ? 1 : 0), _ = Math.floor(_ / 2); for (x = 11; x; x -= 1)B.push(d % 2 ? 1 : 0), d = Math.floor(d / 2); B.push(a ? 1 : 0), B.reverse(); const K = B.join(""); let oe = ""; for (x = 0; x < 64; x += 8) { let Me = parseInt(K.substr(x, 8), 2).toString(16); 1 === Me.length && (Me = "0" + Me), oe += Me } return oe.toLowerCase() }, xt = new RegExp("^-?(0*)\\d{1,10}$"), jn = function (n) { if (xt.test(n)) { const e = Number(n); if (e >= -2147483648 && e <= 2147483647) return e } return null }, er = function (n) { try { n() } catch (e) { setTimeout(() => { throw Wi("Exception was thrown by user callback.", e.stack || ""), e }, Math.floor(0)) } }, Ir = function (n, e) { const t = setTimeout(n, e); return "number" == typeof t && typeof Deno < "u" && Deno.unrefTimer ? Deno.unrefTimer(t) : "object" == typeof t && t.unref && t.unref(), t }; class Pr { constructor(e, t) { this.appName_ = e, this.appCheckProvider = t, this.appCheck = t?.getImmediate({ optional: !0 }), this.appCheck || t?.get().then(r => this.appCheck = r) } getToken(e) { return this.appCheck ? this.appCheck.getToken(e) : new Promise((t, r) => { setTimeout(() => { this.appCheck ? this.getToken(e).then(t, r) : t(null) }, 0) }) } addTokenChangeListener(e) { var t; null === (t = this.appCheckProvider) || void 0 === t || t.get().then(r => r.addTokenListener(e)) } notifyForInvalidToken() { Wi(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`) } } class ca { constructor(e, t, r) { this.appName_ = e, this.firebaseOptions_ = t, this.authProvider_ = r, this.auth_ = null, this.auth_ = r.getImmediate({ optional: !0 }), this.auth_ || r.onInit(a => this.auth_ = a) } getToken(e) { return this.auth_ ? this.auth_.getToken(e).catch(t => t && "auth/token-not-initialized" === t.code ? (Lr("Got auth/token-not-initialized error.  Treating as null token."), null) : Promise.reject(t)) : new Promise((t, r) => { setTimeout(() => { this.auth_ ? this.getToken(e).then(t, r) : t(null) }, 0) }) } addTokenChangeListener(e) { this.auth_ ? this.auth_.addAuthTokenListener(e) : this.authProvider_.get().then(t => t.addAuthTokenListener(e)) } removeTokenChangeListener(e) { this.authProvider_.get().then(t => t.removeAuthTokenListener(e)) } notifyForInvalidToken() { let e = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. '; e += "credential" in this.firebaseOptions_ ? 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.firebaseOptions_ ? 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.', Wi(e) } } let Ws = (() => { class n { constructor(t) { this.accessToken = t } getToken(t) { return Promise.resolve({ accessToken: this.accessToken }) } addTokenChangeListener(t) { t(this.accessToken) } removeTokenChangeListener(t) { } notifyForInvalidToken() { } } return n.OWNER = "owner", n })(); const eu = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/, Af = "websocket", xf = "long_polling"; class Uh { constructor(e, t, r, a, d = !1, _ = "", E = !1) { this.secure = t, this.namespace = r, this.webSocketOnly = a, this.nodeAdmin = d, this.persistenceKey = _, this.includeNamespaceInQueryParams = E, this._host = e.toLowerCase(), this._domain = this._host.substr(this._host.indexOf(".") + 1), this.internalHost = M.get("host:" + e) || this._host } isCacheableHost() { return "s-" === this.internalHost.substr(0, 2) } isCustomHost() { return "firebaseio.com" !== this._domain && "firebaseio-demo.com" !== this._domain } get host() { return this._host } set host(e) { e !== this.internalHost && (this.internalHost = e, this.isCacheableHost() && M.set("host:" + this._host, this.internalHost)) } toString() { let e = this.toURLString(); return this.persistenceKey && (e += "<" + this.persistenceKey + ">"), e } toURLString() { return `${this.secure ? "https://" : "http://"}${this.host}/${this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : ""}` } } function fg(n, e, t) { let r; if ((0, Pe.hu)("string" == typeof e, "typeof type must == string"), (0, Pe.hu)("object" == typeof t, "typeof params must == object"), e === Af) r = (n.secure ? "wss://" : "ws://") + n.internalHost + "/.ws?"; else { if (e !== xf) throw new Error("Unknown connection type: " + e); r = (n.secure ? "https://" : "http://") + n.internalHost + "/.lp?" } (function hp(n) { return n.host !== n.internalHost || n.isCustomHost() || n.includeNamespaceInQueryParams })(n) && (t.ns = n.namespace); const a = []; return vi(t, (d, _) => { a.push(d + "=" + _) }), r + a.join("&") } class fh { constructor() { this.counters_ = {} } incrementCounter(e, t = 1) { (0, Pe.r3)(this.counters_, e) || (this.counters_[e] = 0), this.counters_[e] += t } get() { return (0, Pe.p$)(this.counters_) } } const pg = {}, fp = {}; function dd(n) { const e = n.toString(); return pg[e] || (pg[e] = new fh), pg[e] } class mg { constructor(e) { this.onMessage_ = e, this.pendingResponses = [], this.currentResponseNum = 0, this.closeAfterResponse = -1, this.onClose = null } closeAfter(e, t) { this.closeAfterResponse = e, this.onClose = t, this.closeAfterResponse < this.currentResponseNum && (this.onClose(), this.onClose = null) } handleResponse(e, t) { for (this.pendingResponses[e] = t; this.pendingResponses[this.currentResponseNum];) { const r = this.pendingResponses[this.currentResponseNum]; delete this.pendingResponses[this.currentResponseNum]; for (let a = 0; a < r.length; ++a)r[a] && er(() => { this.onMessage_(r[a]) }); if (this.currentResponseNum === this.closeAfterResponse) { this.onClose && (this.onClose(), this.onClose = null); break } this.currentResponseNum++ } } } class tu { constructor(e, t, r, a, d, _, E) { this.connId = e, this.repoInfo = t, this.applicationId = r, this.appCheckToken = a, this.authToken = d, this.transportSessionId = _, this.lastSessionId = E, this.bytesSent = 0, this.bytesReceived = 0, this.everConnected_ = !1, this.log_ = Gr(e), this.stats_ = dd(t), this.urlFn = x => (this.appCheckToken && (x.ac = this.appCheckToken), fg(t, xf, x)) } open(e, t) { this.curSegmentNum = 0, this.onDisconnect_ = t, this.myPacketOrderer = new mg(e), this.isClosed_ = !1, this.connectTimeoutTimer_ = setTimeout(() => { this.log_("Timed out trying to connect."), this.onClosed_(), this.connectTimeoutTimer_ = null }, Math.floor(3e4)), function (n) { if ((0, Pe.Yr)() || "complete" === document.readyState) n(); else { let e = !1; const t = function () { document.body ? e || (e = !0, n()) : setTimeout(t, Math.floor(10)) }; document.addEventListener ? (document.addEventListener("DOMContentLoaded", t, !1), window.addEventListener("load", t, !1)) : document.attachEvent && (document.attachEvent("onreadystatechange", () => { "complete" === document.readyState && t() }), window.attachEvent("onload", t)) } }(() => { if (this.isClosed_) return; this.scriptTagHolder = new zd((...d) => { const [_, E, x, B, K] = d; if (this.incrementIncomingBytes_(d), this.scriptTagHolder) if (this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null), this.everConnected_ = !0, "start" === _) this.id = E, this.password = x; else { if ("close" !== _) throw new Error("Unrecognized command received: " + _); E ? (this.scriptTagHolder.sendNewPolls = !1, this.myPacketOrderer.closeAfter(E, () => { this.onClosed_() })) : this.onClosed_() } }, (...d) => { const [_, E] = d; this.incrementIncomingBytes_(d), this.myPacketOrderer.handleResponse(_, E) }, () => { this.onClosed_() }, this.urlFn); const r = { start: "t" }; r.ser = Math.floor(1e8 * Math.random()), this.scriptTagHolder.uniqueCallbackIdentifier && (r.cb = this.scriptTagHolder.uniqueCallbackIdentifier), r.v = "5", this.transportSessionId && (r.s = this.transportSessionId), this.lastSessionId && (r.ls = this.lastSessionId), this.applicationId && (r.p = this.applicationId), this.appCheckToken && (r.ac = this.appCheckToken), typeof location < "u" && location.hostname && eu.test(location.hostname) && (r.r = "f"); const a = this.urlFn(r); this.log_("Connecting via long-poll to " + a), this.scriptTagHolder.addTag(a, () => { }) }) } start() { this.scriptTagHolder.startLongPoll(this.id, this.password), this.addDisconnectPingFrame(this.id, this.password) } static forceAllow() { tu.forceAllow_ = !0 } static forceDisallow() { tu.forceDisallow_ = !0 } static isAvailable() { return !((0, Pe.Yr)() || !tu.forceAllow_ && (tu.forceDisallow_ || !(typeof document < "u") || null == document.createElement || "object" == typeof window && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href) || "object" == typeof Windows && "object" == typeof Windows.UI)) } markConnectionHealthy() { } shutdown_() { this.isClosed_ = !0, this.scriptTagHolder && (this.scriptTagHolder.close(), this.scriptTagHolder = null), this.myDisconnFrame && (document.body.removeChild(this.myDisconnFrame), this.myDisconnFrame = null), this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null) } onClosed_() { this.isClosed_ || (this.log_("Longpoll is closing itself"), this.shutdown_(), this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), this.onDisconnect_ = null)) } close() { this.isClosed_ || (this.log_("Longpoll is being closed."), this.shutdown_()) } send(e) { const t = (0, Pe.Wl)(e); this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length); const r = (0, Pe.h$)(t), a = ps(r, 1840); for (let d = 0; d < a.length; d++)this.scriptTagHolder.enqueueSegment(this.curSegmentNum, a.length, a[d]), this.curSegmentNum++ } addDisconnectPingFrame(e, t) { if ((0, Pe.Yr)()) return; this.myDisconnFrame = document.createElement("iframe"); const r = { dframe: "t" }; r.id = e, r.pw = t, this.myDisconnFrame.src = this.urlFn(r), this.myDisconnFrame.style.display = "none", document.body.appendChild(this.myDisconnFrame) } incrementIncomingBytes_(e) { const t = (0, Pe.Wl)(e).length; this.bytesReceived += t, this.stats_.incrementCounter("bytes_received", t) } } class zd { constructor(e, t, r, a) { if (this.onDisconnect = r, this.urlFn = a, this.outstandingRequests = new Set, this.pendingSegs = [], this.currentSerial = Math.floor(1e8 * Math.random()), this.sendNewPolls = !0, (0, Pe.Yr)()) this.commandCB = e, this.onMessageCB = t; else { this.uniqueCallbackIdentifier = ce(), window["pLPCommand" + this.uniqueCallbackIdentifier] = e, window["pRTLPCB" + this.uniqueCallbackIdentifier] = t, this.myIFrame = zd.createIFrame_(); let d = ""; this.myIFrame.src && "javascript:" === this.myIFrame.src.substr(0, 11) && (d = '<script>document.domain="' + document.domain + '";<\/script>'); const _ = "<html><body>" + d + "</body></html>"; try { this.myIFrame.doc.open(), this.myIFrame.doc.write(_), this.myIFrame.doc.close() } catch (E) { Lr("frame writing exception"), E.stack && Lr(E.stack), Lr(E) } } } static createIFrame_() { const e = document.createElement("iframe"); if (e.style.display = "none", !document.body) throw "Document body has not initialized. Wait to initialize Masteruntil after the document is ready."; document.body.appendChild(e); try { e.contentWindow.document || Lr("No IE domain setting required") } catch { const r = document.domain; e.src = "javascript:void((function(){document.open();document.domain='" + r + "';document.close();})())" } return e.contentDocument ? e.doc = e.contentDocument : e.contentWindow ? e.doc = e.contentWindow.document : e.document && (e.doc = e.document), e } close() { this.alive = !1, this.myIFrame && (this.myIFrame.doc.body.innerHTML = "", setTimeout(() => { null !== this.myIFrame && (document.body.removeChild(this.myIFrame), this.myIFrame = null) }, Math.floor(0))); const e = this.onDisconnect; e && (this.onDisconnect = null, e()) } startLongPoll(e, t) { for (this.myID = e, this.myPW = t, this.alive = !0; this.newRequest_();); } newRequest_() { if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) { this.currentSerial++; const e = {}; e.id = this.myID, e.pw = this.myPW, e.ser = this.currentSerial; let t = this.urlFn(e), r = "", a = 0; for (; this.pendingSegs.length > 0 && this.pendingSegs[0].d.length + 30 + r.length <= 1870;) { const _ = this.pendingSegs.shift(); r = r + "&seg" + a + "=" + _.seg + "&ts" + a + "=" + _.ts + "&d" + a + "=" + _.d, a++ } return t += r, this.addLongPollTag_(t, this.currentSerial), !0 } return !1 } enqueueSegment(e, t, r) { this.pendingSegs.push({ seg: e, ts: t, d: r }), this.alive && this.newRequest_() } addLongPollTag_(e, t) { this.outstandingRequests.add(t); const r = () => { this.outstandingRequests.delete(t), this.newRequest_() }, a = setTimeout(r, Math.floor(25e3)); this.addTag(e, () => { clearTimeout(a), r() }) } addTag(e, t) { (0, Pe.Yr)() ? this.doNodeLongPoll(e, t) : setTimeout(() => { try { if (!this.sendNewPolls) return; const r = this.myIFrame.doc.createElement("script"); r.type = "text/javascript", r.async = !0, r.src = e, r.onload = r.onreadystatechange = function () { const a = r.readyState; (!a || "loaded" === a || "complete" === a) && (r.onload = r.onreadystatechange = null, r.parentNode && r.parentNode.removeChild(r), t()) }, r.onerror = () => { Lr("Long-poll script failed to load: " + e), this.sendNewPolls = !1, this.close() }, this.myIFrame.doc.body.appendChild(r) } catch { } }, Math.floor(1)) } } let xa = null; typeof MozWebSocket < "u" ? xa = MozWebSocket : typeof WebSocket < "u" && (xa = WebSocket); let bl = (() => { class n { constructor(t, r, a, d, _, E, x) { this.connId = t, this.applicationId = a, this.appCheckToken = d, this.authToken = _, this.keepaliveTimer = null, this.frames = null, this.totalFrames = 0, this.bytesSent = 0, this.bytesReceived = 0, this.log_ = Gr(this.connId), this.stats_ = dd(r), this.connURL = n.connectionURL_(r, E, x, d, a), this.nodeAdmin = r.nodeAdmin } static connectionURL_(t, r, a, d, _) { const E = { v: "5" }; return !(0, Pe.Yr)() && typeof location < "u" && location.hostname && eu.test(location.hostname) && (E.r = "f"), r && (E.s = r), a && (E.ls = a), d && (E.ac = d), _ && (E.p = _), fg(t, Af, E) } open(t, r) { this.onDisconnect = r, this.onMessage = t, this.log_("Websocket connecting to " + this.connURL), this.everConnected_ = !1, M.set("previous_websocket_failure", !0); try { let a; if ((0, Pe.Yr)()) { a = { headers: { "User-Agent": `Firebase/5/${Bl}/${process.platform}/${this.nodeAdmin ? "AdminNode" : "Node"}`, "X-Firebase-GMPID": this.applicationId || "" } }, this.authToken && (a.headers.Authorization = `Bearer ${this.authToken}`), this.appCheckToken && (a.headers["X-Firebase-AppCheck"] = this.appCheckToken); const _ = process.env, E = 0 === this.connURL.indexOf("wss://") ? _.HTTPS_PROXY || _.https_proxy : _.HTTP_PROXY || _.http_proxy; E && (a.proxy = { origin: E }) } this.mySock = new xa(this.connURL, [], a) } catch (a) { this.log_("Error instantiating WebSocket."); const d = a.message || a.data; return d && this.log_(d), void this.onClosed_() } this.mySock.onopen = () => { this.log_("Websocket connected."), this.everConnected_ = !0 }, this.mySock.onclose = () => { this.log_("Websocket connection was disconnected."), this.mySock = null, this.onClosed_() }, this.mySock.onmessage = a => { this.handleIncomingFrame(a) }, this.mySock.onerror = a => { this.log_("WebSocket error.  Closing connection."); const d = a.message || a.data; d && this.log_(d), this.onClosed_() } } start() { } static forceDisallow() { n.forceDisallow_ = !0 } static isAvailable() { let t = !1; if (typeof navigator < "u" && navigator.userAgent) { const a = navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/); a && a.length > 1 && parseFloat(a[1]) < 4.4 && (t = !0) } return !t && null !== xa && !n.forceDisallow_ } static previouslyFailed() { return M.isInMemoryStorage || !0 === M.get("previous_websocket_failure") } markConnectionHealthy() { M.remove("previous_websocket_failure") } appendFrame_(t) { if (this.frames.push(t), this.frames.length === this.totalFrames) { const r = this.frames.join(""); this.frames = null; const a = (0, Pe.cI)(r); this.onMessage(a) } } handleNewFrameCount_(t) { this.totalFrames = t, this.frames = [] } extractFrameCount_(t) { if ((0, Pe.hu)(null === this.frames, "We already have a frame buffer"), t.length <= 6) { const r = Number(t); if (!isNaN(r)) return this.handleNewFrameCount_(r), null } return this.handleNewFrameCount_(1), t } handleIncomingFrame(t) { if (null === this.mySock) return; const r = t.data; if (this.bytesReceived += r.length, this.stats_.incrementCounter("bytes_received", r.length), this.resetKeepAlive(), null !== this.frames) this.appendFrame_(r); else { const a = this.extractFrameCount_(r); null !== a && this.appendFrame_(a) } } send(t) { this.resetKeepAlive(); const r = (0, Pe.Wl)(t); this.bytesSent += r.length, this.stats_.incrementCounter("bytes_sent", r.length); const a = ps(r, 16384); a.length > 1 && this.sendString_(String(a.length)); for (let d = 0; d < a.length; d++)this.sendString_(a[d]) } shutdown_() { this.isClosed_ = !0, this.keepaliveTimer && (clearInterval(this.keepaliveTimer), this.keepaliveTimer = null), this.mySock && (this.mySock.close(), this.mySock = null) } onClosed_() { this.isClosed_ || (this.log_("WebSocket is closing itself"), this.shutdown_(), this.onDisconnect && (this.onDisconnect(this.everConnected_), this.onDisconnect = null)) } close() { this.isClosed_ || (this.log_("WebSocket is being closed"), this.shutdown_()) } resetKeepAlive() { clearInterval(this.keepaliveTimer), this.keepaliveTimer = setInterval(() => { this.mySock && this.sendString_("0"), this.resetKeepAlive() }, Math.floor(45e3)) } sendString_(t) { try { this.mySock.send(t) } catch (r) { this.log_("Exception thrown from WebSocket.send():", r.message || r.data, "Closing connection."), setTimeout(this.onClosed_.bind(this), 0) } } } return n.responsesRequiredToBeHealthy = 2, n.healthyTimeout = 3e4, n })(), nu = (() => { class n { constructor(t) { this.initTransports_(t) } static get ALL_TRANSPORTS() { return [tu, bl] } static get IS_TRANSPORT_INITIALIZED() { return this.globalTransportInitialized_ } initTransports_(t) { const r = bl && bl.isAvailable(); let a = r && !bl.previouslyFailed(); if (t.webSocketOnly && (r || Wi("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), a = !0), a) this.transports_ = [bl]; else { const d = this.transports_ = []; for (const _ of n.ALL_TRANSPORTS) _ && _.isAvailable() && d.push(_); n.globalTransportInitialized_ = !0 } } initialTransport() { if (this.transports_.length > 0) return this.transports_[0]; throw new Error("No transports available") } upgradeTransport() { return this.transports_.length > 1 ? this.transports_[1] : null } } return n.globalTransportInitialized_ = !1, n })(); class $h { constructor(e, t, r, a, d, _, E, x, B, K) { this.id = e, this.repoInfo_ = t, this.applicationId_ = r, this.appCheckToken_ = a, this.authToken_ = d, this.onMessage_ = _, this.onReady_ = E, this.onDisconnect_ = x, this.onKill_ = B, this.lastSessionId = K, this.connectionCount = 0, this.pendingDataMessages = [], this.state_ = 0, this.log_ = Gr("c:" + this.id + ":"), this.transportManager_ = new nu(t), this.log_("Connection created"), this.start_() } start_() { const e = this.transportManager_.initialTransport(); this.conn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId), this.primaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0; const t = this.connReceiver_(this.conn_), r = this.disconnReceiver_(this.conn_); this.tx_ = this.conn_, this.rx_ = this.conn_, this.secondaryConn_ = null, this.isHealthy_ = !1, setTimeout(() => { this.conn_ && this.conn_.open(t, r) }, Math.floor(0)); const a = e.healthyTimeout || 0; a > 0 && (this.healthyTimeout_ = Ir(() => { this.healthyTimeout_ = null, this.isHealthy_ || (this.conn_ && this.conn_.bytesReceived > 102400 ? (this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()) : this.conn_ && this.conn_.bytesSent > 10240 ? this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.") : (this.log_("Closing unhealthy connection after timeout."), this.close())) }, Math.floor(a))) } nextTransportId_() { return "c:" + this.id + ":" + this.connectionCount++ } disconnReceiver_(e) { return t => { e === this.conn_ ? this.onConnectionLost_(t) : e === this.secondaryConn_ ? (this.log_("Secondary connection lost."), this.onSecondaryConnectionLost_()) : this.log_("closing an old connection") } } connReceiver_(e) { return t => { 2 !== this.state_ && (e === this.rx_ ? this.onPrimaryMessageReceived_(t) : e === this.secondaryConn_ ? this.onSecondaryMessageReceived_(t) : this.log_("message on old connection")) } } sendRequest(e) { this.sendData_({ t: "d", d: e }) } tryCleanupConnection() { this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_ && (this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId), this.conn_ = this.secondaryConn_, this.secondaryConn_ = null) } onSecondaryControl_(e) { if ("t" in e) { const t = e.t; "a" === t ? this.upgradeIfSecondaryHealthy_() : "r" === t ? (this.log_("Got a reset on secondary, closing it"), this.secondaryConn_.close(), (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) && this.close()) : "o" === t && (this.log_("got pong on secondary."), this.secondaryResponsesRequired_--, this.upgradeIfSecondaryHealthy_()) } } onSecondaryMessageReceived_(e) { const t = aa("t", e), r = aa("d", e); if ("c" === t) this.onSecondaryControl_(r); else { if ("d" !== t) throw new Error("Unknown protocol layer: " + t); this.pendingDataMessages.push(r) } } upgradeIfSecondaryHealthy_() { this.secondaryResponsesRequired_ <= 0 ? (this.log_("Secondary connection is healthy."), this.isHealthy_ = !0, this.secondaryConn_.markConnectionHealthy(), this.proceedWithUpgrade_()) : (this.log_("sending ping on secondary."), this.secondaryConn_.send({ t: "c", d: { t: "p", d: {} } })) } proceedWithUpgrade_() { this.secondaryConn_.start(), this.log_("sending client ack on secondary"), this.secondaryConn_.send({ t: "c", d: { t: "a", d: {} } }), this.log_("Ending transmission on primary"), this.conn_.send({ t: "c", d: { t: "n", d: {} } }), this.tx_ = this.secondaryConn_, this.tryCleanupConnection() } onPrimaryMessageReceived_(e) { const t = aa("t", e), r = aa("d", e); "c" === t ? this.onControl_(r) : "d" === t && this.onDataMessage_(r) } onDataMessage_(e) { this.onPrimaryResponse_(), this.onMessage_(e) } onPrimaryResponse_() { this.isHealthy_ || (this.primaryResponsesRequired_--, this.primaryResponsesRequired_ <= 0 && (this.log_("Primary connection is healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy())) } onControl_(e) { const t = aa("t", e); if ("d" in e) { const r = e.d; if ("h" === t) this.onHandshake_(r); else if ("n" === t) { this.log_("recvd end transmission on primary"), this.rx_ = this.secondaryConn_; for (let a = 0; a < this.pendingDataMessages.length; ++a)this.onDataMessage_(this.pendingDataMessages[a]); this.pendingDataMessages = [], this.tryCleanupConnection() } else "s" === t ? this.onConnectionShutdown_(r) : "r" === t ? this.onReset_(r) : "e" === t ? Sr("Server Error: " + r) : "o" === t ? (this.log_("got pong on primary."), this.onPrimaryResponse_(), this.sendPingOnPrimaryIfNecessary_()) : Sr("Unknown control packet command: " + t) } } onHandshake_(e) { const t = e.ts, r = e.v, a = e.h; this.sessionId = e.s, this.repoInfo_.host = a, 0 === this.state_ && (this.conn_.start(), this.onConnectionEstablished_(this.conn_, t), "5" !== r && Wi("Protocol version mismatch detected"), this.tryStartUpgrade_()) } tryStartUpgrade_() { const e = this.transportManager_.upgradeTransport(); e && this.startUpgrade_(e) } startUpgrade_(e) { this.secondaryConn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId), this.secondaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0; const t = this.connReceiver_(this.secondaryConn_), r = this.disconnReceiver_(this.secondaryConn_); this.secondaryConn_.open(t, r), Ir(() => { this.secondaryConn_ && (this.log_("Timed out trying to upgrade."), this.secondaryConn_.close()) }, Math.floor(6e4)) } onReset_(e) { this.log_("Reset packet received.  New host: " + e), this.repoInfo_.host = e, 1 === this.state_ ? this.close() : (this.closeConnections_(), this.start_()) } onConnectionEstablished_(e, t) { this.log_("Realtime connection established."), this.conn_ = e, this.state_ = 1, this.onReady_ && (this.onReady_(t, this.sessionId), this.onReady_ = null), 0 === this.primaryResponsesRequired_ ? (this.log_("Primary connection is healthy."), this.isHealthy_ = !0) : Ir(() => { this.sendPingOnPrimaryIfNecessary_() }, Math.floor(5e3)) } sendPingOnPrimaryIfNecessary_() { !this.isHealthy_ && 1 === this.state_ && (this.log_("sending ping on primary."), this.sendData_({ t: "c", d: { t: "p", d: {} } })) } onSecondaryConnectionLost_() { const e = this.secondaryConn_; this.secondaryConn_ = null, (this.tx_ === e || this.rx_ === e) && this.close() } onConnectionLost_(e) { this.conn_ = null, e || 0 !== this.state_ ? 1 === this.state_ && this.log_("Realtime connection lost.") : (this.log_("Realtime connection failed."), this.repoInfo_.isCacheableHost() && (M.remove("host:" + this.repoInfo_.host), this.repoInfo_.internalHost = this.repoInfo_.host)), this.close() } onConnectionShutdown_(e) { this.log_("Connection shutdown command received. Shutting down..."), this.onKill_ && (this.onKill_(e), this.onKill_ = null), this.onDisconnect_ = null, this.close() } sendData_(e) { if (1 !== this.state_) throw "Connection is not connected"; this.tx_.send(e) } close() { 2 !== this.state_ && (this.log_("Closing realtime connection."), this.state_ = 2, this.closeConnections_(), this.onDisconnect_ && (this.onDisconnect_(), this.onDisconnect_ = null)) } closeConnections_() { this.log_("Shutting down all connections"), this.conn_ && (this.conn_.close(), this.conn_ = null), this.secondaryConn_ && (this.secondaryConn_.close(), this.secondaryConn_ = null), this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), this.healthyTimeout_ = null) } } class yp { put(e, t, r, a) { } merge(e, t, r, a) { } refreshAuthToken(e) { } refreshAppCheckToken(e) { } onDisconnectPut(e, t, r) { } onDisconnectMerge(e, t, r) { } onDisconnectCancel(e, t) { } reportStats(e) { } } class Gu { constructor(e) { this.allowedEvents_ = e, this.listeners_ = {}, (0, Pe.hu)(Array.isArray(e) && e.length > 0, "Requires a non-empty array") } trigger(e, ...t) { if (Array.isArray(this.listeners_[e])) { const r = [...this.listeners_[e]]; for (let a = 0; a < r.length; a++)r[a].callback.apply(r[a].context, t) } } on(e, t, r) { this.validateEventType_(e), this.listeners_[e] = this.listeners_[e] || [], this.listeners_[e].push({ callback: t, context: r }); const a = this.getInitialEvent(e); a && t.apply(r, a) } off(e, t, r) { this.validateEventType_(e); const a = this.listeners_[e] || []; for (let d = 0; d < a.length; d++)if (a[d].callback === t && (!r || r === a[d].context)) return void a.splice(d, 1) } validateEventType_(e) { (0, Pe.hu)(this.allowedEvents_.find(t => t === e), "Unknown event: " + e) } } class Wh extends Gu { constructor() { super(["online"]), this.online_ = !0, typeof window < "u" && typeof window.addEventListener < "u" && !(0, Pe.uI)() && (window.addEventListener("online", () => { this.online_ || (this.online_ = !0, this.trigger("online", !0)) }, !1), window.addEventListener("offline", () => { this.online_ && (this.online_ = !1, this.trigger("online", !1)) }, !1)) } static getInstance() { return new Wh } getInitialEvent(e) { return (0, Pe.hu)("online" === e, "Unknown event type: " + e), [this.online_] } currentlyOnline() { return this.online_ } } class Zi { constructor(e, t) { if (void 0 === t) { this.pieces_ = e.split("/"); let r = 0; for (let a = 0; a < this.pieces_.length; a++)this.pieces_[a].length > 0 && (this.pieces_[r] = this.pieces_[a], r++); this.pieces_.length = r, this.pieceNum_ = 0 } else this.pieces_ = e, this.pieceNum_ = t } toString() { let e = ""; for (let t = this.pieceNum_; t < this.pieces_.length; t++)"" !== this.pieces_[t] && (e += "/" + this.pieces_[t]); return e || "/" } } function Oi() { return new Zi("") } function Qr(n) { return n.pieceNum_ >= n.pieces_.length ? null : n.pieces_[n.pieceNum_] } function rc(n) { return n.pieces_.length - n.pieceNum_ } function ts(n) { let e = n.pieceNum_; return e < n.pieces_.length && e++, new Zi(n.pieces_, e) } function ic(n) { return n.pieceNum_ < n.pieces_.length ? n.pieces_[n.pieces_.length - 1] : null } function Cu(n, e = 0) { return n.pieces_.slice(n.pieceNum_ + e) } function $u(n) { if (n.pieceNum_ >= n.pieces_.length) return null; const e = []; for (let t = n.pieceNum_; t < n.pieces_.length - 1; t++)e.push(n.pieces_[t]); return new Zi(e, 0) } function Hs(n, e) { const t = []; for (let r = n.pieceNum_; r < n.pieces_.length; r++)t.push(n.pieces_[r]); if (e instanceof Zi) for (let r = e.pieceNum_; r < e.pieces_.length; r++)t.push(e.pieces_[r]); else { const r = e.split("/"); for (let a = 0; a < r.length; a++)r[a].length > 0 && t.push(r[a]) } return new Zi(t, 0) } function Xr(n) { return n.pieceNum_ >= n.pieces_.length } function ws(n, e) { const t = Qr(n), r = Qr(e); if (null === t) return e; if (t === r) return ws(ts(n), ts(e)); throw new Error("INTERNAL ERROR: innerPath (" + e + ") is not within outerPath (" + n + ")") } function vp(n, e) { const t = Cu(n, 0), r = Cu(e, 0); for (let a = 0; a < t.length && a < r.length; a++) { const d = kc(t[a], r[a]); if (0 !== d) return d } return t.length === r.length ? 0 : t.length < r.length ? -1 : 1 } function pd(n, e) { if (rc(n) !== rc(e)) return !1; for (let t = n.pieceNum_, r = e.pieceNum_; t <= n.pieces_.length; t++, r++)if (n.pieces_[t] !== e.pieces_[r]) return !1; return !0 } function Ua(n, e) { let t = n.pieceNum_, r = e.pieceNum_; if (rc(n) > rc(e)) return !1; for (; t < n.pieces_.length;) { if (n.pieces_[t] !== e.pieces_[r]) return !1; ++t, ++r } return !0 } class Zh { constructor(e, t) { this.errorPrefix_ = t, this.parts_ = Cu(e, 0), this.byteLength_ = Math.max(1, this.parts_.length); for (let r = 0; r < this.parts_.length; r++)this.byteLength_ += (0, Pe.ug)(this.parts_[r]); vh(this) } } function vh(n) { if (n.byteLength_ > 768) throw new Error(n.errorPrefix_ + "has a key path longer than 768 bytes (" + n.byteLength_ + ")."); if (n.parts_.length > 32) throw new Error(n.errorPrefix_ + "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " + iu(n)) } function iu(n) { return 0 === n.parts_.length ? "" : "in property '" + n.parts_.join(".") + "'" } class bh extends Gu { constructor() { let e, t; super(["visible"]), typeof document < "u" && typeof document.addEventListener < "u" && (typeof document.hidden < "u" ? (t = "visibilitychange", e = "hidden") : typeof document.mozHidden < "u" ? (t = "mozvisibilitychange", e = "mozHidden") : typeof document.msHidden < "u" ? (t = "msvisibilitychange", e = "msHidden") : typeof document.webkitHidden < "u" && (t = "webkitvisibilitychange", e = "webkitHidden")), this.visible_ = !0, t && document.addEventListener(t, () => { const r = !document[e]; r !== this.visible_ && (this.visible_ = r, this.trigger("visible", r)) }, !1) } static getInstance() { return new bh } getInitialEvent(e) { return (0, Pe.hu)("visible" === e, "Unknown event type: " + e), [this.visible_] } } const rl = 1e3; let Rc, sc = (() => { class n extends yp { constructor(t, r, a, d, _, E, x, B) { if (super(), this.repoInfo_ = t, this.applicationId_ = r, this.onDataUpdate_ = a, this.onConnectStatus_ = d, this.onServerInfoUpdate_ = _, this.authTokenProvider_ = E, this.appCheckTokenProvider_ = x, this.authOverride_ = B, this.id = n.nextPersistentConnectionId_++, this.log_ = Gr("p:" + this.id + ":"), this.interruptReasons_ = {}, this.listens = new Map, this.outstandingPuts_ = [], this.outstandingGets_ = [], this.outstandingPutCount_ = 0, this.outstandingGetCount_ = 0, this.onDisconnectRequestQueue_ = [], this.connected_ = !1, this.reconnectDelay_ = rl, this.maxReconnectDelay_ = 3e5, this.securityDebugCallback_ = null, this.lastSessionId = null, this.establishConnectionTimer_ = null, this.visible_ = !1, this.requestCBHash_ = {}, this.requestNumber_ = 0, this.realtime_ = null, this.authToken_ = null, this.appCheckToken_ = null, this.forceTokenRefresh_ = !1, this.invalidAuthTokenCount_ = 0, this.invalidAppCheckTokenCount_ = 0, this.firstConnection_ = !0, this.lastConnectionAttemptTime_ = null, this.lastConnectionEstablishedTime_ = null, B && !(0, Pe.Yr)()) throw new Error("Auth override specified in options, but not supported on non Node.js platforms"); bh.getInstance().on("visible", this.onVisible_, this), -1 === t.host.indexOf("fblocal") && Wh.getInstance().on("online", this.onOnline_, this) } sendRequest(t, r, a) { const d = ++this.requestNumber_, _ = { r: d, a: t, b: r }; this.log_((0, Pe.Wl)(_)), (0, Pe.hu)(this.connected_, "sendRequest call when we're not connected not allowed."), this.realtime_.sendRequest(_), a && (this.requestCBHash_[d] = a) } get(t) { this.initConnection_(); const r = new Pe.BH, d = { action: "g", request: { p: t._path.toString(), q: t._queryObject }, onComplete: E => { const x = E.d; "ok" === E.s ? r.resolve(x) : r.reject(x) } }; return this.outstandingGets_.push(d), this.outstandingGetCount_++, this.connected_ && this.sendGet_(this.outstandingGets_.length - 1), r.promise } listen(t, r, a, d) { this.initConnection_(); const _ = t._queryIdentifier, E = t._path.toString(); this.log_("Listen called for " + E + " " + _), this.listens.has(E) || this.listens.set(E, new Map), (0, Pe.hu)(t._queryParams.isDefault() || !t._queryParams.loadsAllData(), "listen() called for non-default but complete query"), (0, Pe.hu)(!this.listens.get(E).has(_), "listen() called twice for same path/queryId."); const x = { onComplete: d, hashFn: r, query: t, tag: a }; this.listens.get(E).set(_, x), this.connected_ && this.sendListen_(x) } sendGet_(t) { const r = this.outstandingGets_[t]; this.sendRequest("g", r.request, a => { delete this.outstandingGets_[t], this.outstandingGetCount_--, 0 === this.outstandingGetCount_ && (this.outstandingGets_ = []), r.onComplete && r.onComplete(a) }) } sendListen_(t) { const r = t.query, a = r._path.toString(), d = r._queryIdentifier; this.log_("Listen on " + a + " for " + d); const _ = { p: a }; t.tag && (_.q = r._queryObject, _.t = t.tag), _.h = t.hashFn(), this.sendRequest("q", _, x => { const B = x.d, K = x.s; n.warnOnListenWarnings_(B, r), (this.listens.get(a) && this.listens.get(a).get(d)) === t && (this.log_("listen response", x), "ok" !== K && this.removeListen_(a, d), t.onComplete && t.onComplete(K, B)) }) } static warnOnListenWarnings_(t, r) { if (t && "object" == typeof t && (0, Pe.r3)(t, "w")) { const a = (0, Pe.DV)(t, "w"); if (Array.isArray(a) && ~a.indexOf("no_index")) { const d = '".indexOn": "' + r._queryParams.getIndex().toString() + '"', _ = r._path.toString(); Wi(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${d} at ${_} to your security rules for better performance.`) } } } refreshAuthToken(t) { this.authToken_ = t, this.log_("Auth token refreshed"), this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest("unauth", {}, () => { }), this.reduceReconnectDelayIfAdminCredential_(t) } reduceReconnectDelayIfAdminCredential_(t) { (t && 40 === t.length || (0, Pe.GJ)(t)) && (this.log_("Admin auth credential detected.  Reducing max reconnect time."), this.maxReconnectDelay_ = 3e4) } refreshAppCheckToken(t) { this.appCheckToken_ = t, this.log_("App check token refreshed"), this.appCheckToken_ ? this.tryAppCheck() : this.connected_ && this.sendRequest("unappeck", {}, () => { }) } tryAuth() { if (this.connected_ && this.authToken_) { const t = this.authToken_, r = (0, Pe.w9)(t) ? "auth" : "gauth", a = { cred: t }; null === this.authOverride_ ? a.noauth = !0 : "object" == typeof this.authOverride_ && (a.authvar = this.authOverride_), this.sendRequest(r, a, d => { const _ = d.s, E = d.d || "error"; this.authToken_ === t && ("ok" === _ ? this.invalidAuthTokenCount_ = 0 : this.onAuthRevoked_(_, E)) }) } } tryAppCheck() { this.connected_ && this.appCheckToken_ && this.sendRequest("appcheck", { token: this.appCheckToken_ }, t => { const r = t.s, a = t.d || "error"; "ok" === r ? this.invalidAppCheckTokenCount_ = 0 : this.onAppCheckRevoked_(r, a) }) } unlisten(t, r) { const a = t._path.toString(), d = t._queryIdentifier; this.log_("Unlisten called for " + a + " " + d), (0, Pe.hu)(t._queryParams.isDefault() || !t._queryParams.loadsAllData(), "unlisten() called for non-default but complete query"), this.removeListen_(a, d) && this.connected_ && this.sendUnlisten_(a, d, t._queryObject, r) } sendUnlisten_(t, r, a, d) { this.log_("Unlisten on " + t + " for " + r); const _ = { p: t }; d && (_.q = a, _.t = d), this.sendRequest("n", _) } onDisconnectPut(t, r, a) { this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("o", t, r, a) : this.onDisconnectRequestQueue_.push({ pathString: t, action: "o", data: r, onComplete: a }) } onDisconnectMerge(t, r, a) { this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("om", t, r, a) : this.onDisconnectRequestQueue_.push({ pathString: t, action: "om", data: r, onComplete: a }) } onDisconnectCancel(t, r) { this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("oc", t, null, r) : this.onDisconnectRequestQueue_.push({ pathString: t, action: "oc", data: null, onComplete: r }) } sendOnDisconnect_(t, r, a, d) { const _ = { p: r, d: a }; this.log_("onDisconnect " + t, _), this.sendRequest(t, _, E => { d && setTimeout(() => { d(E.s, E.d) }, Math.floor(0)) }) } put(t, r, a, d) { this.putInternal("p", t, r, a, d) } merge(t, r, a, d) { this.putInternal("m", t, r, a, d) } putInternal(t, r, a, d, _) { this.initConnection_(); const E = { p: r, d: a }; void 0 !== _ && (E.h = _), this.outstandingPuts_.push({ action: t, request: E, onComplete: d }), this.outstandingPutCount_++, this.connected_ ? this.sendPut_(this.outstandingPuts_.length - 1) : this.log_("Buffering put: " + r) } sendPut_(t) { const r = this.outstandingPuts_[t].action, a = this.outstandingPuts_[t].request, d = this.outstandingPuts_[t].onComplete; this.outstandingPuts_[t].queued = this.connected_, this.sendRequest(r, a, _ => { this.log_(r + " response", _), delete this.outstandingPuts_[t], this.outstandingPutCount_--, 0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []), d && d(_.s, _.d) }) } reportStats(t) { if (this.connected_) { const r = { c: t }; this.log_("reportStats", r), this.sendRequest("s", r, a => { "ok" !== a.s && this.log_("reportStats", "Error sending stats: " + a.d) }) } } onDataMessage_(t) { if ("r" in t) { this.log_("from server: " + (0, Pe.Wl)(t)); const r = t.r, a = this.requestCBHash_[r]; a && (delete this.requestCBHash_[r], a(t.b)) } else { if ("error" in t) throw "A server-side error has occurred: " + t.error; "a" in t && this.onDataPush_(t.a, t.b) } } onDataPush_(t, r) { this.log_("handleServerMessage", t, r), "d" === t ? this.onDataUpdate_(r.p, r.d, !1, r.t) : "m" === t ? this.onDataUpdate_(r.p, r.d, !0, r.t) : "c" === t ? this.onListenRevoked_(r.p, r.q) : "ac" === t ? this.onAuthRevoked_(r.s, r.d) : "apc" === t ? this.onAppCheckRevoked_(r.s, r.d) : "sd" === t ? this.onSecurityDebugPacket_(r) : Sr("Unrecognized action received from server: " + (0, Pe.Wl)(t) + "\nAre you using the latest client?") } onReady_(t, r) { this.log_("connection ready"), this.connected_ = !0, this.lastConnectionEstablishedTime_ = (new Date).getTime(), this.handleTimestamp_(t), this.lastSessionId = r, this.firstConnection_ && this.sendConnectStats_(), this.restoreState_(), this.firstConnection_ = !1, this.onConnectStatus_(!0) } scheduleConnect_(t) { (0, Pe.hu)(!this.realtime_, "Scheduling a connect when we're already connected/ing?"), this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = setTimeout(() => { this.establishConnectionTimer_ = null, this.establishConnection_() }, Math.floor(t)) } initConnection_() { !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0) } onVisible_(t) { t && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_ && (this.log_("Window became visible.  Reducing delay."), this.reconnectDelay_ = rl, this.realtime_ || this.scheduleConnect_(0)), this.visible_ = t } onOnline_(t) { t ? (this.log_("Browser went online."), this.reconnectDelay_ = rl, this.realtime_ || this.scheduleConnect_(0)) : (this.log_("Browser went offline.  Killing connection."), this.realtime_ && this.realtime_.close()) } onRealtimeDisconnect_() { if (this.log_("data client disconnected"), this.connected_ = !1, this.realtime_ = null, this.cancelSentTransactions_(), this.requestCBHash_ = {}, this.shouldReconnect_()) { this.visible_ ? this.lastConnectionEstablishedTime_ && ((new Date).getTime() - this.lastConnectionEstablishedTime_ > 3e4 && (this.reconnectDelay_ = rl), this.lastConnectionEstablishedTime_ = null) : (this.log_("Window isn't visible.  Delaying reconnect."), this.reconnectDelay_ = this.maxReconnectDelay_, this.lastConnectionAttemptTime_ = (new Date).getTime()); const t = (new Date).getTime() - this.lastConnectionAttemptTime_; let r = Math.max(0, this.reconnectDelay_ - t); r = Math.random() * r, this.log_("Trying to reconnect in " + r + "ms"), this.scheduleConnect_(r), this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, 1.3 * this.reconnectDelay_) } this.onConnectStatus_(!1) } establishConnection_() { var t = this; return (0, cn.Z)(function* () { if (t.shouldReconnect_()) { t.log_("Making a connection attempt"), t.lastConnectionAttemptTime_ = (new Date).getTime(), t.lastConnectionEstablishedTime_ = null; const r = t.onDataMessage_.bind(t), a = t.onReady_.bind(t), d = t.onRealtimeDisconnect_.bind(t), _ = t.id + ":" + n.nextConnectionId_++, E = t.lastSessionId; let x = !1, B = null; const K = function () { B ? B.close() : (x = !0, d()) }; t.realtime_ = { close: K, sendRequest: function (ot) { (0, Pe.hu)(B, "sendRequest call when we're not connected not allowed."), B.sendRequest(ot) } }; const Me = t.forceTokenRefresh_; t.forceTokenRefresh_ = !1; try { const [ot, bt] = yield Promise.all([t.authTokenProvider_.getToken(Me), t.appCheckTokenProvider_.getToken(Me)]); x ? Lr("getToken() completed but was canceled") : (Lr("getToken() completed. Creating connection."), t.authToken_ = ot && ot.accessToken, t.appCheckToken_ = bt && bt.token, B = new $h(_, t.repoInfo_, t.applicationId_, t.appCheckToken_, t.authToken_, r, a, d, qt => { Wi(qt + " (" + t.repoInfo_.toString() + ")"), t.interrupt("server_kill") }, E)) } catch (ot) { t.log_("Failed to get token: " + ot), x || (t.repoInfo_.nodeAdmin && Wi(ot), K()) } } })() } interrupt(t) { Lr("Interrupting connection for reason: " + t), this.interruptReasons_[t] = !0, this.realtime_ ? this.realtime_.close() : (this.establishConnectionTimer_ && (clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = null), this.connected_ && this.onRealtimeDisconnect_()) } resume(t) { Lr("Resuming connection for reason: " + t), delete this.interruptReasons_[t], (0, Pe.xb)(this.interruptReasons_) && (this.reconnectDelay_ = rl, this.realtime_ || this.scheduleConnect_(0)) } handleTimestamp_(t) { const r = t - (new Date).getTime(); this.onServerInfoUpdate_({ serverTimeOffset: r }) } cancelSentTransactions_() { for (let t = 0; t < this.outstandingPuts_.length; t++) { const r = this.outstandingPuts_[t]; r && "h" in r.request && r.queued && (r.onComplete && r.onComplete("disconnect"), delete this.outstandingPuts_[t], this.outstandingPutCount_--) } 0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []) } onListenRevoked_(t, r) { let a; a = r ? r.map(_ => la(_)).join("$") : "default"; const d = this.removeListen_(t, a); d && d.onComplete && d.onComplete("permission_denied") } removeListen_(t, r) { const a = new Zi(t).toString(); let d; if (this.listens.has(a)) { const _ = this.listens.get(a); d = _.get(r), _.delete(r), 0 === _.size && this.listens.delete(a) } else d = void 0; return d } onAuthRevoked_(t, r) { Lr("Auth token revoked: " + t + "/" + r), this.authToken_ = null, this.forceTokenRefresh_ = !0, this.realtime_.close(), ("invalid_token" === t || "permission_denied" === t) && (this.invalidAuthTokenCount_++, this.invalidAuthTokenCount_ >= 3 && (this.reconnectDelay_ = 3e4, this.authTokenProvider_.notifyForInvalidToken())) } onAppCheckRevoked_(t, r) { Lr("App check token revoked: " + t + "/" + r), this.appCheckToken_ = null, this.forceTokenRefresh_ = !0, ("invalid_token" === t || "permission_denied" === t) && (this.invalidAppCheckTokenCount_++, this.invalidAppCheckTokenCount_ >= 3 && this.appCheckTokenProvider_.notifyForInvalidToken()) } onSecurityDebugPacket_(t) { this.securityDebugCallback_ ? this.securityDebugCallback_(t) : "msg" in t && console.log("FIREBASE: " + t.msg.replace("\n", "\nFIREBASE: ")) } restoreState_() { this.tryAuth(), this.tryAppCheck(); for (const t of this.listens.values()) for (const r of t.values()) this.sendListen_(r); for (let t = 0; t < this.outstandingPuts_.length; t++)this.outstandingPuts_[t] && this.sendPut_(t); for (; this.onDisconnectRequestQueue_.length;) { const t = this.onDisconnectRequestQueue_.shift(); this.sendOnDisconnect_(t.action, t.pathString, t.data, t.onComplete) } for (let t = 0; t < this.outstandingGets_.length; t++)this.outstandingGets_[t] && this.sendGet_(t) } sendConnectStats_() { const t = {}; let r = "js"; (0, Pe.Yr)() && (r = this.repoInfo_.nodeAdmin ? "admin_node" : "node"), t["sdk." + r + "." + Bl.replace(/\./g, "-")] = 1, (0, Pe.uI)() ? t["framework.cordova"] = 1 : (0, Pe.b$)() && (t["framework.reactnative"] = 1), this.reportStats(t) } shouldReconnect_() { const t = Wh.getInstance().currentlyOnline(); return (0, Pe.xb)(this.interruptReasons_) && t } } return n.nextPersistentConnectionId_ = 0, n.nextConnectionId_ = 0, n })(); class si { constructor(e, t) { this.name = e, this.node = t } static Wrap(e, t) { return new si(e, t) } } class Zu { getCompare() { return this.compare.bind(this) } indexedValueChanged(e, t) { const r = new si(oa, e), a = new si(oa, t); return 0 !== this.compare(r, a) } minPost() { return si.MIN } } class _d extends Zu { static get __EMPTY_NODE() { return Rc } static set __EMPTY_NODE(e) { Rc = e } compare(e, t) { return kc(e.name, t.name) } isDefinedOn(e) { throw (0, Pe.g5)("KeyIndex.isDefinedOn not expected to be called.") } indexedValueChanged(e, t) { return !1 } minPost() { return si.MIN } maxPost() { return new si(Ns, Rc) } makePost(e, t) { return (0, Pe.hu)("string" == typeof e, "KeyIndex indexValue must always be a string."), new si(e, Rc) } toString() { return ".key" } } const Po = new _d; class Eu { constructor(e, t, r, a, d = null) { this.isReverse_ = a, this.resultGenerator_ = d, this.nodeStack_ = []; let _ = 1; for (; !e.isEmpty();)if (_ = t ? r(e.key, t) : 1, a && (_ *= -1), _ < 0) e = this.isReverse_ ? e.left : e.right; else { if (0 === _) { this.nodeStack_.push(e); break } this.nodeStack_.push(e), e = this.isReverse_ ? e.right : e.left } } getNext() { if (0 === this.nodeStack_.length) return null; let t, e = this.nodeStack_.pop(); if (t = this.resultGenerator_ ? this.resultGenerator_(e.key, e.value) : { key: e.key, value: e.value }, this.isReverse_) for (e = e.left; !e.isEmpty();)this.nodeStack_.push(e), e = e.right; else for (e = e.right; !e.isEmpty();)this.nodeStack_.push(e), e = e.left; return t } hasNext() { return this.nodeStack_.length > 0 } peek() { if (0 === this.nodeStack_.length) return null; const e = this.nodeStack_[this.nodeStack_.length - 1]; return this.resultGenerator_ ? this.resultGenerator_(e.key, e.value) : { key: e.key, value: e.value } } } let Tu, wl = (() => { class n { constructor(t, r, a, d, _) { this.key = t, this.value = r, this.color = a ?? n.RED, this.left = d ?? to.EMPTY_NODE, this.right = _ ?? to.EMPTY_NODE } copy(t, r, a, d, _) { return new n(t ?? this.key, r ?? this.value, a ?? this.color, d ?? this.left, _ ?? this.right) } count() { return this.left.count() + 1 + this.right.count() } isEmpty() { return !1 } inorderTraversal(t) { return this.left.inorderTraversal(t) || !!t(this.key, this.value) || this.right.inorderTraversal(t) } reverseTraversal(t) { return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t) } min_() { return this.left.isEmpty() ? this : this.left.min_() } minKey() { return this.min_().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(t, r, a) { let d = this; const _ = a(t, d.key); return d = _ < 0 ? d.copy(null, null, null, d.left.insert(t, r, a), null) : 0 === _ ? d.copy(null, r, null, null, null) : d.copy(null, null, null, null, d.right.insert(t, r, a)), d.fixUp_() } removeMin_() { if (this.left.isEmpty()) return to.EMPTY_NODE; let t = this; return !t.left.isRed_() && !t.left.left.isRed_() && (t = t.moveRedLeft_()), t = t.copy(null, null, null, t.left.removeMin_(), null), t.fixUp_() } remove(t, r) { let a, d; if (a = this, r(t, a.key) < 0) !a.left.isEmpty() && !a.left.isRed_() && !a.left.left.isRed_() && (a = a.moveRedLeft_()), a = a.copy(null, null, null, a.left.remove(t, r), null); else { if (a.left.isRed_() && (a = a.rotateRight_()), !a.right.isEmpty() && !a.right.isRed_() && !a.right.left.isRed_() && (a = a.moveRedRight_()), 0 === r(t, a.key)) { if (a.right.isEmpty()) return to.EMPTY_NODE; d = a.right.min_(), a = a.copy(d.key, d.value, null, null, a.right.removeMin_()) } a = a.copy(null, null, null, null, a.right.remove(t, r)) } return a.fixUp_() } isRed_() { return this.color } fixUp_() { let t = this; return t.right.isRed_() && !t.left.isRed_() && (t = t.rotateLeft_()), t.left.isRed_() && t.left.left.isRed_() && (t = t.rotateRight_()), t.left.isRed_() && t.right.isRed_() && (t = t.colorFlip_()), t } moveRedLeft_() { let t = this.colorFlip_(); return t.right.left.isRed_() && (t = t.copy(null, null, null, null, t.right.rotateRight_()), t = t.rotateLeft_(), t = t.colorFlip_()), t } moveRedRight_() { let t = this.colorFlip_(); return t.left.left.isRed_() && (t = t.rotateRight_(), t = t.colorFlip_()), t } rotateLeft_() { const t = this.copy(null, null, n.RED, null, this.right.left); return this.right.copy(null, null, this.color, t, null) } rotateRight_() { const t = this.copy(null, null, n.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, t) } colorFlip_() { const t = this.left.copy(null, null, !this.left.color, null, null), r = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, t, r) } checkMaxDepth_() { const t = this.check_(); return Math.pow(2, t) <= this.count() + 1 } check_() { if (this.isRed_() && this.left.isRed_()) throw new Error("Red node has red child(" + this.key + "," + this.value + ")"); if (this.right.isRed_()) throw new Error("Right child of (" + this.key + "," + this.value + ") is red"); const t = this.left.check_(); if (t !== this.right.check_()) throw new Error("Black depths differ"); return t + (this.isRed_() ? 0 : 1) } } return n.RED = !0, n.BLACK = !1, n })(); class to { constructor(e, t = to.EMPTY_NODE) { this.comparator_ = e, this.root_ = t } insert(e, t) { return new to(this.comparator_, this.root_.insert(e, t, this.comparator_).copy(null, null, wl.BLACK, null, null)) } remove(e) { return new to(this.comparator_, this.root_.remove(e, this.comparator_).copy(null, null, wl.BLACK, null, null)) } get(e) { let t, r = this.root_; for (; !r.isEmpty();) { if (t = this.comparator_(e, r.key), 0 === t) return r.value; t < 0 ? r = r.left : t > 0 && (r = r.right) } return null } getPredecessorKey(e) { let t, r = this.root_, a = null; for (; !r.isEmpty();) { if (t = this.comparator_(e, r.key), 0 === t) { if (r.left.isEmpty()) return a ? a.key : null; for (r = r.left; !r.right.isEmpty();)r = r.right; return r.key } t < 0 ? r = r.left : t > 0 && (a = r, r = r.right) } throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?") } isEmpty() { return this.root_.isEmpty() } count() { return this.root_.count() } minKey() { return this.root_.minKey() } maxKey() { return this.root_.maxKey() } inorderTraversal(e) { return this.root_.inorderTraversal(e) } reverseTraversal(e) { return this.root_.reverseTraversal(e) } getIterator(e) { return new Eu(this.root_, null, this.comparator_, !1, e) } getIteratorFrom(e, t) { return new Eu(this.root_, e, this.comparator_, !1, t) } getReverseIteratorFrom(e, t) { return new Eu(this.root_, e, this.comparator_, !0, t) } getReverseIterator(e) { return new Eu(this.root_, null, this.comparator_, !0, e) } } function yd(n, e) { return kc(n.name, e.name) } function Ma(n, e) { return kc(n, e) } to.EMPTY_NODE = new class Ro { copy(e, t, r, a, d) { return this } insert(e, t, r) { return new wl(e, t, null) } remove(e, t) { return this } count() { return 0 } isEmpty() { return !0 } inorderTraversal(e) { return !1 } reverseTraversal(e) { return !1 } minKey() { return null } maxKey() { return null } check_() { return 0 } isRed_() { return !1 } }; const wh = function (n) { return "number" == typeof n ? "number:" + W(n) : "string:" + n }, Cl = function (n) { if (n.isLeafNode()) { const e = n.val(); (0, Pe.hu)("string" == typeof e || "number" == typeof e || "object" == typeof e && (0, Pe.r3)(e, ".sv"), "Priority must be a string or number.") } else (0, Pe.hu)(n === Tu || n.isEmpty(), "priority of unexpected type."); (0, Pe.hu)(n === Tu || n.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.") }; let Kh, vd, bd, El = (() => { class n { constructor(t, r = n.__childrenNodeConstructor.EMPTY_NODE) { this.value_ = t, this.priorityNode_ = r, this.lazyHash_ = null, (0, Pe.hu)(null != this.value_, "LeafNode shouldn't be created with null/undefined value."), Cl(this.priorityNode_) } static set __childrenNodeConstructor(t) { Kh = t } static get __childrenNodeConstructor() { return Kh } isLeafNode() { return !0 } getPriority() { return this.priorityNode_ } updatePriority(t) { return new n(this.value_, t) } getImmediateChild(t) { return ".priority" === t ? this.priorityNode_ : n.__childrenNodeConstructor.EMPTY_NODE } getChild(t) { return Xr(t) ? this : ".priority" === Qr(t) ? this.priorityNode_ : n.__childrenNodeConstructor.EMPTY_NODE } hasChild() { return !1 } getPredecessorChildName(t, r) { return null } updateImmediateChild(t, r) { return ".priority" === t ? this.updatePriority(r) : r.isEmpty() && ".priority" !== t ? this : n.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(t, r).updatePriority(this.priorityNode_) } updateChild(t, r) { const a = Qr(t); return null === a ? r : r.isEmpty() && ".priority" !== a ? this : ((0, Pe.hu)(".priority" !== a || 1 === rc(t), ".priority must be the last token in a path"), this.updateImmediateChild(a, n.__childrenNodeConstructor.EMPTY_NODE.updateChild(ts(t), r))) } isEmpty() { return !1 } numChildren() { return 0 } forEachChild(t, r) { return !1 } val(t) { return t && !this.getPriority().isEmpty() ? { ".value": this.getValue(), ".priority": this.getPriority().val() } : this.getValue() } hash() { if (null === this.lazyHash_) { let t = ""; this.priorityNode_.isEmpty() || (t += "priority:" + wh(this.priorityNode_.val()) + ":"); const r = typeof this.value_; t += r + ":", t += "number" === r ? W(this.value_) : this.value_, this.lazyHash_ = be(t) } return this.lazyHash_ } getValue() { return this.value_ } compareTo(t) { return t === n.__childrenNodeConstructor.EMPTY_NODE ? 1 : t instanceof n.__childrenNodeConstructor ? -1 : ((0, Pe.hu)(t.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(t)) } compareToLeafNode_(t) { const r = typeof t.value_, a = typeof this.value_, d = n.VALUE_TYPE_ORDER.indexOf(r), _ = n.VALUE_TYPE_ORDER.indexOf(a); return (0, Pe.hu)(d >= 0, "Unknown leaf type: " + r), (0, Pe.hu)(_ >= 0, "Unknown leaf type: " + a), d === _ ? "object" === a ? 0 : this.value_ < t.value_ ? -1 : this.value_ === t.value_ ? 0 : 1 : _ - d } withIndex() { return this } isIndexed() { return !0 } equals(t) { return t === this || !!t.isLeafNode() && (this.value_ === t.value_ && this.priorityNode_.equals(t.priorityNode_)) } } return n.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"], n })(); const ui = new class Rf extends Zu { compare(e, t) { const r = e.node.getPriority(), a = t.node.getPriority(), d = r.compareTo(a); return 0 === d ? kc(e.name, t.name) : d } isDefinedOn(e) { return !e.getPriority().isEmpty() } indexedValueChanged(e, t) { return !e.getPriority().equals(t.getPriority()) } minPost() { return si.MIN } maxPost() { return new si(Ns, new El("[PRIORITY-POST]", bd)) } makePost(e, t) { const r = vd(e); return new si(t, new El("[PRIORITY-POST]", r)) } toString() { return ".priority" } }, Ff = Math.log(2); class $d { constructor(e) { this.count = parseInt(Math.log(e + 1) / Ff, 10), this.current_ = this.count - 1; const a = (d => parseInt(Array(this.count + 1).join("1"), 2))(); this.bits_ = e + 1 & a } nextBitIsOne() { const e = !(this.bits_ & 1 << this.current_); return this.current_--, e } } const wd = function (n, e, t, r) { n.sort(e); const a = function (x, B) { const K = B - x; let oe, Me; if (0 === K) return null; if (1 === K) return oe = n[x], Me = t ? t(oe) : oe, new wl(Me, oe.node, wl.BLACK, null, null); { const ot = parseInt(K / 2, 10) + x, bt = a(x, ot), qt = a(ot + 1, B); return oe = n[ot], Me = t ? t(oe) : oe, new wl(Me, oe.node, wl.BLACK, bt, qt) } }, E = function (x) { let B = null, K = null, oe = n.length; const Me = function (bt, qt) { const Tn = oe - bt, cr = oe; oe -= bt; const $r = a(Tn + 1, cr), Rr = n[Tn], Li = t ? t(Rr) : Rr; ot(new wl(Li, Rr.node, qt, null, $r)) }, ot = function (bt) { B ? (B.left = bt, B = bt) : (K = bt, B = bt) }; for (let bt = 0; bt < x.count; ++bt) { const qt = x.nextBitIsOne(), Tn = Math.pow(2, x.count - (bt + 1)); qt ? Me(Tn, wl.BLACK) : (Me(Tn, wl.BLACK), Me(Tn, wl.RED)) } return K }(new $d(n.length)); return new to(r || e, E) }; let oc; const Tl = {}; class il { constructor(e, t) { this.indexes_ = e, this.indexSet_ = t } static get Default() { return (0, Pe.hu)(Tl && ui, "ChildrenNode.ts has not been loaded"), oc = oc || new il({ ".priority": Tl }, { ".priority": ui }), oc } get(e) { const t = (0, Pe.DV)(this.indexes_, e); if (!t) throw new Error("No index defined for " + e); return t instanceof to ? t : null } hasIndex(e) { return (0, Pe.r3)(this.indexSet_, e.toString()) } addIndex(e, t) { (0, Pe.hu)(e !== Po, "KeyIndex always exists and isn't meant to be added to the IndexMap."); const r = []; let a = !1; const d = t.getIterator(si.Wrap); let E, _ = d.getNext(); for (; _;)a = a || e.isDefinedOn(_.node), r.push(_), _ = d.getNext(); E = a ? wd(r, e.getCompare()) : Tl; const x = e.toString(), B = Object.assign({}, this.indexSet_); B[x] = e; const K = Object.assign({}, this.indexes_); return K[x] = E, new il(K, B) } addToIndexes(e, t) { const r = (0, Pe.UI)(this.indexes_, (a, d) => { const _ = (0, Pe.DV)(this.indexSet_, d); if ((0, Pe.hu)(_, "Missing index implementation for " + d), a === Tl) { if (_.isDefinedOn(e.node)) { const E = [], x = t.getIterator(si.Wrap); let B = x.getNext(); for (; B;)B.name !== e.name && E.push(B), B = x.getNext(); return E.push(e), wd(E, _.getCompare()) } return Tl } { const E = t.get(e.name); let x = a; return E && (x = x.remove(new si(e.name, E))), x.insert(e, e.node) } }); return new il(r, this.indexSet_) } removeFromIndexes(e, t) { const r = (0, Pe.UI)(this.indexes_, a => { if (a === Tl) return a; { const d = t.get(e.name); return d ? a.remove(new si(e.name, d)) : a } }); return new il(r, this.indexSet_) } } let ac, ei = (() => { class n { constructor(t, r, a) { this.children_ = t, this.priorityNode_ = r, this.indexMap_ = a, this.lazyHash_ = null, this.priorityNode_ && Cl(this.priorityNode_), this.children_.isEmpty() && (0, Pe.hu)(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority") } static get EMPTY_NODE() { return ac || (ac = new n(new to(Ma), null, il.Default)) } isLeafNode() { return !1 } getPriority() { return this.priorityNode_ || ac } updatePriority(t) { return this.children_.isEmpty() ? this : new n(this.children_, t, this.indexMap_) } getImmediateChild(t) { if (".priority" === t) return this.getPriority(); { const r = this.children_.get(t); return null === r ? ac : r } } getChild(t) { const r = Qr(t); return null === r ? this : this.getImmediateChild(r).getChild(ts(t)) } hasChild(t) { return null !== this.children_.get(t) } updateImmediateChild(t, r) { if ((0, Pe.hu)(r, "We should always be passing snapshot nodes"), ".priority" === t) return this.updatePriority(r); { const a = new si(t, r); let d, _; r.isEmpty() ? (d = this.children_.remove(t), _ = this.indexMap_.removeFromIndexes(a, this.children_)) : (d = this.children_.insert(t, r), _ = this.indexMap_.addToIndexes(a, this.children_)); const E = d.isEmpty() ? ac : this.priorityNode_; return new n(d, E, _) } } updateChild(t, r) { const a = Qr(t); if (null === a) return r; { (0, Pe.hu)(".priority" !== Qr(t) || 1 === rc(t), ".priority must be the last token in a path"); const d = this.getImmediateChild(a).updateChild(ts(t), r); return this.updateImmediateChild(a, d) } } isEmpty() { return this.children_.isEmpty() } numChildren() { return this.children_.count() } val(t) { if (this.isEmpty()) return null; const r = {}; let a = 0, d = 0, _ = !0; if (this.forEachChild(ui, (E, x) => { r[E] = x.val(t), a++, _ && n.INTEGER_REGEXP_.test(E) ? d = Math.max(d, Number(E)) : _ = !1 }), !t && _ && d < 2 * a) { const E = []; for (const x in r) E[x] = r[x]; return E } return t && !this.getPriority().isEmpty() && (r[".priority"] = this.getPriority().val()), r } hash() { if (null === this.lazyHash_) { let t = ""; this.getPriority().isEmpty() || (t += "priority:" + wh(this.getPriority().val()) + ":"), this.forEachChild(ui, (r, a) => { const d = a.hash(); "" !== d && (t += ":" + r + ":" + d) }), this.lazyHash_ = "" === t ? "" : be(t) } return this.lazyHash_ } getPredecessorChildName(t, r, a) { const d = this.resolveIndex_(a); if (d) { const _ = d.getPredecessorKey(new si(t, r)); return _ ? _.name : null } return this.children_.getPredecessorKey(t) } getFirstChildName(t) { const r = this.resolveIndex_(t); if (r) { const a = r.minKey(); return a && a.name } return this.children_.minKey() } getFirstChild(t) { const r = this.getFirstChildName(t); return r ? new si(r, this.children_.get(r)) : null } getLastChildName(t) { const r = this.resolveIndex_(t); if (r) { const a = r.maxKey(); return a && a.name } return this.children_.maxKey() } getLastChild(t) { const r = this.getLastChildName(t); return r ? new si(r, this.children_.get(r)) : null } forEachChild(t, r) { const a = this.resolveIndex_(t); return a ? a.inorderTraversal(d => r(d.name, d.node)) : this.children_.inorderTraversal(r) } getIterator(t) { return this.getIteratorFrom(t.minPost(), t) } getIteratorFrom(t, r) { const a = this.resolveIndex_(r); if (a) return a.getIteratorFrom(t, d => d); { const d = this.children_.getIteratorFrom(t.name, si.Wrap); let _ = d.peek(); for (; null != _ && r.compare(_, t) < 0;)d.getNext(), _ = d.peek(); return d } } getReverseIterator(t) { return this.getReverseIteratorFrom(t.maxPost(), t) } getReverseIteratorFrom(t, r) { const a = this.resolveIndex_(r); if (a) return a.getReverseIteratorFrom(t, d => d); { const d = this.children_.getReverseIteratorFrom(t.name, si.Wrap); let _ = d.peek(); for (; null != _ && r.compare(_, t) > 0;)d.getNext(), _ = d.peek(); return d } } compareTo(t) { return this.isEmpty() ? t.isEmpty() ? 0 : -1 : t.isLeafNode() || t.isEmpty() ? 1 : t === Yu ? -1 : 0 } withIndex(t) { if (t === Po || this.indexMap_.hasIndex(t)) return this; { const r = this.indexMap_.addIndex(t, this.children_); return new n(this.children_, this.priorityNode_, r) } } isIndexed(t) { return t === Po || this.indexMap_.hasIndex(t) } equals(t) { if (t === this) return !0; if (t.isLeafNode()) return !1; { const r = t; if (this.getPriority().equals(r.getPriority())) { if (this.children_.count() === r.children_.count()) { const a = this.getIterator(ui), d = r.getIterator(ui); let _ = a.getNext(), E = d.getNext(); for (; _ && E;) { if (_.name !== E.name || !_.node.equals(E.node)) return !1; _ = a.getNext(), E = d.getNext() } return null === _ && null === E } return !1 } return !1 } } resolveIndex_(t) { return t === Po ? null : this.indexMap_.get(t.toString()) } } return n.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/, n })(); const Yu = new class Ch extends ei { constructor() { super(new to(Ma), ei.EMPTY_NODE, il.Default) } compareTo(e) { return e === this ? 0 : 1 } equals(e) { return e === this } getPriority() { return this } getImmediateChild(e) { return ei.EMPTY_NODE } isEmpty() { return !1 } }; function Zs(n, e = null) { if (null === n) return ei.EMPTY_NODE; if ("object" == typeof n && ".priority" in n && (e = n[".priority"]), (0, Pe.hu)(null === e || "string" == typeof e || "number" == typeof e || "object" == typeof e && ".sv" in e, "Invalid priority type found: " + typeof e), "object" == typeof n && ".value" in n && null !== n[".value"] && (n = n[".value"]), "object" != typeof n || ".sv" in n) return new El(n, Zs(e)); if (n instanceof Array) { let t = ei.EMPTY_NODE; return vi(n, (r, a) => { if ((0, Pe.r3)(n, r) && "." !== r.substring(0, 1)) { const d = Zs(a); (d.isLeafNode() || !d.isEmpty()) && (t = t.updateImmediateChild(r, d)) } }), t.updatePriority(Zs(e)) } { const t = []; let r = !1; if (vi(n, (_, E) => { if ("." !== _.substring(0, 1)) { const x = Zs(E); x.isEmpty() || (r = r || !x.getPriority().isEmpty(), t.push(new si(_, x))) } }), 0 === t.length) return ei.EMPTY_NODE; const d = wd(t, yd, _ => _.name, Ma); if (r) { const _ = wd(t, ui.getCompare()); return new ei(d, Zs(e), new il({ ".priority": _ }, { ".priority": ui })) } return new ei(d, Zs(e), il.Default) } } Object.defineProperties(si, { MIN: { value: new si(oa, ei.EMPTY_NODE) }, MAX: { value: new si(Ns, Yu) } }), _d.__EMPTY_NODE = ei.EMPTY_NODE, El.__childrenNodeConstructor = ei, function jd(n) { Tu = n }(Yu), function qu(n) { bd = n }(Yu), function Pf(n) { vd = n }(Zs); class Wd extends Zu { constructor(e) { super(), this.indexPath_ = e, (0, Pe.hu)(!Xr(e) && ".priority" !== Qr(e), "Can't create PathIndex with empty path or .priority key") } extractChild(e) { return e.getChild(this.indexPath_) } isDefinedOn(e) { return !e.getChild(this.indexPath_).isEmpty() } compare(e, t) { const r = this.extractChild(e.node), a = this.extractChild(t.node), d = r.compareTo(a); return 0 === d ? kc(e.name, t.name) : d } makePost(e, t) { const r = Zs(e), a = ei.EMPTY_NODE.updateChild(this.indexPath_, r); return new si(t, a) } maxPost() { const e = ei.EMPTY_NODE.updateChild(this.indexPath_, Yu); return new si(Ns, e) } toString() { return Cu(this.indexPath_, 0).join("/") } } const C = new class O extends Zu { compare(e, t) { const r = e.node.compareTo(t.node); return 0 === r ? kc(e.name, t.name) : r } isDefinedOn(e) { return !0 } indexedValueChanged(e, t) { return !e.equals(t) } minPost() { return si.MIN } maxPost() { return si.MAX } makePost(e, t) { const r = Zs(e); return new si(t, r) } toString() { return ".value" } }; function S(n) { return { type: "value", snapshotNode: n } } function F(n, e) { return { type: "child_added", snapshotNode: e, childName: n } } function ie(n, e) { return { type: "child_removed", snapshotNode: e, childName: n } } function ge(n, e, t) { return { type: "child_changed", snapshotNode: e, childName: n, oldSnap: t } } class tn { constructor(e) { this.index_ = e } updateChild(e, t, r, a, d, _) { (0, Pe.hu)(e.isIndexed(this.index_), "A node must be indexed if only a child is updated"); const E = e.getImmediateChild(t); return E.getChild(a).equals(r.getChild(a)) && E.isEmpty() === r.isEmpty() || (null != _ && (r.isEmpty() ? e.hasChild(t) ? _.trackChildChange(ie(t, E)) : (0, Pe.hu)(e.isLeafNode(), "A child remove without an old child only makes sense on a leaf node") : E.isEmpty() ? _.trackChildChange(F(t, r)) : _.trackChildChange(ge(t, r, E))), e.isLeafNode() && r.isEmpty()) ? e : e.updateImmediateChild(t, r).withIndex(this.index_) } updateFullNode(e, t, r) { return null != r && (e.isLeafNode() || e.forEachChild(ui, (a, d) => { t.hasChild(a) || r.trackChildChange(ie(a, d)) }), t.isLeafNode() || t.forEachChild(ui, (a, d) => { if (e.hasChild(a)) { const _ = e.getImmediateChild(a); _.equals(d) || r.trackChildChange(ge(a, d, _)) } else r.trackChildChange(F(a, d)) })), t.withIndex(this.index_) } updatePriority(e, t) { return e.isEmpty() ? ei.EMPTY_NODE : e.updatePriority(t) } filtersNodes() { return !1 } getIndexedFilter() { return this } getIndex() { return this.index_ } } class Pn { constructor(e) { this.indexedFilter_ = new tn(e.getIndex()), this.index_ = e.getIndex(), this.startPost_ = Pn.getStartPost_(e), this.endPost_ = Pn.getEndPost_(e), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_ } getStartPost() { return this.startPost_ } getEndPost() { return this.endPost_ } matches(e) { const t = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), e) <= 0 : this.index_.compare(this.getStartPost(), e) < 0, r = this.endIsInclusive_ ? this.index_.compare(e, this.getEndPost()) <= 0 : this.index_.compare(e, this.getEndPost()) < 0; return t && r } updateChild(e, t, r, a, d, _) { return this.matches(new si(t, r)) || (r = ei.EMPTY_NODE), this.indexedFilter_.updateChild(e, t, r, a, d, _) } updateFullNode(e, t, r) { t.isLeafNode() && (t = ei.EMPTY_NODE); let a = t.withIndex(this.index_); a = a.updatePriority(ei.EMPTY_NODE); const d = this; return t.forEachChild(ui, (_, E) => { d.matches(new si(_, E)) || (a = a.updateImmediateChild(_, ei.EMPTY_NODE)) }), this.indexedFilter_.updateFullNode(e, a, r) } updatePriority(e, t) { return e } filtersNodes() { return !0 } getIndexedFilter() { return this.indexedFilter_ } getIndex() { return this.index_ } static getStartPost_(e) { if (e.hasStart()) { const t = e.getIndexStartName(); return e.getIndex().makePost(e.getIndexStartValue(), t) } return e.getIndex().minPost() } static getEndPost_(e) { if (e.hasEnd()) { const t = e.getIndexEndName(); return e.getIndex().makePost(e.getIndexEndValue(), t) } return e.getIndex().maxPost() } } class tr { constructor(e) { this.withinDirectionalStart = t => this.reverse_ ? this.withinEndPost(t) : this.withinStartPost(t), this.withinDirectionalEnd = t => this.reverse_ ? this.withinStartPost(t) : this.withinEndPost(t), this.withinStartPost = t => { const r = this.index_.compare(this.rangedFilter_.getStartPost(), t); return this.startIsInclusive_ ? r <= 0 : r < 0 }, this.withinEndPost = t => { const r = this.index_.compare(t, this.rangedFilter_.getEndPost()); return this.endIsInclusive_ ? r <= 0 : r < 0 }, this.rangedFilter_ = new Pn(e), this.index_ = e.getIndex(), this.limit_ = e.getLimit(), this.reverse_ = !e.isViewFromLeft(), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_ } updateChild(e, t, r, a, d, _) { return this.rangedFilter_.matches(new si(t, r)) || (r = ei.EMPTY_NODE), e.getImmediateChild(t).equals(r) ? e : e.numChildren() < this.limit_ ? this.rangedFilter_.getIndexedFilter().updateChild(e, t, r, a, d, _) : this.fullLimitUpdateChild_(e, t, r, d, _) } updateFullNode(e, t, r) { let a; if (t.isLeafNode() || t.isEmpty()) a = ei.EMPTY_NODE.withIndex(this.index_); else if (2 * this.limit_ < t.numChildren() && t.isIndexed(this.index_)) { let d; a = ei.EMPTY_NODE.withIndex(this.index_), d = this.reverse_ ? t.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_) : t.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_); let _ = 0; for (; d.hasNext() && _ < this.limit_;) { const E = d.getNext(); if (this.withinDirectionalStart(E)) { if (!this.withinDirectionalEnd(E)) break; a = a.updateImmediateChild(E.name, E.node), _++ } } } else { let d; a = t.withIndex(this.index_), a = a.updatePriority(ei.EMPTY_NODE), d = this.reverse_ ? a.getReverseIterator(this.index_) : a.getIterator(this.index_); let _ = 0; for (; d.hasNext();) { const E = d.getNext(); _ < this.limit_ && this.withinDirectionalStart(E) && this.withinDirectionalEnd(E) ? _++ : a = a.updateImmediateChild(E.name, ei.EMPTY_NODE) } } return this.rangedFilter_.getIndexedFilter().updateFullNode(e, a, r) } updatePriority(e, t) { return e } filtersNodes() { return !0 } getIndexedFilter() { return this.rangedFilter_.getIndexedFilter() } getIndex() { return this.index_ } fullLimitUpdateChild_(e, t, r, a, d) { let _; if (this.reverse_) { const oe = this.index_.getCompare(); _ = (Me, ot) => oe(ot, Me) } else _ = this.index_.getCompare(); const E = e; (0, Pe.hu)(E.numChildren() === this.limit_, ""); const x = new si(t, r), B = this.reverse_ ? E.getFirstChild(this.index_) : E.getLastChild(this.index_), K = this.rangedFilter_.matches(x); if (E.hasChild(t)) { const oe = E.getImmediateChild(t); let Me = a.getChildAfterChild(this.index_, B, this.reverse_); for (; null != Me && (Me.name === t || E.hasChild(Me.name));)Me = a.getChildAfterChild(this.index_, Me, this.reverse_); const ot = null == Me ? 1 : _(Me, x); if (K && !r.isEmpty() && ot >= 0) return d?.trackChildChange(ge(t, r, oe)), E.updateImmediateChild(t, r); { d?.trackChildChange(ie(t, oe)); const qt = E.updateImmediateChild(t, ei.EMPTY_NODE); return null != Me && this.rangedFilter_.matches(Me) ? (d?.trackChildChange(F(Me.name, Me.node)), qt.updateImmediateChild(Me.name, Me.node)) : qt } } return r.isEmpty() ? e : K && _(B, x) >= 0 ? (null != d && (d.trackChildChange(ie(B.name, B.node)), d.trackChildChange(F(t, r))), E.updateImmediateChild(t, r).updateImmediateChild(B.name, ei.EMPTY_NODE)) : e } } class br { constructor() { this.limitSet_ = !1, this.startSet_ = !1, this.startNameSet_ = !1, this.startAfterSet_ = !1, this.endSet_ = !1, this.endNameSet_ = !1, this.endBeforeSet_ = !1, this.limit_ = 0, this.viewFrom_ = "", this.indexStartValue_ = null, this.indexStartName_ = "", this.indexEndValue_ = null, this.indexEndName_ = "", this.index_ = ui } hasStart() { return this.startSet_ } isViewFromLeft() { return "" === this.viewFrom_ ? this.startSet_ : "l" === this.viewFrom_ } getIndexStartValue() { return (0, Pe.hu)(this.startSet_, "Only valid if start has been set"), this.indexStartValue_ } getIndexStartName() { return (0, Pe.hu)(this.startSet_, "Only valid if start has been set"), this.startNameSet_ ? this.indexStartName_ : oa } hasEnd() { return this.endSet_ } getIndexEndValue() { return (0, Pe.hu)(this.endSet_, "Only valid if end has been set"), this.indexEndValue_ } getIndexEndName() { return (0, Pe.hu)(this.endSet_, "Only valid if end has been set"), this.endNameSet_ ? this.indexEndName_ : Ns } hasLimit() { return this.limitSet_ } hasAnchoredLimit() { return this.limitSet_ && "" !== this.viewFrom_ } getLimit() { return (0, Pe.hu)(this.limitSet_, "Only valid if limit has been set"), this.limit_ } getIndex() { return this.index_ } loadsAllData() { return !(this.startSet_ || this.endSet_ || this.limitSet_) } isDefault() { return this.loadsAllData() && this.index_ === ui } copy() { const e = new br; return e.limitSet_ = this.limitSet_, e.limit_ = this.limit_, e.startSet_ = this.startSet_, e.startAfterSet_ = this.startAfterSet_, e.indexStartValue_ = this.indexStartValue_, e.startNameSet_ = this.startNameSet_, e.indexStartName_ = this.indexStartName_, e.endSet_ = this.endSet_, e.endBeforeSet_ = this.endBeforeSet_, e.indexEndValue_ = this.indexEndValue_, e.endNameSet_ = this.endNameSet_, e.indexEndName_ = this.indexEndName_, e.index_ = this.index_, e.viewFrom_ = this.viewFrom_, e } } function Ku(n, e, t) { const r = n.copy(); return r.startSet_ = !0, void 0 === e && (e = null), r.indexStartValue_ = e, null != t ? (r.startNameSet_ = !0, r.indexStartName_ = t) : (r.startNameSet_ = !1, r.indexStartName_ = ""), r } function su(n, e, t) { const r = n.copy(); return r.endSet_ = !0, void 0 === e && (e = null), r.indexEndValue_ = e, void 0 !== t ? (r.endNameSet_ = !0, r.indexEndName_ = t) : (r.endNameSet_ = !1, r.indexEndName_ = ""), r } function lc(n, e) { const t = n.copy(); return t.index_ = e, t } function Su(n) { const e = {}; if (n.isDefault()) return e; let t; if (n.index_ === ui ? t = "$priority" : n.index_ === C ? t = "$value" : n.index_ === Po ? t = "$key" : ((0, Pe.hu)(n.index_ instanceof Wd, "Unrecognized index type!"), t = n.index_.toString()), e.orderBy = (0, Pe.Wl)(t), n.startSet_) { const r = n.startAfterSet_ ? "startAfter" : "startAt"; e[r] = (0, Pe.Wl)(n.indexStartValue_), n.startNameSet_ && (e[r] += "," + (0, Pe.Wl)(n.indexStartName_)) } if (n.endSet_) { const r = n.endBeforeSet_ ? "endBefore" : "endAt"; e[r] = (0, Pe.Wl)(n.indexEndValue_), n.endNameSet_ && (e[r] += "," + (0, Pe.Wl)(n.indexEndName_)) } return n.limitSet_ && (n.isViewFromLeft() ? e.limitToFirst = n.limit_ : e.limitToLast = n.limit_), e } function Eh(n) { const e = {}; if (n.startSet_ && (e.sp = n.indexStartValue_, n.startNameSet_ && (e.sn = n.indexStartName_), e.sin = !n.startAfterSet_), n.endSet_ && (e.ep = n.indexEndValue_, n.endNameSet_ && (e.en = n.indexEndName_), e.ein = !n.endBeforeSet_), n.limitSet_) { e.l = n.limit_; let t = n.viewFrom_; "" === t && (t = n.isViewFromLeft() ? "l" : "r"), e.vf = t } return n.index_ !== ui && (e.i = n.index_.toString()), e } class Lc extends yp { constructor(e, t, r, a) { super(), this.repoInfo_ = e, this.onDataUpdate_ = t, this.authTokenProvider_ = r, this.appCheckTokenProvider_ = a, this.log_ = Gr("p:rest:"), this.listens_ = {} } reportStats(e) { throw new Error("Method not implemented.") } static getListenId_(e, t) { return void 0 !== t ? "tag$" + t : ((0, Pe.hu)(e._queryParams.isDefault(), "should have a tag if it's not a default query."), e._path.toString()) } listen(e, t, r, a) { const d = e._path.toString(); this.log_("Listen called for " + d + " " + e._queryIdentifier); const _ = Lc.getListenId_(e, r), E = {}; this.listens_[_] = E; const x = Su(e._queryParams); this.restRequest_(d + ".json", x, (B, K) => { let oe = K; if (404 === B && (oe = null, B = null), null === B && this.onDataUpdate_(d, oe, !1, r), (0, Pe.DV)(this.listens_, _) === E) { let Me; Me = B ? 401 === B ? "permission_denied" : "rest_error:" + B : "ok", a(Me, null) } }) } unlisten(e, t) { const r = Lc.getListenId_(e, t); delete this.listens_[r] } get(e) { const t = Su(e._queryParams), r = e._path.toString(), a = new Pe.BH; return this.restRequest_(r + ".json", t, (d, _) => { let E = _; 404 === d && (E = null, d = null), null === d ? (this.onDataUpdate_(r, E, !1, null), a.resolve(E)) : a.reject(new Error(E)) }), a.promise } refreshAuthToken(e) { } restRequest_(e, t = {}, r) { return t.format = "export", Promise.all([this.authTokenProvider_.getToken(!1), this.appCheckTokenProvider_.getToken(!1)]).then(([a, d]) => { a && a.accessToken && (t.auth = a.accessToken), d && d.token && (t.ac = d.token); const _ = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + e + "?ns=" + this.repoInfo_.namespace + (0, Pe.xO)(t); this.log_("Sending REST request for " + _); const E = new XMLHttpRequest; E.onreadystatechange = () => { if (r && 4 === E.readyState) { this.log_("REST Response for " + _ + " received. status:", E.status, "response:", E.responseText); let x = null; if (E.status >= 200 && E.status < 300) { try { x = (0, Pe.cI)(E.responseText) } catch { Wi("Failed to parse JSON response for " + _ + ": " + E.responseText) } r(null, x) } else 401 !== E.status && 404 !== E.status && Wi("Got unsuccessful REST response for " + _ + " Status: " + E.status), r(E.status); r = null } }, E.open("GET", _, !0), E.send() }) } } class ea { constructor() { this.rootNode_ = ei.EMPTY_NODE } getNode(e) { return this.rootNode_.getChild(e) } updateSnapshot(e, t) { this.rootNode_ = this.rootNode_.updateChild(e, t) } } function Th() { return { value: null, children: new Map } } function Dh(n, e, t) { if (Xr(e)) n.value = t, n.children.clear(); else if (null !== n.value) n.value = n.value.updateChild(e, t); else { const r = Qr(e); n.children.has(r) || n.children.set(r, Th()), Dh(n.children.get(r), e = ts(e), t) } } function Cd(n, e) { if (Xr(e)) return n.value = null, n.children.clear(), !0; if (null !== n.value) { if (n.value.isLeafNode()) return !1; { const t = n.value; return n.value = null, t.forEachChild(ui, (r, a) => { Dh(n, new Zi(r), a) }), Cd(n, e) } } if (n.children.size > 0) { const t = Qr(e); return e = ts(e), n.children.has(t) && Cd(n.children.get(t), e) && n.children.delete(t), 0 === n.children.size } return !0 } function Ed(n, e, t) { null !== n.value ? t(e, n.value) : function Xv(n, e) { n.children.forEach((t, r) => { e(r, t) }) }(n, (r, a) => { Ed(a, new Zi(e.toString() + "/" + r), t) }) } class Ju { constructor(e) { this.collection_ = e, this.last_ = null } get() { const e = this.collection_.get(), t = Object.assign({}, e); return this.last_ && vi(this.last_, (r, a) => { t[r] = t[r] - a }), this.last_ = e, t } } class Sh { constructor(e, t) { this.server_ = t, this.statsToReport_ = {}, this.statsListener_ = new Ju(e); const r = 1e4 + 2e4 * Math.random(); Ir(this.reportStats_.bind(this), Math.floor(r)) } reportStats_() { const e = this.statsListener_.get(), t = {}; let r = !1; vi(e, (a, d) => { d > 0 && (0, Pe.r3)(this.statsToReport_, a) && (t[a] = d, r = !0) }), r && this.server_.reportStats(t), Ir(this.reportStats_.bind(this), Math.floor(2 * Math.random() * 3e5)) } } var Bc = (() => { return (n = Bc || (Bc = {}))[n.OVERWRITE = 0] = "OVERWRITE", n[n.MERGE = 1] = "MERGE", n[n.ACK_USER_WRITE = 2] = "ACK_USER_WRITE", n[n.LISTEN_COMPLETE = 3] = "LISTEN_COMPLETE", Bc; var n })(); function Ih(n) { return { fromUser: !1, fromServer: !0, queryId: n, tagged: !0 } } class Zd { constructor(e, t, r) { this.path = e, this.affectedTree = t, this.revert = r, this.type = Bc.ACK_USER_WRITE, this.source = { fromUser: !0, fromServer: !1, queryId: null, tagged: !1 } } operationForChild(e) { if (Xr(this.path)) { if (null != this.affectedTree.value) return (0, Pe.hu)(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths."), this; { const t = this.affectedTree.subtree(new Zi(e)); return new Zd(Oi(), t, this.revert) } } return (0, Pe.hu)(Qr(this.path) === e, "operationForChild called for unrelated child."), new Zd(ts(this.path), this.affectedTree, this.revert) } } class qd { constructor(e, t) { this.source = e, this.path = t, this.type = Bc.LISTEN_COMPLETE } operationForChild(e) { return Xr(this.path) ? new qd(this.source, Oi()) : new qd(this.source, ts(this.path)) } } class ks { constructor(e, t, r) { this.source = e, this.path = t, this.snap = r, this.type = Bc.OVERWRITE } operationForChild(e) { return Xr(this.path) ? new ks(this.source, Oi(), this.snap.getImmediateChild(e)) : new ks(this.source, ts(this.path), this.snap) } } class ou { constructor(e, t, r) { this.source = e, this.path = t, this.children = r, this.type = Bc.MERGE } operationForChild(e) { if (Xr(this.path)) { const t = this.children.subtree(new Zi(e)); return t.isEmpty() ? null : t.value ? new ks(this.source, Oi(), t.value) : new ou(this.source, Oi(), t) } return (0, Pe.hu)(Qr(this.path) === e, "Can't get a merge for a child not on the path of the operation"), new ou(this.source, ts(this.path), this.children) } toString() { return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")" } } class Yd { constructor(e, t, r) { this.node_ = e, this.fullyInitialized_ = t, this.filtered_ = r } isFullyInitialized() { return this.fullyInitialized_ } isFiltered() { return this.filtered_ } isCompleteForPath(e) { if (Xr(e)) return this.isFullyInitialized() && !this.filtered_; const t = Qr(e); return this.isCompleteForChild(t) } isCompleteForChild(e) { return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(e) } getNode() { return this.node_ } } class Vc { constructor(e) { this.query_ = e, this.index_ = this.query_._queryParams.getIndex() } } function A(n, e, t, r, a, d) { const _ = r.filter(E => E.type === t); _.sort((E, x) => function T(n, e, t) { if (null == e.childName || null == t.childName) throw (0, Pe.g5)("Should only compare child_ events."); const r = new si(e.childName, e.snapshotNode), a = new si(t.childName, t.snapshotNode); return n.index_.compare(r, a) }(n, E, x)), _.forEach(E => { const x = function p(n, e, t) { return "value" === e.type || "child_removed" === e.type || (e.prevName = t.getPredecessorChildName(e.childName, e.snapshotNode, n.index_)), e }(n, E, d); a.forEach(B => { B.respondsTo(E.type) && e.push(B.createEvent(x, n.query_)) }) }) } function P(n, e) { return { eventCache: n, serverCache: e } } function Y(n, e, t, r) { return P(new Yd(e, t, r), n.serverCache) } function Re(n, e, t, r) { return P(n.eventCache, new Yd(e, t, r)) } function Ke(n) { return n.eventCache.isFullyInitialized() ? n.eventCache.getNode() : null } function yt(n) { return n.serverCache.isFullyInitialized() ? n.serverCache.getNode() : null } let Vt; class vn { constructor(e, t = (() => (Vt || (Vt = new to(Qo)), Vt))()) { this.value = e, this.children = t } static fromObject(e) { let t = new vn(null); return vi(e, (r, a) => { t = t.set(new Zi(r), a) }), t } isEmpty() { return null === this.value && this.children.isEmpty() } findRootMostMatchingPathAndValue(e, t) { if (null != this.value && t(this.value)) return { path: Oi(), value: this.value }; if (Xr(e)) return null; { const r = Qr(e), a = this.children.get(r); if (null !== a) { const d = a.findRootMostMatchingPathAndValue(ts(e), t); return null != d ? { path: Hs(new Zi(r), d.path), value: d.value } : null } return null } } findRootMostValueAndPath(e) { return this.findRootMostMatchingPathAndValue(e, () => !0) } subtree(e) { if (Xr(e)) return this; { const t = Qr(e), r = this.children.get(t); return null !== r ? r.subtree(ts(e)) : new vn(null) } } set(e, t) { if (Xr(e)) return new vn(t, this.children); { const r = Qr(e), d = (this.children.get(r) || new vn(null)).set(ts(e), t), _ = this.children.insert(r, d); return new vn(this.value, _) } } remove(e) { if (Xr(e)) return this.children.isEmpty() ? new vn(null) : new vn(null, this.children); { const t = Qr(e), r = this.children.get(t); if (r) { const a = r.remove(ts(e)); let d; return d = a.isEmpty() ? this.children.remove(t) : this.children.insert(t, a), null === this.value && d.isEmpty() ? new vn(null) : new vn(this.value, d) } return this } } get(e) { if (Xr(e)) return this.value; { const t = Qr(e), r = this.children.get(t); return r ? r.get(ts(e)) : null } } setTree(e, t) { if (Xr(e)) return t; { const r = Qr(e), d = (this.children.get(r) || new vn(null)).setTree(ts(e), t); let _; return _ = d.isEmpty() ? this.children.remove(r) : this.children.insert(r, d), new vn(this.value, _) } } fold(e) { return this.fold_(Oi(), e) } fold_(e, t) { const r = {}; return this.children.inorderTraversal((a, d) => { r[a] = d.fold_(Hs(e, a), t) }), t(e, this.value, r) } findOnPath(e, t) { return this.findOnPath_(e, Oi(), t) } findOnPath_(e, t, r) { const a = !!this.value && r(t, this.value); if (a) return a; if (Xr(e)) return null; { const d = Qr(e), _ = this.children.get(d); return _ ? _.findOnPath_(ts(e), Hs(t, d), r) : null } } foreachOnPath(e, t) { return this.foreachOnPath_(e, Oi(), t) } foreachOnPath_(e, t, r) { if (Xr(e)) return this; { this.value && r(t, this.value); const a = Qr(e), d = this.children.get(a); return d ? d.foreachOnPath_(ts(e), Hs(t, a), r) : new vn(null) } } foreach(e) { this.foreach_(Oi(), e) } foreach_(e, t) { this.children.inorderTraversal((r, a) => { a.foreach_(Hs(e, r), t) }), this.value && t(e, this.value) } foreachChild(e) { this.children.inorderTraversal((t, r) => { r.value && e(t, r.value) }) } } class In { constructor(e) { this.writeTree_ = e } static empty() { return new In(new vn(null)) } } function Un(n, e, t) { if (Xr(e)) return new In(new vn(t)); { const r = n.writeTree_.findRootMostValueAndPath(e); if (null != r) { const a = r.path; let d = r.value; const _ = ws(a, e); return d = d.updateChild(_, t), new In(n.writeTree_.set(a, d)) } { const a = new vn(t), d = n.writeTree_.setTree(e, a); return new In(d) } } } function bi(n, e, t) { let r = n; return vi(t, (a, d) => { r = Un(r, Hs(e, a), d) }), r } function Cr(n, e) { if (Xr(e)) return In.empty(); { const t = n.writeTree_.setTree(e, new vn(null)); return new In(t) } } function qr(n, e) { return null != oi(n, e) } function oi(n, e) { const t = n.writeTree_.findRootMostValueAndPath(e); return null != t ? n.writeTree_.get(t.path).getChild(ws(t.path, e)) : null } function ki(n) { const e = [], t = n.writeTree_.value; return null != t ? t.isLeafNode() || t.forEachChild(ui, (r, a) => { e.push(new si(r, a)) }) : n.writeTree_.children.inorderTraversal((r, a) => { null != a.value && e.push(new si(r, a.value)) }), e } function qi(n, e) { if (Xr(e)) return n; { const t = oi(n, e); return new In(null != t ? new vn(t) : n.writeTree_.subtree(e)) } } function Ri(n) { return n.writeTree_.isEmpty() } function di(n, e) { return zi(Oi(), n.writeTree_, e) } function zi(n, e, t) { if (null != e.value) return t.updateChild(n, e.value); { let r = null; return e.children.inorderTraversal((a, d) => { ".priority" === a ? ((0, Pe.hu)(null !== d.value, "Priority writes must always be leaf nodes"), r = d.value) : t = zi(Hs(n, a), d, t) }), !t.getChild(n).isEmpty() && null !== r && (t = t.updateChild(Hs(n, ".priority"), r)), t } } function gs(n, e) { return Cm(e, n) } function au(n, e) { if (n.snap) return Ua(n.path, e); for (const t in n.children) if (n.children.hasOwnProperty(t) && Ua(Hs(n.path, t), e)) return !0; return !1 } function Iu(n) { return n.visible } function Ul(n, e, t) { let r = In.empty(); for (let a = 0; a < n.length; ++a) { const d = n[a]; if (e(d)) { const _ = d.path; let E; if (d.snap) Ua(t, _) ? (E = ws(t, _), r = Un(r, E, d.snap)) : Ua(_, t) && (E = ws(_, t), r = Un(r, Oi(), d.snap.getChild(E))); else { if (!d.children) throw (0, Pe.g5)("WriteRecord should have .snap or .children"); if (Ua(t, _)) E = ws(t, _), r = bi(r, E, d.children); else if (Ua(_, t)) if (E = ws(_, t), Xr(E)) r = bi(r, Oi(), d.children); else { const x = (0, Pe.DV)(d.children, Qr(E)); if (x) { const B = x.getChild(ts(E)); r = Un(r, Oi(), B) } } } } } return r } function Sl(n, e, t, r, a) { if (r || a) { const d = qi(n.visibleWrites, e); return !a && Ri(d) ? t : a || null != t || qr(d, Oi()) ? di(Ul(n.allWrites, function (B) { return (B.visible || a) && (!r || !~r.indexOf(B.writeId)) && (Ua(B.path, e) || Ua(e, B.path)) }, e), t || ei.EMPTY_NODE) : null } { const d = oi(n.visibleWrites, e); if (null != d) return d; { const _ = qi(n.visibleWrites, e); return Ri(_) ? t : null != t || qr(_, Oi()) ? di(_, t || ei.EMPTY_NODE) : null } } } function Jd(n, e, t, r) { return Sl(n.writeTree, n.treePath, e, t, r) } function Sd(n, e) { return function cc(n, e, t) { let r = ei.EMPTY_NODE; const a = oi(n.visibleWrites, e); if (a) return a.isLeafNode() || a.forEachChild(ui, (d, _) => { r = r.updateImmediateChild(d, _) }), r; if (t) { const d = qi(n.visibleWrites, e); return t.forEachChild(ui, (_, E) => { const x = di(qi(d, new Zi(_)), E); r = r.updateImmediateChild(_, x) }), ki(d).forEach(_ => { r = r.updateImmediateChild(_.name, _.node) }), r } return ki(qi(n.visibleWrites, e)).forEach(_ => { r = r.updateImmediateChild(_.name, _.node) }), r }(n.writeTree, n.treePath, e) } function Au(n, e, t, r) { return function Vf(n, e, t, r, a) { (0, Pe.hu)(r || a, "Either existingEventSnap or existingServerSnap must exist"); const d = Hs(e, t); if (qr(n.visibleWrites, d)) return null; { const _ = qi(n.visibleWrites, d); return Ri(_) ? a.getChild(t) : di(_, a.getChild(t)) } }(n.writeTree, n.treePath, e, t, r) } function Qd(n, e) { return function Jh(n, e) { return oi(n.visibleWrites, e) }(n.writeTree, Hs(n.treePath, e)) } function ed(n, e, t) { return function Kd(n, e, t, r) { const a = Hs(e, t), d = oi(n.visibleWrites, a); return null != d ? d : r.isCompleteForChild(t) ? di(qi(n.visibleWrites, a), r.getNode().getImmediateChild(t)) : null }(n.writeTree, n.treePath, e, t) } function ef(n, e) { return Cm(Hs(n.treePath, e), n.writeTree) } function Cm(n, e) { return { treePath: n, writeTree: e } } class bp { constructor() { this.changeMap = new Map } trackChildChange(e) { const t = e.type, r = e.childName; (0, Pe.hu)("child_added" === t || "child_changed" === t || "child_removed" === t, "Only child changes supported for tracking"), (0, Pe.hu)(".priority" !== r, "Only non-priority child changes can be tracked."); const a = this.changeMap.get(r); if (a) { const d = a.type; if ("child_added" === t && "child_removed" === d) this.changeMap.set(r, ge(r, e.snapshotNode, a.snapshotNode)); else if ("child_removed" === t && "child_added" === d) this.changeMap.delete(r); else if ("child_removed" === t && "child_changed" === d) this.changeMap.set(r, ie(r, a.oldSnap)); else if ("child_changed" === t && "child_added" === d) this.changeMap.set(r, F(r, e.snapshotNode)); else { if ("child_changed" !== t || "child_changed" !== d) throw (0, Pe.g5)("Illegal combination of changes: " + e + " occurred after " + a); this.changeMap.set(r, ge(r, e.snapshotNode, a.oldSnap)) } } else this.changeMap.set(r, e) } getChanges() { return Array.from(this.changeMap.values()) } } const wp = new class tf { getCompleteChild(e) { return null } getChildAfterChild(e, t, r) { return null } }; class Id { constructor(e, t, r = null) { this.writes_ = e, this.viewCache_ = t, this.optCompleteServerCache_ = r } getCompleteChild(e) { const t = this.viewCache_.eventCache; if (t.isCompleteForChild(e)) return t.getNode().getImmediateChild(e); { const r = null != this.optCompleteServerCache_ ? new Yd(this.optCompleteServerCache_, !0, !1) : this.viewCache_.serverCache; return ed(this.writes_, e, r) } } getChildAfterChild(e, t, r) { const a = null != this.optCompleteServerCache_ ? this.optCompleteServerCache_ : yt(this.viewCache_), d = function Xh(n, e, t, r, a, d) { return function Dd(n, e, t, r, a, d, _) { let E; const x = qi(n.visibleWrites, e), B = oi(x, Oi()); if (null != B) E = B; else { if (null == t) return []; E = di(x, t) } if (E = E.withIndex(_), E.isEmpty() || E.isLeafNode()) return []; { const K = [], oe = _.getCompare(), Me = d ? E.getReverseIteratorFrom(r, _) : E.getIteratorFrom(r, _); let ot = Me.getNext(); for (; ot && K.length < a;)0 !== oe(ot, r) && K.push(ot), ot = Me.getNext(); return K } }(n.writeTree, n.treePath, e, t, r, a, d) }(this.writes_, a, t, 1, r, e); return 0 === d.length ? null : d[0] } } function Eg(n, e, t, r, a, d) { const _ = e.eventCache; if (null != Qd(r, t)) return e; { let E, x; if (Xr(t)) if ((0, Pe.hu)(e.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data"), e.serverCache.isFiltered()) { const B = yt(e), oe = Sd(r, B instanceof ei ? B : ei.EMPTY_NODE); E = n.filter.updateFullNode(e.eventCache.getNode(), oe, d) } else { const B = Jd(r, yt(e)); E = n.filter.updateFullNode(e.eventCache.getNode(), B, d) } else { const B = Qr(t); if (".priority" === B) { (0, Pe.hu)(1 === rc(t), "Can't have a priority with additional path components"); const K = _.getNode(); x = e.serverCache.getNode(); const oe = Au(r, t, K, x); E = null != oe ? n.filter.updatePriority(K, oe) : _.getNode() } else { const K = ts(t); let oe; if (_.isCompleteForChild(B)) { x = e.serverCache.getNode(); const Me = Au(r, t, _.getNode(), x); oe = null != Me ? _.getNode().getImmediateChild(B).updateChild(K, Me) : _.getNode().getImmediateChild(B) } else oe = ed(r, B, e.serverCache); E = null != oe ? n.filter.updateChild(_.getNode(), B, oe, K, a, d) : _.getNode() } } return Y(e, E, _.isFullyInitialized() || Xr(t), n.filter.filtersNodes()) } } function xu(n, e, t, r, a, d, _, E) { const x = e.serverCache; let B; const K = _ ? n.filter : n.filter.getIndexedFilter(); if (Xr(t)) B = K.updateFullNode(x.getNode(), r, null); else if (K.filtersNodes() && !x.isFiltered()) { const ot = x.getNode().updateChild(t, r); B = K.updateFullNode(x.getNode(), ot, null) } else { const ot = Qr(t); if (!x.isCompleteForPath(t) && rc(t) > 1) return e; const bt = ts(t), Tn = x.getNode().getImmediateChild(ot).updateChild(bt, r); B = ".priority" === ot ? K.updatePriority(x.getNode(), Tn) : K.updateChild(x.getNode(), ot, Tn, bt, wp, null) } const oe = Re(e, B, x.isFullyInitialized() || Xr(t), K.filtersNodes()); return Eg(n, oe, t, a, new Id(a, oe, d), E) } function Xd(n, e, t, r, a, d, _) { const E = e.eventCache; let x, B; const K = new Id(a, e, d); if (Xr(t)) B = n.filter.updateFullNode(e.eventCache.getNode(), r, _), x = Y(e, B, !0, n.filter.filtersNodes()); else { const oe = Qr(t); if (".priority" === oe) B = n.filter.updatePriority(e.eventCache.getNode(), r), x = Y(e, B, E.isFullyInitialized(), E.isFiltered()); else { const Me = ts(t), ot = E.getNode().getImmediateChild(oe); let bt; if (Xr(Me)) bt = r; else { const qt = K.getCompleteChild(oe); bt = null != qt ? ".priority" === ic(Me) && qt.getChild($u(Me)).isEmpty() ? qt : qt.updateChild(Me, r) : ei.EMPTY_NODE } x = ot.equals(bt) ? e : Y(e, n.filter.updateChild(E.getNode(), oe, bt, Me, K, _), E.isFullyInitialized(), n.filter.filtersNodes()) } } return x } function Ad(n, e) { return n.eventCache.isCompleteForChild(e) } function uc(n, e, t) { return t.foreach((r, a) => { e = e.updateChild(r, a) }), e } function zf(n, e, t, r, a, d, _, E) { if (e.serverCache.getNode().isEmpty() && !e.serverCache.isFullyInitialized()) return e; let B, x = e; B = Xr(t) ? r : new vn(null).setTree(t, r); const K = e.serverCache.getNode(); return B.children.inorderTraversal((oe, Me) => { if (K.hasChild(oe)) { const bt = uc(0, e.serverCache.getNode().getImmediateChild(oe), Me); x = xu(n, x, new Zi(oe), bt, a, d, _, E) } }), B.children.inorderTraversal((oe, Me) => { const ot = !e.serverCache.isCompleteForChild(oe) && null === Me.value; if (!K.hasChild(oe) && !ot) { const qt = uc(0, e.serverCache.getNode().getImmediateChild(oe), Me); x = xu(n, x, new Zi(oe), qt, a, d, _, E) } }), x } class e0 { constructor(e, t) { this.query_ = e, this.eventRegistrations_ = []; const r = this.query_._queryParams, a = new tn(r.getIndex()), d = function yr(n) { return n.loadsAllData() ? new tn(n.getIndex()) : n.hasLimit() ? new tr(n) : new Pn(n) }(r); this.processor_ = function nf(n) { return { filter: n } }(d); const _ = t.serverCache, E = t.eventCache, x = a.updateFullNode(ei.EMPTY_NODE, _.getNode(), null), B = d.updateFullNode(ei.EMPTY_NODE, E.getNode(), null), K = new Yd(x, _.isFullyInitialized(), a.filtersNodes()), oe = new Yd(B, E.isFullyInitialized(), d.filtersNodes()); this.viewCache_ = P(oe, K), this.eventGenerator_ = new Vc(this.query_) } get query() { return this.query_ } } function oy(n, e) { const t = yt(n.viewCache_); return t && (n.query._queryParams.loadsAllData() || !Xr(e) && !t.getImmediateChild(Qr(e)).isEmpty()) ? t.getChild(e) : null } function Tm(n) { return 0 === n.eventRegistrations_.length } function rf(n, e, t) { const r = []; if (t) { (0, Pe.hu)(null == e, "A cancel should cancel all event registrations."); const a = n.query._path; n.eventRegistrations_.forEach(d => { const _ = d.createCancelEvent(t, a); _ && r.push(_) }) } if (e) { let a = []; for (let d = 0; d < n.eventRegistrations_.length; ++d) { const _ = n.eventRegistrations_[d]; if (_.matches(e)) { if (e.hasAnyCallback()) { a = a.concat(n.eventRegistrations_.slice(d + 1)); break } } else a.push(_) } n.eventRegistrations_ = a } else n.eventRegistrations_ = []; return r } function xd(n, e, t, r) { e.type === Bc.MERGE && null !== e.source.queryId && ((0, Pe.hu)(yt(n.viewCache_), "We should always have a full cache before handling merges"), (0, Pe.hu)(Ke(n.viewCache_), "Missing event cache, even though we have a server cache")); const a = n.viewCache_, d = function Uf(n, e, t, r, a) { const d = new bp; let _, E; if (t.type === Bc.OVERWRITE) { const B = t; B.source.fromUser ? _ = Xd(n, e, B.path, B.snap, r, a, d) : ((0, Pe.hu)(B.source.fromServer, "Unknown source."), E = B.source.tagged || e.serverCache.isFiltered() && !Xr(B.path), _ = xu(n, e, B.path, B.snap, r, a, E, d)) } else if (t.type === Bc.MERGE) { const B = t; B.source.fromUser ? _ = function Hf(n, e, t, r, a, d, _) { let E = e; return r.foreach((x, B) => { const K = Hs(t, x); Ad(e, Qr(K)) && (E = Xd(n, E, K, B, a, d, _)) }), r.foreach((x, B) => { const K = Hs(t, x); Ad(e, Qr(K)) || (E = Xd(n, E, K, B, a, d, _)) }), E }(n, e, B.path, B.children, r, a, d) : ((0, Pe.hu)(B.source.fromServer, "Unknown source."), E = B.source.tagged || e.serverCache.isFiltered(), _ = zf(n, e, B.path, B.children, r, a, E, d)) } else if (t.type === Bc.ACK_USER_WRITE) { const B = t; _ = B.revert ? function Tg(n, e, t, r, a, d) { let _; if (null != Qd(r, t)) return e; { const E = new Id(r, e, a), x = e.eventCache.getNode(); let B; if (Xr(t) || ".priority" === Qr(t)) { let K; if (e.serverCache.isFullyInitialized()) K = Jd(r, yt(e)); else { const oe = e.serverCache.getNode(); (0, Pe.hu)(oe instanceof ei, "serverChildren would be complete if leaf node"), K = Sd(r, oe) } B = n.filter.updateFullNode(x, K, d) } else { const K = Qr(t); let oe = ed(r, K, e.serverCache); null == oe && e.serverCache.isCompleteForChild(K) && (oe = x.getImmediateChild(K)), B = null != oe ? n.filter.updateChild(x, K, oe, ts(t), E, d) : e.eventCache.getNode().hasChild(K) ? n.filter.updateChild(x, K, ei.EMPTY_NODE, ts(t), E, d) : x, B.isEmpty() && e.serverCache.isFullyInitialized() && (_ = Jd(r, yt(e)), _.isLeafNode() && (B = n.filter.updateFullNode(B, _, d))) } return _ = e.serverCache.isFullyInitialized() || null != Qd(r, Oi()), Y(e, B, _, n.filter.filtersNodes()) } }(n, e, B.path, r, a, d) : function Gf(n, e, t, r, a, d, _) { if (null != Qd(a, t)) return e; const E = e.serverCache.isFiltered(), x = e.serverCache; if (null != r.value) { if (Xr(t) && x.isFullyInitialized() || x.isCompleteForPath(t)) return xu(n, e, t, x.getNode().getChild(t), a, d, E, _); if (Xr(t)) { let B = new vn(null); return x.getNode().forEachChild(Po, (K, oe) => { B = B.set(new Zi(K), oe) }), zf(n, e, t, B, a, d, E, _) } return e } { let B = new vn(null); return r.foreach((K, oe) => { const Me = Hs(t, K); x.isCompleteForPath(Me) && (B = B.set(K, x.getNode().getChild(Me))) }), zf(n, e, t, B, a, d, E, _) } }(n, e, B.path, B.affectedTree, r, a, d) } else { if (t.type !== Bc.LISTEN_COMPLETE) throw (0, Pe.g5)("Unknown operation type: " + t.type); _ = function Ah(n, e, t, r, a) { const d = e.serverCache; return Eg(n, Re(e, d.getNode(), d.isFullyInitialized() || Xr(t), d.isFiltered()), t, r, wp, a) }(n, e, t.path, r, d) } const x = d.getChanges(); return function Em(n, e, t) { const r = e.eventCache; if (r.isFullyInitialized()) { const a = r.getNode().isLeafNode() || r.getNode().isEmpty(), d = Ke(n); (t.length > 0 || !n.eventCache.isFullyInitialized() || a && !r.getNode().equals(d) || !r.getNode().getPriority().equals(d.getPriority())) && t.push(S(Ke(e))) } }(e, _, x), { viewCache: _, changes: x } }(n.processor_, a, e, t, r); return function Cg(n, e) { (0, Pe.hu)(e.eventCache.getNode().isIndexed(n.filter.getIndex()), "Event snap not indexed"), (0, Pe.hu)(e.serverCache.getNode().isIndexed(n.filter.getIndex()), "Server snap not indexed") }(n.processor_, d.viewCache), (0, Pe.hu)(d.viewCache.serverCache.isFullyInitialized() || !a.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back"), n.viewCache_ = d.viewCache, ay(n, d.changes, d.viewCache.eventCache.getNode(), null) } function ay(n, e, t, r) { return function v(n, e, t, r) { const a = [], d = []; return e.forEach(_ => { "child_changed" === _.type && n.index_.indexedValueChanged(_.oldSnap, _.snapshotNode) && d.push(function Tt(n, e) { return { type: "child_moved", snapshotNode: e, childName: n } }(_.childName, _.snapshotNode)) }), A(n, a, "child_removed", e, r, t), A(n, a, "child_added", e, r, t), A(n, a, "child_moved", d, r, t), A(n, a, "child_changed", e, r, t), A(n, a, "value", e, r, t), a }(n.eventGenerator_, e, t, r ? [r] : n.eventRegistrations_) } let Dm, xh; class o0 { constructor() { this.views = new Map } } function Dg(n, e, t, r) { const a = e.source.queryId; if (null !== a) { const d = n.views.get(a); return (0, Pe.hu)(null != d, "SyncTree gave us an op for an invalid query."), xd(d, e, t, r) } { let d = []; for (const _ of n.views.values()) d = d.concat(xd(_, e, t, r)); return d } } function uy(n, e, t, r, a) { const _ = n.views.get(e._queryIdentifier); if (!_) { let E = Jd(t, a ? r : null), x = !1; E ? x = !0 : r instanceof ei ? (E = Sd(t, r), x = !1) : (E = ei.EMPTY_NODE, x = !1); const B = P(new Yd(E, x, !1), new Yd(r, a, !1)); return new e0(e, B) } return _ } function jf(n) { const e = []; for (const t of n.views.values()) t.query._queryParams.loadsAllData() || e.push(t); return e } function Lo(n, e) { let t = null; for (const r of n.views.values()) t = t || oy(r, e); return t } function hy(n, e) { return e._queryParams.loadsAllData() ? Md(n) : n.views.get(e._queryIdentifier) } function Sm(n, e) { return null != hy(n, e) } function td(n) { return null != Md(n) } function Md(n) { for (const e of n.views.values()) if (e.query._queryParams.loadsAllData()) return e; return null } let fy = 1; class sf { constructor(e) { this.listenProvider_ = e, this.syncPointTree_ = new vn(null), this.pendingWriteTree_ = function Qh() { return { visibleWrites: In.empty(), allWrites: [], lastWriteId: -1 } }(), this.tagToQueryMap = new Map, this.queryToTagMap = new Map } } function Im(n, e, t, r, a) { return function Yi(n, e, t, r, a) { (0, Pe.hu)(r > n.lastWriteId, "Stacking an older write on top of newer ones"), void 0 === a && (a = !0), n.allWrites.push({ path: e, snap: t, writeId: r, visible: a }), a && (n.visibleWrites = Un(n.visibleWrites, e, t)), n.lastWriteId = r }(n.pendingWriteTree_, e, t, r, a), a ? af(n, new ks({ fromUser: !0, fromServer: !1, queryId: null, tagged: !1 }, e, t)) : [] } function eh(n, e, t = !1) { const r = function Fo(n, e) { for (let t = 0; t < n.allWrites.length; t++) { const r = n.allWrites[t]; if (r.writeId === e) return r } return null }(n.pendingWriteTree_, e); if (function co(n, e) { const t = n.allWrites.findIndex(E => E.writeId === e); (0, Pe.hu)(t >= 0, "removeWrite called with nonexistent writeId."); const r = n.allWrites[t]; n.allWrites.splice(t, 1); let a = r.visible, d = !1, _ = n.allWrites.length - 1; for (; a && _ >= 0;) { const E = n.allWrites[_]; E.visible && (_ >= t && au(E, r.path) ? a = !1 : Ua(r.path, E.path) && (d = !0)), _-- } return !!a && (d ? (function Ha(n) { n.visibleWrites = Ul(n.allWrites, Iu, Oi()), n.lastWriteId = n.allWrites.length > 0 ? n.allWrites[n.allWrites.length - 1].writeId : -1 }(n), !0) : (r.snap ? n.visibleWrites = Cr(n.visibleWrites, r.path) : vi(r.children, x => { n.visibleWrites = Cr(n.visibleWrites, Hs(r.path, x)) }), !0)) }(n.pendingWriteTree_, e)) { let d = new vn(null); return null != r.snap ? d = d.set(Oi(), !0) : vi(r.children, _ => { d = d.set(new Zi(_), !0) }), af(n, new Zd(r.path, d, t)) } return [] } function $f(n, e, t) { return af(n, new ks({ fromUser: !1, fromServer: !0, queryId: null, tagged: !1 }, e, t)) } function Cp(n, e, t, r, a = !1) { const d = e._path, _ = n.syncPointTree_.get(d); let E = []; if (_ && ("default" === e._queryIdentifier || Sm(_, e))) { const x = function a0(n, e, t, r) { const a = e._queryIdentifier, d = []; let _ = []; const E = td(n); if ("default" === a) for (const [x, B] of n.views.entries()) _ = _.concat(rf(B, t, r)), Tm(B) && (n.views.delete(x), B.query._queryParams.loadsAllData() || d.push(B.query)); else { const x = n.views.get(a); x && (_ = _.concat(rf(x, t, r)), Tm(x) && (n.views.delete(a), x.query._queryParams.loadsAllData() || d.push(x.query))) } return E && !td(n) && d.push(new (function Uw() { return (0, Pe.hu)(Dm, "Reference.ts has not been loaded"), Dm }())(e._repo, e._path)), { removed: d, events: _ } }(_, e, t, r); (function cy(n) { return 0 === n.views.size })(_) && (n.syncPointTree_ = n.syncPointTree_.remove(d)); const B = x.removed; if (E = x.events, !a) { const K = -1 !== B.findIndex(Me => Me._queryParams.loadsAllData()), oe = n.syncPointTree_.findOnPath(d, (Me, ot) => td(ot)); if (K && !oe) { const Me = n.syncPointTree_.subtree(d); if (!Me.isEmpty()) { const ot = function zw(n) { return n.fold((e, t, r) => { if (t && td(t)) return [Md(t)]; { let a = []; return t && (a = jf(t)), vi(r, (d, _) => { a = a.concat(_) }), a } }) }(Me); for (let bt = 0; bt < ot.length; ++bt) { const qt = ot[bt], Tn = qt.query, cr = _y(n, qt); n.listenProvider_.startListening(Ep(Tn), lf(n, Tn), cr.hashFn, cr.onComplete) } } } !oe && B.length > 0 && !r && (K ? n.listenProvider_.stopListening(Ep(e), null) : B.forEach(Me => { const ot = n.queryToTagMap.get(Wf(Me)); n.listenProvider_.stopListening(Ep(Me), ot) })) } !function by(n, e) { for (let t = 0; t < e.length; ++t) { const r = e[t]; if (!r._queryParams.loadsAllData()) { const a = Wf(r), d = n.queryToTagMap.get(a); n.queryToTagMap.delete(a), n.tagToQueryMap.delete(d) } } }(n, B) } return E } function gy(n, e, t, r) { const a = Mm(n, r); if (null != a) { const d = yy(a), _ = d.path, E = d.queryId, x = ws(_, e); return vy(n, _, new ks(Ih(E), x, t)) } return [] } function Am(n, e, t, r = !1) { const a = e._path; let d = null, _ = !1; n.syncPointTree_.foreachOnPath(a, (Me, ot) => { const bt = ws(Me, a); d = d || Lo(ot, bt), _ = _ || td(ot) }); let x, E = n.syncPointTree_.get(a); E ? (_ = _ || td(E), d = d || Lo(E, Oi())) : (E = new o0, n.syncPointTree_ = n.syncPointTree_.set(a, E)), null != d ? x = !0 : (x = !1, d = ei.EMPTY_NODE, n.syncPointTree_.subtree(a).foreachChild((ot, bt) => { const qt = Lo(bt, Oi()); qt && (d = d.updateImmediateChild(ot, qt)) })); const B = Sm(E, e); if (!B && !e._queryParams.loadsAllData()) { const Me = Wf(e); (0, Pe.hu)(!n.queryToTagMap.has(Me), "View does not exist, but we have a tag"); const ot = function Gw() { return fy++ }(); n.queryToTagMap.set(Me, ot), n.tagToQueryMap.set(ot, Me) } let oe = function dy(n, e, t, r, a, d) { const _ = uy(n, e, r, a, d); return n.views.has(e._queryIdentifier) || n.views.set(e._queryIdentifier, _), function r0(n, e) { n.eventRegistrations_.push(e) }(_, t), function s0(n, e) { const t = n.viewCache_.eventCache, r = []; return t.getNode().isLeafNode() || t.getNode().forEachChild(ui, (d, _) => { r.push(F(d, _)) }), t.isFullyInitialized() && r.push(S(t.getNode())), ay(n, r, t.getNode(), e) }(_, t) }(E, e, t, gs(n.pendingWriteTree_, a), d, x); if (!B && !_ && !r) { const Me = hy(E, e); oe = oe.concat(function Ag(n, e, t) { const r = e._path, a = lf(n, e), d = _y(n, t), _ = n.listenProvider_.startListening(Ep(e), a, d.hashFn, d.onComplete), E = n.syncPointTree_.subtree(r); if (a) (0, Pe.hu)(!td(E.value), "If we're adding a query, it shouldn't be shadowed"); else { const x = E.fold((B, K, oe) => { if (!Xr(B) && K && td(K)) return [Md(K).query]; { let Me = []; return K && (Me = Me.concat(jf(K).map(ot => ot.query))), vi(oe, (ot, bt) => { Me = Me.concat(bt) }), Me } }); for (let B = 0; B < x.length; ++B) { const K = x[B]; n.listenProvider_.stopListening(Ep(K), lf(n, K)) } } return _ }(n, e, Me)) } return oe } function Ig(n, e, t) { const a = n.pendingWriteTree_, d = n.syncPointTree_.findOnPath(e, (_, E) => { const B = Lo(E, ws(_, e)); if (B) return B }); return Sl(a, e, d, t, !0) } function af(n, e) { return xm(e, n.syncPointTree_, null, gs(n.pendingWriteTree_, Oi())) } function xm(n, e, t, r) { if (Xr(n.path)) return Mh(n, e, t, r); { const a = e.get(Oi()); null == t && null != a && (t = Lo(a, Oi())); let d = []; const _ = Qr(n.path), E = n.operationForChild(_), x = e.children.get(_); if (x && E) { const B = t ? t.getImmediateChild(_) : null, K = ef(r, _); d = d.concat(xm(E, x, B, K)) } return a && (d = d.concat(Dg(a, n, r, t))), d } } function Mh(n, e, t, r) { const a = e.get(Oi()); null == t && null != a && (t = Lo(a, Oi())); let d = []; return e.children.inorderTraversal((_, E) => { const x = t ? t.getImmediateChild(_) : null, B = ef(r, _), K = n.operationForChild(_); K && (d = d.concat(Mh(K, E, x, B))) }), a && (d = d.concat(Dg(a, n, r, t))), d } function _y(n, e) { const t = e.query, r = lf(n, t); return { hashFn: () => (function t0(n) { return n.viewCache_.serverCache.getNode() }(e) || ei.EMPTY_NODE).hash(), onComplete: a => { if ("ok" === a) return r ? function u0(n, e, t) { const r = Mm(n, t); if (r) { const a = yy(r), d = a.path, _ = a.queryId, E = ws(d, e); return vy(n, d, new qd(Ih(_), E)) } return [] }(n, t._path, r) : function c0(n, e) { return af(n, new qd({ fromUser: !1, fromServer: !0, queryId: null, tagged: !1 }, e)) }(n, t._path); { const d = function We(n, e) { let t = "Unknown Error"; "too_big" === n ? t = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" === n ? t = "Client doesn't have permission to access the desired data." : "unavailable" === n && (t = "The service is unavailable"); const r = new Error(n + " at " + e._path.toString() + ": " + t); return r.code = n.toUpperCase(), r }(a, t); return Cp(n, t, null, d) } } } } function lf(n, e) { const t = Wf(e); return n.queryToTagMap.get(t) } function Wf(n) { return n._path.toString() + "$" + n._queryIdentifier } function Mm(n, e) { return n.tagToQueryMap.get(e) } function yy(n) { const e = n.indexOf("$"); return (0, Pe.hu)(-1 !== e && e < n.length - 1, "Bad queryKey."), { queryId: n.substr(e + 1), path: new Zi(n.substr(0, e)) } } function vy(n, e, t) { const r = n.syncPointTree_.get(e); return (0, Pe.hu)(r, "Missing sync point for query tag that we're tracking"), Dg(r, t, gs(n.pendingWriteTree_, e), null) } function Ep(n) { return n._queryParams.loadsAllData() && !n._queryParams.isDefault() ? new (function Sg() { return (0, Pe.hu)(xh, "Reference.ts has not been loaded"), xh }())(n._repo, n._path) : n } class th { constructor(e) { this.node_ = e } getImmediateChild(e) { const t = this.node_.getImmediateChild(e); return new th(t) } node() { return this.node_ } } class cf { constructor(e, t) { this.syncTree_ = e, this.path_ = t } getImmediateChild(e) { const t = Hs(this.path_, e); return new cf(this.syncTree_, t) } node() { return Ig(this.syncTree_, this.path_) } } const Tp = function (n, e, t) { return n && "object" == typeof n ? ((0, Pe.hu)(".sv" in n, "Unexpected leaf node or priority contents"), "string" == typeof n[".sv"] ? d0(n[".sv"], e, t) : "object" == typeof n[".sv"] ? xg(n[".sv"], e) : void (0, Pe.hu)(!1, "Unexpected server value: " + JSON.stringify(n, null, 2))) : n }, d0 = function (n, e, t) { if ("timestamp" === n) return t.timestamp; (0, Pe.hu)(!1, "Unexpected server value: " + n) }, xg = function (n, e, t) { n.hasOwnProperty("increment") || (0, Pe.hu)(!1, "Unexpected server value: " + JSON.stringify(n, null, 2)); const r = n.increment; "number" != typeof r && (0, Pe.hu)(!1, "Unexpected increment value: " + r); const a = e.node(); if ((0, Pe.hu)(null !== a && typeof a < "u", "Expected ChildrenNode.EMPTY_NODE for nulls"), !a.isLeafNode()) return r; const _ = a.getValue(); return "number" != typeof _ ? r : _ + r }, wy = function (n, e, t, r) { return nh(e, new cf(t, n), r) }, Dp = function (n, e, t) { return nh(n, new th(e), t) }; function nh(n, e, t) { const r = n.getPriority().val(), a = Tp(r, e.getImmediateChild(".priority"), t); let d; if (n.isLeafNode()) { const _ = n, E = Tp(_.getValue(), e, t); return E !== _.getValue() || a !== _.getPriority().val() ? new El(E, Zs(a)) : n } { const _ = n; return d = _, a !== _.getPriority().val() && (d = d.updatePriority(new El(a))), _.forEachChild(ui, (E, x) => { const B = nh(x, e.getImmediateChild(E), t); B !== x && (d = d.updateImmediateChild(E, B)) }), d } } class Mg { constructor(e = "", t = null, r = { children: {}, childCount: 0 }) { this.name = e, this.parent = t, this.node = r } } function rh(n, e) { let t = e instanceof Zi ? e : new Zi(e), r = n, a = Qr(t); for (; null !== a;) { const d = (0, Pe.DV)(r.node.children, a) || { children: {}, childCount: 0 }; r = new Mg(a, r, d), t = ts(t), a = Qr(t) } return r } function Oh(n) { return n.node.value } function Nm(n, e) { n.node.value = e, f0(n) } function km(n) { return n.node.childCount > 0 } function Zf(n, e) { vi(n.node.children, (t, r) => { e(new Mg(t, n, r)) }) } function h0(n, e, t, r) { t && !r && e(n), Zf(n, a => { h0(a, e, !0, r) }), t && r && e(n) } function Sp(n) { return new Zi(null === n.parent ? n.name : Sp(n.parent) + "/" + n.name) } function f0(n) { null !== n.parent && function qf(n, e, t) { const r = function Cy(n) { return void 0 === Oh(n) && !km(n) }(t), a = (0, Pe.r3)(n.node.children, e); r && a ? (delete n.node.children[e], n.node.childCount--, f0(n)) : !r && !a && (n.node.children[e] = t.node, n.node.childCount++, f0(n)) }(n.parent, n.name, n) } const Ty = /[\[\].#$\/\u0000-\u001F\u007F]/, jw = /[\[\].#$\u0000-\u001F\u007F]/, Pm = 10485760, Og = function (n) { return "string" == typeof n && 0 !== n.length && !Ty.test(n) }, Ip = function (n) { return "string" == typeof n && 0 !== n.length && !jw.test(n) }, Od = function (n) { return null === n || "string" == typeof n || "number" == typeof n && !bu(n) || n && "object" == typeof n && (0, Pe.r3)(n, ".sv") }, Mu = function (n, e, t, r) { r && void 0 === e || Nd((0, Pe.gK)(n, "value"), e, t) }, Nd = function (n, e, t) { const r = t instanceof Zi ? new Zh(t, n) : t; if (void 0 === e) throw new Error(n + "contains undefined " + iu(r)); if ("function" == typeof e) throw new Error(n + "contains a function " + iu(r) + " with contents = " + e.toString()); if (bu(e)) throw new Error(n + "contains " + e.toString() + " " + iu(r)); if ("string" == typeof e && e.length > Pm / 3 && (0, Pe.ug)(e) > Pm) throw new Error(n + "contains a string greater than " + Pm + " utf8 bytes " + iu(r) + " ('" + e.substring(0, 50) + "...')"); if (e && "object" == typeof e) { let a = !1, d = !1; if (vi(e, (_, E) => { if (".value" === _) a = !0; else if (".priority" !== _ && ".sv" !== _ && (d = !0, !Og(_))) throw new Error(n + " contains an invalid key (" + _ + ") " + iu(r) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'); (function ru(n, e) { n.parts_.length > 0 && (n.byteLength_ += 1), n.parts_.push(e), n.byteLength_ += (0, Pe.ug)(e), vh(n) })(r, _), Nd(n, E, r), function qh(n) { const e = n.parts_.pop(); n.byteLength_ -= (0, Pe.ug)(e), n.parts_.length > 0 && (n.byteLength_ -= 1) }(r) }), a && d) throw new Error(n + ' contains ".value" child ' + iu(r) + " in addition to actual children.") } }, xp = function (n, e, t, r) { if (r && void 0 === e) return; const a = (0, Pe.gK)(n, "values"); if (!e || "object" != typeof e || Array.isArray(e)) throw new Error(a + " must be an object containing the children to replace."); const d = []; vi(e, (_, E) => { const x = new Zi(_); if (Nd(a, E, Hs(t, x)), ".priority" === ic(x) && !Od(E)) throw new Error(a + "contains an invalid value for '" + x.toString() + "', which must be a valid Masterpriority (a string, finite number, server value, or null)."); d.push(x) }), function (n, e) { let t, r; for (t = 0; t < e.length; t++) { r = e[t]; const d = Cu(r); for (let _ = 0; _ < d.length; _++)if ((".priority" !== d[_] || _ !== d.length - 1) && !Og(d[_])) throw new Error(n + "contains an invalid key (" + d[_] + ") in path " + r.toString() + '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"') } e.sort(vp); let a = null; for (t = 0; t < e.length; t++) { if (r = e[t], null !== a && Ua(a, r)) throw new Error(n + "contains a path " + a.toString() + " that is ancestor of another path " + r.toString()); a = r } }(a, d) }, dc = function (n, e, t) { if (!t || void 0 !== e) { if (bu(e)) throw new Error((0, Pe.gK)(n, "priority") + "is " + e.toString() + ", but must be a valid Masterpriority (a string, finite number, server value, or null)."); if (!Od(e)) throw new Error((0, Pe.gK)(n, "priority") + "must be a valid Masterpriority (a string, finite number, server value, or null).") } }, uf = function (n, e, t, r) { if (!(r && void 0 === t || Og(t))) throw new Error((0, Pe.gK)(n, e) + 'was an invalid key = "' + t + '".  Masterkeys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").') }, df = function (n, e, t, r) { if (!(r && void 0 === t || Ip(t))) throw new Error((0, Pe.gK)(n, e) + 'was an invalid path = "' + t + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"') }, lu = function (n, e) { if (".info" === Qr(e)) throw new Error(n + " failed = Can't modify data under /.info/") }, Ng = function (n, e) { const t = e.path.toString(); if ("string" != typeof e.repoInfo.host || 0 === e.repoInfo.host.length || !Og(e.repoInfo.namespace) && "localhost" !== e.repoInfo.host.split(":")[0] || 0 !== t.length && !function (n) { return n && (n = n.replace(/^\/*\.info(\/|$)/, "/")), Ip(n) }(t)) throw new Error((0, Pe.gK)(n, "url") + 'must be a valid MasterURL and the path can\'t contain ".", "#", "$", "[", or "]".') }; class p0 { constructor() { this.eventLists_ = [], this.recursionDepth_ = 0 } } function kg(n, e) { let t = null; for (let r = 0; r < e.length; r++) { const a = e[r], d = a.getPath(); null !== t && !pd(d, t.path) && (n.eventLists_.push(t), t = null), null === t && (t = { events: [], path: d }), t.events.push(a) } t && n.eventLists_.push(t) } function Lm(n, e, t) { kg(n, t), Bm(n, r => pd(r, e)) } function cu(n, e, t) { kg(n, t), Bm(n, r => Ua(r, e) || Ua(e, r)) } function Bm(n, e) { n.recursionDepth_++; let t = !0; for (let r = 0; r < n.eventLists_.length; r++) { const a = n.eventLists_[r]; a && (e(a.path) ? (Dy(n.eventLists_[r]), n.eventLists_[r] = null) : t = !1) } t && (n.eventLists_ = []), n.recursionDepth_-- } function Dy(n) { for (let e = 0; e < n.events.length; e++) { const t = n.events[e]; if (null !== t) { n.events[e] = null; const r = t.getEventRunner(); on && Lr("event: " + t.toString()), er(r) } } } const Sy = "repo_interrupt"; class Uc { constructor(e, t, r, a) { this.repoInfo_ = e, this.forceRestClient_ = t, this.authTokenProvider_ = r, this.appCheckProvider_ = a, this.dataUpdateCount = 0, this.statsListener_ = null, this.eventQueue_ = new p0, this.nextWriteId_ = 1, this.interceptServerDataCallback_ = null, this.onDisconnect_ = Th(), this.transactionQueueTree_ = new Mg, this.persistentConnection_ = null, this.key = this.repoInfo_.toURLString() } toString() { return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host } } function f(n) { const t = n.infoData_.getNode(new Zi(".info/serverTimeOffset")).val() || 0; return (new Date).getTime() + t } function s(n) { return function (n) { return (n = n || {}).timestamp = n.timestamp || (new Date).getTime(), n }({ timestamp: f(n) }) } function l(n, e, t, r, a) { n.dataUpdateCount++; const d = new Zi(e); t = n.interceptServerDataCallback_ ? n.interceptServerDataCallback_(e, t) : t; let _ = []; if (a) if (r) { const x = (0, Pe.UI)(t, B => Zs(B)); _ = function my(n, e, t, r) { const a = Mm(n, r); if (a) { const d = yy(a), _ = d.path, E = d.queryId, x = ws(_, e), B = vn.fromObject(t); return vy(n, _, new ou(Ih(E), x, B)) } return [] }(n.serverSyncTree_, d, x, a) } else { const x = Zs(t); _ = gy(n.serverSyncTree_, d, x, a) } else if (r) { const x = (0, Pe.UI)(t, B => Zs(B)); _ = function py(n, e, t) { const r = vn.fromObject(t); return af(n, new ou({ fromUser: !1, fromServer: !0, queryId: null, tagged: !1 }, e, r)) }(n.serverSyncTree_, d, x) } else { const x = Zs(t); _ = $f(n.serverSyncTree_, d, x) } let E = d; _.length > 0 && (E = kd(n, d)), cu(n.eventQueue_, E, _) } function h(n, e) { w(n, "connected", e), !1 === e && function se(n) { za(n, "onDisconnectEvents"); const e = s(n), t = Th(); Ed(n.onDisconnect_, Oi(), (a, d) => { const _ = wy(a, d, n.serverSyncTree_, e); Dh(t, a, _) }); let r = []; Ed(t, Oi(), (a, d) => { r = r.concat($f(n.serverSyncTree_, a, d)); const _ = zm(n, a); kd(n, _) }), n.onDisconnect_ = Th(), cu(n.eventQueue_, Oi(), r) }(n) } function w(n, e, t) { const r = new Zi("/.info/" + e), a = Zs(t); n.infoData_.updateSnapshot(r, a); const d = $f(n.infoSyncTree_, r, a); cu(n.eventQueue_, r, d) } function I(n) { return n.nextWriteId_++ } function H(n, e, t, r, a) { za(n, "set", { path: e.toString(), value: t, priority: r }); const d = s(n), _ = Zs(t, r), E = Ig(n.serverSyncTree_, e), x = Dp(_, E, d), B = I(n), K = Im(n.serverSyncTree_, e, x, B, !0); kg(n.eventQueue_, K), n.server_.put(e.toString(), _.val(!0), (Me, ot) => { const bt = "ok" === Me; bt || Wi("set at " + e + " failed: " + Me); const qt = eh(n.serverSyncTree_, B, !bt); cu(n.eventQueue_, e, qt), hc(0, a, Me, ot) }); const oe = zm(n, e); kd(n, oe), cu(n.eventQueue_, oe, []) } function Ge(n, e, t) { n.server_.onDisconnectCancel(e.toString(), (r, a) => { "ok" === r && Cd(n.onDisconnect_, e), hc(0, t, r, a) }) } function at(n, e, t, r) { const a = Zs(t); n.server_.onDisconnectPut(e.toString(), a.val(!0), (d, _) => { "ok" === d && Dh(n.onDisconnect_, e, a), hc(0, r, d, _) }) } function $n(n, e, t) { let r; r = ".info" === Qr(e._path) ? Cp(n.infoSyncTree_, e, t) : Cp(n.serverSyncTree_, e, t), Lm(n.eventQueue_, e._path, r) } function fi(n) { n.persistentConnection_ && n.persistentConnection_.interrupt(Sy) } function za(n, ...e) { let t = ""; n.persistentConnection_ && (t = n.persistentConnection_.id + ":"), Lr(t, ...e) } function hc(n, e, t, r) { e && er(() => { if ("ok" === t) e(null); else { const a = (t || "error").toUpperCase(); let d = a; r && (d += ": " + r); const _ = new Error(d); _.code = a, e(_) } }) } function Mp(n, e, t) { return Ig(n.serverSyncTree_, e, t) || ei.EMPTY_NODE } function hf(n, e = n.transactionQueueTree_) { if (e || g0(n, e), Oh(e)) { const t = xy(n, e); (0, Pe.hu)(t.length > 0, "Sending zero length transaction queue"), t.every(a => 0 === a.status) && function Fi(n, e, t) { const r = t.map(B => B.currentWriteId), a = Mp(n, e, r); let d = a; const _ = a.hash(); for (let B = 0; B < t.length; B++) { const K = t[B]; (0, Pe.hu)(0 === K.status, "tryToSendTransactionQueue_: items in queue should all be run."), K.status = 1, K.retryCount++; const oe = ws(e, K.path); d = d.updateChild(oe, K.currentOutputSnapshotRaw) } const E = d.val(!0), x = e; n.server_.put(x.toString(), E, B => { za(n, "transaction put response", { path: x.toString(), status: B }); let K = []; if ("ok" === B) { const oe = []; for (let Me = 0; Me < t.length; Me++)t[Me].status = 2, K = K.concat(eh(n.serverSyncTree_, t[Me].currentWriteId)), t[Me].onComplete && oe.push(() => t[Me].onComplete(null, !0, t[Me].currentOutputSnapshotResolved)), t[Me].unwatcher(); g0(n, rh(n.transactionQueueTree_, e)), hf(n, n.transactionQueueTree_), cu(n.eventQueue_, e, K); for (let Me = 0; Me < oe.length; Me++)er(oe[Me]) } else { if ("datastale" === B) for (let oe = 0; oe < t.length; oe++)t[oe].status = 3 === t[oe].status ? 4 : 0; else { Wi("transaction at " + x.toString() + " failed: " + B); for (let oe = 0; oe < t.length; oe++)t[oe].status = 4, t[oe].abortReason = B } kd(n, e) } }, _) }(n, Sp(e), t) } else km(e) && Zf(e, t => { hf(n, t) }) } function kd(n, e) { const t = Um(n, e), r = Sp(t); return function Vm(n, e, t) { if (0 === e.length) return; const r = []; let a = []; const _ = e.filter(E => 0 === E.status).map(E => E.currentWriteId); for (let E = 0; E < e.length; E++) { const x = e[E], B = ws(t, x.path); let oe, K = !1; if ((0, Pe.hu)(null !== B, "rerunTransactionsUnderNode_: relativePath should not be null."), 4 === x.status) K = !0, oe = x.abortReason, a = a.concat(eh(n.serverSyncTree_, x.currentWriteId, !0)); else if (0 === x.status) if (x.retryCount >= 25) K = !0, oe = "maxretry", a = a.concat(eh(n.serverSyncTree_, x.currentWriteId, !0)); else { const Me = Mp(n, x.path, _); x.currentInputSnapshot = Me; const ot = e[E].update(Me.val()); if (void 0 !== ot) { Nd("transaction failed: Data returned ", ot, x.path); let bt = Zs(ot); "object" == typeof ot && null != ot && (0, Pe.r3)(ot, ".priority") || (bt = bt.updatePriority(Me.getPriority())); const Tn = x.currentWriteId, cr = s(n), $r = Dp(bt, Me, cr); x.currentOutputSnapshotRaw = bt, x.currentOutputSnapshotResolved = $r, x.currentWriteId = I(n), _.splice(_.indexOf(Tn), 1), a = a.concat(Im(n.serverSyncTree_, x.path, $r, x.currentWriteId, x.applyLocally)), a = a.concat(eh(n.serverSyncTree_, Tn, !0)) } else K = !0, oe = "nodata", a = a.concat(eh(n.serverSyncTree_, x.currentWriteId, !0)) } cu(n.eventQueue_, t, a), a = [], K && (e[E].status = 2, setTimeout(e[E].unwatcher, Math.floor(0)), e[E].onComplete && r.push("nodata" === oe ? () => e[E].onComplete(null, !1, e[E].currentInputSnapshot) : () => e[E].onComplete(new Error(oe), !1, null))) } g0(n, n.transactionQueueTree_); for (let E = 0; E < r.length; E++)er(r[E]); hf(n, n.transactionQueueTree_) }(n, xy(n, t), r), r } function Um(n, e) { let t, r = n.transactionQueueTree_; for (t = Qr(e); null !== t && void 0 === Oh(r);)r = rh(r, t), t = Qr(e = ts(e)); return r } function xy(n, e) { const t = []; return Hm(n, e, t), t.sort((r, a) => r.order - a.order), t } function Hm(n, e, t) { const r = Oh(e); if (r) for (let a = 0; a < r.length; a++)t.push(r[a]); Zf(e, a => { Hm(n, a, t) }) } function g0(n, e) { const t = Oh(e); if (t) { let r = 0; for (let a = 0; a < t.length; a++)2 !== t[a].status && (t[r] = t[a], r++); t.length = r, Nm(e, t.length > 0 ? t : void 0) } Zf(e, r => { g0(n, r) }) } function zm(n, e) { const t = Sp(Um(n, e)), r = rh(n.transactionQueueTree_, e); return function Ey(n, e, t) { let r = t ? n : n.parent; for (; null !== r;) { if (e(r)) return !0; r = r.parent } }(r, a => { $w(n, a) }), $w(n, r), h0(r, a => { $w(n, a) }), t } function $w(n, e) { const t = Oh(e); if (t) { const r = []; let a = [], d = -1; for (let _ = 0; _ < t.length; _++)3 === t[_].status || (1 === t[_].status ? ((0, Pe.hu)(d === _ - 1, "All SENT items should be at beginning of queue."), d = _, t[_].status = 3, t[_].abortReason = "set") : ((0, Pe.hu)(0 === t[_].status, "Unexpected transaction status in abort"), t[_].unwatcher(), a = a.concat(eh(n.serverSyncTree_, t[_].currentWriteId, !0)), t[_].onComplete && r.push(t[_].onComplete.bind(null, new Error("set"), !1, null)))); -1 === d ? Nm(e, void 0) : t.length = d + 1, cu(n.eventQueue_, Sp(e), a); for (let _ = 0; _ < r.length; _++)er(r[_]) } } const My = function (n, e) { const t = qw(n), r = t.namespace; return "firebase.com" === t.domain && $i(t.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"), (!r || "undefined" === r) && "localhost" !== t.domain && $i("Cannot parse Masterurl. Please use https://<YOUR FIREBASE>.firebaseio.com"), t.secure || typeof window < "u" && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && Wi("Insecure Masteraccess from a secure page. Please use https in calls to new Firebase()."), { repoInfo: new Uh(t.host, t.secure, r, "ws" === t.scheme || "wss" === t.scheme, e, "", r !== t.subdomain), path: new Zi(t.pathString) } }, qw = function (n) { let e = "", t = "", r = "", a = "", d = "", _ = !0, E = "https", x = 443; if ("string" == typeof n) { let B = n.indexOf("//"); B >= 0 && (E = n.substring(0, B - 1), n = n.substring(B + 2)); let K = n.indexOf("/"); -1 === K && (K = n.length); let oe = n.indexOf("?"); -1 === oe && (oe = n.length), e = n.substring(0, Math.min(K, oe)), K < oe && (a = function Ww(n) { let e = ""; const t = n.split("/"); for (let r = 0; r < t.length; r++)if (t[r].length > 0) { let a = t[r]; try { a = decodeURIComponent(a.replace(/\+/g, " ")) } catch { } e += "/" + a } return e }(n.substring(K, oe))); const Me = function Zw(n) { const e = {}; "?" === n.charAt(0) && (n = n.substring(1)); for (const t of n.split("&")) { if (0 === t.length) continue; const r = t.split("="); 2 === r.length ? e[decodeURIComponent(r[0])] = decodeURIComponent(r[1]) : Wi(`Invalid query segment '${t}' in query '${n}'`) } return e }(n.substring(Math.min(n.length, oe))); B = e.indexOf(":"), B >= 0 ? (_ = "https" === E || "wss" === E, x = parseInt(e.substring(B + 1), 10)) : B = e.length; const ot = e.slice(0, B); if ("localhost" === ot.toLowerCase()) t = "localhost"; else if (ot.split(".").length <= 2) t = ot; else { const bt = e.indexOf("."); r = e.substring(0, bt).toLowerCase(), t = e.substring(bt + 1), d = r } "ns" in Me && (d = Me.ns) } return { host: e, port: x, domain: t, subdomain: r, secure: _, scheme: E, pathString: a, namespace: d } }, Oy = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz", ff = function () { let n = 0; const e = []; return function (t) { const r = t === n; let a; n = t; const d = new Array(8); for (a = 7; a >= 0; a--)d[a] = Oy.charAt(t % 64), t = Math.floor(t / 64); (0, Pe.hu)(0 === t, "Cannot push at time == 0"); let _ = d.join(""); if (r) { for (a = 11; a >= 0 && 63 === e[a]; a--)e[a] = 0; e[a]++ } else for (a = 0; a < 12; a++)e[a] = Math.floor(64 * Math.random()); for (a = 0; a < 12; a++)_ += Oy.charAt(e[a]); return (0, Pe.hu)(20 === _.length, "nextPushId: Length should be 20."), _ } }(); class Gm { constructor(e, t, r, a) { this.eventType = e, this.eventRegistration = t, this.snapshot = r, this.prevName = a } getPath() { const e = this.snapshot.ref; return "value" === this.eventType ? e._path : e.parent._path } getEventType() { return this.eventType } getEventRunner() { return this.eventRegistration.getEventRunner(this) } toString() { return this.getPath().toString() + ":" + this.eventType + ":" + (0, Pe.Wl)(this.snapshot.exportVal()) } } class jm { constructor(e, t, r) { this.eventRegistration = e, this.error = t, this.path = r } getPath() { return this.path } getEventType() { return "cancel" } getEventRunner() { return this.eventRegistration.getEventRunner(this) } toString() { return this.path.toString() + ":cancel" } } class Op { constructor(e, t) { this.snapshotCallback = e, this.cancelCallback = t } onValue(e, t) { this.snapshotCallback.call(null, e, t) } onCancel(e) { return (0, Pe.hu)(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback"), this.cancelCallback.call(null, e) } get hasCancelCallback() { return !!this.cancelCallback } matches(e) { return this.snapshotCallback === e.snapshotCallback || void 0 !== this.snapshotCallback.userCallback && this.snapshotCallback.userCallback === e.snapshotCallback.userCallback && this.snapshotCallback.context === e.snapshotCallback.context } } class Yw { constructor(e, t) { this._repo = e, this._path = t } cancel() { const e = new Pe.BH; return Ge(this._repo, this._path, e.wrapCallback(() => { })), e.promise } remove() { lu("OnDisconnect.remove", this._path); const e = new Pe.BH; return at(this._repo, this._path, null, e.wrapCallback(() => { })), e.promise } set(e) { lu("OnDisconnect.set", this._path), Mu("OnDisconnect.set", e, this._path, !1); const t = new Pe.BH; return at(this._repo, this._path, e, t.wrapCallback(() => { })), t.promise } setWithPriority(e, t) { lu("OnDisconnect.setWithPriority", this._path), Mu("OnDisconnect.setWithPriority", e, this._path, !1), dc("OnDisconnect.setWithPriority", t, !1); const r = new Pe.BH; return function ut(n, e, t, r, a) { const d = Zs(t, r); n.server_.onDisconnectPut(e.toString(), d.val(!0), (_, E) => { "ok" === _ && Dh(n.onDisconnect_, e, d), hc(0, a, _, E) }) }(this._repo, this._path, e, t, r.wrapCallback(() => { })), r.promise } update(e) { lu("OnDisconnect.update", this._path), xp("OnDisconnect.update", e, this._path, !1); const t = new Pe.BH; return function $t(n, e, t, r) { if ((0, Pe.xb)(t)) return Lr("onDisconnect().update() called with empty data.  Don't do anything."), void hc(0, r, "ok", void 0); n.server_.onDisconnectMerge(e.toString(), t, (a, d) => { "ok" === a && vi(t, (_, E) => { const x = Zs(E); Dh(n.onDisconnect_, Hs(e, _), x) }), hc(0, r, a, d) }) }(this._repo, this._path, e, t.wrapCallback(() => { })), t.promise } } class du { constructor(e, t, r, a) { this._repo = e, this._path = t, this._queryParams = r, this._orderByCalled = a } get key() { return Xr(this._path) ? null : ic(this._path) } get ref() { return new Hc(this._repo, this._path) } get _queryIdentifier() { const e = Eh(this._queryParams), t = la(e); return "{}" === t ? "default" : t } get _queryObject() { return Eh(this._queryParams) } isEqual(e) { if (!((e = (0, Pe.m9)(e)) instanceof du)) return !1; const t = this._repo === e._repo, r = pd(this._path, e._path); return t && r && this._queryIdentifier === e._queryIdentifier } toJSON() { return this.toString() } toString() { return this._repo.toString() + function wu(n) { let e = ""; for (let t = n.pieceNum_; t < n.pieces_.length; t++)"" !== n.pieces_[t] && (e += "/" + encodeURIComponent(String(n.pieces_[t]))); return e || "/" }(this._path) } } function $m(n, e) { if (!0 === n._orderByCalled) throw new Error(e + ": You can't combine multiple orderBy calls.") } function Yf(n) { let e = null, t = null; if (n.hasStart() && (e = n.getIndexStartValue()), n.hasEnd() && (t = n.getIndexEndValue()), n.getIndex() === Po) { const r = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().", a = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string."; if (n.hasStart()) { if (n.getIndexStartName() !== oa) throw new Error(r); if ("string" != typeof e) throw new Error(a) } if (n.hasEnd()) { if (n.getIndexEndName() !== Ns) throw new Error(r); if ("string" != typeof t) throw new Error(a) } } else if (n.getIndex() === ui) { if (null != e && !Od(e) || null != t && !Od(t)) throw new Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).") } else if ((0, Pe.hu)(n.getIndex() instanceof Wd || n.getIndex() === C, "unknown index type."), null != e && "object" == typeof e || null != t && "object" == typeof t) throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.") } function Ny(n) { if (n.hasStart() && n.hasEnd() && n.hasLimit() && !n.hasAnchoredLimit()) throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.") } class Hc extends du { constructor(e, t) { super(e, t, new br, !1) } get parent() { const e = $u(this._path); return null === e ? null : new Hc(this._repo, e) } get root() { let e = this; for (; null !== e.parent;)e = e.parent; return e } } class Np { constructor(e, t, r) { this._node = e, this.ref = t, this._index = r } get priority() { return this._node.getPriority().val() } get key() { return this.ref.key } get size() { return this._node.numChildren() } child(e) { const t = new Zi(e), r = kp(this.ref, e); return new Np(this._node.getChild(t), r, ui) } exists() { return !this._node.isEmpty() } exportVal() { return this._node.val(!0) } forEach(e) { return !this._node.isLeafNode() && !!this._node.forEachChild(this._index, (r, a) => e(new Np(a, kp(this.ref, r), ui))) } hasChild(e) { const t = new Zi(e); return !this._node.getChild(t).isEmpty() } hasChildren() { return !this._node.isLeafNode() && !this._node.isEmpty() } toJSON() { return this.exportVal() } val() { return this._node.val() } } function UE(n, e) { return (n = (0, Pe.m9)(n))._checkNotDeleted("ref"), void 0 !== e ? kp(n._root, e) : n._root } function Kw(n, e) { (n = (0, Pe.m9)(n))._checkNotDeleted("refFromURL"); const t = My(e, n._repo.repoInfo_.nodeAdmin); Ng("refFromURL", t); const r = t.repoInfo; return !n._repo.repoInfo_.isCustomHost() && r.host !== n._repo.repoInfo_.host && $i("refFromURL: Host name does not match the current database: (found " + r.host + " but expected " + n._repo.repoInfo_.host + ")"), UE(n, t.path.toString()) } function kp(n, e) { return null === Qr((n = (0, Pe.m9)(n))._path) ? ((t = e) && (t = t.replace(/^\/*\.info(\/|$)/, "/")), df("child", "path", t, !1)) : df("child", "path", e, !1), new Hc(n._repo, Hs(n._path, e)); var t } function m0(n, e) { n = (0, Pe.m9)(n), lu("set", n._path), Mu("set", e, n._path, !1); const t = new Pe.BH; return H(n._repo, n._path, e, null, t.wrapCallback(() => { })), t.promise } function _0(n, e) { xp("update", e, n._path, !1); const t = new Pe.BH; return function te(n, e, t, r) { za(n, "update", { path: e.toString(), value: t }); let a = !0; const d = s(n), _ = {}; if (vi(t, (E, x) => { a = !1, _[E] = wy(Hs(e, E), Zs(x), n.serverSyncTree_, d) }), a) Lr("update() called with empty data.  Don't do anything."), hc(0, r, "ok", void 0); else { const E = I(n), x = function hi(n, e, t, r) { !function ua(n, e, t, r) { (0, Pe.hu)(r > n.lastWriteId, "Stacking an older merge on top of newer ones"), n.allWrites.push({ path: e, children: t, writeId: r, visible: !0 }), n.visibleWrites = bi(n.visibleWrites, e, t), n.lastWriteId = r }(n.pendingWriteTree_, e, t, r); const a = vn.fromObject(t); return af(n, new ou({ fromUser: !0, fromServer: !1, queryId: null, tagged: !1 }, e, a)) }(n.serverSyncTree_, e, _, E); kg(n.eventQueue_, x), n.server_.merge(e.toString(), t, (B, K) => { const oe = "ok" === B; oe || Wi("update at " + e + " failed: " + B); const Me = eh(n.serverSyncTree_, E, !oe), ot = Me.length > 0 ? kd(n, e) : e; cu(n.eventQueue_, ot, Me), hc(0, r, B, K) }), vi(t, B => { const K = zm(n, Hs(e, B)); kd(n, K) }), cu(n.eventQueue_, e, []) } }(n._repo, n._path, e, t.wrapCallback(() => { })), t.promise } function jE(n) { n = (0, Pe.m9)(n); const e = new Op(() => { }), t = new Pp(e); return function k(n, e, t) { const r = function Hw(n, e) { const t = e._path; let r = null; n.syncPointTree_.foreachOnPath(t, (B, K) => { const oe = ws(B, t); r = r || Lo(K, oe) }); let a = n.syncPointTree_.get(t); a ? r = r || Lo(a, Oi()) : (a = new o0, n.syncPointTree_ = n.syncPointTree_.set(t, a)); const d = null != r, _ = d ? new Yd(r, !0, !1) : null; return function n0(n) { return Ke(n.viewCache_) }(uy(a, e, gs(n.pendingWriteTree_, e._path), d ? _.getNode() : ei.EMPTY_NODE, d)) }(n.serverSyncTree_, e); return null != r ? Promise.resolve(r) : n.server_.get(e).then(a => { const d = Zs(a).withIndex(e._queryParams.getIndex()); let _; if (Am(n.serverSyncTree_, e, t, !0), e._queryParams.loadsAllData()) _ = $f(n.serverSyncTree_, e._path, d); else { const E = lf(n.serverSyncTree_, e); _ = gy(n.serverSyncTree_, e._path, d, E) } return cu(n.eventQueue_, e._path, _), Cp(n.serverSyncTree_, e, t, null, !0), d }, a => (za(n, "get for query " + (0, Pe.Wl)(e) + " failed: " + a), Promise.reject(new Error(a)))) }(n._repo, n, t).then(r => new Np(r, new Hc(n._repo, n._path), n._queryParams.getIndex())) } class Pp { constructor(e) { this.callbackContext = e } respondsTo(e) { return "value" === e } createEvent(e, t) { const r = t._queryParams.getIndex(); return new Gm("value", this, new Np(e.snapshotNode, new Hc(t._repo, t._path), r)) } getEventRunner(e) { return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, null) } createCancelEvent(e, t) { return this.callbackContext.hasCancelCallback ? new jm(this, e, t) : null } matches(e) { return e instanceof Pp && (!e.callbackContext || !this.callbackContext || e.callbackContext.matches(this.callbackContext)) } hasAnyCallback() { return null !== this.callbackContext } } class ky { constructor(e, t) { this.eventType = e, this.callbackContext = t } respondsTo(e) { let t = "children_added" === e ? "child_added" : e; return t = "children_removed" === t ? "child_removed" : t, this.eventType === t } createCancelEvent(e, t) { return this.callbackContext.hasCancelCallback ? new jm(this, e, t) : null } createEvent(e, t) { (0, Pe.hu)(null != e.childName, "Child events should have a childName."); const r = kp(new Hc(t._repo, t._path), e.childName), a = t._queryParams.getIndex(); return new Gm(e.type, this, new Np(e.snapshotNode, r, a), e.prevName) } getEventRunner(e) { return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, e.prevName) } matches(e) { return e instanceof ky && this.eventType === e.eventType && (!this.callbackContext || !e.callbackContext || this.callbackContext.matches(e.callbackContext)) } hasAnyCallback() { return !!this.callbackContext } } function Wm(n, e, t, r, a) { let d; if ("object" == typeof r && (d = void 0, a = r), "function" == typeof r && (d = r), a && a.onlyOnce) { const x = t, B = (K, oe) => { $n(n._repo, n, E), x(K, oe) }; B.userCallback = t.userCallback, B.context = t.context, t = B } const _ = new Op(t, d || void 0), E = "value" === e ? new Pp(_) : new ky(e, _); return function Dn(n, e, t) { let r; r = ".info" === Qr(e._path) ? Am(n.infoSyncTree_, e, t) : Am(n.serverSyncTree_, e, t), Lm(n.eventQueue_, e._path, r) }(n._repo, n, E), () => $n(n._repo, n, E) } function y0(n, e, t, r) { return Wm(n, "value", e, t, r) } function Qw(n, e, t, r) { return Wm(n, "child_added", e, t, r) } function Xw(n, e, t, r) { return Wm(n, "child_changed", e, t, r) } function e1(n, e, t, r) { return Wm(n, "child_moved", e, t, r) } function t1(n, e, t, r) { return Wm(n, "child_removed", e, t, r) } function v0(n, e, t) { let r = null; const a = t ? new Op(t) : null; "value" === e ? r = new Pp(a) : e && (r = new ky(e, a)), $n(n._repo, n, r) } class Pd { } class n1 extends Pd { constructor(e, t) { super(), this._value = e, this._key = t } _apply(e) { Mu("endAt", this._value, e._path, !0); const t = su(e._queryParams, this._value, this._key); if (Ny(t), Yf(t), e._queryParams.hasEnd()) throw new Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo)."); return new du(e._repo, e._path, t, e._orderByCalled) } } class r1 extends Pd { constructor(e, t) { super(), this._value = e, this._key = t } _apply(e) { Mu("endBefore", this._value, e._path, !1); const t = function Fc(n, e, t) { let r; return r = su(n, e, n.index_ === Po || t ? t : oa), r.endBeforeSet_ = !0, r }(e._queryParams, this._value, this._key); if (Ny(t), Yf(t), e._queryParams.hasEnd()) throw new Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo)."); return new du(e._repo, e._path, t, e._orderByCalled) } } class Kf extends Pd { constructor(e, t) { super(), this._value = e, this._key = t } _apply(e) { Mu("startAt", this._value, e._path, !0); const t = Ku(e._queryParams, this._value, this._key); if (Ny(t), Yf(t), e._queryParams.hasStart()) throw new Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo)."); return new du(e._repo, e._path, t, e._orderByCalled) } } class Ry extends Pd { constructor(e, t) { super(), this._value = e, this._key = t } _apply(e) { Mu("startAfter", this._value, e._path, !1); const t = function Lf(n, e, t) { let r; return r = Ku(n, e, n.index_ === Po || t ? t : Ns), r.startAfterSet_ = !0, r }(e._queryParams, this._value, this._key); if (Ny(t), Yf(t), e._queryParams.hasStart()) throw new Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo)."); return new du(e._repo, e._path, t, e._orderByCalled) } } class WE extends Pd { constructor(e) { super(), this._limit = e } _apply(e) { if (e._queryParams.hasLimit()) throw new Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast)."); return new du(e._repo, e._path, function Ni(n, e) { const t = n.copy(); return t.limitSet_ = !0, t.limit_ = e, t.viewFrom_ = "l", t }(e._queryParams, this._limit), e._orderByCalled) } } class ZE extends Pd { constructor(e) { super(), this._limit = e } _apply(e) { if (e._queryParams.hasLimit()) throw new Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast)."); return new du(e._repo, e._path, function Dl(n, e) { const t = n.copy(); return t.limitSet_ = !0, t.limit_ = e, t.viewFrom_ = "r", t }(e._queryParams, this._limit), e._orderByCalled) } } class Zm extends Pd { constructor(e) { super(), this._path = e } _apply(e) { $m(e, "orderByChild"); const t = new Zi(this._path); if (Xr(t)) throw new Error("orderByChild: cannot pass in empty path. Use orderByValue() instead."); const r = new Wd(t), a = lc(e._queryParams, r); return Yf(a), new du(e._repo, e._path, a, !0) } } class Rp extends Pd { _apply(e) { $m(e, "orderByKey"); const t = lc(e._queryParams, Po); return Yf(t), new du(e._repo, e._path, t, !0) } } class Rd extends Pd { _apply(e) { $m(e, "orderByPriority"); const t = lc(e._queryParams, ui); return Yf(t), new du(e._repo, e._path, t, !0) } } class Pg extends Pd { _apply(e) { $m(e, "orderByValue"); const t = lc(e._queryParams, C); return Yf(t), new du(e._repo, e._path, t, !0) } } class Fg extends Pd { constructor(e, t) { super(), this._value = e, this._key = t } _apply(e) { if (Mu("equalTo", this._value, e._path, !1), e._queryParams.hasStart()) throw new Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo)."); if (e._queryParams.hasEnd()) throw new Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo)."); return new n1(this._value, this._key)._apply(new Kf(this._value, this._key)._apply(e)) } } function Gc(n, ...e) { let t = (0, Pe.m9)(n); for (const r of e) t = r._apply(t); return t } (function ly(n) { (0, Pe.hu)(!Dm, "__referenceConstructor has already been defined"), Dm = n })(Hc), function l0(n) { (0, Pe.hu)(!xh, "__referenceConstructor has already been defined"), xh = n }(Hc); const Jf = {}; function Ly(n, e, t, r, a) { let d = r || n.options.databaseURL; void 0 === d && (n.options.projectId || $i("Can't determine MasterDatabase URL. Be sure to include  a Project ID when calling firebase.initializeApp()."), Lr("Using default host for project ", n.options.projectId), d = `${n.options.projectId}-default-rtdb.firebaseio.com`); let x, B, _ = My(d, a), E = _.repoInfo; typeof process < "u" && process.env && (B = process.env.FIREBASE_DATABASE_EMULATOR_HOST), B ? (x = !0, d = `http://${B}?ns=${E.namespace}`, _ = My(d, a), E = _.repoInfo) : x = !_.repoInfo.secure; const K = a && x ? new Ws(Ws.OWNER) : new ca(n.name, n.options, e); Ng("Invalid MasterDatabase URL", _), Xr(_.path) || $i("Database URL must point to the root of a MasterDatabase (not including a child path)."); const oe = function s1(n, e, t, r) { let a = Jf[e.name]; a || (a = {}, Jf[e.name] = a); let d = a[n.toURLString()]; return d && $i("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call."), d = new Uc(n, false, t, r), a[n.toURLString()] = d, d }(E, n, K, new Pr(n.name, t)); return new a1(oe, n) } class a1 { constructor(e, t) { this._repoInternal = e, this.app = t, this.type = "database", this._instanceStarted = !1 } get _repo() { return this._instanceStarted || (function Ay(n, e, t) { if (n.stats_ = dd(n.repoInfo_), n.forceRestClient_ || ("object" == typeof window && window.navigator && window.navigator.userAgent || "").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0) n.server_ = new Lc(n.repoInfo_, (r, a, d, _) => { l(n, r, a, d, _) }, n.authTokenProvider_, n.appCheckProvider_), setTimeout(() => h(n, !0), 0); else { if (typeof t < "u" && null !== t) { if ("object" != typeof t) throw new Error("Only objects are supported for option databaseAuthVariableOverride"); try { (0, Pe.Wl)(t) } catch (r) { throw new Error("Invalid authOverride provided: " + r) } } n.persistentConnection_ = new sc(n.repoInfo_, e, (r, a, d, _) => { l(n, r, a, d, _) }, r => { h(n, r) }, r => { !function y(n, e) { vi(e, (t, r) => { w(n, t, r) }) }(n, r) }, n.authTokenProvider_, n.appCheckProvider_, t), n.server_ = n.persistentConnection_ } n.authTokenProvider_.addTokenChangeListener(r => { n.server_.refreshAuthToken(r) }), n.appCheckProvider_.addTokenChangeListener(r => { n.server_.refreshAppCheckToken(r.token) }), n.statsReporter_ = function gg(n, e) { const t = n.toString(); return fp[t] || (fp[t] = e()), fp[t] }(n.repoInfo_, () => new Sh(n.stats_, n.server_)), n.infoData_ = new ea, n.infoSyncTree_ = new sf({ startListening: (r, a, d, _) => { let E = []; const x = n.infoData_.getNode(r._path); return x.isEmpty() || (E = $f(n.infoSyncTree_, r._path, x), setTimeout(() => { _("ok") }, 0)), E }, stopListening: () => { } }), w(n, "connected", !1), n.serverSyncTree_ = new sf({ startListening: (r, a, d, _) => (n.server_.listen(r, d, a, (E, x) => { const B = _(E, x); cu(n.eventQueue_, r._path, B) }), []), stopListening: (r, a) => { n.server_.unlisten(r, a) } }) }(this._repoInternal, this.app.options.appId, this.app.options.databaseAuthVariableOverride), this._instanceStarted = !0), this._repoInternal } get _root() { return this._rootInternal || (this._rootInternal = new Hc(this._repo, Oi())), this._rootInternal } _delete() { return null !== this._rootInternal && (function i1(n, e) { const t = Jf[e]; (!t || t[n.key] !== n) && $i(`Database ${e}(${n.repoInfo_}) has already been deleted.`), fi(n), delete t[n.key] }(this._repo, this.app.name), this._repoInternal = null, this._rootInternal = null), Promise.resolve() } _checkNotDeleted(e) { null === this._rootInternal && $i("Cannot call " + e + " on a deleted database.") } } function C0() { nu.IS_TRANSPORT_INITIALIZED && Wi("Transport has already been initialized. Please call this function before calling ref or setting up a listener") } function l1() { C0(), tu.forceDisallow() } function c1() { C0(), bl.forceDisallow(), tu.forceAllow() } function KE(n, e) { Vn(n, e) } const E0 = { ".sv": "timestamp" }; class By { constructor(e, t) { this.committed = e, this.snapshot = t } toJSON() { return { committed: this.committed, snapshot: this.snapshot.toJSON() } } } sc.prototype.simpleListen = function (n, e) { this.sendRequest("q", { p: n }, e) }, sc.prototype.echo = function (n, e) { this.sendRequest("echo", { d: n }, e) }, function h1(n) { Xc(tl.SDK_VERSION), (0, tl._registerComponent)(new Oc.wA("database", (e, { instanceIdentifier: t }) => Ly(e.getProvider("app").getImmediate(), e.getProvider("auth-internal"), e.getProvider("app-check-internal"), t), "PUBLIC").setMultipleInstances(!0)), (0, tl.registerVersion)(ml, "0.14.0", n), (0, tl.registerVersion)(ml, "0.14.0", "esm2017") }(); const D0 = new Jo.Yd("@firebase/database-compat"), S0 = function (n) { D0.warn("MasterWARNING: " + n) }; class g1 { constructor(e) { this._delegate = e } cancel(e) { (0, Pe.Dv)("OnDisconnect.cancel", 0, 1, arguments.length), (0, Pe.Wj)("OnDisconnect.cancel", "onComplete", e, !0); const t = this._delegate.cancel(); return e && t.then(() => e(null), r => e(r)), t } remove(e) { (0, Pe.Dv)("OnDisconnect.remove", 0, 1, arguments.length), (0, Pe.Wj)("OnDisconnect.remove", "onComplete", e, !0); const t = this._delegate.remove(); return e && t.then(() => e(null), r => e(r)), t } set(e, t) { (0, Pe.Dv)("OnDisconnect.set", 1, 2, arguments.length), (0, Pe.Wj)("OnDisconnect.set", "onComplete", t, !0); const r = this._delegate.set(e); return t && r.then(() => t(null), a => t(a)), r } setWithPriority(e, t, r) { (0, Pe.Dv)("OnDisconnect.setWithPriority", 2, 3, arguments.length), (0, Pe.Wj)("OnDisconnect.setWithPriority", "onComplete", r, !0); const a = this._delegate.setWithPriority(e, t); return r && a.then(() => r(null), d => r(d)), a } update(e, t) { if ((0, Pe.Dv)("OnDisconnect.update", 1, 2, arguments.length), Array.isArray(e)) { const a = {}; for (let d = 0; d < e.length; ++d)a["" + d] = e[d]; e = a, S0("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.") } (0, Pe.Wj)("OnDisconnect.update", "onComplete", t, !0); const r = this._delegate.update(e); return t && r.then(() => t(null), a => t(a)), r } } class A0 { constructor(e, t) { this.committed = e, this.snapshot = t } toJSON() { return (0, Pe.Dv)("TransactionResult.toJSON", 0, 1, arguments.length), { committed: this.committed, snapshot: this.snapshot.toJSON() } } } class kh { constructor(e, t) { this._database = e, this._delegate = t } val() { return (0, Pe.Dv)("DataSnapshot.val", 0, 0, arguments.length), this._delegate.val() } exportVal() { return (0, Pe.Dv)("DataSnapshot.exportVal", 0, 0, arguments.length), this._delegate.exportVal() } toJSON() { return (0, Pe.Dv)("DataSnapshot.toJSON", 0, 1, arguments.length), this._delegate.toJSON() } exists() { return (0, Pe.Dv)("DataSnapshot.exists", 0, 0, arguments.length), this._delegate.exists() } child(e) { return (0, Pe.Dv)("DataSnapshot.child", 0, 1, arguments.length), e = String(e), df("DataSnapshot.child", "path", e, !1), new kh(this._database, this._delegate.child(e)) } hasChild(e) { return (0, Pe.Dv)("DataSnapshot.hasChild", 1, 1, arguments.length), df("DataSnapshot.hasChild", "path", e, !1), this._delegate.hasChild(e) } getPriority() { return (0, Pe.Dv)("DataSnapshot.getPriority", 0, 0, arguments.length), this._delegate.priority } forEach(e) { return (0, Pe.Dv)("DataSnapshot.forEach", 1, 1, arguments.length), (0, Pe.Wj)("DataSnapshot.forEach", "action", e, !1), this._delegate.forEach(t => e(new kh(this._database, t))) } hasChildren() { return (0, Pe.Dv)("DataSnapshot.hasChildren", 0, 0, arguments.length), this._delegate.hasChildren() } get key() { return this._delegate.key } numChildren() { return (0, Pe.Dv)("DataSnapshot.numChildren", 0, 0, arguments.length), this._delegate.size } getRef() { return (0, Pe.Dv)("DataSnapshot.ref", 0, 0, arguments.length), new Nu(this._database, this._delegate.ref) } get ref() { return this.getRef() } } class fc { constructor(e, t) { this.database = e, this._delegate = t } on(e, t, r, a) { var d; (0, Pe.Dv)("Query.on", 2, 4, arguments.length), (0, Pe.Wj)("Query.on", "callback", t, !1); const _ = fc.getCancelAndContextArgs_("Query.on", r, a), E = (B, K) => { t.call(_.context, new kh(this.database, B), K) }; E.userCallback = t, E.context = _.context; const x = null === (d = _.cancel) || void 0 === d ? void 0 : d.bind(_.context); switch (e) { case "value": return y0(this._delegate, E, x), t; case "child_added": return Qw(this._delegate, E, x), t; case "child_removed": return t1(this._delegate, E, x), t; case "child_changed": return Xw(this._delegate, E, x), t; case "child_moved": return e1(this._delegate, E, x), t; default: throw new Error((0, Pe.gK)("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".') } } off(e, t, r) { if ((0, Pe.Dv)("Query.off", 0, 3, arguments.length), function (n, e, t) { if (void 0 !== e) switch (e) { case "value": case "child_added": case "child_removed": case "child_changed": case "child_moved": break; default: throw new Error((0, Pe.gK)("Query.off", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".') } }(0, e), (0, Pe.Wj)("Query.off", "callback", t, !0), (0, Pe.lb)("Query.off", "context", r, !0), t) { const a = () => { }; a.userCallback = t, a.context = r, v0(this._delegate, e, a) } else v0(this._delegate, e) } get() { return jE(this._delegate).then(e => new kh(this.database, e)) } once(e, t, r, a) { (0, Pe.Dv)("Query.once", 1, 4, arguments.length), (0, Pe.Wj)("Query.once", "callback", t, !0); const d = fc.getCancelAndContextArgs_("Query.once", r, a), _ = new Pe.BH, E = (B, K) => { const oe = new kh(this.database, B); t && t.call(d.context, oe, K), _.resolve(oe) }; E.userCallback = t, E.context = d.context; const x = B => { d.cancel && d.cancel.call(d.context, B), _.reject(B) }; switch (e) { case "value": y0(this._delegate, E, x, { onlyOnce: !0 }); break; case "child_added": Qw(this._delegate, E, x, { onlyOnce: !0 }); break; case "child_removed": t1(this._delegate, E, x, { onlyOnce: !0 }); break; case "child_changed": Xw(this._delegate, E, x, { onlyOnce: !0 }); break; case "child_moved": e1(this._delegate, E, x, { onlyOnce: !0 }); break; default: throw new Error((0, Pe.gK)("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".') }return _.promise } limitToFirst(e) { return (0, Pe.Dv)("Query.limitToFirst", 1, 1, arguments.length), new fc(this.database, Gc(this._delegate, function b0(n) { if ("number" != typeof n || Math.floor(n) !== n || n <= 0) throw new Error("limitToFirst: First argument must be a positive integer."); return new WE(n) }(e))) } limitToLast(e) { return (0, Pe.Dv)("Query.limitToLast", 1, 1, arguments.length), new fc(this.database, Gc(this._delegate, function Nh(n) { if ("number" != typeof n || Math.floor(n) !== n || n <= 0) throw new Error("limitToLast: First argument must be a positive integer."); return new ZE(n) }(e))) } orderByChild(e) { return (0, Pe.Dv)("Query.orderByChild", 1, 1, arguments.length), new fc(this.database, Gc(this._delegate, function zc(n) { if ("$key" === n) throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.'); if ("$priority" === n) throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.'); if ("$value" === n) throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.'); return df("orderByChild", "path", n, !1), new Zm(n) }(e))) } orderByKey() { return (0, Pe.Dv)("Query.orderByKey", 0, 0, arguments.length), new fc(this.database, Gc(this._delegate, function Fy() { return new Rp }())) } orderByPriority() { return (0, Pe.Dv)("Query.orderByPriority", 0, 0, arguments.length), new fc(this.database, Gc(this._delegate, function w0() { return new Rd }())) } orderByValue() { return (0, Pe.Dv)("Query.orderByValue", 0, 0, arguments.length), new fc(this.database, Gc(this._delegate, function Rg() { return new Pg }())) } startAt(e = null, t) { return (0, Pe.Dv)("Query.startAt", 0, 2, arguments.length), new fc(this.database, Gc(this._delegate, function tI(n = null, e) { return uf("startAt", "key", e, !0), new Kf(n, e) }(e, t))) } startAfter(e = null, t) { return (0, Pe.Dv)("Query.startAfter", 0, 2, arguments.length), new fc(this.database, Gc(this._delegate, function $E(n, e) { return uf("startAfter", "key", e, !0), new Ry(n, e) }(e, t))) } endAt(e = null, t) { return (0, Pe.Dv)("Query.endAt", 0, 2, arguments.length), new fc(this.database, Gc(this._delegate, function eI(n, e) { return uf("endAt", "key", e, !0), new n1(n, e) }(e, t))) } endBefore(e = null, t) { return (0, Pe.Dv)("Query.endBefore", 0, 2, arguments.length), new fc(this.database, Gc(this._delegate, function Py(n, e) { return uf("endBefore", "key", e, !0), new r1(n, e) }(e, t))) } equalTo(e, t) { return (0, Pe.Dv)("Query.equalTo", 1, 2, arguments.length), new fc(this.database, Gc(this._delegate, function Lg(n, e) { return uf("equalTo", "key", e, !0), new Fg(n, e) }(e, t))) } toString() { return (0, Pe.Dv)("Query.toString", 0, 0, arguments.length), this._delegate.toString() } toJSON() { return (0, Pe.Dv)("Query.toJSON", 0, 1, arguments.length), this._delegate.toJSON() } isEqual(e) { if ((0, Pe.Dv)("Query.isEqual", 1, 1, arguments.length), !(e instanceof fc)) throw new Error("Query.isEqual failed: First argument must be an instance of firebase.database.Query."); return this._delegate.isEqual(e._delegate) } static getCancelAndContextArgs_(e, t, r) { const a = { cancel: void 0, context: void 0 }; if (t && r) a.cancel = t, (0, Pe.Wj)(e, "cancel", a.cancel, !0), a.context = r, (0, Pe.lb)(e, "context", a.context, !0); else if (t) if ("object" == typeof t && null !== t) a.context = t; else { if ("function" != typeof t) throw new Error((0, Pe.gK)(e, "cancelOrContext") + " must either be a cancel callback or a context object."); a.cancel = t } return a } get ref() { return new Nu(this.database, new Hc(this._delegate._repo, this._delegate._path)) } } class Nu extends fc { constructor(e, t) { super(e, new du(t._repo, t._path, new br, !1)), this.database = e, this._delegate = t } getKey() { return (0, Pe.Dv)("Reference.key", 0, 0, arguments.length), this._delegate.key } child(e) { return (0, Pe.Dv)("Reference.child", 1, 1, arguments.length), "number" == typeof e && (e = String(e)), new Nu(this.database, kp(this._delegate, e)) } getParent() { (0, Pe.Dv)("Reference.parent", 0, 0, arguments.length); const e = this._delegate.parent; return e ? new Nu(this.database, e) : null } getRoot() { return (0, Pe.Dv)("Reference.root", 0, 0, arguments.length), new Nu(this.database, this._delegate.root) } set(e, t) { (0, Pe.Dv)("Reference.set", 1, 2, arguments.length), (0, Pe.Wj)("Reference.set", "onComplete", t, !0); const r = m0(this._delegate, e); return t && r.then(() => t(null), a => t(a)), r } update(e, t) { if ((0, Pe.Dv)("Reference.update", 1, 2, arguments.length), Array.isArray(e)) { const a = {}; for (let d = 0; d < e.length; ++d)a["" + d] = e[d]; e = a, S0("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.") } lu("Reference.update", this._delegate._path), (0, Pe.Wj)("Reference.update", "onComplete", t, !0); const r = _0(this._delegate, e); return t && r.then(() => t(null), a => t(a)), r } setWithPriority(e, t, r) { (0, Pe.Dv)("Reference.setWithPriority", 2, 3, arguments.length), (0, Pe.Wj)("Reference.setWithPriority", "onComplete", r, !0); const a = function Jw(n, e, t) { if (lu("setWithPriority", n._path), Mu("setWithPriority", e, n._path, !1), dc("setWithPriority", t, !1), ".length" === n.key || ".keys" === n.key) throw "setWithPriority failed: " + n.key + " is a read-only object."; const r = new Pe.BH; return H(n._repo, n._path, e, t, r.wrapCallback(() => { })), r.promise }(this._delegate, e, t); return r && a.then(() => r(null), d => r(d)), a } remove(e) { (0, Pe.Dv)("Reference.remove", 0, 1, arguments.length), (0, Pe.Wj)("Reference.remove", "onComplete", e, !0); const t = function zE(n) { return lu("remove", n._path), m0(n, null) }(this._delegate); return e && t.then(() => e(null), r => e(r)), t } transaction(e, t, r) { (0, Pe.Dv)("Reference.transaction", 1, 3, arguments.length), (0, Pe.Wj)("Reference.transaction", "transactionUpdate", e, !1), (0, Pe.Wj)("Reference.transaction", "onComplete", t, !0), function (n, e, t, r) { if (void 0 !== t && "boolean" != typeof t) throw new Error((0, Pe.gK)("Reference.transaction", "applyLocally") + "must be a boolean.") }(0, 0, r); const a = function Vy(n, e, t) { var r; if (n = (0, Pe.m9)(n), lu("Reference.transaction", n._path), ".length" === n.key || ".keys" === n.key) throw "Reference.transaction failed: " + n.key + " is a read-only object."; const a = null === (r = t?.applyLocally) || void 0 === r || r, d = new Pe.BH, E = y0(n, () => { }); return function Ou(n, e, t, r, a, d) { za(n, "transaction on " + e); const _ = { path: e, update: t, onComplete: r, status: null, order: ce(), applyLocally: d, retryCount: 0, unwatcher: a, abortReason: null, currentWriteId: null, currentInputSnapshot: null, currentOutputSnapshotRaw: null, currentOutputSnapshotResolved: null }, E = Mp(n, e, void 0); _.currentInputSnapshot = E; const x = _.update(E.val()); if (void 0 === x) _.unwatcher(), _.currentOutputSnapshotRaw = null, _.currentOutputSnapshotResolved = null, _.onComplete && _.onComplete(null, !1, _.currentInputSnapshot); else { Nd("transaction failed: Data returned ", x, _.path), _.status = 0; const B = rh(n.transactionQueueTree_, e), K = Oh(B) || []; let oe; K.push(_), Nm(B, K), "object" == typeof x && null !== x && (0, Pe.r3)(x, ".priority") ? (oe = (0, Pe.DV)(x, ".priority"), (0, Pe.hu)(Od(oe), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")) : oe = (Ig(n.serverSyncTree_, e) || ei.EMPTY_NODE).getPriority().val(); const Me = s(n), ot = Zs(x, oe), bt = Dp(ot, E, Me); _.currentOutputSnapshotRaw = ot, _.currentOutputSnapshotResolved = bt, _.currentWriteId = I(n); const qt = Im(n.serverSyncTree_, e, bt, _.currentWriteId, _.applyLocally); cu(n.eventQueue_, e, qt), hf(n, n.transactionQueueTree_) } }(n._repo, n._path, e, (x, B, K) => { let oe = null; x ? d.reject(x) : (oe = new Np(K, new Hc(n._repo, n._path), ui), d.resolve(new By(B, oe))) }, E, a), d.promise }(this._delegate, e, { applyLocally: r }).then(d => new A0(d.committed, new kh(this.database, d.snapshot))); return t && a.then(d => t(null, d.committed, d.snapshot), d => t(d, !1, null)), a } setPriority(e, t) { (0, Pe.Dv)("Reference.setPriority", 1, 2, arguments.length), (0, Pe.Wj)("Reference.setPriority", "onComplete", t, !0); const r = function GE(n, e) { n = (0, Pe.m9)(n), lu("setPriority", n._path), dc("setPriority", e, !1); const t = new Pe.BH; return H(n._repo, Hs(n._path, ".priority"), e, null, t.wrapCallback(() => { })), t.promise }(this._delegate, e); return t && r.then(() => t(null), a => t(a)), r } push(e, t) { (0, Pe.Dv)("Reference.push", 0, 2, arguments.length), (0, Pe.Wj)("Reference.push", "onComplete", t, !0); const r = function HE(n, e) { n = (0, Pe.m9)(n), lu("push", n._path), Mu("push", e, n._path, !0); const t = f(n._repo), r = ff(t), a = kp(n, r), d = kp(n, r); let _; return _ = null != e ? m0(d, e).then(() => d) : Promise.resolve(d), a.then = _.then.bind(_), a.catch = _.then.bind(_, void 0), a }(this._delegate, e), a = r.then(_ => new Nu(this.database, _)); t && a.then(() => t(null), _ => t(_)); const d = new Nu(this.database, r); return d.then = a.then.bind(a), d.catch = a.catch.bind(a, void 0), d } onDisconnect() { return lu("Reference.onDisconnect", this._delegate._path), new g1(new Yw(this._delegate._repo, this._delegate._path)) } get key() { return this.getKey() } get parent() { return this.getParent() } get root() { return this.getRoot() } } class Ug { constructor(e, t) { this._delegate = e, this.app = t, this.INTERNAL = { delete: () => this._delegate._delete(), forceWebSockets: l1, forceLongPolling: c1 } } useEmulator(e, t, r = {}) { !function u1(n, e, t, r = {}) { (n = (0, Pe.m9)(n))._checkNotDeleted("useEmulator"), n._instanceStarted && $i("Cannot call useEmulator() after instance has already been initialized."); const a = n._repoInternal; let d; if (a.repoInfo_.nodeAdmin) r.mockUserToken && $i('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'), d = new Ws(Ws.OWNER); else if (r.mockUserToken) { const _ = "string" == typeof r.mockUserToken ? r.mockUserToken : (0, Pe.Sg)(r.mockUserToken, n.app.options.projectId); d = new Ws(_) } !function Vg(n, e, t, r) { n.repoInfo_ = new Uh(`${e}:${t}`, !1, n.repoInfo_.namespace, n.repoInfo_.webSocketOnly, n.repoInfo_.nodeAdmin, n.repoInfo_.persistenceKey, n.repoInfo_.includeNamespaceInQueryParams), r && (n.authTokenProvider_ = r) }(a, e, t, d) }(this._delegate, e, t, r) } ref(e) { if ((0, Pe.Dv)("database.ref", 0, 1, arguments.length), e instanceof Nu) { const t = Kw(this._delegate, e.toString()); return new Nu(this, t) } { const t = UE(this._delegate, e); return new Nu(this, t) } } refFromURL(e) { (0, Pe.Dv)("database.refFromURL", 1, 1, arguments.length); const r = Kw(this._delegate, e); return new Nu(this, r) } goOffline() { return (0, Pe.Dv)("database.goOffline", 0, 0, arguments.length), function YE(n) { (n = (0, Pe.m9)(n))._checkNotDeleted("goOffline"), fi(n._repo) }(this._delegate) } goOnline() { return (0, Pe.Dv)("database.goOnline", 0, 0, arguments.length), function d1(n) { (n = (0, Pe.m9)(n))._checkNotDeleted("goOnline"), function uu(n) { n.persistentConnection_ && n.persistentConnection_.resume(Sy) }(n._repo) }(this._delegate) } } Ug.ServerValue = { TIMESTAMP: function T0() { return E0 }(), increment: n => function JE(n) { return { ".sv": { increment: n } } }(n) }; var _1 = Object.freeze({ __proto__: null, initStandalone: function m1({ app: n, url: e, version: t, customAuthImpl: r, namespace: a, nodeAdmin: d = !1 }) { Xc(t); const _ = new Oc.zt("auth-internal", new Oc.H0("database-standalone")); return _.setComponent(new Oc.wA("auth-internal", () => r, "PRIVATE")), { instance: new Ug(Ly(n, _, void 0, e, d), n), namespace: a } } }); const QE = Ug.ServerValue; !function y1(n) { n.INTERNAL.registerComponent(new Oc.wA("database-compat", (e, { instanceIdentifier: t }) => { const r = e.getProvider("app-compat").getImmediate(), a = e.getProvider("database").getImmediate({ identifier: t }); return new Ug(a, r) }, "PUBLIC").setServiceProps({ Reference: Nu, Query: fc, Database: Ug, DataSnapshot: kh, enableLogging: KE, INTERNAL: _1, ServerValue: QE }).setMultipleInstances(!0)), n.registerVersion("@firebase/database-compat", "0.3.0") }(Mc.Z); var Hl = L(948), zy = L(6217), qm = L(9260); function x0(n) { return null == n } function M0(n) { return "function" == typeof n.set } function O0(n, e) { return M0(e) ? e : n.ref(e) } function N0(n, e) { if (function v1(n) { return "string" == typeof n }(n)) return e.stringCase(); if (M0(n)) return e.firebaseCase(); if (function b1(n) { return "function" == typeof n.exportVal }(n)) return e.snapshotCase(); throw new Error("Expects a string, snapshot, or reference. Got: " + typeof n) } function Hg(n, e, t = "on", r = Ko.z) { return new Bu.y(a => { let d = null; return d = n[t](e, (_, E) => { r.schedule(() => { a.next({ snapshot: _, prevKey: E }) }), "once" === t && r.schedule(() => a.complete()) }, _ => { r.schedule(() => a.error(_)) }), "on" === t ? { unsubscribe() { null != d && n.off(e, d) } } : { unsubscribe() { } } }).pipe((0, ao.U)(a => { const { snapshot: d, prevKey: _ } = a; let E = null; return d.exists() && (E = d.key), { type: e, payload: d, prevKey: _, key: E } }), (0, xc.B)()) } function Ym(n, e) { const t = n.length; for (let r = 0; r < t; r++)if (n[r].payload.key === e) return r; return -1 } function XE(n, e) { const { payload: t, prevKey: r, key: a } = e, d = Ym(n, a), _ = function Qf(n, e) { if (x0(e)) return 0; { const t = Ym(n, e); return -1 === t ? n.length : t + 1 } }(n, r); switch (e.type) { case "value": if (e.payload && e.payload.exists()) { let E = null; e.payload.forEach(x => { const B = { payload: x, type: "value", prevKey: E, key: x.key }; return E = x.key, n = [...n, B], !1 }) } return n; case "child_added": if (d > -1) { const E = n[d - 1]; (E && E.key || null) !== r && (n = n.filter(x => x.payload.key !== t.key)).splice(_, 0, e) } else { if (null == r) return [e, ...n]; (n = n.slice()).splice(_, 0, e) } return n; case "child_removed": return n.filter(E => E.payload.key !== t.key); case "child_changed": return n.map(E => E.payload.key === a ? e : E); case "child_moved": if (d > -1) { const E = n.splice(d, 1)[0]; return (n = n.slice()).splice(_, 0, E), n } return n; default: return n } } function C1(n) { return (x0(n) || 0 === n.length) && (n = ["child_added", "child_removed", "child_changed", "child_moved"]), n } function Gy(n, e, t) { return function w1(n, e, t) { return Hg(n, "value", "once", t).pipe((0, Vu.w)(r => { const a = [(0, Qc.of)(r)]; return e.forEach(d => a.push(Hg(n, d, "on", t))), (0, Sa.T)(...a).pipe((0, Ia.R)(XE, [])) }), (0, Vs.x)()) }(n, e = C1(e), t) } function Xf(n, e, t) { const r = (e = C1(e)).map(a => Hg(n, a, "on", t)); return (0, Sa.T)(...r) } function tT(n, e) { return function (r, a) { return N0(r, { stringCase: () => n.child(r)[e](a), firebaseCase: () => r[e](a), snapshotCase: () => r.ref[e](a) }) } } function rI(n) { return function (t) { return t ? N0(t, { stringCase: () => n.child(t).remove(), firebaseCase: () => t.remove(), snapshotCase: () => t.ref.remove() }) : n.remove() } } function E1(n, e) { return function () { return Hg(n, "value", "on", e) } } const rT = new m.OlP("angularfire2.realtimeDatabaseURL"), Il = new m.OlP("angularfire2.database.use-emulator"); let D1 = (() => { class n { constructor(t, r, a, d, _, E, x, B, K, oe, Me, ot, bt, qt, Tn) { this.schedulers = E; const cr = x, $r = (0, Aa.on)(t, _, r); B && (0, Hl.nw)($r, _, K, Me, ot, bt, oe, qt), this.database = (0, Aa.cc)(`${$r.name}.database.${a}`, "AngularFireDatabase", $r.name, () => { const Rr = _.runOutsideAngular(() => $r.database(a || void 0)); return cr && Rr.useEmulator(...cr), Rr }, [cr]) } list(t, r) { const a = this.schedulers.ngZone.runOutsideAngular(() => O0(this.database, t)); let d = a; return r && (d = r(a)), function nT(n, e) { const t = e.schedulers.outsideAngular, r = e.schedulers.ngZone.run(() => n.ref); return { query: n, update: tT(r, "update"), set: tT(r, "set"), push: a => r.push(a), remove: rI(r), snapshotChanges: a => Gy(n, a, t).pipe(ci.iC), stateChanges: a => Xf(n, a, t).pipe(ci.iC), auditTrail: a => function k0(n, e, t) { return function P0(n, e, t) { return function eT(n, e) { return Hg(n, "value", "on", e).pipe((0, ao.U)(t => { let r; return t.payload.forEach(a => (r = a.key, !1)), { data: t, lastKeyToLoad: r } })) }(n, t).pipe((0, ii.M)(e), (0, ao.U)(([a, d]) => { const _ = a.lastKeyToLoad, E = d.map(x => x.key); return { actions: d, lastKeyToLoad: _, loadedKeys: E } }), function vu(n) { return (0, tc.e)((e, t) => { let r = !1, a = 0; e.subscribe((0, ud.x)(t, d => (r || (r = !n(d, a++))) && t.next(d))) }) }(a => -1 === a.loadedKeys.indexOf(a.lastKeyToLoad)), (0, ao.U)(a => a.actions)) }(n, Xf(n, e).pipe((0, Ia.R)((a, d) => [...a, d], [])), t) }(n, a, t).pipe(ci.iC), valueChanges: (a, d) => Gy(n, a, t).pipe((0, ao.U)(E => E.map(x => d && d.idField ? Object.assign(Object.assign({}, x.payload.val()), { [d.idField]: x.key }) : x.payload.val())), ci.iC) } }(d, this) } object(t) { return function T1(n, e) { return { query: n, snapshotChanges: () => E1(n, e.schedulers.outsideAngular)().pipe(ci.iC), update: t => n.ref.update(t), set: t => n.ref.set(t), remove: () => n.ref.remove(), valueChanges: () => E1(n, e.schedulers.outsideAngular)().pipe(ci.iC, (0, ao.U)(r => r.payload.exists() ? r.payload.val() : null)) } }(this.schedulers.ngZone.runOutsideAngular(() => O0(this.database, t)), this) } createPushId() { return this.schedulers.ngZone.runOutsideAngular(() => this.database.ref()).push().key } } return n.\u0275fac = function (t) { return new (t || n)(m.LFG(Aa.Dh), m.LFG(Aa.xv, 8), m.LFG(rT, 8), m.LFG(m.Lbi), m.LFG(m.R0b), m.LFG(ci.HU), m.LFG(Il, 8), m.LFG(Hl.zQ, 8), m.LFG(Hl.Qv, 8), m.LFG(Hl.L6, 8), m.LFG(Hl._Q, 8), m.LFG(Hl.rT, 8), m.LFG(Hl.lh, 8), m.LFG(Hl.f7, 8), m.LFG(zy.nm, 8)) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac, providedIn: "any" }), n })(), iT = (() => { class n { constructor() { qm.Z.registerVersion("angularfire", ci.q4.full, "rtdb-compat") } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275mod = m.oAB({ type: n }), n.\u0275inj = m.cJS({ providers: [D1] }), n })(); const S1_Master= { apiKey: "AIzaSyA6iX_czMTqUOoRE1MaN8cgw3UROABQbm0", authDomain: "angularproject-7dbc4.firebaseapp.com", projectId: "angularproject-7dbc4", storageBucket: "angularproject-7dbc4.appspot.com", messagingSenderId: "128958291271", appId: "1:128958291271:web:55359c60309d5ba95b8062", measurementId: "G-XJFCKX26LP" }; var Er, Km = L(8996), R0 = L(8675), jy = L(1520), F0 = L(9300), zg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, pf = {}, $y = $y || {}, _i = zg || self; function Jm() { } function L0(n) { var e = typeof n; return "array" == (e = "object" != e ? e : n ? Array.isArray(n) ? "array" : e : "null") || "object" == e && "number" == typeof n.length } function Lp(n) { var e = typeof n; return "object" == e && null != n || "function" == e } var nd = "closure_uid_" + (1e9 * Math.random() >>> 0), sT = 0; function I1(n, e, t) { return n.call.apply(n.bind, arguments) } function Ph(n, e, t) { if (!n) throw Error(); if (2 < arguments.length) { var r = Array.prototype.slice.call(arguments, 2); return function () { var a = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(a, r), n.apply(e, a) } } return function () { return n.apply(e, arguments) } } function Do(n, e, t) { return (Do = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? I1 : Ph).apply(null, arguments) } function ku(n, e) { var t = Array.prototype.slice.call(arguments, 1); return function () { var r = t.slice(); return r.push.apply(r, arguments), n.apply(this, r) } } function zl(n, e) { function t() { } t.prototype = e.prototype, n.X = e.prototype, n.prototype = new t, n.prototype.constructor = n, n.Wb = function (r, a, d) { for (var _ = Array(arguments.length - 2), E = 2; E < arguments.length; E++)_[E - 2] = arguments[E]; return e.prototype[a].apply(r, _) } } function gf() { this.s = this.s, this.o = this.o } gf.prototype.s = !1, gf.prototype.na = function () { !this.s && (this.s = !0, this.M(), 0) && function B0(n) { Object.prototype.hasOwnProperty.call(n, nd) && n[nd] || (n[nd] = ++sT) }(this) }, gf.prototype.M = function () { if (this.o) for (; this.o.length;)this.o.shift()() }; const A1 = Array.prototype.indexOf ? function (n, e) { return Array.prototype.indexOf.call(n, e, void 0) } : function (n, e) { if ("string" == typeof n) return "string" != typeof e || 1 != e.length ? -1 : n.indexOf(e, 0); for (let t = 0; t < n.length; t++)if (t in n && n[t] === e) return t; return -1 }; function V0(n) { const e = n.length; if (0 < e) { const t = Array(e); for (let r = 0; r < e; r++)t[r] = n[r]; return t } return [] } function x1(n, e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; if (L0(r)) { const a = n.length || 0, d = r.length || 0; n.length = a + d; for (let _ = 0; _ < d; _++)n[a + _] = r[_] } else n.push(r) } } function Gl(n, e) { this.type = n, this.g = this.target = e, this.defaultPrevented = !1 } Gl.prototype.h = function () { this.defaultPrevented = !0 }; var Qm = function () { if (!_i.addEventListener || !Object.defineProperty) return !1; var n = !1, e = Object.defineProperty({}, "passive", { get: function () { n = !0 } }); try { _i.addEventListener("test", Jm, e), _i.removeEventListener("test", Jm, e) } catch { } return n }(); function Wy(n) { return /^[\s\xa0]*$/.test(n) } var U0 = String.prototype.trim ? function (n) { return n.trim() } : function (n) { return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(n)[1] }; function H0(n, e) { return n < e ? -1 : n > e ? 1 : 0 } function Xm() { var n = _i.navigator; return n && (n = n.userAgent) ? n : "" } function ih(n) { return -1 != Xm().indexOf(n) } function Gg(n) { return Gg[" "](n), n } Gg[" "] = Jm; var e_, n, M1 = ih("Opera"), Bp = ih("Trident") || ih("MSIE"), Zy = ih("Edge"), jg = Zy || Bp, qy = ih("Gecko") && !(-1 != Xm().toLowerCase().indexOf("webkit") && !ih("Edge")) && !(ih("Trident") || ih("MSIE")) && !ih("Edge"), O1 = -1 != Xm().toLowerCase().indexOf("webkit") && !ih("Edge"); function z0() { var n = _i.document; return n ? n.documentMode : void 0 } e: { var Yy = "", Ky = (n = Xm(), qy ? /rv:([^\);]+)(\)|;)/.exec(n) : Zy ? /Edge\/([\d\.]+)/.exec(n) : Bp ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(n) : O1 ? /WebKit\/(\S+)/.exec(n) : M1 ? /(?:Version)[ \/]?(\S+)/.exec(n) : void 0); if (Ky && (Yy = Ky ? Ky[1] : ""), Bp) { var Jy = z0(); if (null != Jy && Jy > parseFloat(Yy)) { e_ = String(Jy); break e } } e_ = Yy } var N1 = {}; var lT = _i.document && Bp && (z0() || parseInt(e_, 10)) || void 0; function t_(n, e) { if (Gl.call(this, n ? n.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, n) { var t = this.type = n.type, r = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : null; if (this.target = n.target || n.srcElement, this.g = e, e = n.relatedTarget) { if (qy) { e: { try { Gg(e.nodeName); var a = !0; break e } catch { } a = !1 } a || (e = null) } } else "mouseover" == t ? e = n.fromElement : "mouseout" == t && (e = n.toElement); this.relatedTarget = e, r ? (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0) : (this.clientX = void 0 !== n.clientX ? n.clientX : n.pageX, this.clientY = void 0 !== n.clientY ? n.clientY : n.pageY, this.screenX = n.screenX || 0, this.screenY = n.screenY || 0), this.button = n.button, this.key = n.key || "", this.ctrlKey = n.ctrlKey, this.altKey = n.altKey, this.shiftKey = n.shiftKey, this.metaKey = n.metaKey, this.pointerId = n.pointerId || 0, this.pointerType = "string" == typeof n.pointerType ? n.pointerType : cT[n.pointerType] || "", this.state = n.state, this.i = n, n.defaultPrevented && t_.X.h.call(this) } } zl(t_, Gl); var cT = { 2: "touch", 3: "pen", 4: "mouse" }; t_.prototype.h = function () { t_.X.h.call(this); var n = this.i; n.preventDefault ? n.preventDefault() : n.returnValue = !1 }; var n_ = "closure_listenable_" + (1e6 * Math.random() | 0), uT = 0; function dT(n, e, t, r, a) { this.listener = n, this.proxy = null, this.src = e, this.type = t, this.capture = !!r, this.ha = a, this.key = ++uT, this.ba = this.ea = !1 } function Xy(n) { n.ba = !0, n.listener = null, n.proxy = null, n.src = null, n.ha = null } function G0(n, e, t) { for (const r in n) e.call(t, n[r], r, n) } function R1(n) { const e = {}; for (const t in n) e[t] = n[t]; return e } const F1 = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "); function L1(n, e) { let t, r; for (let a = 1; a < arguments.length; a++) { for (t in r = arguments[a], r) n[t] = r[t]; for (let d = 0; d < F1.length; d++)t = F1[d], Object.prototype.hasOwnProperty.call(r, t) && (n[t] = r[t]) } } function ev(n) { this.src = n, this.g = {}, this.h = 0 } function j0(n, e) { var t = e.type; if (t in n.g) { var d, r = n.g[t], a = A1(r, e); (d = 0 <= a) && Array.prototype.splice.call(r, a, 1), d && (Xy(e), 0 == n.g[t].length && (delete n.g[t], n.h--)) } } function $0(n, e, t, r) { for (var a = 0; a < n.length; ++a) { var d = n[a]; if (!d.ba && d.listener == e && d.capture == !!t && d.ha == r) return a } return -1 } ev.prototype.add = function (n, e, t, r, a) { var d = n.toString(); (n = this.g[d]) || (n = this.g[d] = [], this.h++); var _ = $0(n, e, r, a); return -1 < _ ? (e = n[_], t || (e.ea = !1)) : ((e = new dT(e, this.src, d, !!r, a)).ea = t, n.push(e)), e }; var W0 = "closure_lm_" + (1e6 * Math.random() | 0), tv = {}; function Z0(n, e, t, r, a) { if (r && r.once) return Y0(n, e, t, r, a); if (Array.isArray(e)) { for (var d = 0; d < e.length; d++)Z0(n, e[d], t, r, a); return null } return t = mf(t), n && n[n_] ? n.N(e, t, Lp(r) ? !!r.capture : !!r, a) : q0(n, e, t, !1, r, a) } function q0(n, e, t, r, a, d) { if (!e) throw Error("Invalid event type"); var _ = Lp(a) ? !!a.capture : !!a, E = r_(n); if (E || (n[W0] = E = new ev(n)), (t = E.add(e, t, r, _, d)).proxy) return t; if (r = function B1() { const e = V1; return function n(t) { return e.call(n.src, n.listener, t) } }(), t.proxy = r, r.src = n, r.listener = t, n.addEventListener) Qm || (a = _), void 0 === a && (a = !1), n.addEventListener(e.toString(), r, a); else if (n.attachEvent) n.attachEvent(J0(e.toString()), r); else { if (!n.addListener || !n.removeListener) throw Error("addEventListener and attachEvent are unavailable."); n.addListener(r) } return t } function Y0(n, e, t, r, a) { if (Array.isArray(e)) { for (var d = 0; d < e.length; d++)Y0(n, e[d], t, r, a); return null } return t = mf(t), n && n[n_] ? n.O(e, t, Lp(r) ? !!r.capture : !!r, a) : q0(n, e, t, !0, r, a) } function K0(n, e, t, r, a) { if (Array.isArray(e)) for (var d = 0; d < e.length; d++)K0(n, e[d], t, r, a); else r = Lp(r) ? !!r.capture : !!r, t = mf(t), n && n[n_] ? (n = n.i, (e = String(e).toString()) in n.g && -1 < (t = $0(d = n.g[e], t, r, a)) && (Xy(d[t]), Array.prototype.splice.call(d, t, 1), 0 == d.length && (delete n.g[e], n.h--))) : n && (n = r_(n)) && (e = n.g[e.toString()], n = -1, e && (n = $0(e, t, r, a)), (t = -1 < n ? e[n] : null) && nv(t)) } function nv(n) { if ("number" != typeof n && n && !n.ba) { var e = n.src; if (e && e[n_]) j0(e.i, n); else { var t = n.type, r = n.proxy; e.removeEventListener ? e.removeEventListener(t, r, n.capture) : e.detachEvent ? e.detachEvent(J0(t), r) : e.addListener && e.removeListener && e.removeListener(r), (t = r_(e)) ? (j0(t, n), 0 == t.h && (t.src = null, e[W0] = null)) : Xy(n) } } } function J0(n) { return n in tv ? tv[n] : tv[n] = "on" + n } function V1(n, e) { if (n.ba) n = !0; else { e = new t_(e, this); var t = n.listener, r = n.ha || n.src; n.ea && nv(n), n = t.call(r, e) } return n } function r_(n) { return (n = n[W0]) instanceof ev ? n : null } var i_ = "__closure_events_fn_" + (1e9 * Math.random() >>> 0); function mf(n) { return "function" == typeof n ? n : (n[i_] || (n[i_] = function (e) { return n.handleEvent(e) }), n[i_]) } function jl() { gf.call(this), this.i = new ev(this), this.P = this, this.I = null } function pc(n, e) { var t, r = n.I; if (r) for (t = []; r; r = r.I)t.push(r); if (n = n.P, r = e.type || e, "string" == typeof e) e = new Gl(e, n); else if (e instanceof Gl) e.target = e.target || n; else { var a = e; L1(e = new Gl(r, n), a) } if (a = !0, t) for (var d = t.length - 1; 0 <= d; d--) { var _ = e.g = t[d]; a = _f(_, r, !0, e) && a } if (a = _f(_ = e.g = n, r, !0, e) && a, a = _f(_, r, !1, e) && a, t) for (d = 0; d < t.length; d++)a = _f(_ = e.g = t[d], r, !1, e) && a } function _f(n, e, t, r) { if (!(e = n.i.g[String(e)])) return !0; e = e.concat(); for (var a = !0, d = 0; d < e.length; ++d) { var _ = e[d]; if (_ && !_.ba && _.capture == t) { var E = _.listener, x = _.ha || _.src; _.ea && j0(n.i, _), a = !1 !== E.call(x, r) && a } } return a && !r.defaultPrevented } zl(jl, gf), jl.prototype[n_] = !0, jl.prototype.removeEventListener = function (n, e, t, r) { K0(this, n, e, t, r) }, jl.prototype.M = function () { if (jl.X.M.call(this), this.i) { var e, n = this.i; for (e in n.g) { for (var t = n.g[e], r = 0; r < t.length; r++)Xy(t[r]); delete n.g[e], n.h-- } } this.I = null }, jl.prototype.N = function (n, e, t, r) { return this.i.add(String(n), e, !1, t, r) }, jl.prototype.O = function (n, e, t, r) { return this.i.add(String(n), e, !0, t, r) }; var U1 = _i.JSON.stringify; function Q0() { var n = Vp; let e = null; return n.g && (e = n.g, n.g = n.g.next, n.g || (n.h = null), e.next = null), e } var eb, X0 = new class { constructor(n, e) { this.i = n, this.j = e, this.h = 0, this.g = null } get() { let n; return 0 < this.h ? (this.h--, n = this.g, this.g = n.next, n.next = null) : n = this.i(), n } }(() => new H1, n => n.reset()); class H1 { constructor() { this.next = this.g = this.h = null } set(e, t) { this.h = e, this.g = t, this.next = null } reset() { this.next = this.g = this.h = null } } function sI(n) { _i.setTimeout(() => { throw n }, 0) } function Ur(n, e) { eb || function hT() { var n = _i.Promise.resolve(void 0); eb = function () { n.then(fT) } }(), tb || (eb(), tb = !0), Vp.add(n, e) } var tb = !1, Vp = new class iI { constructor() { this.h = this.g = null } add(e, t) { const r = X0.get(); r.set(e, t), this.h ? this.h.next = r : this.g = r, this.h = r } }; function fT() { for (var n; n = Q0();) { try { n.h.call(n.g) } catch (t) { sI(t) } var e = X0; e.j(n), 100 > e.h && (e.h++, n.next = e.g, e.g = n) } tb = !1 } function Up(n, e) { jl.call(this), this.h = n || 1, this.g = e || _i, this.j = Do(this.lb, this), this.l = Date.now() } function $g(n) { n.ca = !1, n.R && (n.g.clearTimeout(n.R), n.R = null) } function ta(n, e, t) { if ("function" == typeof n) t && (n = Do(n, t)); else { if (!n || "function" != typeof n.handleEvent) throw Error("Invalid listener argument"); n = Do(n.handleEvent, n) } return 2147483647 < Number(e) ? -1 : _i.setTimeout(n, e || 0) } function pT(n) { n.g = ta(() => { n.g = null, n.i && (n.i = !1, pT(n)) }, n.j); const e = n.h; n.h = null, n.m.apply(null, e) } zl(Up, jl), (Er = Up.prototype).ca = !1, Er.R = null, Er.lb = function () { if (this.ca) { var n = Date.now() - this.l; 0 < n && n < .8 * this.h ? this.R = this.g.setTimeout(this.j, this.h - n) : (this.R && (this.g.clearTimeout(this.R), this.R = null), pc(this, "tick"), this.ca && ($g(this), this.start())) } }, Er.start = function () { this.ca = !0, this.R || (this.R = this.g.setTimeout(this.j, this.h), this.l = Date.now()) }, Er.M = function () { Up.X.M.call(this), $g(this), delete this.g }; class z1 extends gf { constructor(e, t) { super(), this.m = e, this.j = t, this.h = null, this.i = !1, this.g = null } l(e) { this.h = arguments, this.g ? this.i = !0 : pT(this) } M() { super.M(), this.g && (_i.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null) } } function Wg(n) { gf.call(this), this.h = n, this.g = {} } zl(Wg, gf); var G1 = []; function nb(n, e, t, r) { Array.isArray(t) || (t && (G1[0] = t.toString()), t = G1); for (var a = 0; a < t.length; a++) { var d = Z0(e, t[a], r || n.handleEvent, !1, n.h || n); if (!d) break; n.g[d.key] = d } } function rb(n) { G0(n.g, function (e, t) { this.g.hasOwnProperty(t) && nv(e) }, n), n.g = {} } function s_() { this.g = !0 } function Zg(n, e, t, r) { n.info(function () { return "XMLHTTP TEXT (" + e + "): " + function o_(n, e) { if (!n.g) return e; if (!e) return null; try { var t = JSON.parse(e); if (t) for (n = 0; n < t.length; n++)if (Array.isArray(t[n])) { var r = t[n]; if (!(2 > r.length)) { var a = r[1]; if (Array.isArray(a) && !(1 > a.length)) { var d = a[0]; if ("noop" != d && "stop" != d && "close" != d) for (var _ = 1; _ < a.length; _++)a[_] = "" } } } return U1(t) } catch { return e } }(n, t) + (r ? " " + r : "") }) } Wg.prototype.M = function () { Wg.X.M.call(this), rb(this) }, Wg.prototype.handleEvent = function () { throw Error("EventHandler.handleEvent not implemented") }, s_.prototype.Aa = function () { this.g = !1 }, s_.prototype.info = function () { }; var Hp = {}, $1 = null; function rv() { return $1 = $1 || new jl } function a_(n) { Gl.call(this, Hp.Pa, n) } function qg(n) { const e = rv(); pc(e, new a_(e)) } function ib(n, e) { Gl.call(this, Hp.STAT_EVENT, n), this.stat = e } function jc(n) { const e = rv(); pc(e, new ib(e, n)) } function W1(n, e) { Gl.call(this, Hp.Qa, n), this.size = e } function yf(n, e) { if ("function" != typeof n) throw Error("Fn must not be null and must be a function"); return _i.setTimeout(function () { n() }, e) } Hp.Pa = "serverreachability", zl(a_, Gl), Hp.STAT_EVENT = "statevent", zl(ib, Gl), Hp.Qa = "timingevent", zl(W1, Gl); var ep = { NO_ERROR: 0, mb: 1, zb: 2, yb: 3, tb: 4, xb: 5, Ab: 6, Ma: 7, TIMEOUT: 8, Db: 9 }, Z1 = { rb: "complete", Nb: "success", Na: "error", Ma: "abort", Fb: "ready", Gb: "readystatechange", TIMEOUT: "timeout", Bb: "incrementaldata", Eb: "progress", ub: "downloadprogress", Vb: "uploadprogress" }; function sb() { } function ob() { } sb.prototype.h = null; var sv, Yg = { OPEN: "a", qb: "b", Na: "c", Cb: "d" }; function iv() { Gl.call(this, "d") } function ab() { Gl.call(this, "c") } function ov() { } function l_(n, e, t, r) { this.l = n, this.j = e, this.m = t, this.U = r || 1, this.S = new Wg(this), this.O = oI, this.T = new Up(n = jg ? 125 : void 0), this.H = null, this.i = !1, this.s = this.A = this.v = this.K = this.F = this.V = this.B = null, this.D = [], this.g = null, this.C = 0, this.o = this.u = null, this.Y = -1, this.I = !1, this.N = 0, this.L = null, this.$ = this.J = this.Z = this.P = !1, this.h = new _T } function _T() { this.i = null, this.g = "", this.h = !1 } zl(iv, Gl), zl(ab, Gl), zl(ov, sb), ov.prototype.g = function () { return new XMLHttpRequest }, ov.prototype.i = function () { return {} }, sv = new ov; var oI = 45e3, Y1 = {}, lb = {}; function av(n, e, t) { n.K = 1, n.v = uv(Rh(e)), n.s = t, n.P = !0, c_(n, null) } function c_(n, e) { n.F = Date.now(), vf(n), n.A = Rh(n.v); var t = n.A, r = n.U; Array.isArray(r) || (r = [String(r)]), lC(t.i, "t", r), n.C = 0, t = n.l.H, n.h = new _T, n.g = yC(n.l, t ? e : null, !n.s), 0 < n.N && (n.L = new z1(Do(n.La, n, n.g), n.N)), nb(n.S, n.g, "readystatechange", n.ib), e = n.H ? R1(n.H) : {}, n.s ? (n.u || (n.u = "POST"), e["Content-Type"] = "application/x-www-form-urlencoded", n.g.da(n.A, n.u, n.s, e)) : (n.u = "GET", n.g.da(n.A, n.u, null, e)), qg(), function j1(n, e, t, r, a, d) { n.info(function () { if (n.g) if (d) for (var _ = "", E = d.split("&"), x = 0; x < E.length; x++) { var B = E[x].split("="); if (1 < B.length) { var K = B[0]; B = B[1]; var oe = K.split("_"); _ = 2 <= oe.length && "type" == oe[1] ? _ + (K + "=") + B + "&" : _ + (K + "=redacted&") } } else _ = null; else _ = d; return "XMLHTTP REQ (" + r + ") [attempt " + a + "]: " + e + "\n" + t + "\n" + _ }) }(n.j, n.u, n.A, n.m, n.U, n.s) } function K1(n) { return !!n.g && "GET" == n.u && 2 != n.K && n.l.Da } function J1(n, e, t) { let a, r = !0; for (; !n.I && n.C < t.length;) { if (a = Q1(n, t), a == lb) { 4 == e && (n.o = 4, jc(14), r = !1), Zg(n.j, n.m, null, "[Incomplete Response]"); break } if (a == Y1) { n.o = 4, jc(15), Zg(n.j, n.m, t, "[Invalid Chunk]"), r = !1; break } Zg(n.j, n.m, a, null), eC(n, a) } K1(n) && a != lb && a != Y1 && (n.h.g = "", n.C = 0), 4 != e || 0 != t.length || n.h.h || (n.o = 1, jc(16), r = !1), n.i = n.i && r, r ? 0 < t.length && !n.$ && (n.$ = !0, (e = n.l).g == n && e.$ && !e.K && (e.j.info("Great, no buffering proxy detected. Bytes received: " + t.length), vv(e), e.K = !0, jc(11))) : (Zg(n.j, n.m, t, "[Invalid Chunked Response]"), zp(n), u_(n)) } function Q1(n, e) { var t = n.C, r = e.indexOf("\n", t); return -1 == r ? lb : (t = Number(e.substring(t, r)), isNaN(t) ? Y1 : (r += 1) + t > e.length ? lb : (e = e.substr(r, t), n.C = r + t, e)) } function vf(n) { n.V = Date.now() + n.O, X1(n, n.O) } function X1(n, e) { if (null != n.B) throw Error("WatchDog timer not null"); n.B = yf(Do(n.gb, n), e) } function lv(n) { n.B && (_i.clearTimeout(n.B), n.B = null) } function u_(n) { 0 == n.l.G || n.I || Ib(n.l, n) } function zp(n) { lv(n); var e = n.L; e && "function" == typeof e.na && e.na(), n.L = null, $g(n.T), rb(n.S), n.g && (e = n.g, n.g = null, e.abort(), e.na()) } function eC(n, e) { try { var t = n.l; if (0 != t.G && (t.g == n || dv(t.h, n))) if (!n.J && dv(t.h, n) && 3 == t.G) { try { var r = t.Fa.g.parse(e) } catch { r = null } if (Array.isArray(r) && 3 == r.length) { var a = r; if (0 == a[0]) { e: if (!t.u) { if (t.g) { if (!(t.g.F + 3e3 < n.F)) break e; b_(t), yv(t) } Db(t), jc(18) } } else t.Ba = a[1], 0 < t.Ba - t.T && 37500 > a[2] && t.L && 0 == t.A && !t.v && (t.v = yf(Do(t.cb, t), 6e3)); if (1 >= hb(t.h) && t.ja) { try { t.ja() } catch { } t.ja = void 0 } } else tp(t, 11) } else if ((n.J || t.g == n) && b_(t), !Wy(e)) for (a = t.Fa.g.parse(e), e = 0; e < a.length; e++) { let B = a[e]; if (t.T = B[0], B = B[1], 2 == t.G) if ("c" == B[0]) { t.I = B[1], t.ka = B[2]; const K = B[3]; null != K && (t.ma = K, t.j.info("VER=" + t.ma)); const oe = B[4]; null != oe && (t.Ca = oe, t.j.info("SVER=" + t.Ca)); const Me = B[5]; null != Me && "number" == typeof Me && 0 < Me && (t.J = r = 1.5 * Me, t.j.info("backChannelRequestTimeoutMs_=" + r)), r = t; const ot = n.g; if (ot) { const bt = ot.g ? ot.g.getResponseHeader("X-Client-Wire-Protocol") : null; if (bt) { var d = r.h; d.g || -1 == bt.indexOf("spdy") && -1 == bt.indexOf("quic") && -1 == bt.indexOf("h2") || (d.j = d.l, d.g = new Set, d.h && (fb(d, d.h), d.h = null)) } if (r.D) { const qt = ot.g ? ot.g.getResponseHeader("X-HTTP-Session-Id") : null; qt && (r.za = qt, Bo(r.F, r.D, qt)) } } t.G = 3, t.l && t.l.xa(), t.$ && (t.P = Date.now() - n.F, t.j.info("Handshake RTT: " + t.P + "ms")); var _ = n; if ((r = t).sa = Mb(r, r.H ? r.ka : null, r.V), _.J) { hv(r.h, _); var E = _, x = r.J; x && E.setTimeout(x), E.B && (lv(E), vf(E)), r.g = _ } else _C(r); 0 < t.i.length && Tb(t) } else "stop" != B[0] && "close" != B[0] || tp(t, 7); else 3 == t.G && ("stop" == B[0] || "close" == B[0] ? "stop" == B[0] ? tp(t, 7) : Cb(t) : "noop" != B[0] && t.l && t.l.wa(B), t.A = 0) } qg() } catch { } } function nC(n, e) { if (n.forEach && "function" == typeof n.forEach) n.forEach(e, void 0); else if (L0(n) || "string" == typeof n) Array.prototype.forEach.call(n, e, void 0); else for (var t = function tC(n) { if (n.oa && "function" == typeof n.oa) return n.oa(); if (!n.W || "function" != typeof n.W) { if (typeof Map < "u" && n instanceof Map) return Array.from(n.keys()); if (!(typeof Set < "u" && n instanceof Set)) { if (L0(n) || "string" == typeof n) { var e = []; n = n.length; for (var t = 0; t < n; t++)e.push(t); return e } e = [], t = 0; for (const r in n) e[t++] = r; return e } } }(n), r = function yT(n) { if (n.W && "function" == typeof n.W) return n.W(); if (typeof Map < "u" && n instanceof Map || typeof Set < "u" && n instanceof Set) return Array.from(n.values()); if ("string" == typeof n) return n.split(""); if (L0(n)) { for (var e = [], t = n.length, r = 0; r < t; r++)e.push(n[r]); return e } for (r in e = [], t = 0, n) e[t++] = n[r]; return e }(n), a = r.length, d = 0; d < a; d++)e.call(void 0, r[d], t && t[d], n) } (Er = l_.prototype).setTimeout = function (n) { this.O = n }, Er.ib = function (n) { n = n.target; const e = this.L; e && 3 == Fh(n) ? e.l() : this.La(n) }, Er.La = function (n) { try { if (n == this.g) e: { const K = Fh(this.g); var e = this.g.Ea(); if (this.g.aa(), !(3 > K) && (3 != K || jg || this.g && (this.h.h || this.g.fa() || bb(this.g)))) { this.I || 4 != K || 7 == e || qg(), lv(this); var t = this.g.aa(); this.Y = t; t: if (K1(this)) { var r = bb(this.g); n = ""; var a = r.length, d = 4 == Fh(this.g); if (!this.h.i) { if (typeof TextDecoder > "u") { zp(this), u_(this); var _ = ""; break t } this.h.i = new _i.TextDecoder } for (e = 0; e < a; e++)this.h.h = !0, n += this.h.i.decode(r[e], { stream: d && e == a - 1 }); r.splice(0, a), this.h.g += n, this.C = 0, _ = this.h.g } else _ = this.g.fa(); if (this.i = 200 == t, function gT(n, e, t, r, a, d, _) { n.info(function () { return "XMLHTTP RESP (" + r + ") [ attempt " + a + "]: " + e + "\n" + t + "\n" + d + " " + _ }) }(this.j, this.u, this.A, this.m, this.U, K, t), this.i) { if (this.Z && !this.J) { t: { if (this.g) { var E, x = this.g; if ((E = x.g ? x.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !Wy(E)) { var B = E; break t } } B = null } if (!(t = B)) { this.i = !1, this.o = 3, jc(12), zp(this), u_(this); break e } Zg(this.j, this.m, t, "Initial handshake response via X-HTTP-Initial-Response"), this.J = !0, eC(this, t) } this.P ? (J1(this, K, _), jg && this.i && 3 == K && (nb(this.S, this.T, "tick", this.hb), this.T.start())) : (Zg(this.j, this.m, _, null), eC(this, _)), 4 == K && zp(this), this.i && !this.I && (4 == K ? Ib(this.l, this) : (this.i = !1, vf(this))) } else 400 == t && 0 < _.indexOf("Unknown SID") ? (this.o = 3, jc(12)) : (this.o = 0, jc(13)), zp(this), u_(this) } } } catch { } }, Er.hb = function () { if (this.g) { var n = Fh(this.g), e = this.g.fa(); this.C < e.length && (lv(this), J1(this, n, e), this.i && 4 != n && vf(this)) } }, Er.cancel = function () { this.I = !0, zp(this) }, Er.gb = function () { this.B = null; const n = Date.now(); 0 <= n - this.V ? (function mT(n, e) { n.info(function () { return "TIMEOUT: " + e }) }(this.j, this.A), 2 != this.K && (qg(), jc(17)), zp(this), this.o = 2, u_(this)) : X1(this, this.V - n) }; var rC = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$"); function Gp(n, e) { if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = !1, n instanceof Gp) { this.h = void 0 !== e ? e : n.h, cv(this, n.j), this.s = n.s, this.g = n.g, h_(this, n.m), this.l = n.l, e = n.i; var t = new p_; t.i = e.i, e.g && (t.g = new Map(e.g), t.h = e.h), iC(this, t), this.o = n.o } else n && (t = String(n).match(rC)) ? (this.h = !!e, cv(this, t[1] || "", !0), this.s = jp(t[2] || ""), this.g = jp(t[3] || "", !0), h_(this, t[4]), this.l = jp(t[5] || "", !0), iC(this, t[6] || "", !0), this.o = jp(t[7] || "")) : (this.h = !!e, this.i = new p_(null, this.h)) } function Rh(n) { return new Gp(n) } function cv(n, e, t) { n.j = t ? jp(e, !0) : e, n.j && (n.j = n.j.replace(/:$/, "")) } function h_(n, e) { if (e) { if (e = Number(e), isNaN(e) || 0 > e) throw Error("Bad port number " + e); n.m = e } else n.m = null } function iC(n, e, t) { e instanceof p_ ? (n.i = e, function CT(n, e) { e && !n.j && (bf(n), n.i = null, n.g.forEach(function (t, r) { var a = r.toLowerCase(); r != a && (oC(this, r), lC(this, a, t)) }, n)), n.j = e }(n.i, n.h)) : (t || (e = f_(e, wT)), n.i = new p_(e, n.h)) } function Bo(n, e, t) { n.i.set(e, t) } function uv(n) { return Bo(n, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), n } function jp(n, e) { return n ? e ? decodeURI(n.replace(/%25/g, "%2525")) : decodeURIComponent(n) : "" } function f_(n, e, t) { return "string" == typeof n ? (n = encodeURI(n).replace(e, sC), t && (n = n.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), n) : null } function sC(n) { return "%" + ((n = n.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & n).toString(16) } Gp.prototype.toString = function () { var n = [], e = this.j; e && n.push(f_(e, cb, !0), ":"); var t = this.g; return (t || "file" == e) && (n.push("//"), (e = this.s) && n.push(f_(e, cb, !0), "@"), n.push(encodeURIComponent(String(t)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), null != (t = this.m) && n.push(":", String(t))), (t = this.l) && (this.g && "/" != t.charAt(0) && n.push("/"), n.push(f_(t, "/" == t.charAt(0) ? bT : vT, !0))), (t = this.i.toString()) && n.push("?", t), (t = this.o) && n.push("#", f_(t, ub)), n.join("") }; var cb = /[#\/\?@]/g, vT = /[#\?:]/g, bT = /[#\?]/g, wT = /[#\?@]/g, ub = /#/g; function p_(n, e) { this.h = this.g = null, this.i = n || null, this.j = !!e } function bf(n) { n.g || (n.g = new Map, n.h = 0, n.i && function d_(n, e) { if (n) { n = n.split("&"); for (var t = 0; t < n.length; t++) { var r = n[t].indexOf("="), a = null; if (0 <= r) { var d = n[t].substring(0, r); a = n[t].substring(r + 1) } else d = n[t]; e(d, a ? decodeURIComponent(a.replace(/\+/g, " ")) : "") } } }(n.i, function (e, t) { n.add(decodeURIComponent(e.replace(/\+/g, " ")), t) })) } function oC(n, e) { bf(n), e = Kg(n, e), n.g.has(e) && (n.i = null, n.h -= n.g.get(e).length, n.g.delete(e)) } function aC(n, e) { return bf(n), e = Kg(n, e), n.g.has(e) } function lC(n, e, t) { oC(n, e), 0 < t.length && (n.i = null, n.g.set(Kg(n, e), V0(t)), n.h += t.length) } function Kg(n, e) { return e = String(e), n.j && (e = e.toLowerCase()), e } function cC(n) { this.l = n || TT, n = _i.PerformanceNavigationTiming ? 0 < (n = _i.performance.getEntriesByType("navigation")).length && ("hq" == n[0].nextHopProtocol || "h2" == n[0].nextHopProtocol) : !!(_i.g && _i.g.Ga && _i.g.Ga() && _i.g.Ga().$b), this.j = n ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = [] } (Er = p_.prototype).add = function (n, e) { bf(this), this.i = null, n = Kg(this, n); var t = this.g.get(n); return t || this.g.set(n, t = []), t.push(e), this.h += 1, this }, Er.forEach = function (n, e) { bf(this), this.g.forEach(function (t, r) { t.forEach(function (a) { n.call(e, a, r, this) }, this) }, this) }, Er.oa = function () { bf(this); const n = Array.from(this.g.values()), e = Array.from(this.g.keys()), t = []; for (let r = 0; r < e.length; r++) { const a = n[r]; for (let d = 0; d < a.length; d++)t.push(e[r]) } return t }, Er.W = function (n) { bf(this); let e = []; if ("string" == typeof n) aC(this, n) && (e = e.concat(this.g.get(Kg(this, n)))); else { n = Array.from(this.g.values()); for (let t = 0; t < n.length; t++)e = e.concat(n[t]) } return e }, Er.set = function (n, e) { return bf(this), this.i = null, aC(this, n = Kg(this, n)) && (this.h -= this.g.get(n).length), this.g.set(n, [e]), this.h += 1, this }, Er.get = function (n, e) { return n && 0 < (n = this.W(n)).length ? String(n[0]) : e }, Er.toString = function () { if (this.i) return this.i; if (!this.g) return ""; const n = [], e = Array.from(this.g.keys()); for (var t = 0; t < e.length; t++) { var r = e[t]; const d = encodeURIComponent(String(r)), _ = this.W(r); for (r = 0; r < _.length; r++) { var a = d; "" !== _[r] && (a += "=" + encodeURIComponent(String(_[r]))), n.push(a) } } return this.i = n.join("&") }; var TT = 10; function db(n) { return !!n.h || !!n.g && n.g.size >= n.j } function hb(n) { return n.h ? 1 : n.g ? n.g.size : 0 } function dv(n, e) { return n.h ? n.h == e : !!n.g && n.g.has(e) } function fb(n, e) { n.g ? n.g.add(e) : n.h = e } function hv(n, e) { n.h && n.h == e ? n.h = null : n.g && n.g.has(e) && n.g.delete(e) } function pb(n) { if (null != n.h) return n.i.concat(n.h.D); if (null != n.g && 0 !== n.g.size) { let e = n.i; for (const t of n.g.values()) e = e.concat(t.D); return e } return V0(n.i) } function gb() { } function DT() { this.g = new gb } function mb(n, e, t) { const r = t || ""; try { nC(n, function (a, d) { let _ = a; Lp(a) && (_ = U1(a)), e.push(r + d + "=" + encodeURIComponent(_)) }) } catch (a) { throw e.push(r + "type=" + encodeURIComponent("_badmap")), a } } function g_(n, e, t, r, a) { try { e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null, a(r) } catch { } } function $p(n) { this.l = n.ac || null, this.j = n.jb || !1 } function fv(n, e) { jl.call(this), this.D = n, this.u = e, this.m = void 0, this.readyState = yb, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers, this.h = null, this.C = "GET", this.B = "", this.g = !1, this.A = this.j = this.l = null } cC.prototype.cancel = function () { if (this.i = pb(this), this.h) this.h.cancel(), this.h = null; else if (this.g && 0 !== this.g.size) { for (const n of this.g.values()) n.cancel(); this.g.clear() } }, gb.prototype.stringify = function (n) { return _i.JSON.stringify(n, void 0) }, gb.prototype.parse = function (n) { return _i.JSON.parse(n, void 0) }, zl($p, sb), $p.prototype.g = function () { return new fv(this.l, this.j) }, $p.prototype.i = function (n) { return function () { return n } }({}), zl(fv, jl); var yb = 0; function pv(n) { n.j.read().then(n.Ta.bind(n)).catch(n.ga.bind(n)) } function m_(n) { n.readyState = 4, n.l = null, n.j = null, n.A = null, Jg(n) } function Jg(n) { n.onreadystatechange && n.onreadystatechange.call(n) } (Er = fv.prototype).open = function (n, e) { if (this.readyState != yb) throw this.abort(), Error("Error reopening a connection"); this.C = n, this.B = e, this.readyState = 1, Jg(this) }, Er.send = function (n) { if (1 != this.readyState) throw this.abort(), Error("need to call open() first. "); this.g = !0; const e = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 }; n && (e.body = n), (this.D || _i).fetch(new Request(this.B, e)).then(this.Wa.bind(this), this.ga.bind(this)) }, Er.abort = function () { this.response = this.responseText = "", this.v = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => { }), 1 <= this.readyState && this.g && 4 != this.readyState && (this.g = !1, m_(this)), this.readyState = yb }, Er.Wa = function (n) { if (this.g && (this.l = n, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = n.headers, this.readyState = 2, Jg(this)), this.g && (this.readyState = 3, Jg(this), this.g))) if ("arraybuffer" === this.responseType) n.arrayBuffer().then(this.Ua.bind(this), this.ga.bind(this)); else if (typeof _i.ReadableStream < "u" && "body" in n) { if (this.j = n.body.getReader(), this.u) { if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.'); this.response = [] } else this.response = this.responseText = "", this.A = new TextDecoder; pv(this) } else n.text().then(this.Va.bind(this), this.ga.bind(this)) }, Er.Ta = function (n) { if (this.g) { if (this.u && n.value) this.response.push(n.value); else if (!this.u) { var e = n.value ? n.value : new Uint8Array(0); (e = this.A.decode(e, { stream: !n.done })) && (this.response = this.responseText += e) } n.done ? m_(this) : Jg(this), 3 == this.readyState && pv(this) } }, Er.Va = function (n) { this.g && (this.response = this.responseText = n, m_(this)) }, Er.Ua = function (n) { this.g && (this.response = n, m_(this)) }, Er.ga = function () { this.g && m_(this) }, Er.setRequestHeader = function (n, e) { this.v.append(n, e) }, Er.getResponseHeader = function (n) { return this.h && this.h.get(n.toLowerCase()) || "" }, Er.getAllResponseHeaders = function () { if (!this.h) return ""; const n = [], e = this.h.entries(); for (var t = e.next(); !t.done;)n.push((t = t.value)[0] + ": " + t[1]), t = e.next(); return n.join("\r\n") }, Object.defineProperty(fv.prototype, "withCredentials", { get: function () { return "include" === this.m }, set: function (n) { this.m = n ? "include" : "same-origin" } }); var Qg = _i.JSON.parse; function da(n) { jl.call(this), this.headers = new Map, this.u = n || null, this.h = !1, this.C = this.g = null, this.H = "", this.m = 0, this.j = "", this.l = this.F = this.v = this.D = !1, this.B = 0, this.A = null, this.J = uC, this.K = this.L = !1 } zl(da, jl); var uC = "", aI = /^https?$/i, dC = ["POST", "PUT"]; function hC(n, e) { n.h = !1, n.g && (n.l = !0, n.g.abort(), n.l = !1), n.j = e, n.m = 5, gv(n), __(n) } function gv(n) { n.D || (n.D = !0, pc(n, "complete"), pc(n, "error")) } function fC(n) { if (n.h && typeof $y < "u" && (!n.C[1] || 4 != Fh(n) || 2 != n.aa())) if (n.v && 4 == Fh(n)) ta(n.Ha, 0, n); else if (pc(n, "readystatechange"), 4 == Fh(n)) { n.h = !1; try { const E = n.aa(); e: switch (E) { case 200: case 201: case 202: case 204: case 206: case 304: case 1223: var e = !0; break e; default: e = !1 }var t; if (!(t = e)) { var r; if (r = 0 === E) { var a = String(n.H).match(rC)[1] || null; if (!a && _i.self && _i.self.location) { var d = _i.self.location.protocol; a = d.substr(0, d.length - 1) } r = !aI.test(a ? a.toLowerCase() : "") } t = r } if (t) pc(n, "complete"), pc(n, "success"); else { n.m = 6; try { var _ = 2 < Fh(n) ? n.g.statusText : "" } catch { _ = "" } n.j = _ + " [" + n.aa() + "]", gv(n) } } finally { __(n) } } } function __(n, e) { if (n.g) { mv(n); const t = n.g, r = n.C[0] ? Jm : null; n.g = null, n.C = null, e || pc(n, "ready"); try { t.onreadystatechange = r } catch { } } } function mv(n) { n.g && n.K && (n.g.ontimeout = null), n.A && (_i.clearTimeout(n.A), n.A = null) } function Fh(n) { return n.g ? n.g.readyState : 0 } function bb(n) { try { if (!n.g) return null; if ("response" in n.g) return n.g.response; switch (n.J) { case uC: case "text": return n.g.responseText; case "arraybuffer": if ("mozResponseArrayBuffer" in n.g) return n.g.mozResponseArrayBuffer }return null } catch { return null } } function wb(n) { let e = ""; return G0(n, function (t, r) { e += r, e += ":", e += t, e += "\r\n" }), e } function _v(n, e, t) { e: { for (r in t) { var r = !1; break e } r = !0 } r || (t = wb(t), "string" == typeof n ? null != t && encodeURIComponent(String(t)) : Bo(n, e, t)) } function y_(n, e, t) { return t && t.internalChannelParams && t.internalChannelParams[n] || e } function pC(n) { this.Ca = 0, this.i = [], this.j = new s_, this.ka = this.sa = this.F = this.V = this.g = this.za = this.D = this.ia = this.o = this.S = this.s = null, this.ab = this.U = 0, this.Za = y_("failFast", !1, n), this.L = this.v = this.u = this.m = this.l = null, this.Y = !0, this.pa = this.Ba = this.T = -1, this.Z = this.A = this.C = 0, this.Xa = y_("baseRetryDelayMs", 5e3, n), this.bb = y_("retryDelaySeedMs", 1e4, n), this.$a = y_("forwardChannelMaxRetries", 2, n), this.ta = y_("forwardChannelRequestTimeoutMs", 2e4, n), this.ra = n && n.xmlHttpFactory || void 0, this.Da = n && n.Zb || !1, this.J = void 0, this.H = n && n.supportsCrossDomainXhr || !1, this.I = "", this.h = new cC(n && n.concurrentRequestLimit), this.Fa = new DT, this.O = n && n.fastHandshake || !1, this.N = n && n.encodeInitMessageHeaders || !1, this.O && this.N && (this.N = !1), this.Ya = n && n.Xb || !1, n && n.Aa && this.j.Aa(), n && n.forceLongPolling && (this.Y = !1), this.$ = !this.O && this.Y && n && n.detectBufferingProxy || !1, this.ja = void 0, this.P = 0, this.K = !1, this.la = this.B = null } function Cb(n) { if (Eb(n), 3 == n.G) { var e = n.U++, t = Rh(n.F); Bo(t, "SID", n.I), Bo(t, "RID", e), Bo(t, "TYPE", "terminate"), v_(n, t), (e = new l_(n, n.j, e, void 0)).K = 2, e.v = uv(Rh(t)), t = !1, _i.navigator && _i.navigator.sendBeacon && (t = _i.navigator.sendBeacon(e.v.toString(), "")), !t && _i.Image && ((new Image).src = e.v, t = !0), t || (e.g = yC(e.l, null), e.g.da(e.v)), e.F = Date.now(), vf(e) } xb(n) } function yv(n) { n.g && (vv(n), n.g.cancel(), n.g = null) } function Eb(n) { yv(n), n.u && (_i.clearTimeout(n.u), n.u = null), b_(n), n.h.cancel(), n.m && ("number" == typeof n.m && _i.clearTimeout(n.m), n.m = null) } function Tb(n) { db(n.h) || n.m || (n.m = !0, Ur(n.Ja, n), n.C = 0) } function mC(n, e) { var t; t = e ? e.m : n.U++; const r = Rh(n.F); Bo(r, "SID", n.I), Bo(r, "RID", t), Bo(r, "AID", n.T), v_(n, r), n.o && n.s && _v(r, n.o, n.s), t = new l_(n, n.j, t, n.C + 1), null === n.o && (t.H = n.s), e && (n.i = e.D.concat(n.i)), e = ST(n, t, 1e3), t.setTimeout(Math.round(.5 * n.ta) + Math.round(.5 * n.ta * Math.random())), fb(n.h, t), av(t, r, e) } function v_(n, e) { n.ia && G0(n.ia, function (t, r) { Bo(e, r, t) }), n.l && nC({}, function (t, r) { Bo(e, r, t) }) } function ST(n, e, t) { t = Math.min(n.i.length, t); var r = n.l ? Do(n.l.Ra, n.l, n) : null; e: { var a = n.i; let d = -1; for (; ;) { const _ = ["count=" + t]; -1 == d ? 0 < t ? (d = a[0].h, _.push("ofs=" + d)) : d = 0 : _.push("ofs=" + d); let E = !0; for (let x = 0; x < t; x++) { let B = a[x].h; const K = a[x].g; if (B -= d, 0 > B) d = Math.max(0, a[x].h - 100), E = !1; else try { mb(K, _, "req" + B + "_") } catch { r && r(K) } } if (E) { r = _.join("&"); break e } } } return n = n.i.splice(0, t), e.D = n, r } function _C(n) { n.g || n.u || (n.Z = 1, Ur(n.Ia, n), n.A = 0) } function Db(n) { return !(n.g || n.u || 3 <= n.A || (n.Z++, n.u = yf(Do(n.Ia, n), Ab(n, n.A)), n.A++, 0)) } function vv(n) { null != n.B && (_i.clearTimeout(n.B), n.B = null) } function Sb(n) { n.g = new l_(n, n.j, "rpc", n.Z), null === n.o && (n.g.H = n.s), n.g.N = 0; var e = Rh(n.sa); Bo(e, "RID", "rpc"), Bo(e, "SID", n.I), Bo(e, "CI", n.L ? "0" : "1"), Bo(e, "AID", n.T), Bo(e, "TYPE", "xmlhttp"), v_(n, e), n.o && n.s && _v(e, n.o, n.s), n.J && n.g.setTimeout(n.J); var t = n.g; n = n.ka, t.K = 1, t.v = uv(Rh(e)), t.s = null, t.P = !0, c_(t, n) } function b_(n) { null != n.v && (_i.clearTimeout(n.v), n.v = null) } function Ib(n, e) { var t = null; if (n.g == e) { b_(n), vv(n), n.g = null; var r = 2 } else { if (!dv(n.h, e)) return; t = e.D, hv(n.h, e), r = 1 } if (0 != n.G) if (n.pa = e.Y, e.i) if (1 == r) { t = e.s ? e.s.length : 0, e = Date.now() - e.F; var a = n.C; pc(r = rv(), new W1(r, t)), Tb(n) } else _C(n); else if (3 == (a = e.o) || 0 == a && 0 < n.pa || !(1 == r && function gC(n, e) { return !(hb(n.h) >= n.h.j - (n.m ? 1 : 0) || (n.m ? (n.i = e.D.concat(n.i), 0) : 1 == n.G || 2 == n.G || n.C >= (n.Za ? 0 : n.$a) || (n.m = yf(Do(n.Ja, n, e), Ab(n, n.C)), n.C++, 0))) }(n, e) || 2 == r && Db(n))) switch (t && 0 < t.length && (e = n.h, e.i = e.i.concat(t)), a) { case 1: tp(n, 5); break; case 4: tp(n, 10); break; case 3: tp(n, 6); break; default: tp(n, 2) } } function Ab(n, e) { let t = n.Xa + Math.floor(Math.random() * n.bb); return n.l || (t *= 2), t * e } function tp(n, e) { if (n.j.info("Error code " + e), 2 == e) { var t = null; n.l && (t = null); var r = Do(n.kb, n); t || (t = new Gp("//www.google.com/images/cleardot.gif"), _i.location && "http" == _i.location.protocol || cv(t, "https"), uv(t)), function _b(n, e) { const t = new s_; if (_i.Image) { const r = new Image; r.onload = ku(g_, t, r, "TestLoadImage: loaded", !0, e), r.onerror = ku(g_, t, r, "TestLoadImage: error", !1, e), r.onabort = ku(g_, t, r, "TestLoadImage: abort", !1, e), r.ontimeout = ku(g_, t, r, "TestLoadImage: timeout", !1, e), _i.setTimeout(function () { r.ontimeout && r.ontimeout() }, 1e4), r.src = n } else e(!1) }(t.toString(), r) } else jc(2); n.G = 0, n.l && n.l.va(e), xb(n), Eb(n) } function xb(n) { if (n.G = 0, n.la = [], n.l) { const e = pb(n.h); (0 != e.length || 0 != n.i.length) && (x1(n.la, e), x1(n.la, n.i), n.h.i.length = 0, V0(n.i), n.i.length = 0), n.l.ua() } } function Mb(n, e, t) { var r = t instanceof Gp ? Rh(t) : new Gp(t, void 0); if ("" != r.g) e && (r.g = e + "." + r.g), h_(r, r.m); else { var a = _i.location; r = a.protocol, e = e ? e + "." + a.hostname : a.hostname, a = +a.port; var d = new Gp(null, void 0); r && cv(d, r), e && (d.g = e), a && h_(d, a), t && (d.l = t), r = d } return e = n.za, (t = n.D) && e && Bo(r, t, e), Bo(r, "VER", n.ma), v_(n, r), r } function yC(n, e, t) { if (e && !n.H) throw Error("Can't create secondary domain capable XhrIo object."); return (e = new da(t && n.Da && !n.ra ? new $p({ jb: !0 }) : n.ra)).Ka(n.H), e } function Ob() { } function np() { if (Bp && !(10 <= Number(lT))) throw Error("Environmental error: no available transport.") } function Pu(n, e) { jl.call(this), this.g = new pC(e), this.l = n, this.h = e && e.messageUrlParams || null, n = e && e.messageHeaders || null, e && e.clientProtocolHeaderRequired && (n ? n["X-Client-Protocol"] = "webchannel" : n = { "X-Client-Protocol": "webchannel" }), this.g.s = n, n = e && e.initMessageHeaders || null, e && e.messageContentType && (n ? n["X-WebChannel-Content-Type"] = e.messageContentType : n = { "X-WebChannel-Content-Type": e.messageContentType }), e && e.ya && (n ? n["X-WebChannel-Client-Profile"] = e.ya : n = { "X-WebChannel-Client-Profile": e.ya }), this.g.S = n, (n = e && e.Yb) && !Wy(n) && (this.g.o = n), this.A = e && e.supportsCrossDomainXhr || !1, this.v = e && e.sendRawJson || !1, (e = e && e.httpSessionIdParam) && !Wy(e) && (this.g.D = e, null !== (n = this.h) && e in n && e in (n = this.h) && delete n[e]), this.j = new Wp(this) } function Nb(n) { iv.call(this); var e = n.__sm__; if (e) { e: { for (const t in e) { n = t; break e } n = void 0 } (this.i = n) && (n = this.i, e = null !== e && n in e ? e[n] : void 0), this.data = e } else this.data = n } function kb() { ab.call(this), this.status = 1 } function Wp(n) { this.g = n } (Er = da.prototype).Ka = function (n) { this.L = n }, Er.da = function (n, e, t, r) { if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + n); e = e ? e.toUpperCase() : "GET", this.H = n, this.j = "", this.m = 0, this.D = !1, this.h = !0, this.g = this.u ? this.u.g() : sv.g(), this.C = function q1(n) { return n.h || (n.h = n.i()) }(this.u ? this.u : sv), this.g.onreadystatechange = Do(this.Ha, this); try { this.F = !0, this.g.open(e, String(n), !0), this.F = !1 } catch (d) { return void hC(this, d) } if (n = t || "", t = new Map(this.headers), r) if (Object.getPrototypeOf(r) === Object.prototype) for (var a in r) t.set(a, r[a]); else { if ("function" != typeof r.keys || "function" != typeof r.get) throw Error("Unknown input type for opt_headers: " + String(r)); for (const d of r.keys()) t.set(d, r.get(d)) } r = Array.from(t.keys()).find(d => "content-type" == d.toLowerCase()), a = _i.FormData && n instanceof _i.FormData, !(0 <= A1(dC, e)) || r || a || t.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); for (const [d, _] of t) this.g.setRequestHeader(d, _); this.J && (this.g.responseType = this.J), "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L); try { mv(this), 0 < this.B && ((this.K = function vb(n) { return Bp && function k1() { return function aT(n) { var e = N1; return Object.prototype.hasOwnProperty.call(e, 9) ? e[9] : e[9] = n(9) }(function () { let n = 0; const e = U0(String(e_)).split("."), t = U0("9").split("."), r = Math.max(e.length, t.length); for (let _ = 0; 0 == n && _ < r; _++) { var a = e[_] || "", d = t[_] || ""; do { if (a = /(\d*)(\D*)(.*)/.exec(a) || ["", "", "", ""], d = /(\d*)(\D*)(.*)/.exec(d) || ["", "", "", ""], 0 == a[0].length && 0 == d[0].length) break; n = H0(0 == a[1].length ? 0 : parseInt(a[1], 10), 0 == d[1].length ? 0 : parseInt(d[1], 10)) || H0(0 == a[2].length, 0 == d[2].length) || H0(a[2], d[2]), a = a[3], d = d[3] } while (0 == n) } return 0 <= n }) }() && "number" == typeof n.timeout && void 0 !== n.ontimeout }(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = Do(this.qa, this)) : this.A = ta(this.qa, this.B, this)), this.v = !0, this.g.send(n), this.v = !1 } catch (d) { hC(this, d) } }, Er.qa = function () { typeof $y < "u" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, pc(this, "timeout"), this.abort(8)) }, Er.abort = function (n) { this.g && this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1, this.m = n || 7, pc(this, "complete"), pc(this, "abort"), __(this)) }, Er.M = function () { this.g && (this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1), __(this, !0)), da.X.M.call(this) }, Er.Ha = function () { this.s || (this.F || this.v || this.l ? fC(this) : this.fb()) }, Er.fb = function () { fC(this) }, Er.aa = function () { try { return 2 < Fh(this) ? this.g.status : -1 } catch { return -1 } }, Er.fa = function () { try { return this.g ? this.g.responseText : "" } catch { return "" } }, Er.Sa = function (n) { if (this.g) { var e = this.g.responseText; return n && 0 == e.indexOf(n) && (e = e.substring(n.length)), Qg(e) } }, Er.Ea = function () { return this.m }, Er.Oa = function () { return "string" == typeof this.j ? this.j : String(this.j) }, (Er = pC.prototype).ma = 8, Er.G = 1, Er.Ja = function (n) { if (this.m) if (this.m = null, 1 == this.G) { if (!n) { this.U = Math.floor(1e5 * Math.random()), n = this.U++; const a = new l_(this, this.j, n, void 0); let d = this.s; if (this.S && (d ? (d = R1(d), L1(d, this.S)) : d = this.S), null !== this.o || this.N || (a.H = d, d = null), this.O) e: { for (var e = 0, t = 0; t < this.i.length; t++) { var r = this.i[t]; if (void 0 === (r = "__data__" in r.g && "string" == typeof (r = r.g.__data__) ? r.length : void 0)) break; if (4096 < (e += r)) { e = t; break e } if (4096 === e || t === this.i.length - 1) { e = t + 1; break e } } e = 1e3 } else e = 1e3; e = ST(this, a, e), Bo(t = Rh(this.F), "RID", n), Bo(t, "CVER", 22), this.D && Bo(t, "X-HTTP-Session-Id", this.D), v_(this, t), d && (this.N ? e = "headers=" + encodeURIComponent(String(wb(d))) + "&" + e : this.o && _v(t, this.o, d)), fb(this.h, a), this.Ya && Bo(t, "TYPE", "init"), this.O ? (Bo(t, "$req", e), Bo(t, "SID", "null"), a.Z = !0, av(a, t, null)) : av(a, t, e), this.G = 2 } } else 3 == this.G && (n ? mC(this, n) : 0 == this.i.length || db(this.h) || mC(this)) }, Er.Ia = function () { if (this.u = null, Sb(this), this.$ && !(this.K || null == this.g || 0 >= this.P)) { var n = 2 * this.P; this.j.info("BP detection timer enabled: " + n), this.B = yf(Do(this.eb, this), n) } }, Er.eb = function () { this.B && (this.B = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.L = !1, this.K = !0, jc(10), yv(this), Sb(this)) }, Er.cb = function () { null != this.v && (this.v = null, yv(this), Db(this), jc(19)) }, Er.kb = function (n) { n ? (this.j.info("Successfully pinged google.com"), jc(2)) : (this.j.info("Failed to ping google.com"), jc(1)) }, (Er = Ob.prototype).xa = function () { }, Er.wa = function () { }, Er.va = function () { }, Er.ua = function () { }, Er.Ra = function () { }, np.prototype.g = function (n, e) { return new Pu(n, e) }, zl(Pu, jl), Pu.prototype.m = function () { this.g.l = this.j, this.A && (this.g.H = !0); var n = this.g, e = this.l, t = this.h || void 0; jc(0), n.V = e, n.ia = t || {}, n.L = n.Y, n.F = Mb(n, null, n.V), Tb(n) }, Pu.prototype.close = function () { Cb(this.g) }, Pu.prototype.u = function (n) { var e = this.g; if ("string" == typeof n) { var t = {}; t.__data__ = n, n = t } else this.v && ((t = {}).__data__ = U1(n), n = t); e.i.push(new class { constructor(n, e) { this.h = n, this.g = e } }(e.ab++, n)), 3 == e.G && Tb(e) }, Pu.prototype.M = function () { this.g.l = null, delete this.j, Cb(this.g), delete this.g, Pu.X.M.call(this) }, zl(Nb, iv), zl(kb, ab), zl(Wp, Ob), Wp.prototype.xa = function () { pc(this.g, "a") }, Wp.prototype.wa = function (n) { pc(this.g, new Nb(n)) }, Wp.prototype.va = function (n) { pc(this.g, new kb) }, Wp.prototype.ua = function () { pc(this.g, "b") }, np.prototype.createWebChannel = np.prototype.g, Pu.prototype.send = Pu.prototype.u, Pu.prototype.open = Pu.prototype.m, Pu.prototype.close = Pu.prototype.close, ep.NO_ERROR = 0, ep.TIMEOUT = 8, ep.HTTP_ERROR = 6, Z1.COMPLETE = "complete", ob.EventType = Yg, Yg.OPEN = "a", Yg.CLOSE = "b", Yg.ERROR = "c", Yg.MESSAGE = "d", jl.prototype.listen = jl.prototype.N, da.prototype.listenOnce = da.prototype.O, da.prototype.getLastError = da.prototype.Oa, da.prototype.getLastErrorCode = da.prototype.Ea, da.prototype.getStatus = da.prototype.aa, da.prototype.getResponseJson = da.prototype.Sa, da.prototype.getResponseText = da.prototype.fa, da.prototype.send = da.prototype.da, da.prototype.setWithCredentials = da.prototype.Ka; var vC = pf.createWebChannelTransport = function () { return new np }, bC = pf.getStatEventTarget = function () { return rv() }, Pb = pf.ErrorCode = ep, lI = pf.EventType = Z1, wC = pf.Event = Hp, Rb = pf.Stat = { sb: 0, vb: 1, wb: 2, Pb: 3, Ub: 4, Rb: 5, Sb: 6, Qb: 7, Ob: 8, Tb: 9, PROXY: 10, NOPROXY: 11, Mb: 12, Ib: 13, Jb: 14, Hb: 15, Kb: 16, Lb: 17, ob: 18, nb: 19, pb: 20 }, CC = pf.FetchXmlHttpFactory = $p, w_ = pf.WebChannel = ob, IT = pf.XhrIo = da; const Xg = "@firebase/firestore"; class $l { constructor(e) { this.uid = e } isAuthenticated() { return null != this.uid } toKey() { return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user" } isEqual(e) { return e.uid === this.uid } } $l.UNAUTHENTICATED = new $l(null), $l.GOOGLE_CREDENTIALS = new $l("google-credentials-uid"), $l.FIRST_PARTY = new $l("first-party-uid"), $l.MOCK_USER = new $l("mock-user"); let rp = "9.15.0"; const gc = new Jo.Yd("@firebase/firestore"); function Fb() { return gc.logLevel } function Mn(n, ...e) { if (gc.logLevel <= Jo.in.DEBUG) { const t = e.map(Lb); gc.debug(`Firestore (${rp}): ${n}`, ...t) } } function Ga(n, ...e) { if (gc.logLevel <= Jo.in.ERROR) { const t = e.map(Lb); gc.error(`Firestore (${rp}): ${n}`, ...t) } } function Zp(n, ...e) { if (gc.logLevel <= Jo.in.WARN) { const t = e.map(Lb); gc.warn(`Firestore (${rp}): ${n}`, ...t) } } function Lb(n) { if ("string" == typeof n) return n; try { return JSON.stringify(n) } catch { return n } } function rr(n = "Unexpected state") { const e = `FIRESTORE (${rp}) INTERNAL ASSERTION FAILED: ` + n; throw Ga(e), new Error(e) } function mr(n, e) { n || rr() } function Wn(n, e) { return n } const en = { OK: "ok", CANCELLED: "cancelled", UNKNOWN: "unknown", INVALID_ARGUMENT: "invalid-argument", DEADLINE_EXCEEDED: "deadline-exceeded", NOT_FOUND: "not-found", ALREADY_EXISTS: "already-exists", PERMISSION_DENIED: "permission-denied", UNAUTHENTICATED: "unauthenticated", RESOURCE_EXHAUSTED: "resource-exhausted", FAILED_PRECONDITION: "failed-precondition", ABORTED: "aborted", OUT_OF_RANGE: "out-of-range", UNIMPLEMENTED: "unimplemented", INTERNAL: "internal", UNAVAILABLE: "unavailable", DATA_LOSS: "data-loss" }; class Cn extends Pe.ZR { constructor(e, t) { super(e, t), this.code = e, this.message = t, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}` } } class ja { constructor() { this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } } class Bb { constructor(e, t) { this.user = t, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${e}`) } } class Vb { getToken() { return Promise.resolve(null) } invalidateToken() { } start(e, t) { e.enqueueRetryable(() => t($l.UNAUTHENTICATED)) } shutdown() { } } class Ub { constructor(e) { this.token = e, this.changeListener = null } getToken() { return Promise.resolve(this.token) } invalidateToken() { } start(e, t) { this.changeListener = t, e.enqueueRetryable(() => t(this.token.user)) } shutdown() { this.changeListener = null } } class EC { constructor(e) { this.t = e, this.currentUser = $l.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null } start(e, t) { var r = this; let a = this.i; const d = B => this.i !== a ? (a = this.i, t(B)) : Promise.resolve(); let _ = new ja; this.o = () => { this.i++, this.currentUser = this.u(), _.resolve(), _ = new ja, e.enqueueRetryable(() => d(this.currentUser)) }; const E = () => { const B = _; e.enqueueRetryable((0, cn.Z)(function* () { yield B.promise, yield d(r.currentUser) })) }, x = B => { Mn("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = B, this.auth.addAuthTokenListener(this.o), E() }; this.t.onInit(B => x(B)), setTimeout(() => { if (!this.auth) { const B = this.t.getImmediate({ optional: !0 }); B ? x(B) : (Mn("FirebaseAuthCredentialsProvider", "Auth not yet detected"), _.resolve(), _ = new ja) } }, 0), E() } getToken() { const e = this.i, t = this.forceRefresh; return this.forceRefresh = !1, this.auth ? this.auth.getToken(t).then(r => this.i !== e ? (Mn("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : r ? (mr("string" == typeof r.accessToken), new Bb(r.accessToken, this.currentUser)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.auth && this.auth.removeAuthTokenListener(this.o) } u() { const e = this.auth && this.auth.getUid(); return mr(null === e || "string" == typeof e), new $l(e) } } class Hb { constructor(e, t, r, a) { this.h = e, this.l = t, this.m = r, this.g = a, this.type = "FirstParty", this.user = $l.FIRST_PARTY, this.p = new Map } I() { return this.g ? this.g() : (mr(!("object" != typeof this.h || null === this.h || !this.h.auth || !this.h.auth.getAuthHeaderValueForFirstParty)), this.h.auth.getAuthHeaderValueForFirstParty([])) } get headers() { this.p.set("X-Goog-AuthUser", this.l); const e = this.I(); return e && this.p.set("Authorization", e), this.m && this.p.set("X-Goog-Iam-Authorization-Token", this.m), this.p } } class zb { constructor(e, t, r, a) { this.h = e, this.l = t, this.m = r, this.g = a } getToken() { return Promise.resolve(new Hb(this.h, this.l, this.m, this.g)) } start(e, t) { e.enqueueRetryable(() => t($l.FIRST_PARTY)) } shutdown() { } invalidateToken() { } } class TC { constructor(e) { this.value = e, this.type = "AppCheck", this.headers = new Map, e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value) } } class xT { constructor(e) { this.T = e, this.forceRefresh = !1, this.appCheck = null, this.A = null } start(e, t) { const r = d => { null != d.error && Mn("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${d.error.message}`); const _ = d.token !== this.A; return this.A = d.token, Mn("FirebaseAppCheckTokenProvider", `Received ${_ ? "new" : "existing"} token.`), _ ? t(d.token) : Promise.resolve() }; this.o = d => { e.enqueueRetryable(() => r(d)) }; const a = d => { Mn("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = d, this.appCheck.addTokenListener(this.o) }; this.T.onInit(d => a(d)), setTimeout(() => { if (!this.appCheck) { const d = this.T.getImmediate({ optional: !0 }); d ? a(d) : Mn("FirebaseAppCheckTokenProvider", "AppCheck not yet detected") } }, 0) } getToken() { const e = this.forceRefresh; return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then(t => t ? (mr("string" == typeof t.token), this.A = t.token, new TC(t.token)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.appCheck && this.appCheck.removeTokenListener(this.o) } } function MT(n) { const e = typeof self < "u" && (self.crypto || self.msCrypto), t = new Uint8Array(n); if (e && "function" == typeof e.getRandomValues) e.getRandomValues(t); else for (let r = 0; r < n; r++)t[r] = Math.floor(256 * Math.random()); return t } class Gb { static R() { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = Math.floor(256 / e.length) * e.length; let r = ""; for (; r.length < 20;) { const a = MT(40); for (let d = 0; d < a.length; ++d)r.length < 20 && a[d] < t && (r += e.charAt(a[d] % e.length)) } return r } } function ai(n, e) { return n < e ? -1 : n > e ? 1 : 0 } function qp(n, e, t) { return n.length === e.length && n.every((r, a) => t(r, e[a])) } function jb(n) { return n + "\0" } class Vo { constructor(e, t) { if (this.seconds = e, this.nanoseconds = t, t < 0) throw new Cn(en.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (t >= 1e9) throw new Cn(en.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (e < -62135596800) throw new Cn(en.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e); if (e >= 253402300800) throw new Cn(en.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e) } static now() { return Vo.fromMillis(Date.now()) } static fromDate(e) { return Vo.fromMillis(e.getTime()) } static fromMillis(e) { const t = Math.floor(e / 1e3), r = Math.floor(1e6 * (e - 1e3 * t)); return new Vo(t, r) } toDate() { return new Date(this.toMillis()) } toMillis() { return 1e3 * this.seconds + this.nanoseconds / 1e6 } _compareTo(e) { return this.seconds === e.seconds ? ai(this.nanoseconds, e.nanoseconds) : ai(this.seconds, e.seconds) } isEqual(e) { return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds } toString() { return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")" } toJSON() { return { seconds: this.seconds, nanoseconds: this.nanoseconds } } valueOf() { return String(this.seconds - -62135596800).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0") } } class Ar { constructor(e) { this.timestamp = e } static fromTimestamp(e) { return new Ar(e) } static min() { return new Ar(new Vo(0, 0)) } static max() { return new Ar(new Vo(253402300799, 999999999)) } compareTo(e) { return this.timestamp._compareTo(e.timestamp) } isEqual(e) { return this.timestamp.isEqual(e.timestamp) } toMicroseconds() { return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3 } toString() { return "SnapshotVersion(" + this.timestamp.toString() + ")" } toTimestamp() { return this.timestamp } } class C_ { constructor(e, t, r) { void 0 === t ? t = 0 : t > e.length && rr(), void 0 === r ? r = e.length - t : r > e.length - t && rr(), this.segments = e, this.offset = t, this.len = r } get length() { return this.len } isEqual(e) { return 0 === C_.comparator(this, e) } child(e) { const t = this.segments.slice(this.offset, this.limit()); return e instanceof C_ ? e.forEach(r => { t.push(r) }) : t.push(e), this.construct(t) } limit() { return this.offset + this.length } popFirst(e) { return this.construct(this.segments, this.offset + (e = void 0 === e ? 1 : e), this.length - e) } popLast() { return this.construct(this.segments, this.offset, this.length - 1) } firstSegment() { return this.segments[this.offset] } lastSegment() { return this.get(this.length - 1) } get(e) { return this.segments[this.offset + e] } isEmpty() { return 0 === this.length } isPrefixOf(e) { if (e.length < this.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } isImmediateParentOf(e) { if (this.length + 1 !== e.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } forEach(e) { for (let t = this.offset, r = this.limit(); t < r; t++)e(this.segments[t]) } toArray() { return this.segments.slice(this.offset, this.limit()) } static comparator(e, t) { const r = Math.min(e.length, t.length); for (let a = 0; a < r; a++) { const d = e.get(a), _ = t.get(a); if (d < _) return -1; if (d > _) return 1 } return e.length < t.length ? -1 : e.length > t.length ? 1 : 0 } } class is extends C_ { construct(e, t, r) { return new is(e, t, r) } canonicalString() { return this.toArray().join("/") } toString() { return this.canonicalString() } static fromString(...e) { const t = []; for (const r of e) { if (r.indexOf("//") >= 0) throw new Cn(en.INVALID_ARGUMENT, `Invalid segment (${r}). Paths must not contain // in them.`); t.push(...r.split("/").filter(a => a.length > 0)) } return new is(t) } static emptyPath() { return new is([]) } } const DC = /^[_a-zA-Z][_a-zA-Z0-9]*$/; class Oa extends C_ { construct(e, t, r) { return new Oa(e, t, r) } static isValidIdentifier(e) { return DC.test(e) } canonicalString() { return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Oa.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".") } toString() { return this.canonicalString() } isKeyField() { return 1 === this.length && "__name__" === this.get(0) } static keyField() { return new Oa(["__name__"]) } static fromServerFormat(e) { const t = []; let r = "", a = 0; const d = () => { if (0 === r.length) throw new Cn(en.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`); t.push(r), r = "" }; let _ = !1; for (; a < e.length;) { const E = e[a]; if ("\\" === E) { if (a + 1 === e.length) throw new Cn(en.INVALID_ARGUMENT, "Path has trailing escape character: " + e); const x = e[a + 1]; if ("\\" !== x && "." !== x && "`" !== x) throw new Cn(en.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e); r += x, a += 2 } else "`" === E ? (_ = !_, a++) : "." !== E || _ ? (r += E, a++) : (d(), a++) } if (d(), _) throw new Cn(en.INVALID_ARGUMENT, "Unterminated ` in path: " + e); return new Oa(t) } static emptyPath() { return new Oa([]) } } class Gn { constructor(e) { this.path = e } static fromPath(e) { return new Gn(is.fromString(e)) } static fromName(e) { return new Gn(is.fromString(e).popFirst(5)) } static empty() { return new Gn(is.emptyPath()) } get collectionGroup() { return this.path.popLast().lastSegment() } hasCollectionId(e) { return this.path.length >= 2 && this.path.get(this.path.length - 2) === e } getCollectionGroup() { return this.path.get(this.path.length - 2) } getCollectionPath() { return this.path.popLast() } isEqual(e) { return null !== e && 0 === is.comparator(this.path, e.path) } toString() { return this.path.toString() } static comparator(e, t) { return is.comparator(e.path, t.path) } static isDocumentKey(e) { return e.length % 2 == 0 } static fromSegments(e) { return new Gn(new is(e.slice())) } } class E_ { constructor(e, t, r, a) { this.indexId = e, this.collectionGroup = t, this.fields = r, this.indexState = a } } function mc(n) { return n.fields.find(e => 2 === e.kind) } function Fd(n) { return n.fields.filter(e => 2 !== e.kind) } E_.UNKNOWN_ID = -1; class wv { constructor(e, t) { this.fieldPath = e, this.kind = t } } class Cv { constructor(e, t) { this.sequenceNumber = e, this.offset = t } static empty() { return new Cv(0, _c.min()) } } function $b(n, e) { const t = n.toTimestamp().seconds, r = n.toTimestamp().nanoseconds + 1, a = Ar.fromTimestamp(1e9 === r ? new Vo(t + 1, 0) : new Vo(t, r)); return new _c(a, Gn.empty(), e) } function Wb(n) { return new _c(n.readTime, n.key, -1) } class _c { constructor(e, t, r) { this.readTime = e, this.documentKey = t, this.largestBatchId = r } static min() { return new _c(Ar.min(), Gn.empty(), -1) } static max() { return new _c(Ar.max(), Gn.empty(), -1) } } function Zb(n, e) { let t = n.readTime.compareTo(e.readTime); return 0 !== t ? t : (t = Gn.comparator(n.documentKey, e.documentKey), 0 !== t ? t : ai(n.largestBatchId, e.largestBatchId)) } const Ev = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab."; class SC { constructor() { this.onCommittedListeners = [] } addOnCommittedListener(e) { this.onCommittedListeners.push(e) } raiseOnCommittedEvent() { this.onCommittedListeners.forEach(e => e()) } } function wf(n) { return qb.apply(this, arguments) } function qb() { return qb = (0, cn.Z)(function* (n) { if (n.code !== en.FAILED_PRECONDITION || n.message !== Ev) throw n; Mn("LocalStore", "Unexpectedly lost primary lease") }), qb.apply(this, arguments) } class Qt { constructor(e) { this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, e(t => { this.isDone = !0, this.result = t, this.nextCallback && this.nextCallback(t) }, t => { this.isDone = !0, this.error = t, this.catchCallback && this.catchCallback(t) }) } catch(e) { return this.next(void 0, e) } next(e, t) { return this.callbackAttached && rr(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new Qt((r, a) => { this.nextCallback = d => { this.wrapSuccess(e, d).next(r, a) }, this.catchCallback = d => { this.wrapFailure(t, d).next(r, a) } }) } toPromise() { return new Promise((e, t) => { this.next(e, t) }) } wrapUserFunction(e) { try { const t = e(); return t instanceof Qt ? t : Qt.resolve(t) } catch (t) { return Qt.reject(t) } } wrapSuccess(e, t) { return e ? this.wrapUserFunction(() => e(t)) : Qt.resolve(t) } wrapFailure(e, t) { return e ? this.wrapUserFunction(() => e(t)) : Qt.reject(t) } static resolve(e) { return new Qt((t, r) => { t(e) }) } static reject(e) { return new Qt((t, r) => { r(e) }) } static waitFor(e) { return new Qt((t, r) => { let a = 0, d = 0, _ = !1; e.forEach(E => { ++a, E.next(() => { ++d, _ && d === a && t() }, x => r(x)) }), _ = !0, d === a && t() }) } static or(e) { let t = Qt.resolve(!1); for (const r of e) t = t.next(a => a ? Qt.resolve(a) : r()); return t } static forEach(e, t) { const r = []; return e.forEach((a, d) => { r.push(t.call(this, a, d)) }), this.waitFor(r) } static mapArray(e, t) { return new Qt((r, a) => { const d = e.length, _ = new Array(d); let E = 0; for (let x = 0; x < d; x++) { const B = x; t(e[B]).next(K => { _[B] = K, ++E, E === d && r(_) }, K => a(K)) } }) } static doWhile(e, t) { return new Qt((r, a) => { const d = () => { !0 === e() ? t().next(() => { d() }, a) : r() }; d() }) } } class Tv { constructor(e, t) { this.action = e, this.transaction = t, this.aborted = !1, this.P = new ja, this.transaction.oncomplete = () => { this.P.resolve() }, this.transaction.onabort = () => { t.error ? this.P.reject(new em(e, t.error)) : this.P.resolve() }, this.transaction.onerror = r => { const a = Jb(r.target.error); this.P.reject(new em(e, a)) } } static open(e, t, r, a) { try { return new Tv(t, e.transaction(a, r)) } catch (d) { throw new em(t, d) } } get v() { return this.P.promise } abort(e) { e && this.P.reject(e), this.aborted || (Mn("SimpleDb", "Aborting transaction:", e ? e.message : "Client-initiated abort"), this.aborted = !0, this.transaction.abort()) } V() { const e = this.transaction; this.aborted || "function" != typeof e.commit || e.commit() } store(e) { const t = this.transaction.objectStore(e); return new Yb(t) } } class rd { constructor(e, t, r) { this.name = e, this.version = t, this.S = r, 12.2 === rd.D((0, Pe.z$)()) && Ga("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.") } static delete(e) { return Mn("SimpleDb", "Removing database:", e), tm(window.indexedDB.deleteDatabase(e)).toPromise() } static C() { if (!(0, Pe.hl)()) return !1; if (rd.N()) return !0; const e = (0, Pe.z$)(), t = rd.D(e), r = 0 < t && t < 10, a = rd.k(e), d = 0 < a && a < 4.5; return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || r || d) } static N() { var e; return typeof process < "u" && "YES" === (null === (e = process.env) || void 0 === e ? void 0 : e.O) } static M(e, t) { return e.store(t) } static D(e) { const t = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i), r = t ? t[1].split("_").slice(0, 2).join(".") : "-1"; return Number(r) } static k(e) { const t = e.match(/Android ([\d.]+)/i), r = t ? t[1].split(".").slice(0, 2).join(".") : "-1"; return Number(r) } F(e) { var t = this; return (0, cn.Z)(function* () { return t.db || (Mn("SimpleDb", "Opening database:", t.name), t.db = yield new Promise((r, a) => { const d = indexedDB.open(t.name, t.version); d.onsuccess = _ => { r(_.target.result) }, d.onblocked = () => { a(new em(e, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.")) }, d.onerror = _ => { const E = _.target.error; a("VersionError" === E.name ? new Cn(en.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.") : "InvalidStateError" === E.name ? new Cn(en.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + E) : new em(e, E)) }, d.onupgradeneeded = _ => { Mn("SimpleDb", 'Database "' + t.name + '" requires upgrade from version:', _.oldVersion), t.S.$(_.target.result, d.transaction, _.oldVersion, t.version).next(() => { Mn("SimpleDb", "Database upgrade to version " + t.version + " complete") }) } })), t.B && (t.db.onversionchange = r => t.B(r)), t.db })() } L(e) { this.B = e, this.db && (this.db.onversionchange = t => e(t)) } runTransaction(e, t, r, a) { var d = this; return (0, cn.Z)(function* () { const _ = "readonly" === t; let E = 0; for (; ;) { ++E; try { d.db = yield d.F(e); const x = Tv.open(d.db, e, _ ? "readonly" : "readwrite", r), B = a(x).next(K => (x.V(), K)).catch(K => (x.abort(K), Qt.reject(K))).toPromise(); return B.catch(() => { }), yield x.v, B } catch (x) { const B = x, K = "FirebaseError" !== B.name && E < 3; if (Mn("SimpleDb", "Transaction failed with error:", B.message, "Retrying:", K), d.close(), !K) return Promise.reject(B) } } })() } close() { this.db && this.db.close(), this.db = void 0 } } class IC { constructor(e) { this.q = e, this.U = !1, this.K = null } get isDone() { return this.U } get G() { return this.K } set cursor(e) { this.q = e } done() { this.U = !0 } j(e) { this.K = e } delete() { return tm(this.q.delete()) } } class em extends Cn { constructor(e, t) { super(en.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${t}`), this.name = "IndexedDbTransactionError" } } function sh(n) { return "IndexedDbTransactionError" === n.name } class Yb { constructor(e) { this.store = e } put(e, t) { let r; return void 0 !== t ? (Mn("SimpleDb", "PUT", this.store.name, e, t), r = this.store.put(t, e)) : (Mn("SimpleDb", "PUT", this.store.name, "<auto-key>", e), r = this.store.put(e)), tm(r) } add(e) { return Mn("SimpleDb", "ADD", this.store.name, e, e), tm(this.store.add(e)) } get(e) { return tm(this.store.get(e)).next(t => (void 0 === t && (t = null), Mn("SimpleDb", "GET", this.store.name, e, t), t)) } delete(e) { return Mn("SimpleDb", "DELETE", this.store.name, e), tm(this.store.delete(e)) } count() { return Mn("SimpleDb", "COUNT", this.store.name), tm(this.store.count()) } W(e, t) { const r = this.options(e, t); if (r.index || "function" != typeof this.store.getAll) { const a = this.cursor(r), d = []; return this.H(a, (_, E) => { d.push(E) }).next(() => d) } { const a = this.store.getAll(r.range); return new Qt((d, _) => { a.onerror = E => { _(E.target.error) }, a.onsuccess = E => { d(E.target.result) } }) } } J(e, t) { const r = this.store.getAll(e, null === t ? void 0 : t); return new Qt((a, d) => { r.onerror = _ => { d(_.target.error) }, r.onsuccess = _ => { a(_.target.result) } }) } Y(e, t) { Mn("SimpleDb", "DELETE ALL", this.store.name); const r = this.options(e, t); r.X = !1; const a = this.cursor(r); return this.H(a, (d, _, E) => E.delete()) } Z(e, t) { let r; t ? r = e : (r = {}, t = e); const a = this.cursor(r); return this.H(a, t) } tt(e) { const t = this.cursor({}); return new Qt((r, a) => { t.onerror = d => { const _ = Jb(d.target.error); a(_) }, t.onsuccess = d => { const _ = d.target.result; _ ? e(_.primaryKey, _.value).next(E => { E ? _.continue() : r() }) : r() } }) } H(e, t) { const r = []; return new Qt((a, d) => { e.onerror = _ => { d(_.target.error) }, e.onsuccess = _ => { const E = _.target.result; if (!E) return void a(); const x = new IC(E), B = t(E.primaryKey, E.value, x); if (B instanceof Qt) { const K = B.catch(oe => (x.done(), Qt.reject(oe))); r.push(K) } x.isDone ? a() : null === x.G ? E.continue() : E.continue(x.G) } }).next(() => Qt.waitFor(r)) } options(e, t) { let r; return void 0 !== e && ("string" == typeof e ? r = e : t = e), { index: r, range: t } } cursor(e) { let t = "next"; if (e.reverse && (t = "prev"), e.index) { const r = this.store.index(e.index); return e.X ? r.openKeyCursor(e.range, t) : r.openCursor(e.range, t) } return this.store.openCursor(e.range, t) } } function tm(n) { return new Qt((e, t) => { n.onsuccess = r => { e(r.target.result) }, n.onerror = r => { const a = Jb(r.target.error); t(a) } }) } let Kb = !1; function Jb(n) { const e = rd.D((0, Pe.z$)()); if (e >= 12.2 && e < 13) { const t = "An internal error was encountered in the Indexed Database server"; if (n.message.indexOf(t) >= 0) { const r = new Cn("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${t}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`); return Kb || (Kb = !0, setTimeout(() => { throw r }, 0)), r } } return n } class AC { constructor(e, t) { this.asyncQueue = e, this.et = t, this.task = null } start() { this.nt(15e3) } stop() { this.task && (this.task.cancel(), this.task = null) } get started() { return null !== this.task } nt(e) { var t = this; Mn("IndexBackiller", `Scheduled in ${e}ms`), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", e, (0, cn.Z)(function* () { t.task = null; try { Mn("IndexBackiller", `Documents written: ${yield t.et.st()}`) } catch (r) { sh(r) ? Mn("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", r) : yield wf(r) } yield t.nt(6e4) })) } } class nm { constructor(e, t) { this.localStore = e, this.persistence = t } st(e = 50) { var t = this; return (0, cn.Z)(function* () { return t.persistence.runTransaction("Backfill Indexes", "readwrite-primary", r => t.it(r, e)) })() } it(e, t) { const r = new Set; let a = t, d = !0; return Qt.doWhile(() => !0 === d && a > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(e).next(_ => { if (null !== _ && !r.has(_)) return Mn("IndexBackiller", `Processing collection: ${_}`), this.rt(e, _, a).next(E => { a -= E, r.add(_) }); d = !1 })).next(() => t - a) } rt(e, t, r) { return this.localStore.indexManager.getMinOffsetFromCollectionGroup(e, t).next(a => this.localStore.localDocuments.getNextDocuments(e, t, a, r).next(d => { const _ = d.changes; return this.localStore.indexManager.updateIndexEntries(e, _).next(() => this.ot(a, d)).next(E => (Mn("IndexBackiller", `Updating offset: ${E}`), this.localStore.indexManager.updateCollectionGroup(e, t, E))).next(() => _.size) })) } ot(e, t) { let r = e; return t.changes.forEach((a, d) => { const _ = Wb(d); Zb(_, r) > 0 && (r = _) }), new _c(r.readTime, r.documentKey, Math.max(t.batchId, e.largestBatchId)) } } let id = (() => { class n { constructor(t, r) { this.previousValue = t, r && (r.sequenceNumberHandler = a => this.ut(a), this.ct = a => r.writeSequenceNumber(a)) } ut(t) { return this.previousValue = Math.max(t, this.previousValue), this.previousValue } next() { const t = ++this.previousValue; return this.ct && this.ct(t), t } } return n.at = -1, n })(); class xC { constructor(e, t, r, a, d, _, E, x) { this.databaseId = e, this.appId = t, this.persistenceKey = r, this.host = a, this.ssl = d, this.forceLongPolling = _, this.autoDetectLongPolling = E, this.useFetchStreams = x } } class Lh { constructor(e, t) { this.projectId = e, this.database = t || "(default)" } static empty() { return new Lh("", "") } get isDefaultDatabase() { return "(default)" === this.database } isEqual(e) { return e instanceof Lh && e.projectId === this.projectId && e.database === this.database } } function NT(n) { let e = 0; for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && e++; return e } function Yp(n, e) { for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && e(t, n[t]) } function kT(n) { for (const e in n) if (Object.prototype.hasOwnProperty.call(n, e)) return !1; return !0 } function T_(n) { return null == n } function D_(n) { return 0 === n && 1 / n == -1 / 0 } function MC(n) { return "number" == typeof n && Number.isInteger(n) && !D_(n) && n <= Number.MAX_SAFE_INTEGER && n >= Number.MIN_SAFE_INTEGER } class sl { constructor(e) { this.binaryString = e } static fromBase64String(e) { const t = atob(e); return new sl(t) } static fromUint8Array(e) { const t = function (r) { let a = ""; for (let d = 0; d < r.length; ++d)a += String.fromCharCode(r[d]); return a }(e); return new sl(t) } [Symbol.iterator]() { let e = 0; return { next: () => e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 } } } toBase64() { return btoa(this.binaryString) } toUint8Array() { return function (e) { const t = new Uint8Array(e.length); for (let r = 0; r < e.length; r++)t[r] = e.charCodeAt(r); return t }(this.binaryString) } approximateByteSize() { return 2 * this.binaryString.length } compareTo(e) { return ai(this.binaryString, e.binaryString) } isEqual(e) { return this.binaryString === e.binaryString } } sl.EMPTY_BYTE_STRING = new sl(""); const PT = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/); function Cf(n) { if (mr(!!n), "string" == typeof n) { let e = 0; const t = PT.exec(n); if (mr(!!t), t[1]) { let a = t[1]; a = (a + "000000000").substr(0, 9), e = Number(a) } const r = new Date(n); return { seconds: Math.floor(r.getTime() / 1e3), nanos: e } } return { seconds: ha(n.seconds), nanos: ha(n.nanos) } } function ha(n) { return "number" == typeof n ? n : "string" == typeof n ? Number(n) : 0 } function Kp(n) { return "string" == typeof n ? sl.fromBase64String(n) : sl.fromUint8Array(n) } function Qb(n) { var e, t; return "server_timestamp" === (null === (t = ((null === (e = n?.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === t ? void 0 : t.stringValue) } function Xb(n) { const e = n.mapValue.fields.__previous_value__; return Qb(e) ? Xb(e) : e } function S_(n) { const e = Cf(n.mapValue.fields.__local_write_time__.timestampValue); return new Vo(e.seconds, e.nanos) } const Ef = { mapValue: { fields: { __type__: { stringValue: "__max__" } } } }, I_ = { nullValue: "NULL_VALUE" }; function ip(n) { return "nullValue" in n ? 0 : "booleanValue" in n ? 1 : "integerValue" in n || "doubleValue" in n ? 2 : "timestampValue" in n ? 3 : "stringValue" in n ? 5 : "bytesValue" in n ? 6 : "referenceValue" in n ? 7 : "geoPointValue" in n ? 8 : "arrayValue" in n ? 9 : "mapValue" in n ? Qb(n) ? 4 : M_(n) ? 9007199254740991 : 10 : rr() } function oh(n, e) { if (n === e) return !0; const t = ip(n); if (t !== ip(e)) return !1; switch (t) { case 0: case 9007199254740991: return !0; case 1: return n.booleanValue === e.booleanValue; case 4: return S_(n).isEqual(S_(e)); case 3: return function (r, a) { if ("string" == typeof r.timestampValue && "string" == typeof a.timestampValue && r.timestampValue.length === a.timestampValue.length) return r.timestampValue === a.timestampValue; const d = Cf(r.timestampValue), _ = Cf(a.timestampValue); return d.seconds === _.seconds && d.nanos === _.nanos }(n, e); case 5: return n.stringValue === e.stringValue; case 6: return a = e, Kp(n.bytesValue).isEqual(Kp(a.bytesValue)); case 7: return n.referenceValue === e.referenceValue; case 8: return function (r, a) { return ha(r.geoPointValue.latitude) === ha(a.geoPointValue.latitude) && ha(r.geoPointValue.longitude) === ha(a.geoPointValue.longitude) }(n, e); case 2: return function (r, a) { if ("integerValue" in r && "integerValue" in a) return ha(r.integerValue) === ha(a.integerValue); if ("doubleValue" in r && "doubleValue" in a) { const d = ha(r.doubleValue), _ = ha(a.doubleValue); return d === _ ? D_(d) === D_(_) : isNaN(d) && isNaN(_) } return !1 }(n, e); case 9: return qp(n.arrayValue.values || [], e.arrayValue.values || [], oh); case 10: return function (r, a) { const d = r.mapValue.fields || {}, _ = a.mapValue.fields || {}; if (NT(d) !== NT(_)) return !1; for (const E in d) if (d.hasOwnProperty(E) && (void 0 === _[E] || !oh(d[E], _[E]))) return !1; return !0 }(n, e); default: return rr() }var a } function A_(n, e) { return void 0 !== (n.values || []).find(t => oh(t, e)) } function sp(n, e) { if (n === e) return 0; const t = ip(n), r = ip(e); if (t !== r) return ai(t, r); switch (t) { case 0: case 9007199254740991: return 0; case 1: return ai(n.booleanValue, e.booleanValue); case 2: return function (a, d) { const _ = ha(a.integerValue || a.doubleValue), E = ha(d.integerValue || d.doubleValue); return _ < E ? -1 : _ > E ? 1 : _ === E ? 0 : isNaN(_) ? isNaN(E) ? 0 : -1 : 1 }(n, e); case 3: return RT(n.timestampValue, e.timestampValue); case 4: return RT(S_(n), S_(e)); case 5: return ai(n.stringValue, e.stringValue); case 6: return function (a, d) { const _ = Kp(a), E = Kp(d); return _.compareTo(E) }(n.bytesValue, e.bytesValue); case 7: return function (a, d) { const _ = a.split("/"), E = d.split("/"); for (let x = 0; x < _.length && x < E.length; x++) { const B = ai(_[x], E[x]); if (0 !== B) return B } return ai(_.length, E.length) }(n.referenceValue, e.referenceValue); case 8: return function (a, d) { const _ = ai(ha(a.latitude), ha(d.latitude)); return 0 !== _ ? _ : ai(ha(a.longitude), ha(d.longitude)) }(n.geoPointValue, e.geoPointValue); case 9: return function (a, d) { const _ = a.values || [], E = d.values || []; for (let x = 0; x < _.length && x < E.length; ++x) { const B = sp(_[x], E[x]); if (B) return B } return ai(_.length, E.length) }(n.arrayValue, e.arrayValue); case 10: return function (a, d) { if (a === Ef.mapValue && d === Ef.mapValue) return 0; if (a === Ef.mapValue) return 1; if (d === Ef.mapValue) return -1; const _ = a.fields || {}, E = Object.keys(_), x = d.fields || {}, B = Object.keys(x); E.sort(), B.sort(); for (let K = 0; K < E.length && K < B.length; ++K) { const oe = ai(E[K], B[K]); if (0 !== oe) return oe; const Me = sp(_[E[K]], x[B[K]]); if (0 !== Me) return Me } return ai(E.length, B.length) }(n.mapValue, e.mapValue); default: throw rr() } } function RT(n, e) { if ("string" == typeof n && "string" == typeof e && n.length === e.length) return ai(n, e); const t = Cf(n), r = Cf(e), a = ai(t.seconds, r.seconds); return 0 !== a ? a : ai(t.nanos, r.nanos) } function Jp(n) { return NC(n) } function NC(n) { return "nullValue" in n ? "null" : "booleanValue" in n ? "" + n.booleanValue : "integerValue" in n ? "" + n.integerValue : "doubleValue" in n ? "" + n.doubleValue : "timestampValue" in n ? function (r) { const a = Cf(r); return `time(${a.seconds},${a.nanos})` }(n.timestampValue) : "stringValue" in n ? n.stringValue : "bytesValue" in n ? Kp(n.bytesValue).toBase64() : "referenceValue" in n ? Gn.fromName(n.referenceValue).toString() : "geoPointValue" in n ? `geo(${(e = n.geoPointValue).latitude},${e.longitude})` : "arrayValue" in n ? function (r) { let a = "[", d = !0; for (const _ of r.values || []) d ? d = !1 : a += ",", a += NC(_); return a + "]" }(n.arrayValue) : "mapValue" in n ? function (r) { const a = Object.keys(r.fields || {}).sort(); let d = "{", _ = !0; for (const E of a) _ ? _ = !1 : d += ",", d += `${E}:${NC(r.fields[E])}`; return d + "}" }(n.mapValue) : rr(); var e } function rm(n, e) { return { referenceValue: `projects/${n.projectId}/databases/${n.database}/documents/${e.path.canonicalString()}` } } function kC(n) { return !!n && "integerValue" in n } function x_(n) { return !!n && "arrayValue" in n } function PC(n) { return !!n && "nullValue" in n } function FT(n) { return !!n && "doubleValue" in n && isNaN(Number(n.doubleValue)) } function Dv(n) { return !!n && "mapValue" in n } function Sv(n) { if (n.geoPointValue) return { geoPointValue: Object.assign({}, n.geoPointValue) }; if (n.timestampValue && "object" == typeof n.timestampValue) return { timestampValue: Object.assign({}, n.timestampValue) }; if (n.mapValue) { const e = { mapValue: { fields: {} } }; return Yp(n.mapValue.fields, (t, r) => e.mapValue.fields[t] = Sv(r)), e } if (n.arrayValue) { const e = { arrayValue: { values: [] } }; for (let t = 0; t < (n.arrayValue.values || []).length; ++t)e.arrayValue.values[t] = Sv(n.arrayValue.values[t]); return e } return Object.assign({}, n) } function M_(n) { return "__max__" === (((n.mapValue || {}).fields || {}).__type__ || {}).stringValue } function dI(n) { return "nullValue" in n ? I_ : "booleanValue" in n ? { booleanValue: !1 } : "integerValue" in n || "doubleValue" in n ? { doubleValue: NaN } : "timestampValue" in n ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "stringValue" in n ? { stringValue: "" } : "bytesValue" in n ? { bytesValue: "" } : "referenceValue" in n ? rm(Lh.empty(), Gn.empty()) : "geoPointValue" in n ? { geoPointValue: { latitude: -90, longitude: -180 } } : "arrayValue" in n ? { arrayValue: {} } : "mapValue" in n ? { mapValue: {} } : rr() } function RC(n) { return "nullValue" in n ? { booleanValue: !1 } : "booleanValue" in n ? { doubleValue: NaN } : "integerValue" in n || "doubleValue" in n ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "timestampValue" in n ? { stringValue: "" } : "stringValue" in n ? { bytesValue: "" } : "bytesValue" in n ? rm(Lh.empty(), Gn.empty()) : "referenceValue" in n ? { geoPointValue: { latitude: -90, longitude: -180 } } : "geoPointValue" in n ? { arrayValue: {} } : "arrayValue" in n ? { mapValue: {} } : "mapValue" in n ? Ef : rr() } function O_(n, e) { const t = sp(n.value, e.value); return 0 !== t ? t : n.inclusive && !e.inclusive ? -1 : !n.inclusive && e.inclusive ? 1 : 0 } function ew(n, e) { const t = sp(n.value, e.value); return 0 !== t ? t : n.inclusive && !e.inclusive ? 1 : !n.inclusive && e.inclusive ? -1 : 0 } class Tf { constructor(e, t) { this.position = e, this.inclusive = t } } function LT(n, e, t) { let r = 0; for (let a = 0; a < n.position.length; a++) { const d = e[a], _ = n.position[a]; if (r = d.field.isKeyField() ? Gn.comparator(Gn.fromName(_.referenceValue), t.key) : sp(_, t.data.field(d.field)), "desc" === d.dir && (r *= -1), 0 !== r) break } return r } function Iv(n, e) { if (null === n) return null === e; if (null === e || n.inclusive !== e.inclusive || n.position.length !== e.position.length) return !1; for (let t = 0; t < n.position.length; t++)if (!oh(n.position[t], e.position[t])) return !1; return !0 } class tw { } class ns extends tw { constructor(e, t, r) { super(), this.field = e, this.op = t, this.value = r } static create(e, t, r) { return e.isKeyField() ? "in" === t || "not-in" === t ? this.createKeyFieldInFilter(e, t, r) : new hI(e, t, r) : "array-contains" === t ? new fI(e, r) : "in" === t ? new UC(e, r) : "not-in" === t ? new HC(e, r) : "array-contains-any" === t ? new zC(e, r) : new ns(e, t, r) } static createKeyFieldInFilter(e, t, r) { return "in" === t ? new UT(e, r) : new HT(e, r) } matches(e) { const t = e.data.field(this.field); return "!=" === this.op ? null !== t && this.matchesComparison(sp(t, this.value)) : null !== t && ip(this.value) === ip(t) && this.matchesComparison(sp(t, this.value)) } matchesComparison(e) { switch (this.op) { case "<": return e < 0; case "<=": return e <= 0; case "==": return 0 === e; case "!=": return 0 !== e; case ">": return e > 0; case ">=": return e >= 0; default: return rr() } } isInequality() { return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0 } getFlattenedFilters() { return [this] } getFilters() { return [this] } getFirstInequalityField() { return this.isInequality() ? this.field : null } } class qs extends tw { constructor(e, t) { super(), this.filters = e, this.op = t, this.ht = null } static create(e, t) { return new qs(e, t) } matches(e) { return N_(this) ? void 0 === this.filters.find(t => !t.matches(e)) : void 0 !== this.filters.find(t => t.matches(e)) } getFlattenedFilters() { return null !== this.ht || (this.ht = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.ht } getFilters() { return Object.assign([], this.filters) } getFirstInequalityField() { const e = this.lt(t => t.isInequality()); return null !== e ? e.field : null } lt(e) { for (const t of this.getFlattenedFilters()) if (e(t)) return t; return null } } function N_(n) { return "and" === n.op } function nw(n) { return "or" === n.op } function FC(n) { return LC(n) && N_(n) } function LC(n) { for (const e of n.filters) if (e instanceof qs) return !1; return !0 } function k_(n) { if (n instanceof ns) return n.field.canonicalString() + n.op.toString() + Jp(n.value); { const e = n.filters.map(t => k_(t)).join(","); return `${n.op}(${e})` } } function BC(n, e) { return n instanceof ns ? (t = n, (r = e) instanceof ns && t.op === r.op && t.field.isEqual(r.field) && oh(t.value, r.value)) : n instanceof qs ? function (t, r) { return r instanceof qs && t.op === r.op && t.filters.length === r.filters.length && t.filters.reduce((a, d, _) => a && BC(d, r.filters[_]), !0) }(n, e) : void rr(); var t, r } function BT(n, e) { const t = n.filters.concat(e); return qs.create(t, n.op) } function VT(n) { return n instanceof ns ? `${(e = n).field.canonicalString()} ${e.op} ${Jp(e.value)}` : n instanceof qs ? function (e) { return e.op.toString() + " {" + e.getFilters().map(VT).join(" ,") + "}" }(n) : "Filter"; var e } class hI extends ns { constructor(e, t, r) { super(e, t, r), this.key = Gn.fromName(r.referenceValue) } matches(e) { const t = Gn.comparator(e.key, this.key); return this.matchesComparison(t) } } class UT extends ns { constructor(e, t) { super(e, "in", t), this.keys = VC(0, t) } matches(e) { return this.keys.some(t => t.isEqual(e.key)) } } class HT extends ns { constructor(e, t) { super(e, "not-in", t), this.keys = VC(0, t) } matches(e) { return !this.keys.some(t => t.isEqual(e.key)) } } function VC(n, e) { var t; return ((null === (t = e.arrayValue) || void 0 === t ? void 0 : t.values) || []).map(r => Gn.fromName(r.referenceValue)) } class fI extends ns { constructor(e, t) { super(e, "array-contains", t) } matches(e) { const t = e.data.field(this.field); return x_(t) && A_(t.arrayValue, this.value) } } class UC extends ns { constructor(e, t) { super(e, "in", t) } matches(e) { const t = e.data.field(this.field); return null !== t && A_(this.value.arrayValue, t) } } class HC extends ns { constructor(e, t) { super(e, "not-in", t) } matches(e) { if (A_(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1; const t = e.data.field(this.field); return null !== t && !A_(this.value.arrayValue, t) } } class zC extends ns { constructor(e, t) { super(e, "array-contains-any", t) } matches(e) { const t = e.data.field(this.field); return !(!x_(t) || !t.arrayValue.values) && t.arrayValue.values.some(r => A_(this.value.arrayValue, r)) } } class P_ { constructor(e, t = "asc") { this.field = e, this.dir = t } } function ah(n, e) { return n.dir === e.dir && n.field.isEqual(e.field) } class Na { constructor(e, t) { this.comparator = e, this.root = t || yc.EMPTY } insert(e, t) { return new Na(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, yc.BLACK, null, null)) } remove(e) { return new Na(this.comparator, this.root.remove(e, this.comparator).copy(null, null, yc.BLACK, null, null)) } get(e) { let t = this.root; for (; !t.isEmpty();) { const r = this.comparator(e, t.key); if (0 === r) return t.value; r < 0 ? t = t.left : r > 0 && (t = t.right) } return null } indexOf(e) { let t = 0, r = this.root; for (; !r.isEmpty();) { const a = this.comparator(e, r.key); if (0 === a) return t + r.left.size; a < 0 ? r = r.left : (t += r.left.size + 1, r = r.right) } return -1 } isEmpty() { return this.root.isEmpty() } get size() { return this.root.size } minKey() { return this.root.minKey() } maxKey() { return this.root.maxKey() } inorderTraversal(e) { return this.root.inorderTraversal(e) } forEach(e) { this.inorderTraversal((t, r) => (e(t, r), !1)) } toString() { const e = []; return this.inorderTraversal((t, r) => (e.push(`${t}:${r}`), !1)), `{${e.join(", ")}}` } reverseTraversal(e) { return this.root.reverseTraversal(e) } getIterator() { return new im(this.root, null, this.comparator, !1) } getIteratorFrom(e) { return new im(this.root, e, this.comparator, !1) } getReverseIterator() { return new im(this.root, null, this.comparator, !0) } getReverseIteratorFrom(e) { return new im(this.root, e, this.comparator, !0) } } class im { constructor(e, t, r, a) { this.isReverse = a, this.nodeStack = []; let d = 1; for (; !e.isEmpty();)if (d = t ? r(e.key, t) : 1, t && a && (d *= -1), d < 0) e = this.isReverse ? e.left : e.right; else { if (0 === d) { this.nodeStack.push(e); break } this.nodeStack.push(e), e = this.isReverse ? e.right : e.left } } getNext() { let e = this.nodeStack.pop(); const t = { key: e.key, value: e.value }; if (this.isReverse) for (e = e.left; !e.isEmpty();)this.nodeStack.push(e), e = e.right; else for (e = e.right; !e.isEmpty();)this.nodeStack.push(e), e = e.left; return t } hasNext() { return this.nodeStack.length > 0 } peek() { if (0 === this.nodeStack.length) return null; const e = this.nodeStack[this.nodeStack.length - 1]; return { key: e.key, value: e.value } } } class yc { constructor(e, t, r, a, d) { this.key = e, this.value = t, this.color = r ?? yc.RED, this.left = a ?? yc.EMPTY, this.right = d ?? yc.EMPTY, this.size = this.left.size + 1 + this.right.size } copy(e, t, r, a, d) { return new yc(e ?? this.key, t ?? this.value, r ?? this.color, a ?? this.left, d ?? this.right) } isEmpty() { return !1 } inorderTraversal(e) { return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e) } reverseTraversal(e) { return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e) } min() { return this.left.isEmpty() ? this : this.left.min() } minKey() { return this.min().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(e, t, r) { let a = this; const d = r(e, a.key); return a = d < 0 ? a.copy(null, null, null, a.left.insert(e, t, r), null) : 0 === d ? a.copy(null, t, null, null, null) : a.copy(null, null, null, null, a.right.insert(e, t, r)), a.fixUp() } removeMin() { if (this.left.isEmpty()) return yc.EMPTY; let e = this; return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp() } remove(e, t) { let r, a = this; if (t(e, a.key) < 0) a.left.isEmpty() || a.left.isRed() || a.left.left.isRed() || (a = a.moveRedLeft()), a = a.copy(null, null, null, a.left.remove(e, t), null); else { if (a.left.isRed() && (a = a.rotateRight()), a.right.isEmpty() || a.right.isRed() || a.right.left.isRed() || (a = a.moveRedRight()), 0 === t(e, a.key)) { if (a.right.isEmpty()) return yc.EMPTY; r = a.right.min(), a = a.copy(r.key, r.value, null, null, a.right.removeMin()) } a = a.copy(null, null, null, null, a.right.remove(e, t)) } return a.fixUp() } isRed() { return this.color } fixUp() { let e = this; return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e } moveRedLeft() { let e = this.colorFlip(); return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e } moveRedRight() { let e = this.colorFlip(); return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e } rotateLeft() { const e = this.copy(null, null, yc.RED, null, this.right.left); return this.right.copy(null, null, this.color, e, null) } rotateRight() { const e = this.copy(null, null, yc.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, e) } colorFlip() { const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, e, t) } checkMaxDepth() { const e = this.check(); return Math.pow(2, e) <= this.size + 1 } check() { if (this.isRed() && this.left.isRed() || this.right.isRed()) throw rr(); const e = this.left.check(); if (e !== this.right.check()) throw rr(); return e + (this.isRed() ? 0 : 1) } } yc.EMPTY = null, yc.RED = !0, yc.BLACK = !1, yc.EMPTY = new class { constructor() { this.size = 0 } get key() { throw rr() } get value() { throw rr() } get color() { throw rr() } get left() { throw rr() } get right() { throw rr() } copy(n, e, t, r, a) { return this } insert(n, e, t) { return new yc(n, e) } remove(n, e) { return this } isEmpty() { return !0 } inorderTraversal(n) { return !1 } reverseTraversal(n) { return !1 } minKey() { return null } maxKey() { return null } isRed() { return !1 } checkMaxDepth() { return !0 } check() { return 0 } }; class _o { constructor(e) { this.comparator = e, this.data = new Na(this.comparator) } has(e) { return null !== this.data.get(e) } first() { return this.data.minKey() } last() { return this.data.maxKey() } get size() { return this.data.size } indexOf(e) { return this.data.indexOf(e) } forEach(e) { this.data.inorderTraversal((t, r) => (e(t), !1)) } forEachInRange(e, t) { const r = this.data.getIteratorFrom(e[0]); for (; r.hasNext();) { const a = r.getNext(); if (this.comparator(a.key, e[1]) >= 0) return; t(a.key) } } forEachWhile(e, t) { let r; for (r = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); r.hasNext();)if (!e(r.getNext().key)) return } firstAfterOrEqual(e) { const t = this.data.getIteratorFrom(e); return t.hasNext() ? t.getNext().key : null } getIterator() { return new sd(this.data.getIterator()) } getIteratorFrom(e) { return new sd(this.data.getIteratorFrom(e)) } add(e) { return this.copy(this.data.remove(e).insert(e, !0)) } delete(e) { return this.has(e) ? this.copy(this.data.remove(e)) : this } isEmpty() { return this.data.isEmpty() } unionWith(e) { let t = this; return t.size < e.size && (t = e, e = this), e.forEach(r => { t = t.add(r) }), t } isEqual(e) { if (!(e instanceof _o) || this.size !== e.size) return !1; const t = this.data.getIterator(), r = e.data.getIterator(); for (; t.hasNext();) { const a = t.getNext().key, d = r.getNext().key; if (0 !== this.comparator(a, d)) return !1 } return !0 } toArray() { const e = []; return this.forEach(t => { e.push(t) }), e } toString() { const e = []; return this.forEach(t => e.push(t)), "SortedSet(" + e.toString() + ")" } copy(e) { const t = new _o(this.comparator); return t.data = e, t } } class sd { constructor(e) { this.iter = e } getNext() { return this.iter.getNext().key } hasNext() { return this.iter.hasNext() } } function sm(n) { return n.hasNext() ? n.getNext() : void 0 } class hu { constructor(e) { this.fields = e, e.sort(Oa.comparator) } static empty() { return new hu([]) } unionWith(e) { let t = new _o(Oa.comparator); for (const r of this.fields) t = t.add(r); for (const r of e) t = t.add(r); return new hu(t.toArray()) } covers(e) { for (const t of this.fields) if (t.isPrefixOf(e)) return !0; return !1 } isEqual(e) { return qp(this.fields, e.fields, (t, r) => t.isEqual(r)) } } class vc { constructor(e) { this.value = e } static empty() { return new vc({ mapValue: {} }) } field(e) { if (e.isEmpty()) return this.value; { let t = this.value; for (let r = 0; r < e.length - 1; ++r)if (t = (t.mapValue.fields || {})[e.get(r)], !Dv(t)) return null; return t = (t.mapValue.fields || {})[e.lastSegment()], t || null } } set(e, t) { this.getFieldsMap(e.popLast())[e.lastSegment()] = Sv(t) } setAll(e) { let t = Oa.emptyPath(), r = {}, a = []; e.forEach((_, E) => { if (!t.isImmediateParentOf(E)) { const x = this.getFieldsMap(t); this.applyChanges(x, r, a), r = {}, a = [], t = E.popLast() } _ ? r[E.lastSegment()] = Sv(_) : a.push(E.lastSegment()) }); const d = this.getFieldsMap(t); this.applyChanges(d, r, a) } delete(e) { const t = this.field(e.popLast()); Dv(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()] } isEqual(e) { return oh(this.value, e.value) } getFieldsMap(e) { let t = this.value; t.mapValue.fields || (t.mapValue = { fields: {} }); for (let r = 0; r < e.length; ++r) { let a = t.mapValue.fields[e.get(r)]; Dv(a) && a.mapValue.fields || (a = { mapValue: { fields: {} } }, t.mapValue.fields[e.get(r)] = a), t = a } return t.mapValue.fields } applyChanges(e, t, r) { Yp(t, (a, d) => e[a] = d); for (const a of r) delete e[a] } clone() { return new vc(Sv(this.value)) } } function GC(n) { const e = []; return Yp(n.fields, (t, r) => { const a = new Oa([t]); if (Dv(r)) { const d = GC(r.mapValue).fields; if (0 === d.length) e.push(a); else for (const _ of d) e.push(a.child(_)) } else e.push(a) }), new hu(e) } class yo { constructor(e, t, r, a, d, _, E) { this.key = e, this.documentType = t, this.version = r, this.readTime = a, this.createTime = d, this.data = _, this.documentState = E } static newInvalidDocument(e) { return new yo(e, 0, Ar.min(), Ar.min(), Ar.min(), vc.empty(), 0) } static newFoundDocument(e, t, r, a) { return new yo(e, 1, t, Ar.min(), r, a, 0) } static newNoDocument(e, t) { return new yo(e, 2, t, Ar.min(), Ar.min(), vc.empty(), 0) } static newUnknownDocument(e, t) { return new yo(e, 3, t, Ar.min(), Ar.min(), vc.empty(), 2) } convertToFoundDocument(e, t) { return !this.createTime.isEqual(Ar.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = e), this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this } convertToNoDocument(e) { return this.version = e, this.documentType = 2, this.data = vc.empty(), this.documentState = 0, this } convertToUnknownDocument(e) { return this.version = e, this.documentType = 3, this.data = vc.empty(), this.documentState = 2, this } setHasCommittedMutations() { return this.documentState = 2, this } setHasLocalMutations() { return this.documentState = 1, this.version = Ar.min(), this } setReadTime(e) { return this.readTime = e, this } get hasLocalMutations() { return 1 === this.documentState } get hasCommittedMutations() { return 2 === this.documentState } get hasPendingWrites() { return this.hasLocalMutations || this.hasCommittedMutations } isValidDocument() { return 0 !== this.documentType } isFoundDocument() { return 1 === this.documentType } isNoDocument() { return 2 === this.documentType } isUnknownDocument() { return 3 === this.documentType } isEqual(e) { return e instanceof yo && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data) } mutableCopy() { return new yo(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState) } toString() { return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})` } } class jC { constructor(e, t = null, r = [], a = [], d = null, _ = null, E = null) { this.path = e, this.collectionGroup = t, this.orderBy = r, this.filters = a, this.limit = d, this.startAt = _, this.endAt = E, this.ft = null } } function Av(n, e = null, t = [], r = [], a = null, d = null, _ = null) { return new jC(n, e, t, r, a, d, _) } function Qp(n) { const e = Wn(n); if (null === e.ft) { let t = e.path.canonicalString(); null !== e.collectionGroup && (t += "|cg:" + e.collectionGroup), t += "|f:", t += e.filters.map(r => k_(r)).join(","), t += "|ob:", t += e.orderBy.map(r => { return (a = r).field.canonicalString() + a.dir; var a }).join(","), T_(e.limit) || (t += "|l:", t += e.limit), e.startAt && (t += "|lb:", t += e.startAt.inclusive ? "b:" : "a:", t += e.startAt.position.map(r => Jp(r)).join(",")), e.endAt && (t += "|ub:", t += e.endAt.inclusive ? "a:" : "b:", t += e.endAt.position.map(r => Jp(r)).join(",")), e.ft = t } return e.ft } function om(n, e) { if (n.limit !== e.limit || n.orderBy.length !== e.orderBy.length) return !1; for (let t = 0; t < n.orderBy.length; t++)if (!ah(n.orderBy[t], e.orderBy[t])) return !1; if (n.filters.length !== e.filters.length) return !1; for (let t = 0; t < n.filters.length; t++)if (!BC(n.filters[t], e.filters[t])) return !1; return n.collectionGroup === e.collectionGroup && !!n.path.isEqual(e.path) && !!Iv(n.startAt, e.startAt) && Iv(n.endAt, e.endAt) } function R_(n) { return Gn.isDocumentKey(n.path) && null === n.collectionGroup && 0 === n.filters.length } function xv(n, e) { return n.filters.filter(t => t instanceof ns && t.field.isEqual(e)) } function rw(n, e, t) { let r = I_, a = !0; for (const d of xv(n, e)) { let _ = I_, E = !0; switch (d.op) { case "<": case "<=": _ = dI(d.value); break; case "==": case "in": case ">=": _ = d.value; break; case ">": _ = d.value, E = !1; break; case "!=": case "not-in": _ = I_ }O_({ value: r, inclusive: a }, { value: _, inclusive: E }) < 0 && (r = _, a = E) } if (null !== t) for (let d = 0; d < n.orderBy.length; ++d)if (n.orderBy[d].field.isEqual(e)) { const _ = t.position[d]; O_({ value: r, inclusive: a }, { value: _, inclusive: t.inclusive }) < 0 && (r = _, a = t.inclusive); break } return { value: r, inclusive: a } } function $C(n, e, t) { let r = Ef, a = !0; for (const d of xv(n, e)) { let _ = Ef, E = !0; switch (d.op) { case ">=": case ">": _ = RC(d.value), E = !1; break; case "==": case "in": case "<=": _ = d.value; break; case "<": _ = d.value, E = !1; break; case "!=": case "not-in": _ = Ef }ew({ value: r, inclusive: a }, { value: _, inclusive: E }) > 0 && (r = _, a = E) } if (null !== t) for (let d = 0; d < n.orderBy.length; ++d)if (n.orderBy[d].field.isEqual(e)) { const _ = t.position[d]; ew({ value: r, inclusive: a }, { value: _, inclusive: t.inclusive }) > 0 && (r = _, a = t.inclusive); break } return { value: r, inclusive: a } } class lh { constructor(e, t = null, r = [], a = [], d = null, _ = "F", E = null, x = null) { this.path = e, this.collectionGroup = t, this.explicitOrderBy = r, this.filters = a, this.limit = d, this.limitType = _, this.startAt = E, this.endAt = x, this.dt = null, this._t = null } } function Df(n, e, t, r, a, d, _, E) { return new lh(n, e, t, r, a, d, _, E) } function Xp(n) { return new lh(n) } function Mv(n) { return 0 === n.filters.length && null === n.limit && null == n.startAt && null == n.endAt && (0 === n.explicitOrderBy.length || 1 === n.explicitOrderBy.length && n.explicitOrderBy[0].field.isKeyField()) } function ch(n) { return n.explicitOrderBy.length > 0 ? n.explicitOrderBy[0].field : null } function Ov(n) { for (const e of n.filters) { const t = e.getFirstInequalityField(); if (null !== t) return t } return null } function WC(n) { return null !== n.collectionGroup } function eg(n) { const e = Wn(n); if (null === e.dt) { e.dt = []; const t = Ov(e), r = ch(e); if (null !== t && null === r) t.isKeyField() || e.dt.push(new P_(t)), e.dt.push(new P_(Oa.keyField(), "asc")); else { let a = !1; for (const d of e.explicitOrderBy) e.dt.push(d), d.field.isKeyField() && (a = !0); if (!a) { const d = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc"; e.dt.push(new P_(Oa.keyField(), d)) } } } return e.dt } function fu(n) { const e = Wn(n); if (!e._t) if ("F" === e.limitType) e._t = Av(e.path, e.collectionGroup, eg(e), e.filters, e.limit, e.startAt, e.endAt); else { const t = []; for (const d of eg(e)) t.push(new P_(d.field, "desc" === d.dir ? "asc" : "desc")); const r = e.endAt ? new Tf(e.endAt.position, e.endAt.inclusive) : null, a = e.startAt ? new Tf(e.startAt.position, e.startAt.inclusive) : null; e._t = Av(e.path, e.collectionGroup, t, e.filters, e.limit, r, a) } return e._t } function iw(n, e) { e.getFirstInequalityField(), Ov(n); const t = n.filters.concat([e]); return new lh(n.path, n.collectionGroup, n.explicitOrderBy.slice(), t, n.limit, n.limitType, n.startAt, n.endAt) } function Nv(n, e, t) { return new lh(n.path, n.collectionGroup, n.explicitOrderBy.slice(), n.filters.slice(), e, t, n.startAt, n.endAt) } function am(n, e) { return om(fu(n), fu(e)) && n.limitType === e.limitType } function zT(n) { return `${Qp(fu(n))}|lt:${n.limitType}` } function kv(n) { return `Query(target=${function (e) { let t = e.path.canonicalString(); return null !== e.collectionGroup && (t += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (t += `, filters: [${e.filters.map(r => VT(r)).join(", ")}]`), T_(e.limit) || (t += ", limit: " + e.limit), e.orderBy.length > 0 && (t += `, orderBy: [${e.orderBy.map(r => { return `${(a = r).field.canonicalString()} (${a.dir})`; var a }).join(", ")}]`), e.startAt && (t += ", startAt: ", t += e.startAt.inclusive ? "b:" : "a:", t += e.startAt.position.map(r => Jp(r)).join(",")), e.endAt && (t += ", endAt: ", t += e.endAt.inclusive ? "a:" : "b:", t += e.endAt.position.map(r => Jp(r)).join(",")), `Target(${t})` }(fu(n))}; limitType=${n.limitType})` } function sw(n, e) { return e.isFoundDocument() && function (t, r) { const a = r.key.path; return null !== t.collectionGroup ? r.key.hasCollectionId(t.collectionGroup) && t.path.isPrefixOf(a) : Gn.isDocumentKey(t.path) ? t.path.isEqual(a) : t.path.isImmediateParentOf(a) }(n, e) && function (t, r) { for (const a of eg(t)) if (!a.field.isKeyField() && null === r.data.field(a.field)) return !1; return !0 }(n, e) && function (t, r) { for (const a of t.filters) if (!a.matches(r)) return !1; return !0 }(n, e) && (r = e, !((t = n).startAt && !function (a, d, _) { const E = LT(a, d, _); return a.inclusive ? E <= 0 : E < 0 }(t.startAt, eg(t), r) || t.endAt && !function (a, d, _) { const E = LT(a, d, _); return a.inclusive ? E >= 0 : E > 0 }(t.endAt, eg(t), r))); var t, r } function ow(n) { return n.collectionGroup || (n.path.length % 2 == 1 ? n.path.lastSegment() : n.path.get(n.path.length - 2)) } function GT(n) { return (e, t) => { let r = !1; for (const a of eg(n)) { const d = aw(a, e, t); if (0 !== d) return d; r = r || a.field.isKeyField() } return 0 } } function aw(n, e, t) { const r = n.field.isKeyField() ? Gn.comparator(e.key, t.key) : function (a, d, _) { const E = d.data.field(a), x = _.data.field(a); return null !== E && null !== x ? sp(E, x) : rr() }(n.field, e, t); switch (n.dir) { case "asc": return r; case "desc": return -1 * r; default: return rr() } } function lw(n, e) { if (n.wt) { if (isNaN(e)) return { doubleValue: "NaN" }; if (e === 1 / 0) return { doubleValue: "Infinity" }; if (e === -1 / 0) return { doubleValue: "-Infinity" } } return { doubleValue: D_(e) ? "-0" : e } } function cw(n) { return { integerValue: "" + n } } function uw(n, e) { return MC(e) ? cw(e) : lw(n, e) } class F_ { constructor() { this._ = void 0 } } function ZC(n, e, t) { return n instanceof tg ? function (r, a) { const d = { fields: { __type__: { stringValue: "server_timestamp" }, __local_write_time__: { timestampValue: { seconds: r.seconds, nanos: r.nanoseconds } } } }; return a && (d.fields.__previous_value__ = a), { mapValue: d } }(t, e) : n instanceof ng ? qC(n, e) : n instanceof rg ? jT(n, e) : function (r, a) { const d = L_(r, a), _ = dw(d) + dw(r.gt); return kC(d) && kC(r.gt) ? cw(_) : lw(r.yt, _) }(n, e) } function Pv(n, e, t) { return n instanceof ng ? qC(n, e) : n instanceof rg ? jT(n, e) : t } function L_(n, e) { return n instanceof B_ ? kC(t = e) || (r = t) && "doubleValue" in r ? e : { integerValue: 0 } : null; var r, t } class tg extends F_ { } class ng extends F_ { constructor(e) { super(), this.elements = e } } function qC(n, e) { const t = YC(e); for (const r of n.elements) t.some(a => oh(a, r)) || t.push(r); return { arrayValue: { values: t } } } class rg extends F_ { constructor(e) { super(), this.elements = e } } function jT(n, e) { let t = YC(e); for (const r of n.elements) t = t.filter(a => !oh(a, r)); return { arrayValue: { values: t } } } class B_ extends F_ { constructor(e, t) { super(), this.yt = e, this.gt = t } } function dw(n) { return ha(n.integerValue || n.doubleValue) } function YC(n) { return x_(n) && n.arrayValue.values ? n.arrayValue.values.slice() : [] } class V_ { constructor(e, t) { this.field = e, this.transform = t } } class pI { constructor(e, t) { this.version = e, this.transformResults = t } } class fa { constructor(e, t) { this.updateTime = e, this.exists = t } static none() { return new fa } static exists(e) { return new fa(void 0, e) } static updateTime(e) { return new fa(e) } get isNone() { return void 0 === this.updateTime && void 0 === this.exists } isEqual(e) { return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime) } } function hw(n, e) { return void 0 !== n.updateTime ? e.isFoundDocument() && e.version.isEqual(n.updateTime) : void 0 === n.exists || n.exists === e.isFoundDocument() } class fw { } function WT(n, e) { if (!n.hasLocalMutations || e && 0 === e.fields.length) return null; if (null === e) return n.isNoDocument() ? new lm(n.key, fa.none()) : new ig(n.key, n.data, fa.none()); { const t = n.data, r = vc.empty(); let a = new _o(Oa.comparator); for (let d of e.fields) if (!a.has(d)) { let _ = t.field(d); null === _ && d.length > 1 && (d = d.popLast(), _ = t.field(d)), null === _ ? r.delete(d) : r.set(d, _), a = a.add(d) } return new pu(n.key, r, new hu(a.toArray()), fa.none()) } } function ZT(n, e, t) { n instanceof ig ? function (r, a, d) { const _ = r.value.clone(), E = Rv(r.fieldTransforms, a, d.transformResults); _.setAll(E), a.convertToFoundDocument(d.version, _).setHasCommittedMutations() }(n, e, t) : n instanceof pu ? function (r, a, d) { if (!hw(r.precondition, a)) return void a.convertToUnknownDocument(d.version); const _ = Rv(r.fieldTransforms, a, d.transformResults), E = a.data; E.setAll(pw(r)), E.setAll(_), a.convertToFoundDocument(d.version, E).setHasCommittedMutations() }(n, e, t) : e.convertToNoDocument(t.version).setHasCommittedMutations() } function op(n, e, t, r) { return n instanceof ig ? function (a, d, _, E) { if (!hw(a.precondition, d)) return _; const x = a.value.clone(), B = Fv(a.fieldTransforms, E, d); return x.setAll(B), d.convertToFoundDocument(d.version, x).setHasLocalMutations(), null }(n, e, t, r) : n instanceof pu ? function (a, d, _, E) { if (!hw(a.precondition, d)) return _; const x = Fv(a.fieldTransforms, E, d), B = d.data; return B.setAll(pw(a)), B.setAll(x), d.convertToFoundDocument(d.version, B).setHasLocalMutations(), null === _ ? null : _.unionWith(a.fieldMask.fields).unionWith(a.fieldTransforms.map(K => K.field)) }(n, e, t, r) : (_ = t, hw(n.precondition, d = e) ? (d.convertToNoDocument(d.version).setHasLocalMutations(), null) : _); var d, _ } function qT(n, e) { let t = null; for (const r of n.fieldTransforms) { const a = e.data.field(r.field), d = L_(r.transform, a || null); null != d && (null === t && (t = vc.empty()), t.set(r.field, d)) } return t || null } function KC(n, e) { return n.type === e.type && !!n.key.isEqual(e.key) && !!n.precondition.isEqual(e.precondition) && (r = e.fieldTransforms, !!(void 0 === (t = n.fieldTransforms) && void 0 === r || t && r && qp(t, r, (a, d) => function $T(n, e) { return n.field.isEqual(e.field) && (r = e.transform, (t = n.transform) instanceof ng && r instanceof ng || t instanceof rg && r instanceof rg ? qp(t.elements, r.elements, oh) : t instanceof B_ && r instanceof B_ ? oh(t.gt, r.gt) : t instanceof tg && r instanceof tg); var t, r }(a, d)))) && (0 === n.type ? n.value.isEqual(e.value) : 1 !== n.type || n.data.isEqual(e.data) && n.fieldMask.isEqual(e.fieldMask)); var t, r } class ig extends fw { constructor(e, t, r, a = []) { super(), this.key = e, this.value = t, this.precondition = r, this.fieldTransforms = a, this.type = 0 } getFieldMask() { return null } } class pu extends fw { constructor(e, t, r, a, d = []) { super(), this.key = e, this.data = t, this.fieldMask = r, this.precondition = a, this.fieldTransforms = d, this.type = 1 } getFieldMask() { return this.fieldMask } } function pw(n) { const e = new Map; return n.fieldMask.fields.forEach(t => { if (!t.isEmpty()) { const r = n.data.field(t); e.set(t, r) } }), e } function Rv(n, e, t) { const r = new Map; mr(n.length === t.length); for (let a = 0; a < t.length; a++) { const d = n[a], _ = d.transform, E = e.data.field(d.field); r.set(d.field, Pv(_, E, t[a])) } return r } function Fv(n, e, t) { const r = new Map; for (const a of n) { const d = a.transform, _ = t.data.field(a.field); r.set(a.field, ZC(d, _, e)) } return r } class lm extends fw { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [] } getFieldMask() { return null } } class U_ extends fw { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [] } getFieldMask() { return null } } class gw { constructor(e) { this.count = e } } var pa, Cs; function YT(n) { switch (n) { default: return rr(); case en.CANCELLED: case en.UNKNOWN: case en.DEADLINE_EXCEEDED: case en.RESOURCE_EXHAUSTED: case en.INTERNAL: case en.UNAVAILABLE: case en.UNAUTHENTICATED: return !1; case en.INVALID_ARGUMENT: case en.NOT_FOUND: case en.ALREADY_EXISTS: case en.PERMISSION_DENIED: case en.FAILED_PRECONDITION: case en.ABORTED: case en.OUT_OF_RANGE: case en.UNIMPLEMENTED: case en.DATA_LOSS: return !0 } } function KT(n) { if (void 0 === n) return Ga("GRPC error has no .code"), en.UNKNOWN; switch (n) { case pa.OK: return en.OK; case pa.CANCELLED: return en.CANCELLED; case pa.UNKNOWN: return en.UNKNOWN; case pa.DEADLINE_EXCEEDED: return en.DEADLINE_EXCEEDED; case pa.RESOURCE_EXHAUSTED: return en.RESOURCE_EXHAUSTED; case pa.INTERNAL: return en.INTERNAL; case pa.UNAVAILABLE: return en.UNAVAILABLE; case pa.UNAUTHENTICATED: return en.UNAUTHENTICATED; case pa.INVALID_ARGUMENT: return en.INVALID_ARGUMENT; case pa.NOT_FOUND: return en.NOT_FOUND; case pa.ALREADY_EXISTS: return en.ALREADY_EXISTS; case pa.PERMISSION_DENIED: return en.PERMISSION_DENIED; case pa.FAILED_PRECONDITION: return en.FAILED_PRECONDITION; case pa.ABORTED: return en.ABORTED; case pa.OUT_OF_RANGE: return en.OUT_OF_RANGE; case pa.UNIMPLEMENTED: return en.UNIMPLEMENTED; case pa.DATA_LOSS: return en.DATA_LOSS; default: return rr() } } (Cs = pa || (pa = {}))[Cs.OK = 0] = "OK", Cs[Cs.CANCELLED = 1] = "CANCELLED", Cs[Cs.UNKNOWN = 2] = "UNKNOWN", Cs[Cs.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Cs[Cs.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Cs[Cs.NOT_FOUND = 5] = "NOT_FOUND", Cs[Cs.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Cs[Cs.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Cs[Cs.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Cs[Cs.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Cs[Cs.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Cs[Cs.ABORTED = 10] = "ABORTED", Cs[Cs.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Cs[Cs.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Cs[Cs.INTERNAL = 13] = "INTERNAL", Cs[Cs.UNAVAILABLE = 14] = "UNAVAILABLE", Cs[Cs.DATA_LOSS = 15] = "DATA_LOSS"; class sg { constructor(e, t) { this.mapKeyFn = e, this.equalsFn = t, this.inner = {}, this.innerSize = 0 } get(e) { const t = this.mapKeyFn(e), r = this.inner[t]; if (void 0 !== r) for (const [a, d] of r) if (this.equalsFn(a, e)) return d } has(e) { return void 0 !== this.get(e) } set(e, t) { const r = this.mapKeyFn(e), a = this.inner[r]; if (void 0 === a) return this.inner[r] = [[e, t]], void this.innerSize++; for (let d = 0; d < a.length; d++)if (this.equalsFn(a[d][0], e)) return void (a[d] = [e, t]); a.push([e, t]), this.innerSize++ } delete(e) { const t = this.mapKeyFn(e), r = this.inner[t]; if (void 0 === r) return !1; for (let a = 0; a < r.length; a++)if (this.equalsFn(r[a][0], e)) return 1 === r.length ? delete this.inner[t] : r.splice(a, 1), this.innerSize--, !0; return !1 } forEach(e) { Yp(this.inner, (t, r) => { for (const [a, d] of r) e(a, d) }) } isEmpty() { return kT(this.inner) } size() { return this.innerSize } } const JC = new Na(Gn.comparator); function Ru() { return JC } const QC = new Na(Gn.comparator); function H_(...n) { let e = QC; for (const t of n) e = e.insert(t.key, t); return e } function XC(n) { let e = QC; return n.forEach((t, r) => e = e.insert(t, r.overlayedDocument)), e } function uh() { return cm() } function mw() { return cm() } function cm() { return new sg(n => n.toString(), (n, e) => n.isEqual(e)) } const JT = new Na(Gn.comparator), QT = new _o(Gn.comparator); function Ci(...n) { let e = QT; for (const t of n) e = e.add(t); return e } const _w = new _o(ai); function yw() { return _w } class um { constructor(e, t, r, a, d) { this.snapshotVersion = e, this.targetChanges = t, this.targetMismatches = r, this.documentUpdates = a, this.resolvedLimboDocuments = d } static createSynthesizedRemoteEventForCurrentChange(e, t, r) { const a = new Map; return a.set(e, og.createSynthesizedTargetChangeForCurrentChange(e, t, r)), new um(Ar.min(), a, yw(), Ru(), Ci()) } } class og { constructor(e, t, r, a, d) { this.resumeToken = e, this.current = t, this.addedDocuments = r, this.modifiedDocuments = a, this.removedDocuments = d } static createSynthesizedTargetChangeForCurrentChange(e, t, r) { return new og(r, t, Ci(), Ci(), Ci()) } } class Lv { constructor(e, t, r, a) { this.It = e, this.removedTargetIds = t, this.key = r, this.Tt = a } } class eE { constructor(e, t) { this.targetId = e, this.Et = t } } class XT { constructor(e, t, r = sl.EMPTY_BYTE_STRING, a = null) { this.state = e, this.targetIds = t, this.resumeToken = r, this.cause = a } } class eD { constructor() { this.At = 0, this.Rt = nE(), this.bt = sl.EMPTY_BYTE_STRING, this.Pt = !1, this.vt = !0 } get current() { return this.Pt } get resumeToken() { return this.bt } get Vt() { return 0 !== this.At } get St() { return this.vt } Dt(e) { e.approximateByteSize() > 0 && (this.vt = !0, this.bt = e) } Ct() { let e = Ci(), t = Ci(), r = Ci(); return this.Rt.forEach((a, d) => { switch (d) { case 0: e = e.add(a); break; case 2: t = t.add(a); break; case 1: r = r.add(a); break; default: rr() } }), new og(this.bt, this.Pt, e, t, r) } xt() { this.vt = !1, this.Rt = nE() } Nt(e, t) { this.vt = !0, this.Rt = this.Rt.insert(e, t) } kt(e) { this.vt = !0, this.Rt = this.Rt.remove(e) } Ot() { this.At += 1 } Mt() { this.At -= 1 } Ft() { this.vt = !0, this.Pt = !0 } } class tD { constructor(e) { this.$t = e, this.Bt = new Map, this.Lt = Ru(), this.qt = tE(), this.Ut = new _o(ai) } Kt(e) { for (const t of e.It) e.Tt && e.Tt.isFoundDocument() ? this.Gt(t, e.Tt) : this.Qt(t, e.key, e.Tt); for (const t of e.removedTargetIds) this.Qt(t, e.key, e.Tt) } jt(e) { this.forEachTarget(e, t => { const r = this.Wt(t); switch (e.state) { case 0: this.zt(t) && r.Dt(e.resumeToken); break; case 1: r.Mt(), r.Vt || r.xt(), r.Dt(e.resumeToken); break; case 2: r.Mt(), r.Vt || this.removeTarget(t); break; case 3: this.zt(t) && (r.Ft(), r.Dt(e.resumeToken)); break; case 4: this.zt(t) && (this.Ht(t), r.Dt(e.resumeToken)); break; default: rr() } }) } forEachTarget(e, t) { e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.Bt.forEach((r, a) => { this.zt(a) && t(a) }) } Jt(e) { const t = e.targetId, r = e.Et.count, a = this.Yt(t); if (a) { const d = a.target; if (R_(d)) if (0 === r) { const _ = new Gn(d.path); this.Qt(t, _, yo.newNoDocument(_, Ar.min())) } else mr(1 === r); else this.Xt(t) !== r && (this.Ht(t), this.Ut = this.Ut.add(t)) } } Zt(e) { const t = new Map; this.Bt.forEach((d, _) => { const E = this.Yt(_); if (E) { if (d.current && R_(E.target)) { const x = new Gn(E.target.path); null !== this.Lt.get(x) || this.te(_, x) || this.Qt(_, x, yo.newNoDocument(x, e)) } d.St && (t.set(_, d.Ct()), d.xt()) } }); let r = Ci(); this.qt.forEach((d, _) => { let E = !0; _.forEachWhile(x => { const B = this.Yt(x); return !B || 2 === B.purpose || (E = !1, !1) }), E && (r = r.add(d)) }), this.Lt.forEach((d, _) => _.setReadTime(e)); const a = new um(e, t, this.Ut, this.Lt, r); return this.Lt = Ru(), this.qt = tE(), this.Ut = new _o(ai), a } Gt(e, t) { if (!this.zt(e)) return; const r = this.te(e, t.key) ? 2 : 0; this.Wt(e).Nt(t.key, r), this.Lt = this.Lt.insert(t.key, t), this.qt = this.qt.insert(t.key, this.ee(t.key).add(e)) } Qt(e, t, r) { if (!this.zt(e)) return; const a = this.Wt(e); this.te(e, t) ? a.Nt(t, 1) : a.kt(t), this.qt = this.qt.insert(t, this.ee(t).delete(e)), r && (this.Lt = this.Lt.insert(t, r)) } removeTarget(e) { this.Bt.delete(e) } Xt(e) { const t = this.Wt(e).Ct(); return this.$t.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size } Ot(e) { this.Wt(e).Ot() } Wt(e) { let t = this.Bt.get(e); return t || (t = new eD, this.Bt.set(e, t)), t } ee(e) { let t = this.qt.get(e); return t || (t = new _o(ai), this.qt = this.qt.insert(e, t)), t } zt(e) { const t = null !== this.Yt(e); return t || Mn("WatchChangeAggregator", "Detected inactive target", e), t } Yt(e) { const t = this.Bt.get(e); return t && t.Vt ? null : this.$t.ne(e) } Ht(e) { this.Bt.set(e, new eD), this.$t.getRemoteKeysForTarget(e).forEach(t => { this.Qt(e, t, null) }) } te(e, t) { return this.$t.getRemoteKeysForTarget(e).has(t) } } function tE() { return new Na(Gn.comparator) } function nE() { return new Na(Gn.comparator) } const gI = { asc: "ASCENDING", desc: "DESCENDING" }, mI = { "<": "LESS_THAN", "<=": "LESS_THAN_OR_EQUAL", ">": "GREATER_THAN", ">=": "GREATER_THAN_OR_EQUAL", "==": "EQUAL", "!=": "NOT_EQUAL", "array-contains": "ARRAY_CONTAINS", in: "IN", "not-in": "NOT_IN", "array-contains-any": "ARRAY_CONTAINS_ANY" }, _I = { and: "AND", or: "OR" }; class yI { constructor(e, t) { this.databaseId = e, this.wt = t } } function z_(n, e) { return n.wt ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : { seconds: "" + e.seconds, nanos: e.nanoseconds } } function rE(n, e) { return n.wt ? e.toBase64() : e.toUint8Array() } function vI(n, e) { return z_(n, e.toTimestamp()) } function ol(n) { return mr(!!n), Ar.fromTimestamp(function (e) { const t = Cf(e); return new Vo(t.seconds, t.nanos) }(n)) } function iE(n, e) { return (t = n, new is(["projects", t.projectId, "databases", t.database])).child("documents").child(e).canonicalString(); var t } function nD(n) { const e = is.fromString(n); return mr(rD(e)), e } function G_(n, e) { return iE(n.databaseId, e.path) } function Sf(n, e) { const t = nD(e); if (t.get(1) !== n.databaseId.projectId) throw new Cn(en.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + t.get(1) + " vs " + n.databaseId.projectId); if (t.get(3) !== n.databaseId.database) throw new Cn(en.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + t.get(3) + " vs " + n.databaseId.database); return new Gn(g(t)) } function o(n, e) { return iE(n.databaseId, e) } function c(n) { const e = nD(n); return 4 === e.length ? is.emptyPath() : g(e) } function u(n) { return new is(["projects", n.databaseId.projectId, "databases", n.databaseId.database]).canonicalString() } function g(n) { return mr(n.length > 4 && "documents" === n.get(4)), n.popFirst(5) } function b(n, e, t) { return { name: G_(n, e), fields: t.value.mapValue.fields } } function D(n, e, t) { const r = Sf(n, e.name), a = ol(e.updateTime), d = e.createTime ? ol(e.createTime) : Ar.min(), _ = new vc({ mapValue: { fields: e.fields } }), E = yo.newFoundDocument(r, a, d, _); return t && E.setHasCommittedMutations(), t ? E.setHasCommittedMutations() : E } function j(n, e) { let t; if (e instanceof ig) t = { update: b(n, e.key, e.value) }; else if (e instanceof lm) t = { delete: G_(n, e.key) }; else if (e instanceof pu) t = { update: b(n, e.key, e.data), updateMask: $a(e.fieldMask) }; else { if (!(e instanceof U_)) return rr(); t = { verify: G_(n, e.key) } } return e.fieldTransforms.length > 0 && (t.updateTransforms = e.fieldTransforms.map(r => function (a, d) { const _ = d.transform; if (_ instanceof tg) return { fieldPath: d.field.canonicalString(), setToServerValue: "REQUEST_TIME" }; if (_ instanceof ng) return { fieldPath: d.field.canonicalString(), appendMissingElements: { values: _.elements } }; if (_ instanceof rg) return { fieldPath: d.field.canonicalString(), removeAllFromArray: { values: _.elements } }; if (_ instanceof B_) return { fieldPath: d.field.canonicalString(), increment: _.gt }; throw rr() }(0, r))), e.precondition.isNone || (t.currentDocument = void 0 !== (a = e.precondition).updateTime ? { updateTime: vI(n, a.updateTime) } : void 0 !== a.exists ? { exists: a.exists } : rr()), t; var a } function ne(n, e) { const t = e.currentDocument ? void 0 !== (a = e.currentDocument).updateTime ? fa.updateTime(ol(a.updateTime)) : void 0 !== a.exists ? fa.exists(a.exists) : fa.none() : fa.none(), r = e.updateTransforms ? e.updateTransforms.map(a => function (d, _) { let E = null; "setToServerValue" in _ ? (mr("REQUEST_TIME" === _.setToServerValue), E = new tg) : "appendMissingElements" in _ ? E = new ng(_.appendMissingElements.values || []) : "removeAllFromArray" in _ ? E = new rg(_.removeAllFromArray.values || []) : "increment" in _ ? E = new B_(d, _.increment) : rr(); const x = Oa.fromServerFormat(_.fieldPath); return new V_(x, E) }(n, a)) : []; var a; if (e.update) { const a = Sf(n, e.update.name), d = new vc({ mapValue: { fields: e.update.fields } }); if (e.updateMask) { const _ = new hu((e.updateMask.fieldPaths || []).map(B => Oa.fromServerFormat(B))); return new pu(a, d, _, t, r) } return new ig(a, d, t, r) } if (e.delete) { const a = Sf(n, e.delete); return new lm(a, t) } if (e.verify) { const a = Sf(n, e.verify); return new U_(a, t) } return rr() } function He(n, e) { return { documents: [o(n, e.path)] } } function Dt(n, e) { const t = { structuredQuery: {} }, r = e.path; null !== e.collectionGroup ? (t.parent = o(n, r), t.structuredQuery.from = [{ collectionId: e.collectionGroup, allDescendants: !0 }]) : (t.parent = o(n, r.popLast()), t.structuredQuery.from = [{ collectionId: r.lastSegment() }]); const a = function (x) { if (0 !== x.length) return Uo(qs.create(x, "and")) }(e.filters); a && (t.structuredQuery.where = a); const d = function (x) { if (0 !== x.length) return x.map(B => { return { field: En((K = B).field), direction: Zn(K.dir) }; var K }) }(e.orderBy); d && (t.structuredQuery.orderBy = d); const _ = (B = e.limit, n.wt || T_(B) ? B : { value: B }); var B, E, x; return null !== _ && (t.structuredQuery.limit = _), e.startAt && (t.structuredQuery.startAt = { before: (E = e.startAt).inclusive, values: E.position }), e.endAt && (t.structuredQuery.endAt = { before: !(x = e.endAt).inclusive, values: x.position }), t } function Ut(n) { let e = c(n.parent); const t = n.structuredQuery, r = t.from ? t.from.length : 0; let a = null; if (r > 0) { mr(1 === r); const K = t.from[0]; K.allDescendants ? a = K.collectionId : e = e.child(K.collectionId) } let d = []; t.where && (d = function (K) { const oe = Rn(K); return oe instanceof qs && FC(oe) ? oe.getFilters() : [oe] }(t.where)); let _ = []; t.orderBy && (_ = t.orderBy.map(K => { return new P_(Yr((oe = K).field), function (Me) { switch (Me) { case "ASCENDING": return "asc"; case "DESCENDING": return "desc"; default: return } }(oe.direction)); var oe })); let E = null; t.limit && (E = function (K) { let oe; return oe = "object" == typeof K ? K.value : K, T_(oe) ? null : oe }(t.limit)); let x = null; var K; t.startAt && (x = new Tf((K = t.startAt).values || [], !!K.before)); let B = null; return t.endAt && (B = function (K) { return new Tf(K.values || [], !K.before) }(t.endAt)), Df(e, a, _, d, E, "F", x, B) } function Rn(n) { return void 0 !== n.unaryFilter ? function (e) { switch (e.unaryFilter.op) { case "IS_NAN": const t = Yr(e.unaryFilter.field); return ns.create(t, "==", { doubleValue: NaN }); case "IS_NULL": const r = Yr(e.unaryFilter.field); return ns.create(r, "==", { nullValue: "NULL_VALUE" }); case "IS_NOT_NAN": const a = Yr(e.unaryFilter.field); return ns.create(a, "!=", { doubleValue: NaN }); case "IS_NOT_NULL": const d = Yr(e.unaryFilter.field); return ns.create(d, "!=", { nullValue: "NULL_VALUE" }); default: return rr() } }(n) : void 0 !== n.fieldFilter ? ns.create(Yr((e = n).fieldFilter.field), function (t) { switch (t) { case "EQUAL": return "=="; case "NOT_EQUAL": return "!="; case "GREATER_THAN": return ">"; case "GREATER_THAN_OR_EQUAL": return ">="; case "LESS_THAN": return "<"; case "LESS_THAN_OR_EQUAL": return "<="; case "ARRAY_CONTAINS": return "array-contains"; case "IN": return "in"; case "NOT_IN": return "not-in"; case "ARRAY_CONTAINS_ANY": return "array-contains-any"; default: return rr() } }(e.fieldFilter.op), e.fieldFilter.value) : void 0 !== n.compositeFilter ? function (e) { return qs.create(e.compositeFilter.filters.map(t => Rn(t)), function (t) { switch (t) { case "AND": return "and"; case "OR": return "or"; default: return rr() } }(e.compositeFilter.op)) }(n) : rr(); var e } function Zn(n) { return gI[n] } function fr(n) { return mI[n] } function jr(n) { return _I[n] } function En(n) { return { fieldPath: n.canonicalString() } } function Yr(n) { return Oa.fromServerFormat(n.fieldPath) } function Uo(n) { return n instanceof ns ? function (e) { if ("==" === e.op) { if (FT(e.value)) return { unaryFilter: { field: En(e.field), op: "IS_NAN" } }; if (PC(e.value)) return { unaryFilter: { field: En(e.field), op: "IS_NULL" } } } else if ("!=" === e.op) { if (FT(e.value)) return { unaryFilter: { field: En(e.field), op: "IS_NOT_NAN" } }; if (PC(e.value)) return { unaryFilter: { field: En(e.field), op: "IS_NOT_NULL" } } } return { fieldFilter: { field: En(e.field), op: fr(e.op), value: e.value } } }(n) : n instanceof qs ? function (e) { const t = e.getFilters().map(r => Uo(r)); return 1 === t.length ? t[0] : { compositeFilter: { op: jr(e.op), filters: t } } }(n) : rr() } function $a(n) { const e = []; return n.fields.forEach(t => e.push(t.canonicalString())), { fieldPaths: e } } function rD(n) { return n.length >= 4 && "projects" === n.get(0) && "databases" === n.get(2) } function od(n) { let e = ""; for (let t = 0; t < n.length; t++)e.length > 0 && (e = bI(e)), e = Lx(n.get(t), e); return bI(e) } function Lx(n, e) { let t = e; const r = n.length; for (let a = 0; a < r; a++) { const d = n.charAt(a); switch (d) { case "\0": t += "\x01\x10"; break; case "\x01": t += "\x01\x11"; break; default: t += d } } return t } function bI(n) { return n + "\x01\x01" } function ap(n) { const e = n.length; if (mr(e >= 2), 2 === e) return mr("\x01" === n.charAt(0) && "\x01" === n.charAt(1)), is.emptyPath(); const t = e - 2, r = []; let a = ""; for (let d = 0; d < e;) { const _ = n.indexOf("\x01", d); switch ((_ < 0 || _ > t) && rr(), n.charAt(_ + 1)) { case "\x01": const E = n.substring(d, _); let x; 0 === a.length ? x = E : (a += E, x = a, a = ""), r.push(x); break; case "\x10": a += n.substring(d, _), a += "\0"; break; case "\x11": a += n.substring(d, _ + 1); break; default: rr() }d = _ + 2 } return new is(r) } const wI = ["userId", "batchId"]; function sE(n, e) { return [n, od(e)] } function CI(n, e, t) { return [n, od(e), t] } const Bx = {}, Vx = ["prefixPath", "collectionGroup", "readTime", "documentId"], Ux = ["prefixPath", "collectionGroup", "documentId"], Hx = ["collectionGroup", "readTime", "prefixPath", "documentId"], zx = ["canonicalId", "targetId"], Gx = ["targetId", "path"], jx = ["path", "targetId"], $x = ["collectionId", "parent"], Wx = ["indexId", "uid"], Zx = ["uid", "sequenceNumber"], qx = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"], Yx = ["indexId", "uid", "orderedDocumentKey"], Kx = ["userId", "collectionPath", "documentId"], Jx = ["userId", "collectionPath", "largestBatchId"], Qx = ["userId", "collectionGroup", "largestBatchId"], EI = ["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries"], Xx = [...EI, "documentOverlays"], TI = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"], DI = TI, eM = [...DI, "indexConfiguration", "indexState", "indexEntries"]; class iD extends SC { constructor(e, t) { super(), this.se = e, this.currentSequenceNumber = t } } function $c(n, e) { const t = Wn(n); return rd.M(t.se, e) } class sD { constructor(e, t, r, a) { this.batchId = e, this.localWriteTime = t, this.baseMutations = r, this.mutations = a } applyToRemoteDocument(e, t) { const r = t.mutationResults; for (let a = 0; a < this.mutations.length; a++) { const d = this.mutations[a]; d.key.isEqual(e.key) && ZT(d, e, r[a]) } } applyToLocalView(e, t) { for (const r of this.baseMutations) r.key.isEqual(e.key) && (t = op(r, e, t, this.localWriteTime)); for (const r of this.mutations) r.key.isEqual(e.key) && (t = op(r, e, t, this.localWriteTime)); return t } applyToLocalDocumentSet(e, t) { const r = mw(); return this.mutations.forEach(a => { const d = e.get(a.key), _ = d.overlayedDocument; let E = this.applyToLocalView(_, d.mutatedFields); E = t.has(a.key) ? null : E; const x = WT(_, E); null !== x && r.set(a.key, x), _.isValidDocument() || _.convertToNoDocument(Ar.min()) }), r } keys() { return this.mutations.reduce((e, t) => e.add(t.key), Ci()) } isEqual(e) { return this.batchId === e.batchId && qp(this.mutations, e.mutations, (t, r) => KC(t, r)) && qp(this.baseMutations, e.baseMutations, (t, r) => KC(t, r)) } } class oD { constructor(e, t, r, a) { this.batch = e, this.commitVersion = t, this.mutationResults = r, this.docVersions = a } static from(e, t, r) { mr(e.mutations.length === r.length); let a = JT; const d = e.mutations; for (let _ = 0; _ < d.length; _++)a = a.insert(d[_].key, r[_].version); return new oD(e, t, r, a) } } class aD { constructor(e, t) { this.largestBatchId = e, this.mutation = t } getKey() { return this.mutation.key } isEqual(e) { return null !== e && this.mutation === e.mutation } toString() { return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }` } } class dm { constructor(e, t, r, a, d = Ar.min(), _ = Ar.min(), E = sl.EMPTY_BYTE_STRING) { this.target = e, this.targetId = t, this.purpose = r, this.sequenceNumber = a, this.snapshotVersion = d, this.lastLimboFreeSnapshotVersion = _, this.resumeToken = E } withSequenceNumber(e) { return new dm(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken) } withResumeToken(e, t) { return new dm(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e) } withLastLimboFreeSnapshotVersion(e) { return new dm(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken) } } class SI { constructor(e) { this.ie = e } } function II(n, e) { const t = e.key, r = { prefixPath: t.getCollectionPath().popLast().toArray(), collectionGroup: t.collectionGroup, documentId: t.path.lastSegment(), readTime: oE(e.readTime), hasCommittedMutations: e.hasCommittedMutations }; if (e.isFoundDocument()) r.document = { name: G_(a = n.ie, (d = e).key), fields: d.data.value.mapValue.fields, updateTime: z_(a, d.version.toTimestamp()), createTime: z_(a, d.createTime.toTimestamp()) }; else if (e.isNoDocument()) r.noDocument = { path: t.path.toArray(), readTime: j_(e.version) }; else { if (!e.isUnknownDocument()) return rr(); r.unknownDocument = { path: t.path.toArray(), version: j_(e.version) } } var a, d; return r } function oE(n) { const e = n.toTimestamp(); return [e.seconds, e.nanoseconds] } function j_(n) { const e = n.toTimestamp(); return { seconds: e.seconds, nanoseconds: e.nanoseconds } } function $_(n) { const e = new Vo(n.seconds, n.nanoseconds); return Ar.fromTimestamp(e) } function W_(n, e) { const t = (e.baseMutations || []).map(d => ne(n.ie, d)); for (let d = 0; d < e.mutations.length - 1; ++d)d + 1 < e.mutations.length && void 0 !== e.mutations[d + 1].transform && (e.mutations[d].updateTransforms = e.mutations[d + 1].transform.fieldTransforms, e.mutations.splice(d + 1, 1), ++d); const r = e.mutations.map(d => ne(n.ie, d)), a = Vo.fromMillis(e.localWriteTimeMs); return new sD(e.batchId, a, t, r) } function vw(n) { const e = $_(n.readTime), t = void 0 !== n.lastLimboFreeSnapshotVersion ? $_(n.lastLimboFreeSnapshotVersion) : Ar.min(); let r; var a; return void 0 !== n.query.documents ? (mr(1 === (a = n.query).documents.length), r = fu(Xp(c(a.documents[0])))) : r = fu(Ut(n.query)), new dm(r, n.targetId, 0, n.lastListenSequenceNumber, e, t, sl.fromBase64String(n.resumeToken)) } function AI(n, e) { const t = j_(e.snapshotVersion), r = j_(e.lastLimboFreeSnapshotVersion); let a; a = R_(e.target) ? He(n.ie, e.target) : Dt(n.ie, e.target); const d = e.resumeToken.toBase64(); return { targetId: e.targetId, canonicalId: Qp(e.target), readTime: t, resumeToken: d, lastListenSequenceNumber: e.sequenceNumber, lastLimboFreeSnapshotVersion: r, query: a } } function lD(n) { const e = Ut({ parent: n.parent, structuredQuery: n.structuredQuery }); return "LAST" === n.limitType ? Nv(e, e.limit, "L") : e } function cD(n, e) { return new aD(e.largestBatchId, ne(n.ie, e.overlayMutation)) } function xI(n, e) { const t = e.path.lastSegment(); return [n, od(e.path.popLast()), t] } function MI(n, e, t, r) { return { indexId: n, uid: e.uid || "", sequenceNumber: t, readTime: j_(r.readTime), documentKey: od(r.documentKey.path), largestBatchId: r.largestBatchId } } class nM { getBundleMetadata(e, t) { return OI(e).get(t).next(r => { if (r) return { id: (a = r).bundleId, createTime: $_(a.createTime), version: a.version }; var a }) } saveBundleMetadata(e, t) { return OI(e).put({ bundleId: (r = t).id, createTime: j_(ol(r.createTime)), version: r.version }); var r } getNamedQuery(e, t) { return NI(e).get(t).next(r => { if (r) return { name: (a = r).name, query: lD(a.bundledQuery), readTime: $_(a.readTime) }; var a }) } saveNamedQuery(e, t) { return NI(e).put({ name: (r = t).name, readTime: j_(ol(r.readTime)), bundledQuery: r.bundledQuery }); var r } } function OI(n) { return $c(n, "bundles") } function NI(n) { return $c(n, "namedQueries") } class aE { constructor(e, t) { this.yt = e, this.userId = t } static re(e, t) { return new aE(e, t.uid || "") } getOverlay(e, t) { return bw(e).get(xI(this.userId, t)).next(r => r ? cD(this.yt, r) : null) } getOverlays(e, t) { const r = uh(); return Qt.forEach(t, a => this.getOverlay(e, a).next(d => { null !== d && r.set(a, d) })).next(() => r) } saveOverlays(e, t, r) { const a = []; return r.forEach((d, _) => { const E = new aD(t, _); a.push(this.oe(e, E)) }), Qt.waitFor(a) } removeOverlaysForBatchId(e, t, r) { const a = new Set; t.forEach(_ => a.add(od(_.getCollectionPath()))); const d = []; return a.forEach(_ => { const E = IDBKeyRange.bound([this.userId, _, r], [this.userId, _, r + 1], !1, !0); d.push(bw(e).Y("collectionPathOverlayIndex", E)) }), Qt.waitFor(d) } getOverlaysForCollection(e, t, r) { const a = uh(), d = od(t), _ = IDBKeyRange.bound([this.userId, d, r], [this.userId, d, Number.POSITIVE_INFINITY], !0); return bw(e).W("collectionPathOverlayIndex", _).next(E => { for (const x of E) { const B = cD(this.yt, x); a.set(B.getKey(), B) } return a }) } getOverlaysForCollectionGroup(e, t, r, a) { const d = uh(); let _; const E = IDBKeyRange.bound([this.userId, t, r], [this.userId, t, Number.POSITIVE_INFINITY], !0); return bw(e).Z({ index: "collectionGroupOverlayIndex", range: E }, (x, B, K) => { const oe = cD(this.yt, B); d.size() < a || oe.largestBatchId === _ ? (d.set(oe.getKey(), oe), _ = oe.largestBatchId) : K.done() }).next(() => d) } oe(e, t) { return bw(e).put(function (r, a, d) { const [_, E, x] = xI(a, d.mutation.key); return { userId: a, collectionPath: E, documentId: x, collectionGroup: d.mutation.key.getCollectionGroup(), largestBatchId: d.largestBatchId, overlayMutation: j(r.ie, d.mutation) } }(this.yt, this.userId, t)) } } function bw(n) { return $c(n, "documentOverlays") } class Z_ { constructor() { } ue(e, t) { this.ce(e, t), t.ae() } ce(e, t) { if ("nullValue" in e) this.he(t, 5); else if ("booleanValue" in e) this.he(t, 10), t.le(e.booleanValue ? 1 : 0); else if ("integerValue" in e) this.he(t, 15), t.le(ha(e.integerValue)); else if ("doubleValue" in e) { const r = ha(e.doubleValue); isNaN(r) ? this.he(t, 13) : (this.he(t, 15), D_(r) ? t.le(0) : t.le(r)) } else if ("timestampValue" in e) { const r = e.timestampValue; this.he(t, 20), "string" == typeof r ? t.fe(r) : (t.fe(`${r.seconds || ""}`), t.le(r.nanos || 0)) } else if ("stringValue" in e) this.de(e.stringValue, t), this._e(t); else if ("bytesValue" in e) this.he(t, 30), t.we(Kp(e.bytesValue)), this._e(t); else if ("referenceValue" in e) this.me(e.referenceValue, t); else if ("geoPointValue" in e) { const r = e.geoPointValue; this.he(t, 45), t.le(r.latitude || 0), t.le(r.longitude || 0) } else "mapValue" in e ? M_(e) ? this.he(t, Number.MAX_SAFE_INTEGER) : (this.ge(e.mapValue, t), this._e(t)) : "arrayValue" in e ? (this.ye(e.arrayValue, t), this._e(t)) : rr() } de(e, t) { this.he(t, 25), this.pe(e, t) } pe(e, t) { t.fe(e) } ge(e, t) { const r = e.fields || {}; this.he(t, 55); for (const a of Object.keys(r)) this.de(a, t), this.ce(r[a], t) } ye(e, t) { const r = e.values || []; this.he(t, 50); for (const a of r) this.ce(a, t) } me(e, t) { this.he(t, 37), Gn.fromName(e).path.forEach(r => { this.he(t, 60), this.pe(r, t) }) } he(e, t) { e.le(t) } _e(e) { e.le(2) } } function rM(n) { if (0 === n) return 8; let e = 0; return !(n >> 4) && (e += 4, n <<= 4), !(n >> 6) && (e += 2, n <<= 2), !(n >> 7) && (e += 1), e } function kI(n) { const e = 64 - function (t) { let r = 0; for (let a = 0; a < 8; ++a) { const d = rM(255 & t[a]); if (r += d, 8 !== d) break } return r }(n); return Math.ceil(e / 8) } Z_.Ie = new Z_; class iM { constructor() { this.buffer = new Uint8Array(1024), this.position = 0 } Te(e) { const t = e[Symbol.iterator](); let r = t.next(); for (; !r.done;)this.Ee(r.value), r = t.next(); this.Ae() } Re(e) { const t = e[Symbol.iterator](); let r = t.next(); for (; !r.done;)this.be(r.value), r = t.next(); this.Pe() } ve(e) { for (const t of e) { const r = t.charCodeAt(0); if (r < 128) this.Ee(r); else if (r < 2048) this.Ee(960 | r >>> 6), this.Ee(128 | 63 & r); else if (t < "\ud800" || "\udbff" < t) this.Ee(480 | r >>> 12), this.Ee(128 | 63 & r >>> 6), this.Ee(128 | 63 & r); else { const a = t.codePointAt(0); this.Ee(240 | a >>> 18), this.Ee(128 | 63 & a >>> 12), this.Ee(128 | 63 & a >>> 6), this.Ee(128 | 63 & a) } } this.Ae() } Ve(e) { for (const t of e) { const r = t.charCodeAt(0); if (r < 128) this.be(r); else if (r < 2048) this.be(960 | r >>> 6), this.be(128 | 63 & r); else if (t < "\ud800" || "\udbff" < t) this.be(480 | r >>> 12), this.be(128 | 63 & r >>> 6), this.be(128 | 63 & r); else { const a = t.codePointAt(0); this.be(240 | a >>> 18), this.be(128 | 63 & a >>> 12), this.be(128 | 63 & a >>> 6), this.be(128 | 63 & a) } } this.Pe() } Se(e) { const t = this.De(e), r = kI(t); this.Ce(1 + r), this.buffer[this.position++] = 255 & r; for (let a = t.length - r; a < t.length; ++a)this.buffer[this.position++] = 255 & t[a] } xe(e) { const t = this.De(e), r = kI(t); this.Ce(1 + r), this.buffer[this.position++] = ~(255 & r); for (let a = t.length - r; a < t.length; ++a)this.buffer[this.position++] = ~(255 & t[a]) } Ne() { this.ke(255), this.ke(255) } Oe() { this.Me(255), this.Me(255) } reset() { this.position = 0 } seed(e) { this.Ce(e.length), this.buffer.set(e, this.position), this.position += e.length } Fe() { return this.buffer.slice(0, this.position) } De(e) { const t = function (a) { const d = new DataView(new ArrayBuffer(8)); return d.setFloat64(0, a, !1), new Uint8Array(d.buffer) }(e), r = 0 != (128 & t[0]); t[0] ^= r ? 255 : 128; for (let a = 1; a < t.length; ++a)t[a] ^= r ? 255 : 0; return t } Ee(e) { const t = 255 & e; 0 === t ? (this.ke(0), this.ke(255)) : 255 === t ? (this.ke(255), this.ke(0)) : this.ke(t) } be(e) { const t = 255 & e; 0 === t ? (this.Me(0), this.Me(255)) : 255 === t ? (this.Me(255), this.Me(0)) : this.Me(e) } Ae() { this.ke(0), this.ke(1) } Pe() { this.Me(0), this.Me(1) } ke(e) { this.Ce(1), this.buffer[this.position++] = e } Me(e) { this.Ce(1), this.buffer[this.position++] = ~e } Ce(e) { const t = e + this.position; if (t <= this.buffer.length) return; let r = 2 * this.buffer.length; r < t && (r = t); const a = new Uint8Array(r); a.set(this.buffer), this.buffer = a } } class sM { constructor(e) { this.$e = e } we(e) { this.$e.Te(e) } fe(e) { this.$e.ve(e) } le(e) { this.$e.Se(e) } ae() { this.$e.Ne() } } class oM { constructor(e) { this.$e = e } we(e) { this.$e.Re(e) } fe(e) { this.$e.Ve(e) } le(e) { this.$e.xe(e) } ae() { this.$e.Oe() } } class ww { constructor() { this.$e = new iM, this.Be = new sM(this.$e), this.Le = new oM(this.$e) } seed(e) { this.$e.seed(e) } qe(e) { return 0 === e ? this.Be : this.Le } Fe() { return this.$e.Fe() } reset() { this.$e.reset() } } class q_ { constructor(e, t, r, a) { this.indexId = e, this.documentKey = t, this.arrayValue = r, this.directionalValue = a } Ue() { const e = this.directionalValue.length, t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e, r = new Uint8Array(t); return r.set(this.directionalValue, 0), t !== e ? r.set([0], this.directionalValue.length) : ++r[r.length - 1], new q_(this.indexId, this.documentKey, this.arrayValue, r) } } function hm(n, e) { let t = n.indexId - e.indexId; return 0 !== t ? t : (t = PI(n.arrayValue, e.arrayValue), 0 !== t ? t : (t = PI(n.directionalValue, e.directionalValue), 0 !== t ? t : Gn.comparator(n.documentKey, e.documentKey))) } function PI(n, e) { for (let t = 0; t < n.length && t < e.length; ++t) { const r = n[t] - e[t]; if (0 !== r) return r } return n.length - e.length } class aM { constructor(e) { this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment(), this.Ke = e.orderBy, this.Ge = []; for (const t of e.filters) { const r = t; r.isInequality() ? this.Qe = r : this.Ge.push(r) } } je(e) { mr(e.collectionGroup === this.collectionId); const t = mc(e); if (void 0 !== t && !this.We(t)) return !1; const r = Fd(e); let a = 0, d = 0; for (; a < r.length && this.We(r[a]); ++a); if (a === r.length) return !0; if (void 0 !== this.Qe) { const _ = r[a]; if (!this.ze(this.Qe, _) || !this.He(this.Ke[d++], _)) return !1; ++a } for (; a < r.length; ++a)if (d >= this.Ke.length || !this.He(this.Ke[d++], r[a])) return !1; return !0 } We(e) { for (const t of this.Ge) if (this.ze(t, e)) return !0; return !1 } ze(e, t) { return !(void 0 === e || !e.field.isEqual(t.fieldPath)) && 2 === t.kind == ("array-contains" === e.op || "array-contains-any" === e.op) } He(e, t) { return !!e.field.isEqual(t.fieldPath) && (0 === t.kind && "asc" === e.dir || 1 === t.kind && "desc" === e.dir) } } function RI(n) { var e, t; if (mr(n instanceof ns || n instanceof qs), n instanceof ns) { if (n instanceof UC) { const a = (null === (t = null === (e = n.value.arrayValue) || void 0 === e ? void 0 : e.values) || void 0 === t ? void 0 : t.map(d => ns.create(n.field, "==", d))) || []; return qs.create(a, "or") } return n } const r = n.filters.map(a => RI(a)); return qs.create(r, n.op) } function lM(n) { if (0 === n.getFilters().length) return []; const e = hD(RI(n)); return mr(FI(e)), uD(e) || dD(e) ? [e] : e.getFilters() } function uD(n) { return n instanceof ns } function dD(n) { return n instanceof qs && FC(n) } function FI(n) { return uD(n) || dD(n) || function (e) { if (e instanceof qs && nw(e)) { for (const t of e.getFilters()) if (!uD(t) && !dD(t)) return !1; return !0 } return !1 }(n) } function hD(n) { if (mr(n instanceof ns || n instanceof qs), n instanceof ns) return n; if (1 === n.filters.length) return hD(n.filters[0]); const e = n.filters.map(r => hD(r)); let t = qs.create(e, n.op); return t = lE(t), FI(t) ? t : (mr(t instanceof qs), mr(N_(t)), mr(t.filters.length > 1), t.filters.reduce((r, a) => fD(r, a))) } function fD(n, e) { let t; return mr(n instanceof ns || n instanceof qs), mr(e instanceof ns || e instanceof qs), t = n instanceof ns ? e instanceof ns ? qs.create([n, e], "and") : LI(n, e) : e instanceof ns ? LI(e, n) : function (r, a) { if (mr(r.filters.length > 0 && a.filters.length > 0), N_(r) && N_(a)) return BT(r, a.getFilters()); const d = nw(r) ? r : a, _ = nw(r) ? a : r, E = d.filters.map(x => fD(x, _)); return qs.create(E, "or") }(n, e), lE(t) } function LI(n, e) { if (N_(e)) return BT(e, n.getFilters()); { const t = e.filters.map(r => fD(n, r)); return qs.create(t, "or") } } function lE(n) { if (mr(n instanceof ns || n instanceof qs), n instanceof ns) return n; const e = n.getFilters(); if (1 === e.length) return lE(e[0]); if (LC(n)) return n; const t = e.map(a => lE(a)), r = []; return t.forEach(a => { a instanceof ns ? r.push(a) : a instanceof qs && (a.op === n.op ? r.push(...a.filters) : r.push(a)) }), 1 === r.length ? r[0] : qs.create(r, n.op) } class cM { constructor() { this.Je = new pD } addToCollectionParentIndex(e, t) { return this.Je.add(t), Qt.resolve() } getCollectionParents(e, t) { return Qt.resolve(this.Je.getEntries(t)) } addFieldIndex(e, t) { return Qt.resolve() } deleteFieldIndex(e, t) { return Qt.resolve() } getDocumentsMatchingTarget(e, t) { return Qt.resolve(null) } getIndexType(e, t) { return Qt.resolve(0) } getFieldIndexes(e, t) { return Qt.resolve([]) } getNextCollectionGroupToUpdate(e) { return Qt.resolve(null) } getMinOffset(e, t) { return Qt.resolve(_c.min()) } getMinOffsetFromCollectionGroup(e, t) { return Qt.resolve(_c.min()) } updateCollectionGroup(e, t, r) { return Qt.resolve() } updateIndexEntries(e, t) { return Qt.resolve() } } class pD { constructor() { this.index = {} } add(e) { const t = e.lastSegment(), r = e.popLast(), a = this.index[t] || new _o(is.comparator), d = !a.has(r); return this.index[t] = a.add(r), d } has(e) { const t = e.lastSegment(), r = e.popLast(), a = this.index[t]; return a && a.has(r) } getEntries(e) { return (this.index[e] || new _o(is.comparator)).toArray() } } const cE = new Uint8Array(0); class uM { constructor(e, t) { this.user = e, this.databaseId = t, this.Ye = new pD, this.Xe = new sg(r => Qp(r), (r, a) => om(r, a)), this.uid = e.uid || "" } addToCollectionParentIndex(e, t) { if (!this.Ye.has(t)) { const r = t.lastSegment(), a = t.popLast(); e.addOnCommittedListener(() => { this.Ye.add(t) }); const d = { collectionId: r, parent: od(a) }; return BI(e).put(d) } return Qt.resolve() } getCollectionParents(e, t) { const r = [], a = IDBKeyRange.bound([t, ""], [jb(t), ""], !1, !0); return BI(e).W(a).next(d => { for (const _ of d) { if (_.collectionId !== t) break; r.push(ap(_.parent)) } return r }) } addFieldIndex(e, t) { const r = uE(e), a = { indexId: (_ = t).indexId, collectionGroup: _.collectionGroup, fields: _.fields.map(E => [E.fieldPath.canonicalString(), E.kind]) }; var _; delete a.indexId; const d = r.add(a); if (t.indexState) { const _ = Ew(e); return d.next(E => { _.put(MI(E, this.user, t.indexState.sequenceNumber, t.indexState.offset)) }) } return d.next() } deleteFieldIndex(e, t) { const r = uE(e), a = Ew(e), d = Cw(e); return r.delete(t.indexId).next(() => a.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))).next(() => d.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))) } getDocumentsMatchingTarget(e, t) { const r = Cw(e); let a = !0; const d = new Map; return Qt.forEach(this.Ze(t), _ => this.tn(e, _).next(E => { a && (a = !!E), d.set(_, E) })).next(() => { if (a) { let _ = Ci(); const E = []; return Qt.forEach(d, (x, B) => { var K; Mn("IndexedDbIndexManager", `Using index ${K = x, `id=${K.indexId}|cg=${K.collectionGroup}|f=${K.fields.map(Rr => `${Rr.fieldPath}:${Rr.kind}`).join(",")}`} to execute ${Qp(t)}`); const oe = function (Rr, Li) { const Ki = mc(Li); if (void 0 === Ki) return null; for (const Pi of xv(Rr, Ki.fieldPath)) switch (Pi.op) { case "array-contains-any": return Pi.value.arrayValue.values || []; case "array-contains": return [Pi.value] }return null }(B, x), Me = function (Rr, Li) { const Ki = new Map; for (const Pi of Fd(Li)) for (const Es of xv(Rr, Pi.fieldPath)) switch (Es.op) { case "==": case "in": Ki.set(Pi.fieldPath.canonicalString(), Es.value); break; case "not-in": case "!=": return Ki.set(Pi.fieldPath.canonicalString(), Es.value), Array.from(Ki.values()) }return null }(B, x), ot = function (Rr, Li) { const Ki = []; let Pi = !0; for (const Es of Fd(Li)) { const cd = 0 === Es.kind ? rw(Rr, Es.fieldPath, Rr.startAt) : $C(Rr, Es.fieldPath, Rr.startAt); Ki.push(cd.value), Pi && (Pi = cd.inclusive) } return new Tf(Ki, Pi) }(B, x), bt = function (Rr, Li) { const Ki = []; let Pi = !0; for (const Es of Fd(Li)) { const cd = 0 === Es.kind ? $C(Rr, Es.fieldPath, Rr.endAt) : rw(Rr, Es.fieldPath, Rr.endAt); Ki.push(cd.value), Pi && (Pi = cd.inclusive) } return new Tf(Ki, Pi) }(B, x), qt = this.en(x, B, ot), Tn = this.en(x, B, bt), cr = this.nn(x, B, Me), $r = this.sn(x.indexId, oe, qt, ot.inclusive, Tn, bt.inclusive, cr); return Qt.forEach($r, Rr => r.J(Rr, t.limit).next(Li => { Li.forEach(Ki => { const Pi = Gn.fromSegments(Ki.documentKey); _.has(Pi) || (_ = _.add(Pi), E.push(Pi)) }) })) }).next(() => E) } return Qt.resolve(null) }) } Ze(e) { let t = this.Xe.get(e); return t || (t = 0 === e.filters.length ? [e] : lM(qs.create(e.filters, "and")).map(r => Av(e.path, e.collectionGroup, e.orderBy, r.getFilters(), e.limit, e.startAt, e.endAt)), this.Xe.set(e, t), t) } sn(e, t, r, a, d, _, E) { const x = (null != t ? t.length : 1) * Math.max(r.length, d.length), B = x / (null != t ? t.length : 1), K = []; for (let oe = 0; oe < x; ++oe) { const Me = t ? this.rn(t[oe / B]) : cE, ot = this.on(e, Me, r[oe % B], a), bt = this.un(e, Me, d[oe % B], _), qt = E.map(Tn => this.on(e, Me, Tn, !0)); K.push(...this.createRange(ot, bt, qt)) } return K } on(e, t, r, a) { const d = new q_(e, Gn.empty(), t, r); return a ? d : d.Ue() } un(e, t, r, a) { const d = new q_(e, Gn.empty(), t, r); return a ? d.Ue() : d } tn(e, t) { const r = new aM(t), a = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment(); return this.getFieldIndexes(e, a).next(d => { let _ = null; for (const E of d) r.je(E) && (!_ || E.fields.length > _.fields.length) && (_ = E); return _ }) } getIndexType(e, t) { let r = 2; const a = this.Ze(t); return Qt.forEach(a, d => this.tn(e, d).next(_ => { _ ? 0 !== r && _.fields.length < function (E) { let x = new _o(Oa.comparator), B = !1; for (const K of E.filters) for (const oe of K.getFlattenedFilters()) oe.field.isKeyField() || ("array-contains" === oe.op || "array-contains-any" === oe.op ? B = !0 : x = x.add(oe.field)); for (const K of E.orderBy) K.field.isKeyField() || (x = x.add(K.field)); return x.size + (B ? 1 : 0) }(d) && (r = 1) : r = 0 })).next(() => null !== t.limit && a.length > 1 && 2 === r ? 1 : r) } cn(e, t) { const r = new ww; for (const a of Fd(e)) { const d = t.data.field(a.fieldPath); if (null == d) return null; const _ = r.qe(a.kind); Z_.Ie.ue(d, _) } return r.Fe() } rn(e) { const t = new ww; return Z_.Ie.ue(e, t.qe(0)), t.Fe() } an(e, t) { const r = new ww; return Z_.Ie.ue(rm(this.databaseId, t), r.qe(function (a) { const d = Fd(a); return 0 === d.length ? 0 : d[d.length - 1].kind }(e))), r.Fe() } nn(e, t, r) { if (null === r) return []; let a = []; a.push(new ww); let d = 0; for (const _ of Fd(e)) { const E = r[d++]; for (const x of a) if (this.hn(t, _.fieldPath) && x_(E)) a = this.ln(a, _, E); else { const B = x.qe(_.kind); Z_.Ie.ue(E, B) } } return this.fn(a) } en(e, t, r) { return this.nn(e, t, r.position) } fn(e) { const t = []; for (let r = 0; r < e.length; ++r)t[r] = e[r].Fe(); return t } ln(e, t, r) { const a = [...e], d = []; for (const _ of r.arrayValue.values || []) for (const E of a) { const x = new ww; x.seed(E.Fe()), Z_.Ie.ue(_, x.qe(t.kind)), d.push(x) } return d } hn(e, t) { return !!e.filters.find(r => r instanceof ns && r.field.isEqual(t) && ("in" === r.op || "not-in" === r.op)) } getFieldIndexes(e, t) { const r = uE(e), a = Ew(e); return (t ? r.W("collectionGroupIndex", IDBKeyRange.bound(t, t)) : r.W()).next(d => { const _ = []; return Qt.forEach(d, E => a.get([E.indexId, this.uid]).next(x => { _.push(function (B, K) { const oe = K ? new Cv(K.sequenceNumber, new _c($_(K.readTime), new Gn(ap(K.documentKey)), K.largestBatchId)) : Cv.empty(), Me = B.fields.map(([ot, bt]) => new wv(Oa.fromServerFormat(ot), bt)); return new E_(B.indexId, B.collectionGroup, Me, oe) }(E, x)) })).next(() => _) }) } getNextCollectionGroupToUpdate(e) { return this.getFieldIndexes(e).next(t => 0 === t.length ? null : (t.sort((r, a) => { const d = r.indexState.sequenceNumber - a.indexState.sequenceNumber; return 0 !== d ? d : ai(r.collectionGroup, a.collectionGroup) }), t[0].collectionGroup)) } updateCollectionGroup(e, t, r) { const a = uE(e), d = Ew(e); return this.dn(e).next(_ => a.W("collectionGroupIndex", IDBKeyRange.bound(t, t)).next(E => Qt.forEach(E, x => d.put(MI(x.indexId, this.user, _, r))))) } updateIndexEntries(e, t) { const r = new Map; return Qt.forEach(t, (a, d) => { const _ = r.get(a.collectionGroup); return (_ ? Qt.resolve(_) : this.getFieldIndexes(e, a.collectionGroup)).next(E => (r.set(a.collectionGroup, E), Qt.forEach(E, x => this._n(e, a, x).next(B => { const K = this.wn(d, x); return B.isEqual(K) ? Qt.resolve() : this.mn(e, d, x, B, K) })))) }) } gn(e, t, r, a) { return Cw(e).put({ indexId: a.indexId, uid: this.uid, arrayValue: a.arrayValue, directionalValue: a.directionalValue, orderedDocumentKey: this.an(r, t.key), documentKey: t.key.path.toArray() }) } yn(e, t, r, a) { return Cw(e).delete([a.indexId, this.uid, a.arrayValue, a.directionalValue, this.an(r, t.key), t.key.path.toArray()]) } _n(e, t, r) { const a = Cw(e); let d = new _o(hm); return a.Z({ index: "documentKeyIndex", range: IDBKeyRange.only([r.indexId, this.uid, this.an(r, t)]) }, (_, E) => { d = d.add(new q_(r.indexId, t, E.arrayValue, E.directionalValue)) }).next(() => d) } wn(e, t) { let r = new _o(hm); const a = this.cn(t, e); if (null == a) return r; const d = mc(t); if (null != d) { const _ = e.data.field(d.fieldPath); if (x_(_)) for (const E of _.arrayValue.values || []) r = r.add(new q_(t.indexId, e.key, this.rn(E), a)) } else r = r.add(new q_(t.indexId, e.key, cE, a)); return r } mn(e, t, r, a, d) { Mn("IndexedDbIndexManager", "Updating index entries for document '%s'", t.key); const _ = []; return function (E, x, B, K, oe) { const Me = E.getIterator(), ot = x.getIterator(); let bt = sm(Me), qt = sm(ot); for (; bt || qt;) { let Tn = !1, cr = !1; if (bt && qt) { const $r = B(bt, qt); $r < 0 ? cr = !0 : $r > 0 && (Tn = !0) } else null != bt ? cr = !0 : Tn = !0; Tn ? (K(qt), qt = sm(ot)) : cr ? (oe(bt), bt = sm(Me)) : (bt = sm(Me), qt = sm(ot)) } }(a, d, hm, E => { _.push(this.gn(e, t, r, E)) }, E => { _.push(this.yn(e, t, r, E)) }), Qt.waitFor(_) } dn(e) { let t = 1; return Ew(e).Z({ index: "sequenceNumberIndex", reverse: !0, range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]) }, (r, a, d) => { d.done(), t = a.sequenceNumber + 1 }).next(() => t) } createRange(e, t, r) { r = r.sort((_, E) => hm(_, E)).filter((_, E, x) => !E || 0 !== hm(_, x[E - 1])); const a = []; a.push(e); for (const _ of r) { const E = hm(_, e), x = hm(_, t); if (0 === E) a[0] = e.Ue(); else if (E > 0 && x < 0) a.push(_), a.push(_.Ue()); else if (x > 0) break } a.push(t); const d = []; for (let _ = 0; _ < a.length; _ += 2) { if (this.pn(a[_], a[_ + 1])) return []; d.push(IDBKeyRange.bound([a[_].indexId, this.uid, a[_].arrayValue, a[_].directionalValue, cE, []], [a[_ + 1].indexId, this.uid, a[_ + 1].arrayValue, a[_ + 1].directionalValue, cE, []])) } return d } pn(e, t) { return hm(e, t) > 0 } getMinOffsetFromCollectionGroup(e, t) { return this.getFieldIndexes(e, t).next(VI) } getMinOffset(e, t) { return Qt.mapArray(this.Ze(t), r => this.tn(e, r).next(a => a || rr())).next(VI) } } function BI(n) { return $c(n, "collectionParents") } function Cw(n) { return $c(n, "indexEntries") } function uE(n) { return $c(n, "indexConfiguration") } function Ew(n) { return $c(n, "indexState") } function VI(n) { mr(0 !== n.length); let e = n[0].indexState.offset, t = e.largestBatchId; for (let r = 1; r < n.length; r++) { const a = n[r].indexState.offset; Zb(a, e) < 0 && (e = a), t < a.largestBatchId && (t = a.largestBatchId) } return new _c(e.readTime, e.documentKey, t) } const UI = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 }; class Ld { constructor(e, t, r) { this.cacheSizeCollectionThreshold = e, this.percentileToCollect = t, this.maximumSequenceNumbersToCollect = r } static withCacheSize(e) { return new Ld(e, Ld.DEFAULT_COLLECTION_PERCENTILE, Ld.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT) } } function HI(n, e, t) { const r = n.store("mutations"), a = n.store("documentMutations"), d = [], _ = IDBKeyRange.only(t.batchId); let E = 0; const x = r.Z({ range: _ }, (K, oe, Me) => (E++, Me.delete())); d.push(x.next(() => { mr(1 === E) })); const B = []; for (const K of t.mutations) { const oe = CI(e, K.key.path, t.batchId); d.push(a.delete(oe)), B.push(K.key) } return Qt.waitFor(d).next(() => B) } function dE(n) { if (!n) return 0; let e; if (n.document) e = n.document; else if (n.unknownDocument) e = n.unknownDocument; else { if (!n.noDocument) throw rr(); e = n.noDocument } return JSON.stringify(e).length } Ld.DEFAULT_COLLECTION_PERCENTILE = 10, Ld.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Ld.DEFAULT = new Ld(41943040, Ld.DEFAULT_COLLECTION_PERCENTILE, Ld.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Ld.DISABLED = new Ld(-1, 0, 0); class hE { constructor(e, t, r, a) { this.userId = e, this.yt = t, this.indexManager = r, this.referenceDelegate = a, this.In = {} } static re(e, t, r, a) { mr("" !== e.uid); const d = e.isAuthenticated() ? e.uid : ""; return new hE(d, t, r, a) } checkEmpty(e) { let t = !0; const r = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]); return fm(e).Z({ index: "userMutationsIndex", range: r }, (a, d, _) => { t = !1, _.done() }).next(() => t) } addMutationBatch(e, t, r, a) { const d = Bv(e), _ = fm(e); return _.add({}).next(E => { mr("number" == typeof E); const x = new sD(E, t, r, a), B = function (Me, ot, bt) { const qt = bt.baseMutations.map(cr => j(Me.ie, cr)), Tn = bt.mutations.map(cr => j(Me.ie, cr)); return { userId: ot, batchId: bt.batchId, localWriteTimeMs: bt.localWriteTime.toMillis(), baseMutations: qt, mutations: Tn } }(this.yt, this.userId, x), K = []; let oe = new _o((Me, ot) => ai(Me.canonicalString(), ot.canonicalString())); for (const Me of a) { const ot = CI(this.userId, Me.key.path, E); oe = oe.add(Me.key.path.popLast()), K.push(_.put(B)), K.push(d.put(ot, Bx)) } return oe.forEach(Me => { K.push(this.indexManager.addToCollectionParentIndex(e, Me)) }), e.addOnCommittedListener(() => { this.In[E] = x.keys() }), Qt.waitFor(K).next(() => x) }) } lookupMutationBatch(e, t) { return fm(e).get(t).next(r => r ? (mr(r.userId === this.userId), W_(this.yt, r)) : null) } Tn(e, t) { return this.In[t] ? Qt.resolve(this.In[t]) : this.lookupMutationBatch(e, t).next(r => { if (r) { const a = r.keys(); return this.In[t] = a, a } return null }) } getNextMutationBatchAfterBatchId(e, t) { const r = t + 1, a = IDBKeyRange.lowerBound([this.userId, r]); let d = null; return fm(e).Z({ index: "userMutationsIndex", range: a }, (_, E, x) => { E.userId === this.userId && (mr(E.batchId >= r), d = W_(this.yt, E)), x.done() }).next(() => d) } getHighestUnacknowledgedBatchId(e) { const t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]); let r = -1; return fm(e).Z({ index: "userMutationsIndex", range: t, reverse: !0 }, (a, d, _) => { r = d.batchId, _.done() }).next(() => r) } getAllMutationBatches(e) { const t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]); return fm(e).W("userMutationsIndex", t).next(r => r.map(a => W_(this.yt, a))) } getAllMutationBatchesAffectingDocumentKey(e, t) { const r = sE(this.userId, t.path), a = IDBKeyRange.lowerBound(r), d = []; return Bv(e).Z({ range: a }, (_, E, x) => { const [B, K, oe] = _, Me = ap(K); if (B === this.userId && t.path.isEqual(Me)) return fm(e).get(oe).next(ot => { if (!ot) throw rr(); mr(ot.userId === this.userId), d.push(W_(this.yt, ot)) }); x.done() }).next(() => d) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let r = new _o(ai); const a = []; return t.forEach(d => { const _ = sE(this.userId, d.path), E = IDBKeyRange.lowerBound(_), x = Bv(e).Z({ range: E }, (B, K, oe) => { const [Me, ot, bt] = B, qt = ap(ot); Me === this.userId && d.path.isEqual(qt) ? r = r.add(bt) : oe.done() }); a.push(x) }), Qt.waitFor(a).next(() => this.En(e, r)) } getAllMutationBatchesAffectingQuery(e, t) { const r = t.path, a = r.length + 1, d = sE(this.userId, r), _ = IDBKeyRange.lowerBound(d); let E = new _o(ai); return Bv(e).Z({ range: _ }, (x, B, K) => { const [oe, Me, ot] = x, bt = ap(Me); oe === this.userId && r.isPrefixOf(bt) ? bt.length === a && (E = E.add(ot)) : K.done() }).next(() => this.En(e, E)) } En(e, t) { const r = [], a = []; return t.forEach(d => { a.push(fm(e).get(d).next(_ => { if (null === _) throw rr(); mr(_.userId === this.userId), r.push(W_(this.yt, _)) })) }), Qt.waitFor(a).next(() => r) } removeMutationBatch(e, t) { return HI(e.se, this.userId, t).next(r => (e.addOnCommittedListener(() => { this.An(t.batchId) }), Qt.forEach(r, a => this.referenceDelegate.markPotentiallyOrphaned(e, a)))) } An(e) { delete this.In[e] } performConsistencyCheck(e) { return this.checkEmpty(e).next(t => { if (!t) return Qt.resolve(); const r = IDBKeyRange.lowerBound([this.userId]), a = []; return Bv(e).Z({ range: r }, (d, _, E) => { if (d[0] === this.userId) { const x = ap(d[1]); a.push(x) } else E.done() }).next(() => { mr(0 === a.length) }) }) } containsKey(e, t) { return zI(e, this.userId, t) } Rn(e) { return GI(e).get(this.userId).next(t => t || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: "" }) } } function zI(n, e, t) { const r = sE(e, t.path), a = r[1], d = IDBKeyRange.lowerBound(r); let _ = !1; return Bv(n).Z({ range: d, X: !0 }, (E, x, B) => { const [K, oe, Me] = E; K === e && oe === a && (_ = !0), B.done() }).next(() => _) } function fm(n) { return $c(n, "mutations") } function Bv(n) { return $c(n, "documentMutations") } function GI(n) { return $c(n, "mutationQueues") } class Y_ { constructor(e) { this.bn = e } next() { return this.bn += 2, this.bn } static Pn() { return new Y_(0) } static vn() { return new Y_(-1) } } class dM { constructor(e, t) { this.referenceDelegate = e, this.yt = t } allocateTargetId(e) { return this.Vn(e).next(t => { const r = new Y_(t.highestTargetId); return t.highestTargetId = r.next(), this.Sn(e, t).next(() => t.highestTargetId) }) } getLastRemoteSnapshotVersion(e) { return this.Vn(e).next(t => Ar.fromTimestamp(new Vo(t.lastRemoteSnapshotVersion.seconds, t.lastRemoteSnapshotVersion.nanoseconds))) } getHighestSequenceNumber(e) { return this.Vn(e).next(t => t.highestListenSequenceNumber) } setTargetsMetadata(e, t, r) { return this.Vn(e).next(a => (a.highestListenSequenceNumber = t, r && (a.lastRemoteSnapshotVersion = r.toTimestamp()), t > a.highestListenSequenceNumber && (a.highestListenSequenceNumber = t), this.Sn(e, a))) } addTargetData(e, t) { return this.Dn(e, t).next(() => this.Vn(e).next(r => (r.targetCount += 1, this.Cn(t, r), this.Sn(e, r)))) } updateTargetData(e, t) { return this.Dn(e, t) } removeTargetData(e, t) { return this.removeMatchingKeysForTargetId(e, t.targetId).next(() => Vv(e).delete(t.targetId)).next(() => this.Vn(e)).next(r => (mr(r.targetCount > 0), r.targetCount -= 1, this.Sn(e, r))) } removeTargets(e, t, r) { let a = 0; const d = []; return Vv(e).Z((_, E) => { const x = vw(E); x.sequenceNumber <= t && null === r.get(x.targetId) && (a++, d.push(this.removeTargetData(e, x))) }).next(() => Qt.waitFor(d)).next(() => a) } forEachTarget(e, t) { return Vv(e).Z((r, a) => { const d = vw(a); t(d) }) } Vn(e) { return jI(e).get("targetGlobalKey").next(t => (mr(null !== t), t)) } Sn(e, t) { return jI(e).put("targetGlobalKey", t) } Dn(e, t) { return Vv(e).put(AI(this.yt, t)) } Cn(e, t) { let r = !1; return e.targetId > t.highestTargetId && (t.highestTargetId = e.targetId, r = !0), e.sequenceNumber > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = e.sequenceNumber, r = !0), r } getTargetCount(e) { return this.Vn(e).next(t => t.targetCount) } getTargetData(e, t) { const r = Qp(t), a = IDBKeyRange.bound([r, Number.NEGATIVE_INFINITY], [r, Number.POSITIVE_INFINITY]); let d = null; return Vv(e).Z({ range: a, index: "queryTargetsIndex" }, (_, E, x) => { const B = vw(E); om(t, B.target) && (d = B, x.done()) }).next(() => d) } addMatchingKeys(e, t, r) { const a = [], d = pm(e); return t.forEach(_ => { const E = od(_.path); a.push(d.put({ targetId: r, path: E })), a.push(this.referenceDelegate.addReference(e, r, _)) }), Qt.waitFor(a) } removeMatchingKeys(e, t, r) { const a = pm(e); return Qt.forEach(t, d => { const _ = od(d.path); return Qt.waitFor([a.delete([r, _]), this.referenceDelegate.removeReference(e, r, d)]) }) } removeMatchingKeysForTargetId(e, t) { const r = pm(e), a = IDBKeyRange.bound([t], [t + 1], !1, !0); return r.delete(a) } getMatchingKeysForTargetId(e, t) { const r = IDBKeyRange.bound([t], [t + 1], !1, !0), a = pm(e); let d = Ci(); return a.Z({ range: r, X: !0 }, (_, E, x) => { const B = ap(_[1]), K = new Gn(B); d = d.add(K) }).next(() => d) } containsKey(e, t) { const r = od(t.path), a = IDBKeyRange.bound([r], [jb(r)], !1, !0); let d = 0; return pm(e).Z({ index: "documentTargetsIndex", X: !0, range: a }, ([_, E], x, B) => { 0 !== _ && (d++, B.done()) }).next(() => d > 0) } ne(e, t) { return Vv(e).get(t).next(r => r ? vw(r) : null) } } function Vv(n) { return $c(n, "targets") } function jI(n) { return $c(n, "targetGlobal") } function pm(n) { return $c(n, "targetDocuments") } function $I([n, e], [t, r]) { const a = ai(n, t); return 0 === a ? ai(e, r) : a } class hM { constructor(e) { this.xn = e, this.buffer = new _o($I), this.Nn = 0 } kn() { return ++this.Nn } On(e) { const t = [e, this.kn()]; if (this.buffer.size < this.xn) this.buffer = this.buffer.add(t); else { const r = this.buffer.last(); $I(t, r) < 0 && (this.buffer = this.buffer.delete(r).add(t)) } } get maxValue() { return this.buffer.last()[0] } } class fM { constructor(e, t, r) { this.garbageCollector = e, this.asyncQueue = t, this.localStore = r, this.Mn = null } start() { -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Fn(6e4) } stop() { this.Mn && (this.Mn.cancel(), this.Mn = null) } get started() { return null !== this.Mn } Fn(e) { var t = this; Mn("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.Mn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, (0, cn.Z)(function* () { t.Mn = null; try { yield t.localStore.collectGarbage(t.garbageCollector) } catch (r) { sh(r) ? Mn("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", r) : yield wf(r) } yield t.Fn(3e5) })) } } class pM { constructor(e, t) { this.$n = e, this.params = t } calculateTargetCount(e, t) { return this.$n.Bn(e).next(r => Math.floor(t / 100 * r)) } nthSequenceNumber(e, t) { if (0 === t) return Qt.resolve(id.at); const r = new hM(t); return this.$n.forEachTarget(e, a => r.On(a.sequenceNumber)).next(() => this.$n.Ln(e, a => r.On(a))).next(() => r.maxValue) } removeTargets(e, t, r) { return this.$n.removeTargets(e, t, r) } removeOrphanedDocuments(e, t) { return this.$n.removeOrphanedDocuments(e, t) } collect(e, t) { return -1 === this.params.cacheSizeCollectionThreshold ? (Mn("LruGarbageCollector", "Garbage collection skipped; disabled"), Qt.resolve(UI)) : this.getCacheSize(e).next(r => r < this.params.cacheSizeCollectionThreshold ? (Mn("LruGarbageCollector", `Garbage collection skipped; Cache size ${r} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), UI) : this.qn(e, t)) } getCacheSize(e) { return this.$n.getCacheSize(e) } qn(e, t) { let r, a, d, _, E, x, B; const K = Date.now(); return this.calculateTargetCount(e, this.params.percentileToCollect).next(oe => (oe > this.params.maximumSequenceNumbersToCollect ? (Mn("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${oe}`), a = this.params.maximumSequenceNumbersToCollect) : a = oe, _ = Date.now(), this.nthSequenceNumber(e, a))).next(oe => (r = oe, E = Date.now(), this.removeTargets(e, r, t))).next(oe => (d = oe, x = Date.now(), this.removeOrphanedDocuments(e, r))).next(oe => (B = Date.now(), Fb() <= Jo.in.DEBUG && Mn("LruGarbageCollector", `LRU Garbage Collection\n\tCounted targets in ${_ - K}ms\n\tDetermined least recently used ${a} in ` + (E - _) + `ms\n\tRemoved ${d} targets in ` + (x - E) + `ms\n\tRemoved ${oe} documents in ` + (B - x) + `ms\nTotal Duration: ${B - K}ms`), Qt.resolve({ didRun: !0, sequenceNumbersCollected: a, targetsRemoved: d, documentsRemoved: oe }))) } } class gM { constructor(e, t) { this.db = e, this.garbageCollector = new pM(this, t) } Bn(e) { const t = this.Un(e); return this.db.getTargetCache().getTargetCount(e).next(r => t.next(a => r + a)) } Un(e) { let t = 0; return this.Ln(e, r => { t++ }).next(() => t) } forEachTarget(e, t) { return this.db.getTargetCache().forEachTarget(e, t) } Ln(e, t) { return this.Kn(e, (r, a) => t(a)) } addReference(e, t, r) { return fE(e, r) } removeReference(e, t, r) { return fE(e, r) } removeTargets(e, t, r) { return this.db.getTargetCache().removeTargets(e, t, r) } markPotentiallyOrphaned(e, t) { return fE(e, t) } Gn(e, t) { return function (r, a) { let d = !1; return GI(r).tt(_ => zI(r, _, a).next(E => (E && (d = !0), Qt.resolve(!E)))).next(() => d) }(e, t) } removeOrphanedDocuments(e, t) { const r = this.db.getRemoteDocumentCache().newChangeBuffer(), a = []; let d = 0; return this.Kn(e, (_, E) => { if (E <= t) { const x = this.Gn(e, _).next(B => { if (!B) return d++, r.getEntry(e, _).next(() => (r.removeEntry(_, Ar.min()), pm(e).delete([0, od(_.path)]))) }); a.push(x) } }).next(() => Qt.waitFor(a)).next(() => r.apply(e)).next(() => d) } removeTarget(e, t) { const r = t.withSequenceNumber(e.currentSequenceNumber); return this.db.getTargetCache().updateTargetData(e, r) } updateLimboDocument(e, t) { return fE(e, t) } Kn(e, t) { const r = pm(e); let a, d = id.at; return r.Z({ index: "documentTargetsIndex" }, ([_, E], { path: x, sequenceNumber: B }) => { 0 === _ ? (d !== id.at && t(new Gn(ap(a)), d), d = B, a = x) : d = id.at }).next(() => { d !== id.at && t(new Gn(ap(a)), d) }) } getCacheSize(e) { return this.db.getRemoteDocumentCache().getSize(e) } } function fE(n, e) { return pm(n).put((r = n.currentSequenceNumber, { targetId: 0, path: od(e.path), sequenceNumber: r })); var r } class WI { constructor() { this.changes = new sg(e => e.toString(), (e, t) => e.isEqual(t)), this.changesApplied = !1 } addEntry(e) { this.assertNotApplied(), this.changes.set(e.key, e) } removeEntry(e, t) { this.assertNotApplied(), this.changes.set(e, yo.newInvalidDocument(e).setReadTime(t)) } getEntry(e, t) { this.assertNotApplied(); const r = this.changes.get(t); return void 0 !== r ? Qt.resolve(r) : this.getFromCache(e, t) } getEntries(e, t) { return this.getAllFromCache(e, t) } apply(e) { return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e) } assertNotApplied() { } } class mM { constructor(e) { this.yt = e } setIndexManager(e) { this.indexManager = e } addEntry(e, t, r) { return K_(e).put(r) } removeEntry(e, t, r) { return K_(e).delete(function (a, d) { const _ = a.path.toArray(); return [_.slice(0, _.length - 2), _[_.length - 2], oE(d), _[_.length - 1]] }(t, r)) } updateMetadata(e, t) { return this.getMetadata(e).next(r => (r.byteSize += t, this.Qn(e, r))) } getEntry(e, t) { let r = yo.newInvalidDocument(t); return K_(e).Z({ index: "documentKeyIndex", range: IDBKeyRange.only(Tw(t)) }, (a, d) => { r = this.jn(t, d) }).next(() => r) } Wn(e, t) { let r = { size: 0, document: yo.newInvalidDocument(t) }; return K_(e).Z({ index: "documentKeyIndex", range: IDBKeyRange.only(Tw(t)) }, (a, d) => { r = { document: this.jn(t, d), size: dE(d) } }).next(() => r) } getEntries(e, t) { let r = Ru(); return this.zn(e, t, (a, d) => { const _ = this.jn(a, d); r = r.insert(a, _) }).next(() => r) } Hn(e, t) { let r = Ru(), a = new Na(Gn.comparator); return this.zn(e, t, (d, _) => { const E = this.jn(d, _); r = r.insert(d, E), a = a.insert(d, dE(_)) }).next(() => ({ documents: r, Jn: a })) } zn(e, t, r) { if (t.isEmpty()) return Qt.resolve(); let a = new _o(KI); t.forEach(x => a = a.add(x)); const d = IDBKeyRange.bound(Tw(a.first()), Tw(a.last())), _ = a.getIterator(); let E = _.getNext(); return K_(e).Z({ index: "documentKeyIndex", range: d }, (x, B, K) => { const oe = Gn.fromSegments([...B.prefixPath, B.collectionGroup, B.documentId]); for (; E && KI(E, oe) < 0;)r(E, null), E = _.getNext(); E && E.isEqual(oe) && (r(E, B), E = _.hasNext() ? _.getNext() : null), E ? K.j(Tw(E)) : K.done() }).next(() => { for (; E;)r(E, null), E = _.hasNext() ? _.getNext() : null }) } getAllFromCollection(e, t, r) { const a = [t.popLast().toArray(), t.lastSegment(), oE(r.readTime), r.documentKey.path.isEmpty() ? "" : r.documentKey.path.lastSegment()], d = [t.popLast().toArray(), t.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""]; return K_(e).W(IDBKeyRange.bound(a, d, !0)).next(_ => { let E = Ru(); for (const x of _) { const B = this.jn(Gn.fromSegments(x.prefixPath.concat(x.collectionGroup, x.documentId)), x); E = E.insert(B.key, B) } return E }) } getAllFromCollectionGroup(e, t, r, a) { let d = Ru(); const _ = YI(t, r), E = YI(t, _c.max()); return K_(e).Z({ index: "collectionGroupIndex", range: IDBKeyRange.bound(_, E, !0) }, (x, B, K) => { const oe = this.jn(Gn.fromSegments(B.prefixPath.concat(B.collectionGroup, B.documentId)), B); d = d.insert(oe.key, oe), d.size === a && K.done() }).next(() => d) } newChangeBuffer(e) { return new _M(this, !!e && e.trackRemovals) } getSize(e) { return this.getMetadata(e).next(t => t.byteSize) } getMetadata(e) { return qI(e).get("remoteDocumentGlobalKey").next(t => (mr(!!t), t)) } Qn(e, t) { return qI(e).put("remoteDocumentGlobalKey", t) } jn(e, t) { if (t) { const r = function tM(n, e) { let t; if (e.document) t = D(n.ie, e.document, !!e.hasCommittedMutations); else if (e.noDocument) { const r = Gn.fromSegments(e.noDocument.path), a = $_(e.noDocument.readTime); t = yo.newNoDocument(r, a), e.hasCommittedMutations && t.setHasCommittedMutations() } else { if (!e.unknownDocument) return rr(); { const r = Gn.fromSegments(e.unknownDocument.path), a = $_(e.unknownDocument.version); t = yo.newUnknownDocument(r, a) } } return e.readTime && t.setReadTime(function (r) { const a = new Vo(r[0], r[1]); return Ar.fromTimestamp(a) }(e.readTime)), t }(this.yt, t); if (!r.isNoDocument() || !r.version.isEqual(Ar.min())) return r } return yo.newInvalidDocument(e) } } function ZI(n) { return new mM(n) } class _M extends WI { constructor(e, t) { super(), this.Yn = e, this.trackRemovals = t, this.Xn = new sg(r => r.toString(), (r, a) => r.isEqual(a)) } applyChanges(e) { const t = []; let r = 0, a = new _o((d, _) => ai(d.canonicalString(), _.canonicalString())); return this.changes.forEach((d, _) => { const E = this.Xn.get(d); if (t.push(this.Yn.removeEntry(e, d, E.readTime)), _.isValidDocument()) { const x = II(this.Yn.yt, _); a = a.add(d.path.popLast()); const B = dE(x); r += B - E.size, t.push(this.Yn.addEntry(e, d, x)) } else if (r -= E.size, this.trackRemovals) { const x = II(this.Yn.yt, _.convertToNoDocument(Ar.min())); t.push(this.Yn.addEntry(e, d, x)) } }), a.forEach(d => { t.push(this.Yn.indexManager.addToCollectionParentIndex(e, d)) }), t.push(this.Yn.updateMetadata(e, r)), Qt.waitFor(t) } getFromCache(e, t) { return this.Yn.Wn(e, t).next(r => (this.Xn.set(t, { size: r.size, readTime: r.document.readTime }), r.document)) } getAllFromCache(e, t) { return this.Yn.Hn(e, t).next(({ documents: r, Jn: a }) => (a.forEach((d, _) => { this.Xn.set(d, { size: _, readTime: r.get(d).readTime }) }), r)) } } function qI(n) { return $c(n, "remoteDocumentGlobal") } function K_(n) { return $c(n, "remoteDocumentsV14") } function Tw(n) { const e = n.path.toArray(); return [e.slice(0, e.length - 2), e[e.length - 2], e[e.length - 1]] } function YI(n, e) { const t = e.documentKey.path.toArray(); return [n, oE(e.readTime), t.slice(0, t.length - 2), t.length > 0 ? t[t.length - 1] : ""] } function KI(n, e) { const t = n.path.toArray(), r = e.path.toArray(); let a = 0; for (let d = 0; d < t.length - 2 && d < r.length - 2; ++d)if (a = ai(t[d], r[d]), a) return a; return a = ai(t.length, r.length), a || (a = ai(t[t.length - 2], r[r.length - 2]), a || ai(t[t.length - 1], r[r.length - 1])) } class yM { constructor(e, t) { this.overlayedDocument = e, this.mutatedFields = t } } class JI { constructor(e, t, r, a) { this.remoteDocumentCache = e, this.mutationQueue = t, this.documentOverlayCache = r, this.indexManager = a } getDocument(e, t) { let r = null; return this.documentOverlayCache.getOverlay(e, t).next(a => (r = a, this.remoteDocumentCache.getEntry(e, t))).next(a => (null !== r && op(r.mutation, a, hu.empty(), Vo.now()), a)) } getDocuments(e, t) { return this.remoteDocumentCache.getEntries(e, t).next(r => this.getLocalViewOfDocuments(e, r, Ci()).next(() => r)) } getLocalViewOfDocuments(e, t, r = Ci()) { const a = uh(); return this.populateOverlays(e, a, t).next(() => this.computeViews(e, t, a, r).next(d => { let _ = H_(); return d.forEach((E, x) => { _ = _.insert(E, x.overlayedDocument) }), _ })) } getOverlayedDocuments(e, t) { const r = uh(); return this.populateOverlays(e, r, t).next(() => this.computeViews(e, t, r, Ci())) } populateOverlays(e, t, r) { const a = []; return r.forEach(d => { t.has(d) || a.push(d) }), this.documentOverlayCache.getOverlays(e, a).next(d => { d.forEach((_, E) => { t.set(_, E) }) }) } computeViews(e, t, r, a) { let d = Ru(); const _ = cm(), E = cm(); return t.forEach((x, B) => { const K = r.get(B.key); a.has(B.key) && (void 0 === K || K.mutation instanceof pu) ? d = d.insert(B.key, B) : void 0 !== K && (_.set(B.key, K.mutation.getFieldMask()), op(K.mutation, B, K.mutation.getFieldMask(), Vo.now())) }), this.recalculateAndSaveOverlays(e, d).next(x => (x.forEach((B, K) => _.set(B, K)), t.forEach((B, K) => { var oe; return E.set(B, new yM(K, null !== (oe = _.get(B)) && void 0 !== oe ? oe : null)) }), E)) } recalculateAndSaveOverlays(e, t) { const r = cm(); let a = new Na((_, E) => _ - E), d = Ci(); return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next(_ => { for (const E of _) E.keys().forEach(x => { const B = t.get(x); if (null === B) return; let K = r.get(x) || hu.empty(); K = E.applyToLocalView(B, K), r.set(x, K); const oe = (a.get(E.batchId) || Ci()).add(x); a = a.insert(E.batchId, oe) }) }).next(() => { const _ = [], E = a.getReverseIterator(); for (; E.hasNext();) { const x = E.getNext(), B = x.key, K = x.value, oe = mw(); K.forEach(Me => { if (!d.has(Me)) { const ot = WT(t.get(Me), r.get(Me)); null !== ot && oe.set(Me, ot), d = d.add(Me) } }), _.push(this.documentOverlayCache.saveOverlays(e, B, oe)) } return Qt.waitFor(_) }).next(() => r) } recalculateAndSaveOverlaysForDocumentKeys(e, t) { return this.remoteDocumentCache.getEntries(e, t).next(r => this.recalculateAndSaveOverlays(e, r)) } getDocumentsMatchingQuery(e, t, r) { return Gn.isDocumentKey((a = t).path) && null === a.collectionGroup && 0 === a.filters.length ? this.getDocumentsMatchingDocumentQuery(e, t.path) : WC(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, r) : this.getDocumentsMatchingCollectionQuery(e, t, r); var a } getNextDocuments(e, t, r, a) { return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, r, a).next(d => { const _ = a - d.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, r.largestBatchId, a - d.size) : Qt.resolve(uh()); let E = -1, x = d; return _.next(B => Qt.forEach(B, (K, oe) => (E < oe.largestBatchId && (E = oe.largestBatchId), d.get(K) ? Qt.resolve() : this.remoteDocumentCache.getEntry(e, K).next(Me => { x = x.insert(K, Me) }))).next(() => this.populateOverlays(e, B, d)).next(() => this.computeViews(e, x, B, Ci())).next(K => ({ batchId: E, changes: XC(K) }))) }) } getDocumentsMatchingDocumentQuery(e, t) { return this.getDocument(e, new Gn(t)).next(r => { let a = H_(); return r.isFoundDocument() && (a = a.insert(r.key, r)), a }) } getDocumentsMatchingCollectionGroupQuery(e, t, r) { const a = t.collectionGroup; let d = H_(); return this.indexManager.getCollectionParents(e, a).next(_ => Qt.forEach(_, E => { const x = (B = t, K = E.child(a), new lh(K, null, B.explicitOrderBy.slice(), B.filters.slice(), B.limit, B.limitType, B.startAt, B.endAt)); var B, K; return this.getDocumentsMatchingCollectionQuery(e, x, r).next(B => { B.forEach((K, oe) => { d = d.insert(K, oe) }) }) }).next(() => d)) } getDocumentsMatchingCollectionQuery(e, t, r) { let a; return this.remoteDocumentCache.getAllFromCollection(e, t.path, r).next(d => (a = d, this.documentOverlayCache.getOverlaysForCollection(e, t.path, r.largestBatchId))).next(d => { d.forEach((E, x) => { const B = x.getKey(); null === a.get(B) && (a = a.insert(B, yo.newInvalidDocument(B))) }); let _ = H_(); return a.forEach((E, x) => { const B = d.get(E); void 0 !== B && op(B.mutation, x, hu.empty(), Vo.now()), sw(t, x) && (_ = _.insert(E, x)) }), _ }) } } class vM { constructor(e) { this.yt = e, this.Zn = new Map, this.ts = new Map } getBundleMetadata(e, t) { return Qt.resolve(this.Zn.get(t)) } saveBundleMetadata(e, t) { var r; return this.Zn.set(t.id, { id: (r = t).id, version: r.version, createTime: ol(r.createTime) }), Qt.resolve() } getNamedQuery(e, t) { return Qt.resolve(this.ts.get(t)) } saveNamedQuery(e, t) { return this.ts.set(t.name, { name: (r = t).name, query: lD(r.bundledQuery), readTime: ol(r.readTime) }), Qt.resolve(); var r } } class bM { constructor() { this.overlays = new Na(Gn.comparator), this.es = new Map } getOverlay(e, t) { return Qt.resolve(this.overlays.get(t)) } getOverlays(e, t) { const r = uh(); return Qt.forEach(t, a => this.getOverlay(e, a).next(d => { null !== d && r.set(a, d) })).next(() => r) } saveOverlays(e, t, r) { return r.forEach((a, d) => { this.oe(e, t, d) }), Qt.resolve() } removeOverlaysForBatchId(e, t, r) { const a = this.es.get(r); return void 0 !== a && (a.forEach(d => this.overlays = this.overlays.remove(d)), this.es.delete(r)), Qt.resolve() } getOverlaysForCollection(e, t, r) { const a = uh(), d = t.length + 1, _ = new Gn(t.child("")), E = this.overlays.getIteratorFrom(_); for (; E.hasNext();) { const x = E.getNext().value, B = x.getKey(); if (!t.isPrefixOf(B.path)) break; B.path.length === d && x.largestBatchId > r && a.set(x.getKey(), x) } return Qt.resolve(a) } getOverlaysForCollectionGroup(e, t, r, a) { let d = new Na((B, K) => B - K); const _ = this.overlays.getIterator(); for (; _.hasNext();) { const B = _.getNext().value; if (B.getKey().getCollectionGroup() === t && B.largestBatchId > r) { let K = d.get(B.largestBatchId); null === K && (K = uh(), d = d.insert(B.largestBatchId, K)), K.set(B.getKey(), B) } } const E = uh(), x = d.getIterator(); for (; x.hasNext() && (x.getNext().value.forEach((B, K) => E.set(B, K)), !(E.size() >= a));); return Qt.resolve(E) } oe(e, t, r) { const a = this.overlays.get(r.key); if (null !== a) { const _ = this.es.get(a.largestBatchId).delete(r.key); this.es.set(a.largestBatchId, _) } this.overlays = this.overlays.insert(r.key, new aD(t, r)); let d = this.es.get(t); void 0 === d && (d = Ci(), this.es.set(t, d)), this.es.set(t, d.add(r.key)) } } class gD { constructor() { this.ns = new _o(Wc.ss), this.rs = new _o(Wc.os) } isEmpty() { return this.ns.isEmpty() } addReference(e, t) { const r = new Wc(e, t); this.ns = this.ns.add(r), this.rs = this.rs.add(r) } us(e, t) { e.forEach(r => this.addReference(r, t)) } removeReference(e, t) { this.cs(new Wc(e, t)) } hs(e, t) { e.forEach(r => this.removeReference(r, t)) } ls(e) { const t = new Gn(new is([])), r = new Wc(t, e), a = new Wc(t, e + 1), d = []; return this.rs.forEachInRange([r, a], _ => { this.cs(_), d.push(_.key) }), d } fs() { this.ns.forEach(e => this.cs(e)) } cs(e) { this.ns = this.ns.delete(e), this.rs = this.rs.delete(e) } ds(e) { const t = new Gn(new is([])), r = new Wc(t, e), a = new Wc(t, e + 1); let d = Ci(); return this.rs.forEachInRange([r, a], _ => { d = d.add(_.key) }), d } containsKey(e) { const t = new Wc(e, 0), r = this.ns.firstAfterOrEqual(t); return null !== r && e.isEqual(r.key) } } class Wc { constructor(e, t) { this.key = e, this._s = t } static ss(e, t) { return Gn.comparator(e.key, t.key) || ai(e._s, t._s) } static os(e, t) { return ai(e._s, t._s) || Gn.comparator(e.key, t.key) } } class wM { constructor(e, t) { this.indexManager = e, this.referenceDelegate = t, this.mutationQueue = [], this.ws = 1, this.gs = new _o(Wc.ss) } checkEmpty(e) { return Qt.resolve(0 === this.mutationQueue.length) } addMutationBatch(e, t, r, a) { const d = this.ws; this.ws++; const _ = new sD(d, t, r, a); this.mutationQueue.push(_); for (const E of a) this.gs = this.gs.add(new Wc(E.key, d)), this.indexManager.addToCollectionParentIndex(e, E.key.path.popLast()); return Qt.resolve(_) } lookupMutationBatch(e, t) { return Qt.resolve(this.ys(t)) } getNextMutationBatchAfterBatchId(e, t) { const a = this.ps(t + 1), d = a < 0 ? 0 : a; return Qt.resolve(this.mutationQueue.length > d ? this.mutationQueue[d] : null) } getHighestUnacknowledgedBatchId() { return Qt.resolve(0 === this.mutationQueue.length ? -1 : this.ws - 1) } getAllMutationBatches(e) { return Qt.resolve(this.mutationQueue.slice()) } getAllMutationBatchesAffectingDocumentKey(e, t) { const r = new Wc(t, 0), a = new Wc(t, Number.POSITIVE_INFINITY), d = []; return this.gs.forEachInRange([r, a], _ => { const E = this.ys(_._s); d.push(E) }), Qt.resolve(d) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let r = new _o(ai); return t.forEach(a => { const d = new Wc(a, 0), _ = new Wc(a, Number.POSITIVE_INFINITY); this.gs.forEachInRange([d, _], E => { r = r.add(E._s) }) }), Qt.resolve(this.Is(r)) } getAllMutationBatchesAffectingQuery(e, t) { const r = t.path, a = r.length + 1; let d = r; Gn.isDocumentKey(d) || (d = d.child("")); const _ = new Wc(new Gn(d), 0); let E = new _o(ai); return this.gs.forEachWhile(x => { const B = x.key.path; return !!r.isPrefixOf(B) && (B.length === a && (E = E.add(x._s)), !0) }, _), Qt.resolve(this.Is(E)) } Is(e) { const t = []; return e.forEach(r => { const a = this.ys(r); null !== a && t.push(a) }), t } removeMutationBatch(e, t) { mr(0 === this.Ts(t.batchId, "removed")), this.mutationQueue.shift(); let r = this.gs; return Qt.forEach(t.mutations, a => { const d = new Wc(a.key, t.batchId); return r = r.delete(d), this.referenceDelegate.markPotentiallyOrphaned(e, a.key) }).next(() => { this.gs = r }) } An(e) { } containsKey(e, t) { const r = new Wc(t, 0), a = this.gs.firstAfterOrEqual(r); return Qt.resolve(t.isEqual(a && a.key)) } performConsistencyCheck(e) { return Qt.resolve() } Ts(e, t) { return this.ps(e) } ps(e) { return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId } ys(e) { const t = this.ps(e); return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t] } } class CM { constructor(e) { this.Es = e, this.docs = new Na(Gn.comparator), this.size = 0 } setIndexManager(e) { this.indexManager = e } addEntry(e, t) { const r = t.key, a = this.docs.get(r), d = a ? a.size : 0, _ = this.Es(t); return this.docs = this.docs.insert(r, { document: t.mutableCopy(), size: _ }), this.size += _ - d, this.indexManager.addToCollectionParentIndex(e, r.path.popLast()) } removeEntry(e) { const t = this.docs.get(e); t && (this.docs = this.docs.remove(e), this.size -= t.size) } getEntry(e, t) { const r = this.docs.get(t); return Qt.resolve(r ? r.document.mutableCopy() : yo.newInvalidDocument(t)) } getEntries(e, t) { let r = Ru(); return t.forEach(a => { const d = this.docs.get(a); r = r.insert(a, d ? d.document.mutableCopy() : yo.newInvalidDocument(a)) }), Qt.resolve(r) } getAllFromCollection(e, t, r) { let a = Ru(); const d = new Gn(t.child("")), _ = this.docs.getIteratorFrom(d); for (; _.hasNext();) { const { key: E, value: { document: x } } = _.getNext(); if (!t.isPrefixOf(E.path)) break; E.path.length > t.length + 1 || Zb(Wb(x), r) <= 0 || (a = a.insert(x.key, x.mutableCopy())) } return Qt.resolve(a) } getAllFromCollectionGroup(e, t, r, a) { rr() } As(e, t) { return Qt.forEach(this.docs, r => t(r)) } newChangeBuffer(e) { return new EM(this) } getSize(e) { return Qt.resolve(this.size) } } class EM extends WI { constructor(e) { super(), this.Yn = e } applyChanges(e) { const t = []; return this.changes.forEach((r, a) => { a.isValidDocument() ? t.push(this.Yn.addEntry(e, a)) : this.Yn.removeEntry(r) }), Qt.waitFor(t) } getFromCache(e, t) { return this.Yn.getEntry(e, t) } getAllFromCache(e, t) { return this.Yn.getEntries(e, t) } } class TM { constructor(e) { this.persistence = e, this.Rs = new sg(t => Qp(t), om), this.lastRemoteSnapshotVersion = Ar.min(), this.highestTargetId = 0, this.bs = 0, this.Ps = new gD, this.targetCount = 0, this.vs = Y_.Pn() } forEachTarget(e, t) { return this.Rs.forEach((r, a) => t(a)), Qt.resolve() } getLastRemoteSnapshotVersion(e) { return Qt.resolve(this.lastRemoteSnapshotVersion) } getHighestSequenceNumber(e) { return Qt.resolve(this.bs) } allocateTargetId(e) { return this.highestTargetId = this.vs.next(), Qt.resolve(this.highestTargetId) } setTargetsMetadata(e, t, r) { return r && (this.lastRemoteSnapshotVersion = r), t > this.bs && (this.bs = t), Qt.resolve() } Dn(e) { this.Rs.set(e.target, e); const t = e.targetId; t > this.highestTargetId && (this.vs = new Y_(t), this.highestTargetId = t), e.sequenceNumber > this.bs && (this.bs = e.sequenceNumber) } addTargetData(e, t) { return this.Dn(t), this.targetCount += 1, Qt.resolve() } updateTargetData(e, t) { return this.Dn(t), Qt.resolve() } removeTargetData(e, t) { return this.Rs.delete(t.target), this.Ps.ls(t.targetId), this.targetCount -= 1, Qt.resolve() } removeTargets(e, t, r) { let a = 0; const d = []; return this.Rs.forEach((_, E) => { E.sequenceNumber <= t && null === r.get(E.targetId) && (this.Rs.delete(_), d.push(this.removeMatchingKeysForTargetId(e, E.targetId)), a++) }), Qt.waitFor(d).next(() => a) } getTargetCount(e) { return Qt.resolve(this.targetCount) } getTargetData(e, t) { const r = this.Rs.get(t) || null; return Qt.resolve(r) } addMatchingKeys(e, t, r) { return this.Ps.us(t, r), Qt.resolve() } removeMatchingKeys(e, t, r) { this.Ps.hs(t, r); const a = this.persistence.referenceDelegate, d = []; return a && t.forEach(_ => { d.push(a.markPotentiallyOrphaned(e, _)) }), Qt.waitFor(d) } removeMatchingKeysForTargetId(e, t) { return this.Ps.ls(t), Qt.resolve() } getMatchingKeysForTargetId(e, t) { const r = this.Ps.ds(t); return Qt.resolve(r) } containsKey(e, t) { return Qt.resolve(this.Ps.containsKey(t)) } } class QI { constructor(e, t) { this.Vs = {}, this.overlays = {}, this.Ss = new id(0), this.Ds = !1, this.Ds = !0, this.referenceDelegate = e(this), this.Cs = new TM(this), this.indexManager = new cM, this.remoteDocumentCache = new CM(r => this.referenceDelegate.xs(r)), this.yt = new SI(t), this.Ns = new vM(this.yt) } start() { return Promise.resolve() } shutdown() { return this.Ds = !1, Promise.resolve() } get started() { return this.Ds } setDatabaseDeletedListener() { } setNetworkEnabled() { } getIndexManager(e) { return this.indexManager } getDocumentOverlayCache(e) { let t = this.overlays[e.toKey()]; return t || (t = new bM, this.overlays[e.toKey()] = t), t } getMutationQueue(e, t) { let r = this.Vs[e.toKey()]; return r || (r = new wM(t, this.referenceDelegate), this.Vs[e.toKey()] = r), r } getTargetCache() { return this.Cs } getRemoteDocumentCache() { return this.remoteDocumentCache } getBundleCache() { return this.Ns } runTransaction(e, t, r) { Mn("MemoryPersistence", "Starting transaction:", e); const a = new DM(this.Ss.next()); return this.referenceDelegate.ks(), r(a).next(d => this.referenceDelegate.Os(a).next(() => d)).toPromise().then(d => (a.raiseOnCommittedEvent(), d)) } Ms(e, t) { return Qt.or(Object.values(this.Vs).map(r => () => r.containsKey(e, t))) } } class DM extends SC { constructor(e) { super(), this.currentSequenceNumber = e } } class pE { constructor(e) { this.persistence = e, this.Fs = new gD, this.$s = null } static Bs(e) { return new pE(e) } get Ls() { if (this.$s) return this.$s; throw rr() } addReference(e, t, r) { return this.Fs.addReference(r, t), this.Ls.delete(r.toString()), Qt.resolve() } removeReference(e, t, r) { return this.Fs.removeReference(r, t), this.Ls.add(r.toString()), Qt.resolve() } markPotentiallyOrphaned(e, t) { return this.Ls.add(t.toString()), Qt.resolve() } removeTarget(e, t) { this.Fs.ls(t.targetId).forEach(a => this.Ls.add(a.toString())); const r = this.persistence.getTargetCache(); return r.getMatchingKeysForTargetId(e, t.targetId).next(a => { a.forEach(d => this.Ls.add(d.toString())) }).next(() => r.removeTargetData(e, t)) } ks() { this.$s = new Set } Os(e) { const t = this.persistence.getRemoteDocumentCache().newChangeBuffer(); return Qt.forEach(this.Ls, r => { const a = Gn.fromPath(r); return this.qs(e, a).next(d => { d || t.removeEntry(a, Ar.min()) }) }).next(() => (this.$s = null, t.apply(e))) } updateLimboDocument(e, t) { return this.qs(e, t).next(r => { r ? this.Ls.delete(t.toString()) : this.Ls.add(t.toString()) }) } xs(e) { return 0 } qs(e, t) { return Qt.or([() => Qt.resolve(this.Fs.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Ms(e, t)]) } } class SM { constructor(e) { this.yt = e } $(e, t, r, a) { const d = new Tv("createOrUpgrade", t); var E; r < 1 && a >= 1 && (e.createObjectStore("owner"), (E = e).createObjectStore("mutationQueues", { keyPath: "userId" }), E.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", wI, { unique: !0 }), E.createObjectStore("documentMutations"), XI(e), function (E) { E.createObjectStore("remoteDocuments") }(e)); let _ = Qt.resolve(); return r < 3 && a >= 3 && (0 !== r && (function (E) { E.deleteObjectStore("targetDocuments"), E.deleteObjectStore("targets"), E.deleteObjectStore("targetGlobal") }(e), XI(e)), _ = _.next(() => function (E) { const x = E.store("targetGlobal"), B = { highestTargetId: 0, highestListenSequenceNumber: 0, lastRemoteSnapshotVersion: Ar.min().toTimestamp(), targetCount: 0 }; return x.put("targetGlobalKey", B) }(d))), r < 4 && a >= 4 && (0 !== r && (_ = _.next(() => function (E, x) { return x.store("mutations").W().next(B => { E.deleteObjectStore("mutations"), E.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", wI, { unique: !0 }); const K = x.store("mutations"), oe = B.map(Me => K.put(Me)); return Qt.waitFor(oe) }) }(e, d))), _ = _.next(() => { !function (E) { E.createObjectStore("clientMetadata", { keyPath: "clientId" }) }(e) })), r < 5 && a >= 5 && (_ = _.next(() => this.Us(d))), r < 6 && a >= 6 && (_ = _.next(() => (function (E) { E.createObjectStore("remoteDocumentGlobal") }(e), this.Ks(d)))), r < 7 && a >= 7 && (_ = _.next(() => this.Gs(d))), r < 8 && a >= 8 && (_ = _.next(() => this.Qs(e, d))), r < 9 && a >= 9 && (_ = _.next(() => { !function (E) { E.objectStoreNames.contains("remoteDocumentChanges") && E.deleteObjectStore("remoteDocumentChanges") }(e) })), r < 10 && a >= 10 && (_ = _.next(() => this.js(d))), r < 11 && a >= 11 && (_ = _.next(() => { (function (E) { E.createObjectStore("bundles", { keyPath: "bundleId" }) })(e), function (E) { E.createObjectStore("namedQueries", { keyPath: "name" }) }(e) })), r < 12 && a >= 12 && (_ = _.next(() => { !function (E) { const x = E.createObjectStore("documentOverlays", { keyPath: Kx }); x.createIndex("collectionPathOverlayIndex", Jx, { unique: !1 }), x.createIndex("collectionGroupOverlayIndex", Qx, { unique: !1 }) }(e) })), r < 13 && a >= 13 && (_ = _.next(() => function (E) { const x = E.createObjectStore("remoteDocumentsV14", { keyPath: Vx }); x.createIndex("documentKeyIndex", Ux), x.createIndex("collectionGroupIndex", Hx) }(e)).next(() => this.Ws(e, d)).next(() => e.deleteObjectStore("remoteDocuments"))), r < 14 && a >= 14 && (_ = _.next(() => this.zs(e, d))), r < 15 && a >= 15 && (_ = _.next(() => function (E) { E.createObjectStore("indexConfiguration", { keyPath: "indexId", autoIncrement: !0 }).createIndex("collectionGroupIndex", "collectionGroup", { unique: !1 }), E.createObjectStore("indexState", { keyPath: Wx }).createIndex("sequenceNumberIndex", Zx, { unique: !1 }), E.createObjectStore("indexEntries", { keyPath: qx }).createIndex("documentKeyIndex", Yx, { unique: !1 }) }(e))), _ } Ks(e) { let t = 0; return e.store("remoteDocuments").Z((r, a) => { t += dE(a) }).next(() => { const r = { byteSize: t }; return e.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", r) }) } Us(e) { const t = e.store("mutationQueues"), r = e.store("mutations"); return t.W().next(a => Qt.forEach(a, d => { const _ = IDBKeyRange.bound([d.userId, -1], [d.userId, d.lastAcknowledgedBatchId]); return r.W("userMutationsIndex", _).next(E => Qt.forEach(E, x => { mr(x.userId === d.userId); const B = W_(this.yt, x); return HI(e, d.userId, B).next(() => { }) })) })) } Gs(e) { const t = e.store("targetDocuments"), r = e.store("remoteDocuments"); return e.store("targetGlobal").get("targetGlobalKey").next(a => { const d = []; return r.Z((_, E) => { const x = new is(_), B = [0, od(x)]; d.push(t.get(B).next(K => K ? Qt.resolve() : t.put({ targetId: 0, path: od(x), sequenceNumber: a.highestListenSequenceNumber }))) }).next(() => Qt.waitFor(d)) }) } Qs(e, t) { e.createObjectStore("collectionParents", { keyPath: $x }); const r = t.store("collectionParents"), a = new pD, d = _ => { if (a.add(_)) { const E = _.lastSegment(), x = _.popLast(); return r.put({ collectionId: E, parent: od(x) }) } }; return t.store("remoteDocuments").Z({ X: !0 }, (_, E) => { const x = new is(_); return d(x.popLast()) }).next(() => t.store("documentMutations").Z({ X: !0 }, ([_, E, x], B) => { const K = ap(E); return d(K.popLast()) })) } js(e) { const t = e.store("targets"); return t.Z((r, a) => { const d = vw(a), _ = AI(this.yt, d); return t.put(_) }) } Ws(e, t) { const r = t.store("remoteDocuments"), a = []; return r.Z((d, _) => { const E = t.store("remoteDocumentsV14"), x = (B = _, B.document ? new Gn(is.fromString(B.document.name).popFirst(5)) : B.noDocument ? Gn.fromSegments(B.noDocument.path) : B.unknownDocument ? Gn.fromSegments(B.unknownDocument.path) : rr()).path.toArray(); var B; const K = { prefixPath: x.slice(0, x.length - 2), collectionGroup: x[x.length - 2], documentId: x[x.length - 1], readTime: _.readTime || [0, 0], unknownDocument: _.unknownDocument, noDocument: _.noDocument, document: _.document, hasCommittedMutations: !!_.hasCommittedMutations }; a.push(E.put(K)) }).next(() => Qt.waitFor(a)) } zs(e, t) { const r = t.store("mutations"), a = ZI(this.yt), d = new QI(pE.Bs, this.yt.ie); return r.W().next(_ => { const E = new Map; return _.forEach(x => { var B; let K = null !== (B = E.get(x.userId)) && void 0 !== B ? B : Ci(); W_(this.yt, x).keys().forEach(oe => K = K.add(oe)), E.set(x.userId, K) }), Qt.forEach(E, (x, B) => { const K = new $l(B), oe = aE.re(this.yt, K), Me = d.getIndexManager(K), ot = hE.re(K, this.yt, Me, d.referenceDelegate); return new JI(a, ot, oe, Me).recalculateAndSaveOverlaysForDocumentKeys(new iD(t, id.at), x).next() }) }) } } function XI(n) { n.createObjectStore("targetDocuments", { keyPath: Gx }).createIndex("documentTargetsIndex", jx, { unique: !0 }), n.createObjectStore("targets", { keyPath: "targetId" }).createIndex("queryTargetsIndex", zx, { unique: !0 }), n.createObjectStore("targetGlobal") } const mD = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time."; class _D { constructor(e, t, r, a, d, _, E, x, B, K, oe = 15) { if (this.allowTabSynchronization = e, this.persistenceKey = t, this.clientId = r, this.Hs = d, this.window = _, this.document = E, this.Js = B, this.Ys = K, this.Xs = oe, this.Ss = null, this.Ds = !1, this.isPrimary = !1, this.networkEnabled = !0, this.Zs = null, this.inForeground = !1, this.ti = null, this.ei = null, this.ni = Number.NEGATIVE_INFINITY, this.si = Me => Promise.resolve(), !_D.C()) throw new Cn(en.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled."); this.referenceDelegate = new gM(this, a), this.ii = t + "main", this.yt = new SI(x), this.ri = new rd(this.ii, this.Xs, new SM(this.yt)), this.Cs = new dM(this.referenceDelegate, this.yt), this.remoteDocumentCache = ZI(this.yt), this.Ns = new nM, this.window && this.window.localStorage ? this.oi = this.window.localStorage : (this.oi = null, !1 === K && Ga("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.")) } start() { return this.ui().then(() => { if (!this.isPrimary && !this.allowTabSynchronization) throw new Cn(en.FAILED_PRECONDITION, mD); return this.ci(), this.ai(), this.hi(), this.runTransaction("getHighestListenSequenceNumber", "readonly", e => this.Cs.getHighestSequenceNumber(e)) }).then(e => { this.Ss = new id(e, this.Js) }).then(() => { this.Ds = !0 }).catch(e => (this.ri && this.ri.close(), Promise.reject(e))) } li(e) { var t = this; return this.si = function () { var r = (0, cn.Z)(function* (a) { if (t.started) return e(a) }); return function (a) { return r.apply(this, arguments) } }(), e(this.isPrimary) } setDatabaseDeletedListener(e) { this.ri.L(function () { var t = (0, cn.Z)(function* (r) { null === r.newVersion && (yield e()) }); return function (r) { return t.apply(this, arguments) } }()) } setNetworkEnabled(e) { var t = this; this.networkEnabled !== e && (this.networkEnabled = e, this.Hs.enqueueAndForget((0, cn.Z)(function* () { t.started && (yield t.ui()) }))) } ui() { return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", e => gE(e).put({ clientId: this.clientId, updateTimeMs: Date.now(), networkEnabled: this.networkEnabled, inForeground: this.inForeground }).next(() => { if (this.isPrimary) return this.fi(e).next(t => { t || (this.isPrimary = !1, this.Hs.enqueueRetryable(() => this.si(!1))) }) }).next(() => this.di(e)).next(t => this.isPrimary && !t ? this._i(e).next(() => !1) : !!t && this.wi(e).next(() => !0))).catch(e => { if (sh(e)) return Mn("IndexedDbPersistence", "Failed to extend owner lease: ", e), this.isPrimary; if (!this.allowTabSynchronization) throw e; return Mn("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e), !1 }).then(e => { this.isPrimary !== e && this.Hs.enqueueRetryable(() => this.si(e)), this.isPrimary = e }) } fi(e) { return Dw(e).get("owner").next(t => Qt.resolve(this.mi(t))) } gi(e) { return gE(e).delete(this.clientId) } yi() { var e = this; return (0, cn.Z)(function* () { if (e.isPrimary && !e.pi(e.ni, 18e5)) { e.ni = Date.now(); const t = yield e.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", r => { const a = $c(r, "clientMetadata"); return a.W().next(d => { const _ = e.Ii(d, 18e5), E = d.filter(x => -1 === _.indexOf(x)); return Qt.forEach(E, x => a.delete(x.clientId)).next(() => E) }) }).catch(() => []); if (e.oi) for (const r of t) e.oi.removeItem(e.Ti(r.clientId)) } })() } hi() { this.ei = this.Hs.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.ui().then(() => this.yi()).then(() => this.hi())) } mi(e) { return !!e && e.ownerId === this.clientId } di(e) { return this.Ys ? Qt.resolve(!0) : Dw(e).get("owner").next(t => { if (null !== t && this.pi(t.leaseTimestampMs, 5e3) && !this.Ei(t.ownerId)) { if (this.mi(t) && this.networkEnabled) return !0; if (!this.mi(t)) { if (!t.allowTabSynchronization) throw new Cn(en.FAILED_PRECONDITION, mD); return !1 } } return !(!this.networkEnabled || !this.inForeground) || gE(e).W().next(r => void 0 === this.Ii(r, 5e3).find(a => !(this.clientId === a.clientId || !(!this.networkEnabled && a.networkEnabled || !this.inForeground && a.inForeground && this.networkEnabled === a.networkEnabled)))) }).next(t => (this.isPrimary !== t && Mn("IndexedDbPersistence", `Client ${t ? "is" : "is not"} eligible for a primary lease.`), t)) } shutdown() { var e = this; return (0, cn.Z)(function* () { e.Ds = !1, e.Ai(), e.ei && (e.ei.cancel(), e.ei = null), e.Ri(), e.bi(), yield e.ri.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], t => { const r = new iD(t, id.at); return e._i(r).next(() => e.gi(r)) }), e.ri.close(), e.Pi() })() } Ii(e, t) { return e.filter(r => this.pi(r.updateTimeMs, t) && !this.Ei(r.clientId)) } vi() { return this.runTransaction("getActiveClients", "readonly", e => gE(e).W().next(t => this.Ii(t, 18e5).map(r => r.clientId))) } get started() { return this.Ds } getMutationQueue(e, t) { return hE.re(e, this.yt, t, this.referenceDelegate) } getTargetCache() { return this.Cs } getRemoteDocumentCache() { return this.remoteDocumentCache } getIndexManager(e) { return new uM(e, this.yt.ie.databaseId) } getDocumentOverlayCache(e) { return aE.re(this.yt, e) } getBundleCache() { return this.Ns } runTransaction(e, t, r) { Mn("IndexedDbPersistence", "Starting transaction:", e); const a = "readonly" === t ? "readonly" : "readwrite", d = 15 === (_ = this.Xs) ? eM : 14 === _ ? DI : 13 === _ ? TI : 12 === _ ? Xx : 11 === _ ? EI : void rr(); var _; let E; return this.ri.runTransaction(e, a, d, x => (E = new iD(x, this.Ss ? this.Ss.next() : id.at), "readwrite-primary" === t ? this.fi(E).next(B => !!B || this.di(E)).next(B => { if (!B) throw Ga(`Failed to obtain primary lease for action '${e}'.`), this.isPrimary = !1, this.Hs.enqueueRetryable(() => this.si(!1)), new Cn(en.FAILED_PRECONDITION, Ev); return r(E) }).next(B => this.wi(E).next(() => B)) : this.Vi(E).next(() => r(E)))).then(x => (E.raiseOnCommittedEvent(), x)) } Vi(e) { return Dw(e).get("owner").next(t => { if (null !== t && this.pi(t.leaseTimestampMs, 5e3) && !this.Ei(t.ownerId) && !this.mi(t) && !(this.Ys || this.allowTabSynchronization && t.allowTabSynchronization)) throw new Cn(en.FAILED_PRECONDITION, mD) }) } wi(e) { const t = { ownerId: this.clientId, allowTabSynchronization: this.allowTabSynchronization, leaseTimestampMs: Date.now() }; return Dw(e).put("owner", t) } static C() { return rd.C() } _i(e) { const t = Dw(e); return t.get("owner").next(r => this.mi(r) ? (Mn("IndexedDbPersistence", "Releasing primary lease."), t.delete("owner")) : Qt.resolve()) } pi(e, t) { const r = Date.now(); return !(e < r - t || e > r && (Ga(`Detected an update time that is in the future: ${e} > ${r}`), 1)) } ci() { null !== this.document && "function" == typeof this.document.addEventListener && (this.ti = () => { this.Hs.enqueueAndForget(() => (this.inForeground = "visible" === this.document.visibilityState, this.ui())) }, this.document.addEventListener("visibilitychange", this.ti), this.inForeground = "visible" === this.document.visibilityState) } Ri() { this.ti && (this.document.removeEventListener("visibilitychange", this.ti), this.ti = null) } ai() { var e; "function" == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) && (this.Zs = () => { this.Ai(), (0, Pe.G6)() && navigator.appVersion.match(/Version\/1[45]/) && this.Hs.enterRestrictedMode(!0), this.Hs.enqueueAndForget(() => this.shutdown()) }, this.window.addEventListener("pagehide", this.Zs)) } bi() { this.Zs && (this.window.removeEventListener("pagehide", this.Zs), this.Zs = null) } Ei(e) { var t; try { const r = null !== (null === (t = this.oi) || void 0 === t ? void 0 : t.getItem(this.Ti(e))); return Mn("IndexedDbPersistence", `Client '${e}' ${r ? "is" : "is not"} zombied in LocalStorage`), r } catch (r) { return Ga("IndexedDbPersistence", "Failed to get zombied client id.", r), !1 } } Ai() { if (this.oi) try { this.oi.setItem(this.Ti(this.clientId), String(Date.now())) } catch (e) { Ga("Failed to set zombie client id.", e) } } Pi() { if (this.oi) try { this.oi.removeItem(this.Ti(this.clientId)) } catch { } } Ti(e) { return `firestore_zombie_${this.persistenceKey}_${e}` } } function Dw(n) { return $c(n, "owner") } function gE(n) { return $c(n, "clientMetadata") } function yD(n, e) { let t = n.projectId; return n.isDefaultDatabase || (t += "." + n.database), "firestore/" + e + "/" + t + "/" } class vD { constructor(e, t, r, a) { this.targetId = e, this.fromCache = t, this.Si = r, this.Di = a } static Ci(e, t) { let r = Ci(), a = Ci(); for (const d of t.docChanges) switch (d.type) { case 0: r = r.add(d.doc.key); break; case 1: a = a.add(d.doc.key) }return new vD(e, t.fromCache, r, a) } } class eA { constructor() { this.xi = !1 } initialize(e, t) { this.Ni = e, this.indexManager = t, this.xi = !0 } getDocumentsMatchingQuery(e, t, r, a) { return this.ki(e, t).next(d => d || this.Oi(e, t, a, r)).next(d => d || this.Mi(e, t)) } ki(e, t) { if (Mv(t)) return Qt.resolve(null); let r = fu(t); return this.indexManager.getIndexType(e, r).next(a => 0 === a ? null : (null !== t.limit && 1 === a && (t = Nv(t, null, "F"), r = fu(t)), this.indexManager.getDocumentsMatchingTarget(e, r).next(d => { const _ = Ci(...d); return this.Ni.getDocuments(e, _).next(E => this.indexManager.getMinOffset(e, r).next(x => { const B = this.Fi(t, E); return this.$i(t, B, _, x.readTime) ? this.ki(e, Nv(t, null, "F")) : this.Bi(e, B, t, x) })) }))) } Oi(e, t, r, a) { return Mv(t) || a.isEqual(Ar.min()) ? this.Mi(e, t) : this.Ni.getDocuments(e, r).next(d => { const _ = this.Fi(t, d); return this.$i(t, _, r, a) ? this.Mi(e, t) : (Fb() <= Jo.in.DEBUG && Mn("QueryEngine", "Re-using previous result from %s to execute query: %s", a.toString(), kv(t)), this.Bi(e, _, t, $b(a, -1))) }) } Fi(e, t) { let r = new _o(GT(e)); return t.forEach((a, d) => { sw(e, d) && (r = r.add(d)) }), r } $i(e, t, r, a) { if (null === e.limit) return !1; if (r.size !== t.size) return !0; const d = "F" === e.limitType ? t.last() : t.first(); return !!d && (d.hasPendingWrites || d.version.compareTo(a) > 0) } Mi(e, t) { return Fb() <= Jo.in.DEBUG && Mn("QueryEngine", "Using full collection scan to execute query:", kv(t)), this.Ni.getDocumentsMatchingQuery(e, t, _c.min()) } Bi(e, t, r, a) { return this.Ni.getDocumentsMatchingQuery(e, r, a).next(d => (t.forEach(_ => { d = d.insert(_.key, _) }), d)) } } class IM { constructor(e, t, r, a) { this.persistence = e, this.Li = t, this.yt = a, this.qi = new Na(ai), this.Ui = new sg(d => Qp(d), om), this.Ki = new Map, this.Gi = e.getRemoteDocumentCache(), this.Cs = e.getTargetCache(), this.Ns = e.getBundleCache(), this.Qi(r) } Qi(e) { this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new JI(this.Gi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Gi.setIndexManager(this.indexManager), this.Li.initialize(this.localDocuments, this.indexManager) } collectGarbage(e) { return this.persistence.runTransaction("Collect garbage", "readwrite-primary", t => e.collect(t, this.qi)) } } function tA(n, e, t, r) { return new IM(n, e, t, r) } function nA(n, e) { return bD.apply(this, arguments) } function bD() { return bD = (0, cn.Z)(function* (n, e) { const t = Wn(n); return yield t.persistence.runTransaction("Handle user change", "readonly", r => { let a; return t.mutationQueue.getAllMutationBatches(r).next(d => (a = d, t.Qi(e), t.mutationQueue.getAllMutationBatches(r))).next(d => { const _ = [], E = []; let x = Ci(); for (const B of a) { _.push(B.batchId); for (const K of B.mutations) x = x.add(K.key) } for (const B of d) { E.push(B.batchId); for (const K of B.mutations) x = x.add(K.key) } return t.localDocuments.getDocuments(r, x).next(B => ({ ji: B, removedBatchIds: _, addedBatchIds: E })) }) }) }), bD.apply(this, arguments) } function AM(n, e) { const t = Wn(n); return t.persistence.runTransaction("Acknowledge batch", "readwrite-primary", r => { const a = e.batch.keys(), d = t.Gi.newChangeBuffer({ trackRemovals: !0 }); return function (_, E, x, B) { const K = x.batch, oe = K.keys(); let Me = Qt.resolve(); return oe.forEach(ot => { Me = Me.next(() => B.getEntry(E, ot)).next(bt => { const qt = x.docVersions.get(ot); mr(null !== qt), bt.version.compareTo(qt) < 0 && (K.applyToRemoteDocument(bt, x), bt.isValidDocument() && (bt.setReadTime(x.commitVersion), B.addEntry(bt))) }) }), Me.next(() => _.mutationQueue.removeMutationBatch(E, K)) }(t, r, e, d).next(() => d.apply(r)).next(() => t.mutationQueue.performConsistencyCheck(r)).next(() => t.documentOverlayCache.removeOverlaysForBatchId(r, a, e.batch.batchId)).next(() => t.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(r, function (_) { let E = Ci(); for (let x = 0; x < _.mutationResults.length; ++x)_.mutationResults[x].transformResults.length > 0 && (E = E.add(_.batch.mutations[x].key)); return E }(e))).next(() => t.localDocuments.getDocuments(r, a)) }) } function rA(n) { const e = Wn(n); return e.persistence.runTransaction("Get last remote snapshot version", "readonly", t => e.Cs.getLastRemoteSnapshotVersion(t)) } function xM(n, e) { const t = Wn(n), r = e.snapshotVersion; let a = t.qi; return t.persistence.runTransaction("Apply remote event", "readwrite-primary", d => { const _ = t.Gi.newChangeBuffer({ trackRemovals: !0 }); a = t.qi; const E = []; e.targetChanges.forEach((K, oe) => { const Me = a.get(oe); if (!Me) return; E.push(t.Cs.removeMatchingKeys(d, K.removedDocuments, oe).next(() => t.Cs.addMatchingKeys(d, K.addedDocuments, oe))); let ot = Me.withSequenceNumber(d.currentSequenceNumber); var bt, qt, Tn; e.targetMismatches.has(oe) ? ot = ot.withResumeToken(sl.EMPTY_BYTE_STRING, Ar.min()).withLastLimboFreeSnapshotVersion(Ar.min()) : K.resumeToken.approximateByteSize() > 0 && (ot = ot.withResumeToken(K.resumeToken, r)), a = a.insert(oe, ot), qt = ot, Tn = K, (0 === (bt = Me).resumeToken.approximateByteSize() || qt.snapshotVersion.toMicroseconds() - bt.snapshotVersion.toMicroseconds() >= 3e8 || Tn.addedDocuments.size + Tn.modifiedDocuments.size + Tn.removedDocuments.size > 0) && E.push(t.Cs.updateTargetData(d, ot)) }); let x = Ru(), B = Ci(); if (e.documentUpdates.forEach(K => { e.resolvedLimboDocuments.has(K) && E.push(t.persistence.referenceDelegate.updateLimboDocument(d, K)) }), E.push(iA(d, _, e.documentUpdates).next(K => { x = K.Wi, B = K.zi })), !r.isEqual(Ar.min())) { const K = t.Cs.getLastRemoteSnapshotVersion(d).next(oe => t.Cs.setTargetsMetadata(d, d.currentSequenceNumber, r)); E.push(K) } return Qt.waitFor(E).next(() => _.apply(d)).next(() => t.localDocuments.getLocalViewOfDocuments(d, x, B)).next(() => x) }).then(d => (t.qi = a, d)) } function iA(n, e, t) { let r = Ci(), a = Ci(); return t.forEach(d => r = r.add(d)), e.getEntries(n, r).next(d => { let _ = Ru(); return t.forEach((E, x) => { const B = d.get(E); x.isFoundDocument() !== B.isFoundDocument() && (a = a.add(E)), x.isNoDocument() && x.version.isEqual(Ar.min()) ? (e.removeEntry(E, x.readTime), _ = _.insert(E, x)) : !B.isValidDocument() || x.version.compareTo(B.version) > 0 || 0 === x.version.compareTo(B.version) && B.hasPendingWrites ? (e.addEntry(x), _ = _.insert(E, x)) : Mn("LocalStore", "Ignoring outdated watch update for ", E, ". Current version:", B.version, " Watch version:", x.version) }), { Wi: _, zi: a } }) } function MM(n, e) { const t = Wn(n); return t.persistence.runTransaction("Get next mutation batch", "readonly", r => (void 0 === e && (e = -1), t.mutationQueue.getNextMutationBatchAfterBatchId(r, e))) } function Uv(n, e) { const t = Wn(n); return t.persistence.runTransaction("Allocate target", "readwrite", r => { let a; return t.Cs.getTargetData(r, e).next(d => d ? (a = d, Qt.resolve(a)) : t.Cs.allocateTargetId(r).next(_ => (a = new dm(e, _, 0, r.currentSequenceNumber), t.Cs.addTargetData(r, a).next(() => a)))) }).then(r => { const a = t.qi.get(r.targetId); return (null === a || r.snapshotVersion.compareTo(a.snapshotVersion) > 0) && (t.qi = t.qi.insert(r.targetId, r), t.Ui.set(e, r.targetId)), r }) } function Hv(n, e, t) { return wD.apply(this, arguments) } function wD() { return wD = (0, cn.Z)(function* (n, e, t) { const r = Wn(n), a = r.qi.get(e), d = t ? "readwrite" : "readwrite-primary"; try { t || (yield r.persistence.runTransaction("Release target", d, _ => r.persistence.referenceDelegate.removeTarget(_, a))) } catch (_) { if (!sh(_)) throw _; Mn("LocalStore", `Failed to update sequence numbers for target ${e}: ${_}`) } r.qi = r.qi.remove(e), r.Ui.delete(a.target) }), wD.apply(this, arguments) } function mE(n, e, t) { const r = Wn(n); let a = Ar.min(), d = Ci(); return r.persistence.runTransaction("Execute query", "readonly", _ => function (E, x, B) { const K = Wn(E), oe = K.Ui.get(B); return void 0 !== oe ? Qt.resolve(K.qi.get(oe)) : K.Cs.getTargetData(x, B) }(r, _, fu(e)).next(E => { if (E) return a = E.lastLimboFreeSnapshotVersion, r.Cs.getMatchingKeysForTargetId(_, E.targetId).next(x => { d = x }) }).next(() => r.Li.getDocumentsMatchingQuery(_, e, t ? a : Ar.min(), t ? d : Ci())).next(E => (aA(r, ow(e), E), { documents: E, Hi: d }))) } function sA(n, e) { const t = Wn(n), r = Wn(t.Cs), a = t.qi.get(e); return a ? Promise.resolve(a.target) : t.persistence.runTransaction("Get target data", "readonly", d => r.ne(d, e).next(_ => _ ? _.target : null)) } function oA(n, e) { const t = Wn(n), r = t.Ki.get(e) || Ar.min(); return t.persistence.runTransaction("Get new document changes", "readonly", a => t.Gi.getAllFromCollectionGroup(a, e, $b(r, -1), Number.MAX_SAFE_INTEGER)).then(a => (aA(t, e, a), a)) } function aA(n, e, t) { let r = n.Ki.get(e) || Ar.min(); t.forEach((a, d) => { d.readTime.compareTo(r) > 0 && (r = d.readTime) }), n.Ki.set(e, r) } function CD() { return CD = (0, cn.Z)(function* (n, e, t, r) { const a = Wn(n); let d = Ci(), _ = Ru(); for (const B of t) { const K = e.Ji(B.metadata.name); B.document && (d = d.add(K)); const oe = e.Yi(B); oe.setReadTime(e.Xi(B.metadata.readTime)), _ = _.insert(K, oe) } const E = a.Gi.newChangeBuffer({ trackRemovals: !0 }), x = yield Uv(a, (B = r, fu(Xp(is.fromString(`__bundle__/docs/${B}`))))); var B; return a.persistence.runTransaction("Apply bundle documents", "readwrite", B => iA(B, E, _).next(K => (E.apply(B), K)).next(K => a.Cs.removeMatchingKeysForTargetId(B, x.targetId).next(() => a.Cs.addMatchingKeys(B, d, x.targetId)).next(() => a.localDocuments.getLocalViewOfDocuments(B, K.Wi, K.zi)).next(() => K.Wi))) }), CD.apply(this, arguments) } function NM(n, e) { return ED.apply(this, arguments) } function ED() { return ED = (0, cn.Z)(function* (n, e, t = Ci()) { const r = yield Uv(n, fu(lD(e.bundledQuery))), a = Wn(n); return a.persistence.runTransaction("Save named query", "readwrite", d => { const _ = ol(e.readTime); if (r.snapshotVersion.compareTo(_) >= 0) return a.Ns.saveNamedQuery(d, e); const E = r.withResumeToken(sl.EMPTY_BYTE_STRING, _); return a.qi = a.qi.insert(E.targetId, E), a.Cs.updateTargetData(d, E).next(() => a.Cs.removeMatchingKeysForTargetId(d, r.targetId)).next(() => a.Cs.addMatchingKeys(d, t, r.targetId)).next(() => a.Ns.saveNamedQuery(d, e)) }) }), ED.apply(this, arguments) } function lA(n, e) { return `firestore_clients_${n}_${e}` } function cA(n, e, t) { let r = `firestore_mutations_${n}_${t}`; return e.isAuthenticated() && (r += `_${e.uid}`), r } function TD(n, e) { return `firestore_targets_${n}_${e}` } class _E { constructor(e, t, r, a) { this.user = e, this.batchId = t, this.state = r, this.error = a } static Zi(e, t, r) { const a = JSON.parse(r); let d, _ = "object" == typeof a && -1 !== ["pending", "acknowledged", "rejected"].indexOf(a.state) && (void 0 === a.error || "object" == typeof a.error); return _ && a.error && (_ = "string" == typeof a.error.message && "string" == typeof a.error.code, _ && (d = new Cn(a.error.code, a.error.message))), _ ? new _E(e, t, a.state, d) : (Ga("SharedClientState", `Failed to parse mutation state for ID '${t}': ${r}`), null) } tr() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class Sw { constructor(e, t, r) { this.targetId = e, this.state = t, this.error = r } static Zi(e, t) { const r = JSON.parse(t); let a, d = "object" == typeof r && -1 !== ["not-current", "current", "rejected"].indexOf(r.state) && (void 0 === r.error || "object" == typeof r.error); return d && r.error && (d = "string" == typeof r.error.message && "string" == typeof r.error.code, d && (a = new Cn(r.error.code, r.error.message))), d ? new Sw(e, r.state, a) : (Ga("SharedClientState", `Failed to parse target state for ID '${e}': ${t}`), null) } tr() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class yE { constructor(e, t) { this.clientId = e, this.activeTargetIds = t } static Zi(e, t) { const r = JSON.parse(t); let a = "object" == typeof r && r.activeTargetIds instanceof Array, d = yw(); for (let _ = 0; a && _ < r.activeTargetIds.length; ++_)a = MC(r.activeTargetIds[_]), d = d.add(r.activeTargetIds[_]); return a ? new yE(e, d) : (Ga("SharedClientState", `Failed to parse client data for instance '${e}': ${t}`), null) } } class DD { constructor(e, t) { this.clientId = e, this.onlineState = t } static Zi(e) { const t = JSON.parse(e); return "object" == typeof t && -1 !== ["Unknown", "Online", "Offline"].indexOf(t.onlineState) && "string" == typeof t.clientId ? new DD(t.clientId, t.onlineState) : (Ga("SharedClientState", `Failed to parse online state: ${e}`), null) } } class SD { constructor() { this.activeTargetIds = yw() } er(e) { this.activeTargetIds = this.activeTargetIds.add(e) } nr(e) { this.activeTargetIds = this.activeTargetIds.delete(e) } tr() { const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }; return JSON.stringify(e) } } class ID { constructor(e, t, r, a, d) { this.window = e, this.Hs = t, this.persistenceKey = r, this.sr = a, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.ir = this.rr.bind(this), this.ur = new Na(ai), this.started = !1, this.cr = []; const _ = r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); this.storage = this.window.localStorage, this.currentUser = d, this.ar = lA(this.persistenceKey, this.sr), this.hr = `firestore_sequence_number_${this.persistenceKey}`, this.ur = this.ur.insert(this.sr, new SD), this.lr = new RegExp(`^firestore_clients_${_}_([^_]*)$`), this.dr = new RegExp(`^firestore_mutations_${_}_(\\d+)(?:_(.*))?$`), this._r = new RegExp(`^firestore_targets_${_}_(\\d+)$`), this.wr = `firestore_online_state_${this.persistenceKey}`, this.mr = function (E) { return `firestore_bundle_loaded_v2_${E}` }(this.persistenceKey), this.window.addEventListener("storage", this.ir) } static C(e) { return !(!e || !e.localStorage) } start() { var e = this; return (0, cn.Z)(function* () { const t = yield e.syncEngine.vi(); for (const a of t) { if (a === e.sr) continue; const d = e.getItem(lA(e.persistenceKey, a)); if (d) { const _ = yE.Zi(a, d); _ && (e.ur = e.ur.insert(_.clientId, _)) } } e.gr(); const r = e.storage.getItem(e.wr); if (r) { const a = e.yr(r); a && e.pr(a) } for (const a of e.cr) e.rr(a); e.cr = [], e.window.addEventListener("pagehide", () => e.shutdown()), e.started = !0 })() } writeSequenceNumber(e) { this.setItem(this.hr, JSON.stringify(e)) } getAllActiveQueryTargets() { return this.Ir(this.ur) } isActiveQueryTarget(e) { let t = !1; return this.ur.forEach((r, a) => { a.activeTargetIds.has(e) && (t = !0) }), t } addPendingMutation(e) { this.Tr(e, "pending") } updateMutationState(e, t, r) { this.Tr(e, t, r), this.Er(e) } addLocalQueryTarget(e) { let t = "not-current"; if (this.isActiveQueryTarget(e)) { const r = this.storage.getItem(TD(this.persistenceKey, e)); if (r) { const a = Sw.Zi(e, r); a && (t = a.state) } } return this.Ar.er(e), this.gr(), t } removeLocalQueryTarget(e) { this.Ar.nr(e), this.gr() } isLocalQueryTarget(e) { return this.Ar.activeTargetIds.has(e) } clearQueryState(e) { this.removeItem(TD(this.persistenceKey, e)) } updateQueryState(e, t, r) { this.Rr(e, t, r) } handleUserChange(e, t, r) { t.forEach(a => { this.Er(a) }), this.currentUser = e, r.forEach(a => { this.addPendingMutation(a) }) } setOnlineState(e) { this.br(e) } notifyBundleLoaded(e) { this.Pr(e) } shutdown() { this.started && (this.window.removeEventListener("storage", this.ir), this.removeItem(this.ar), this.started = !1) } getItem(e) { const t = this.storage.getItem(e); return Mn("SharedClientState", "READ", e, t), t } setItem(e, t) { Mn("SharedClientState", "SET", e, t), this.storage.setItem(e, t) } removeItem(e) { Mn("SharedClientState", "REMOVE", e), this.storage.removeItem(e) } rr(e) { var t = this; const r = e; if (r.storageArea === this.storage) { if (Mn("SharedClientState", "EVENT", r.key, r.newValue), r.key === this.ar) return void Ga("Received WebStorage notification for local change. Another client might have garbage-collected our state"); this.Hs.enqueueRetryable((0, cn.Z)(function* () { if (t.started) { if (null !== r.key) if (t.lr.test(r.key)) { if (null == r.newValue) { const a = t.vr(r.key); return t.Vr(a, null) } { const a = t.Sr(r.key, r.newValue); if (a) return t.Vr(a.clientId, a) } } else if (t.dr.test(r.key)) { if (null !== r.newValue) { const a = t.Dr(r.key, r.newValue); if (a) return t.Cr(a) } } else if (t._r.test(r.key)) { if (null !== r.newValue) { const a = t.Nr(r.key, r.newValue); if (a) return t.kr(a) } } else if (r.key === t.wr) { if (null !== r.newValue) { const a = t.yr(r.newValue); if (a) return t.pr(a) } } else if (r.key === t.hr) { const a = function (d) { let _ = id.at; if (null != d) try { const E = JSON.parse(d); mr("number" == typeof E), _ = E } catch (E) { Ga("SharedClientState", "Failed to read sequence number from WebStorage", E) } return _ }(r.newValue); a !== id.at && t.sequenceNumberHandler(a) } else if (r.key === t.mr) { const a = t.Or(r.newValue); yield Promise.all(a.map(d => t.syncEngine.Mr(d))) } } else t.cr.push(r) })) } } get Ar() { return this.ur.get(this.sr) } gr() { this.setItem(this.ar, this.Ar.tr()) } Tr(e, t, r) { const a = new _E(this.currentUser, e, t, r), d = cA(this.persistenceKey, this.currentUser, e); this.setItem(d, a.tr()) } Er(e) { const t = cA(this.persistenceKey, this.currentUser, e); this.removeItem(t) } br(e) { this.storage.setItem(this.wr, JSON.stringify({ clientId: this.sr, onlineState: e })) } Rr(e, t, r) { const a = TD(this.persistenceKey, e), d = new Sw(e, t, r); this.setItem(a, d.tr()) } Pr(e) { const t = JSON.stringify(Array.from(e)); this.setItem(this.mr, t) } vr(e) { const t = this.lr.exec(e); return t ? t[1] : null } Sr(e, t) { const r = this.vr(e); return yE.Zi(r, t) } Dr(e, t) { const r = this.dr.exec(e), a = Number(r[1]); return _E.Zi(new $l(void 0 !== r[2] ? r[2] : null), a, t) } Nr(e, t) { const r = this._r.exec(e), a = Number(r[1]); return Sw.Zi(a, t) } yr(e) { return DD.Zi(e) } Or(e) { return JSON.parse(e) } Cr(e) { var t = this; return (0, cn.Z)(function* () { if (e.user.uid === t.currentUser.uid) return t.syncEngine.Fr(e.batchId, e.state, e.error); Mn("SharedClientState", `Ignoring mutation for non-active user ${e.user.uid}`) })() } kr(e) { return this.syncEngine.$r(e.targetId, e.state, e.error) } Vr(e, t) { const r = t ? this.ur.insert(e, t) : this.ur.remove(e), a = this.Ir(this.ur), d = this.Ir(r), _ = [], E = []; return d.forEach(x => { a.has(x) || _.push(x) }), a.forEach(x => { d.has(x) || E.push(x) }), this.syncEngine.Br(_, E).then(() => { this.ur = r }) } pr(e) { this.ur.get(e.clientId) && this.onlineStateHandler(e.onlineState) } Ir(e) { let t = yw(); return e.forEach((r, a) => { t = t.unionWith(a.activeTargetIds) }), t } } class uA { constructor() { this.Lr = new SD, this.qr = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null } addPendingMutation(e) { } updateMutationState(e, t, r) { } addLocalQueryTarget(e) { return this.Lr.er(e), this.qr[e] || "not-current" } updateQueryState(e, t, r) { this.qr[e] = t } removeLocalQueryTarget(e) { this.Lr.nr(e) } isLocalQueryTarget(e) { return this.Lr.activeTargetIds.has(e) } clearQueryState(e) { delete this.qr[e] } getAllActiveQueryTargets() { return this.Lr.activeTargetIds } isActiveQueryTarget(e) { return this.Lr.activeTargetIds.has(e) } start() { return this.Lr = new SD, Promise.resolve() } handleUserChange(e, t, r) { } setOnlineState(e) { } shutdown() { } writeSequenceNumber(e) { } notifyBundleLoaded(e) { } } class kM { Ur(e) { } shutdown() { } } class dA { constructor() { this.Kr = () => this.Gr(), this.Qr = () => this.jr(), this.Wr = [], this.zr() } Ur(e) { this.Wr.push(e) } shutdown() { window.removeEventListener("online", this.Kr), window.removeEventListener("offline", this.Qr) } zr() { window.addEventListener("online", this.Kr), window.addEventListener("offline", this.Qr) } Gr() { Mn("ConnectivityMonitor", "Network connectivity changed: AVAILABLE"); for (const e of this.Wr) e(0) } jr() { Mn("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE"); for (const e of this.Wr) e(1) } static C() { return typeof window < "u" && void 0 !== window.addEventListener && void 0 !== window.removeEventListener } } const PM = { BatchGetDocuments: "batchGet", Commit: "commit", RunQuery: "runQuery", RunAggregationQuery: "runAggregationQuery" }; class RM { constructor(e) { this.Hr = e.Hr, this.Jr = e.Jr } Yr(e) { this.Xr = e } Zr(e) { this.eo = e } onMessage(e) { this.no = e } close() { this.Jr() } send(e) { this.Hr(e) } so() { this.Xr() } io(e) { this.eo(e) } ro(e) { this.no(e) } } class FM extends class { constructor(e) { this.databaseInfo = e, this.databaseId = e.databaseId, this.oo = (e.ssl ? "https" : "http") + "://" + e.host, this.uo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents" } get co() { return !1 } ao(e, t, r, a, d) { const _ = this.ho(e, t); Mn("RestConnection", "Sending: ", _, r); const E = {}; return this.lo(E, a, d), this.fo(e, _, E, r).then(x => (Mn("RestConnection", "Received: ", x), x), x => { throw Zp("RestConnection", `${e} failed with error: `, x, "url: ", _, "request:", r), x }) } _o(e, t, r, a, d, _) { return this.ao(e, t, r, a, d) } lo(e, t, r) { e["X-Goog-Api-Client"] = "gl-js/ fire/" + rp, e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach((a, d) => e[d] = a), r && r.headers.forEach((a, d) => e[d] = a) } ho(e, t) { return `${this.oo}/v1/${t}:${PM[e]}` } }{ constructor(e) { super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams } fo(e, t, r, a) { return new Promise((d, _) => { const E = new IT; E.setWithCredentials(!0), E.listenOnce(lI.COMPLETE, () => { try { switch (E.getLastErrorCode()) { case Pb.NO_ERROR: const B = E.getResponseJson(); Mn("Connection", "XHR received:", JSON.stringify(B)), d(B); break; case Pb.TIMEOUT: Mn("Connection", 'RPC "' + e + '" timed out'), _(new Cn(en.DEADLINE_EXCEEDED, "Request time out")); break; case Pb.HTTP_ERROR: const K = E.getStatus(); if (Mn("Connection", 'RPC "' + e + '" failed with status:', K, "response text:", E.getResponseText()), K > 0) { let oe = E.getResponseJson(); Array.isArray(oe) && (oe = oe[0]); const Me = oe?.error; if (Me && Me.status && Me.message) { const ot = function (bt) { const qt = bt.toLowerCase().replace(/_/g, "-"); return Object.values(en).indexOf(qt) >= 0 ? qt : en.UNKNOWN }(Me.status); _(new Cn(ot, Me.message)) } else _(new Cn(en.UNKNOWN, "Server responded with status " + E.getStatus())) } else _(new Cn(en.UNAVAILABLE, "Connection failed.")); break; default: rr() } } finally { Mn("Connection", 'RPC "' + e + '" completed.') } }); const x = JSON.stringify(a); E.send(t, "POST", x, r, 15) }) } wo(e, t, r) { const a = [this.oo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], d = vC(), _ = bC(), E = { httpSessionIdParam: "gsessionid", initMessageHeaders: {}, messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` }, sendRawJson: !0, supportsCrossDomainXhr: !0, internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 }, forceLongPolling: this.forceLongPolling, detectBufferingProxy: this.autoDetectLongPolling }; this.useFetchStreams && (E.xmlHttpFactory = new CC({})), this.lo(E.initMessageHeaders, t, r), E.encodeInitMessageHeaders = !0; const x = a.join(""); Mn("Connection", "Creating WebChannel: " + x, E); const B = d.createWebChannel(x, E); let K = !1, oe = !1; const Me = new RM({ Hr: bt => { oe ? Mn("Connection", "Not sending because WebChannel is closed:", bt) : (K || (Mn("Connection", "Opening WebChannel transport."), B.open(), K = !0), Mn("Connection", "WebChannel sending:", bt), B.send(bt)) }, Jr: () => B.close() }), ot = (bt, qt, Tn) => { bt.listen(qt, cr => { try { Tn(cr) } catch ($r) { setTimeout(() => { throw $r }, 0) } }) }; return ot(B, w_.EventType.OPEN, () => { oe || Mn("Connection", "WebChannel transport opened.") }), ot(B, w_.EventType.CLOSE, () => { oe || (oe = !0, Mn("Connection", "WebChannel transport closed"), Me.io()) }), ot(B, w_.EventType.ERROR, bt => { oe || (oe = !0, Zp("Connection", "WebChannel transport errored:", bt), Me.io(new Cn(en.UNAVAILABLE, "The operation could not be completed"))) }), ot(B, w_.EventType.MESSAGE, bt => { var qt; if (!oe) { const Tn = bt.data[0]; mr(!!Tn); const $r = Tn.error || (null === (qt = Tn[0]) || void 0 === qt ? void 0 : qt.error); if ($r) { Mn("Connection", "WebChannel received error:", $r); const Rr = $r.status; let Li = function (Pi) { const Es = pa[Pi]; if (void 0 !== Es) return KT(Es) }(Rr), Ki = $r.message; void 0 === Li && (Li = en.INTERNAL, Ki = "Unknown error status: " + Rr + " with message " + $r.message), oe = !0, Me.io(new Cn(Li, Ki)), B.close() } else Mn("Connection", "WebChannel received:", Tn), Me.ro(Tn) } }), ot(_, wC.STAT_EVENT, bt => { bt.stat === Rb.PROXY ? Mn("Connection", "Detected buffering proxy") : bt.stat === Rb.NOPROXY && Mn("Connection", "Detected no buffering proxy") }), setTimeout(() => { Me.so() }, 0), Me } } function hA() { return typeof window < "u" ? window : null } function vE() { return typeof document < "u" ? document : null } function Iw(n) { return new yI(n, !0) } class AD { constructor(e, t, r = 1e3, a = 1.5, d = 6e4) { this.Hs = e, this.timerId = t, this.mo = r, this.yo = a, this.po = d, this.Io = 0, this.To = null, this.Eo = Date.now(), this.reset() } reset() { this.Io = 0 } Ao() { this.Io = this.po } Ro(e) { this.cancel(); const t = Math.floor(this.Io + this.bo()), r = Math.max(0, Date.now() - this.Eo), a = Math.max(0, t - r); a > 0 && Mn("ExponentialBackoff", `Backing off for ${a} ms (base delay: ${this.Io} ms, delay with jitter: ${t} ms, last attempt: ${r} ms ago)`), this.To = this.Hs.enqueueAfterDelay(this.timerId, a, () => (this.Eo = Date.now(), e())), this.Io *= this.yo, this.Io < this.mo && (this.Io = this.mo), this.Io > this.po && (this.Io = this.po) } Po() { null !== this.To && (this.To.skipDelay(), this.To = null) } cancel() { null !== this.To && (this.To.cancel(), this.To = null) } bo() { return (Math.random() - .5) * this.Io } } class fA { constructor(e, t, r, a, d, _, E, x) { this.Hs = e, this.vo = r, this.Vo = a, this.connection = d, this.authCredentialsProvider = _, this.appCheckCredentialsProvider = E, this.listener = x, this.state = 0, this.So = 0, this.Do = null, this.Co = null, this.stream = null, this.xo = new AD(e, t) } No() { return 1 === this.state || 5 === this.state || this.ko() } ko() { return 2 === this.state || 3 === this.state } start() { 4 !== this.state ? this.auth() : this.Oo() } stop() { var e = this; return (0, cn.Z)(function* () { e.No() && (yield e.close(0)) })() } Mo() { this.state = 0, this.xo.reset() } Fo() { this.ko() && null === this.Do && (this.Do = this.Hs.enqueueAfterDelay(this.vo, 6e4, () => this.$o())) } Bo(e) { this.Lo(), this.stream.send(e) } $o() { var e = this; return (0, cn.Z)(function* () { if (e.ko()) return e.close(0) })() } Lo() { this.Do && (this.Do.cancel(), this.Do = null) } qo() { this.Co && (this.Co.cancel(), this.Co = null) } close(e, t) { var r = this; return (0, cn.Z)(function* () { r.Lo(), r.qo(), r.xo.cancel(), r.So++, 4 !== e ? r.xo.reset() : t && t.code === en.RESOURCE_EXHAUSTED ? (Ga(t.toString()), Ga("Using maximum backoff delay to prevent overloading the backend."), r.xo.Ao()) : t && t.code === en.UNAUTHENTICATED && 3 !== r.state && (r.authCredentialsProvider.invalidateToken(), r.appCheckCredentialsProvider.invalidateToken()), null !== r.stream && (r.Uo(), r.stream.close(), r.stream = null), r.state = e, yield r.listener.Zr(t) })() } Uo() { } auth() { this.state = 1; const e = this.Ko(this.So), t = this.So; Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([r, a]) => { this.So === t && this.Go(r, a) }, r => { e(() => { const a = new Cn(en.UNKNOWN, "Fetching auth token failed: " + r.message); return this.Qo(a) }) }) } Go(e, t) { const r = this.Ko(this.So); this.stream = this.jo(e, t), this.stream.Yr(() => { r(() => (this.state = 2, this.Co = this.Hs.enqueueAfterDelay(this.Vo, 1e4, () => (this.ko() && (this.state = 3), Promise.resolve())), this.listener.Yr())) }), this.stream.Zr(a => { r(() => this.Qo(a)) }), this.stream.onMessage(a => { r(() => this.onMessage(a)) }) } Oo() { var e = this; this.state = 5, this.xo.Ro((0, cn.Z)(function* () { e.state = 0, e.start() })) } Qo(e) { return Mn("PersistentStream", `close with error: ${e}`), this.stream = null, this.close(4, e) } Ko(e) { return t => { this.Hs.enqueueAndForget(() => this.So === e ? t() : (Mn("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve())) } } } class LM extends fA { constructor(e, t, r, a, d, _) { super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, r, a, _), this.yt = d } jo(e, t) { return this.connection.wo("Listen", e, t) } onMessage(e) { this.xo.reset(); const t = function U(n, e) { let t; if ("targetChange" in e) { const r = "NO_CHANGE" === (x = e.targetChange.targetChangeType || "NO_CHANGE") ? 0 : "ADD" === x ? 1 : "REMOVE" === x ? 2 : "CURRENT" === x ? 3 : "RESET" === x ? 4 : rr(), a = e.targetChange.targetIds || [], d = function (x, B) { return x.wt ? (mr(void 0 === B || "string" == typeof B), sl.fromBase64String(B || "")) : (mr(void 0 === B || B instanceof Uint8Array), sl.fromUint8Array(B || new Uint8Array)) }(n, e.targetChange.resumeToken), _ = e.targetChange.cause, E = _ && function (x) { const B = void 0 === x.code ? en.UNKNOWN : KT(x.code); return new Cn(B, x.message || "") }(_); t = new XT(r, a, d, E || null) } else if ("documentChange" in e) { const r = e.documentChange, a = Sf(n, r.document.name), d = ol(r.document.updateTime), _ = r.document.createTime ? ol(r.document.createTime) : Ar.min(), E = new vc({ mapValue: { fields: r.document.fields } }), x = yo.newFoundDocument(a, d, _, E); t = new Lv(r.targetIds || [], r.removedTargetIds || [], x.key, x) } else if ("documentDelete" in e) { const r = e.documentDelete, a = Sf(n, r.document), d = r.readTime ? ol(r.readTime) : Ar.min(), _ = yo.newNoDocument(a, d); t = new Lv([], r.removedTargetIds || [], _.key, _) } else if ("documentRemove" in e) { const r = e.documentRemove, a = Sf(n, r.document); t = new Lv([], r.removedTargetIds || [], a, null) } else { if (!("filter" in e)) return rr(); { const r = e.filter, d = new gw(r.count || 0); t = new eE(r.targetId, d) } } var x; return t }(this.yt, e), r = function (a) { if (!("targetChange" in a)) return Ar.min(); const d = a.targetChange; return d.targetIds && d.targetIds.length ? Ar.min() : d.readTime ? ol(d.readTime) : Ar.min() }(e); return this.listener.Wo(t, r) } zo(e) { const t = {}; t.database = u(this.yt), t.addTarget = function (a, d) { let _; const E = d.target; return _ = R_(E) ? { documents: He(a, E) } : { query: Dt(a, E) }, _.targetId = d.targetId, d.resumeToken.approximateByteSize() > 0 ? _.resumeToken = rE(a, d.resumeToken) : d.snapshotVersion.compareTo(Ar.min()) > 0 && (_.readTime = z_(a, d.snapshotVersion.toTimestamp())), _ }(this.yt, e); const r = function mn(n, e) { const t = function (r, a) { switch (a) { case 0: return null; case 1: return "existence-filter-mismatch"; case 2: return "limbo-document"; default: return rr() } }(0, e.purpose); return null == t ? null : { "goog-listen-tags": t } }(0, e); r && (t.labels = r), this.Bo(t) } Ho(e) { const t = {}; t.database = u(this.yt), t.removeTarget = e, this.Bo(t) } } class BM extends fA { constructor(e, t, r, a, d, _) { super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, r, a, _), this.yt = d, this.Jo = !1 } get Yo() { return this.Jo } start() { this.Jo = !1, this.lastStreamToken = void 0, super.start() } Uo() { this.Jo && this.Xo([]) } jo(e, t) { return this.connection.wo("Write", e, t) } onMessage(e) { if (mr(!!e.streamToken), this.lastStreamToken = e.streamToken, this.Jo) { this.xo.reset(); const t = function pe(n, e) { return n && n.length > 0 ? (mr(void 0 !== e), n.map(t => function (r, a) { let d = ol(r.updateTime ? r.updateTime : a); return d.isEqual(Ar.min()) && (d = ol(a)), new pI(d, r.transformResults || []) }(t, e))) : [] }(e.writeResults, e.commitTime), r = ol(e.commitTime); return this.listener.Zo(r, t) } return mr(!e.writeResults || 0 === e.writeResults.length), this.Jo = !0, this.listener.tu() } eu() { const e = {}; e.database = u(this.yt), this.Bo(e) } Xo(e) { const t = { streamToken: this.lastStreamToken, writes: e.map(r => j(this.yt, r)) }; this.Bo(t) } } class VM extends class { }{ constructor(e, t, r, a) { super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = r, this.yt = a, this.nu = !1 } su() { if (this.nu) throw new Cn(en.FAILED_PRECONDITION, "The client has already been terminated.") } ao(e, t, r) { return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([a, d]) => this.connection.ao(e, t, r, a, d)).catch(a => { throw "FirebaseError" === a.name ? (a.code === en.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), a) : new Cn(en.UNKNOWN, a.toString()) }) } _o(e, t, r, a) { return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([d, _]) => this.connection._o(e, t, r, d, _, a)).catch(d => { throw "FirebaseError" === d.name ? (d.code === en.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), d) : new Cn(en.UNKNOWN, d.toString()) }) } terminate() { this.nu = !0 } } class HM { constructor(e, t) { this.asyncQueue = e, this.onlineStateHandler = t, this.state = "Unknown", this.iu = 0, this.ru = null, this.ou = !0 } uu() { 0 === this.iu && (this.cu("Unknown"), this.ru = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.ru = null, this.au("Backend didn't respond within 10 seconds."), this.cu("Offline"), Promise.resolve()))) } hu(e) { "Online" === this.state ? this.cu("Unknown") : (this.iu++, this.iu >= 1 && (this.lu(), this.au(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.cu("Offline"))) } set(e) { this.lu(), this.iu = 0, "Online" === e && (this.ou = !1), this.cu(e) } cu(e) { e !== this.state && (this.state = e, this.onlineStateHandler(e)) } au(e) { const t = `Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`; this.ou ? (Ga(t), this.ou = !1) : Mn("OnlineStateTracker", t) } lu() { null !== this.ru && (this.ru.cancel(), this.ru = null) } } class zM { constructor(e, t, r, a, d) { var _ = this; this.localStore = e, this.datastore = t, this.asyncQueue = r, this.remoteSyncer = {}, this.fu = [], this.du = new Map, this._u = new Set, this.wu = [], this.mu = d, this.mu.Ur(E => { r.enqueueAndForget((0, cn.Z)(function* () { var x; ag(_) && (Mn("RemoteStore", "Restarting streams for network reachability change."), yield (x = (0, cn.Z)(function* (B) { const K = Wn(B); K._u.add(4), yield zv(K), K.gu.set("Unknown"), K._u.delete(4), yield Aw(K) }), function (B) { return x.apply(this, arguments) })(_)) })) }), this.gu = new HM(r, a) } } function Aw(n) { return MD.apply(this, arguments) } function MD() { return MD = (0, cn.Z)(function* (n) { if (ag(n)) for (const e of n.wu) yield e(!0) }), MD.apply(this, arguments) } function zv(n) { return OD.apply(this, arguments) } function OD() { return OD = (0, cn.Z)(function* (n) { for (const e of n.wu) yield e(!1) }), OD.apply(this, arguments) } function bE(n, e) { const t = Wn(n); t.du.has(e.targetId) || (t.du.set(e.targetId, e), PD(t) ? kD(t) : jv(t).ko() && ND(t, e)) } function xw(n, e) { const t = Wn(n), r = jv(t); t.du.delete(e), r.ko() && pA(t, e), 0 === t.du.size && (r.ko() ? r.Fo() : ag(t) && t.gu.set("Unknown")) } function ND(n, e) { n.yu.Ot(e.targetId), jv(n).zo(e) } function pA(n, e) { n.yu.Ot(e), jv(n).Ho(e) } function kD(n) { n.yu = new tD({ getRemoteKeysForTarget: e => n.remoteSyncer.getRemoteKeysForTarget(e), ne: e => n.du.get(e) || null }), jv(n).start(), n.gu.uu() } function PD(n) { return ag(n) && !jv(n).No() && n.du.size > 0 } function ag(n) { return 0 === Wn(n)._u.size } function gA(n) { n.yu = void 0 } function GM(n) { return RD.apply(this, arguments) } function RD() { return RD = (0, cn.Z)(function* (n) { n.du.forEach((e, t) => { ND(n, e) }) }), RD.apply(this, arguments) } function jM(n, e) { return FD.apply(this, arguments) } function FD() { return FD = (0, cn.Z)(function* (n, e) { gA(n), PD(n) ? (n.gu.hu(e), kD(n)) : n.gu.set("Unknown") }), FD.apply(this, arguments) } function $M(n, e, t) { return LD.apply(this, arguments) } function LD() { return LD = (0, cn.Z)(function* (n, e, t) { if (n.gu.set("Online"), e instanceof XT && 2 === e.state && e.cause) try { yield (r = (0, cn.Z)(function* (a, d) { const _ = d.cause; for (const E of d.targetIds) a.du.has(E) && (yield a.remoteSyncer.rejectListen(E, _), a.du.delete(E), a.yu.removeTarget(E)) }), function (a, d) { return r.apply(this, arguments) })(n, e) } catch (r) { Mn("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), r), yield wE(n, r) } else if (e instanceof Lv ? n.yu.Kt(e) : e instanceof eE ? n.yu.Jt(e) : n.yu.jt(e), !t.isEqual(Ar.min())) try { const r = yield rA(n.localStore); t.compareTo(r) >= 0 && (yield function (a, d) { const _ = a.yu.Zt(d); return _.targetChanges.forEach((E, x) => { if (E.resumeToken.approximateByteSize() > 0) { const B = a.du.get(x); B && a.du.set(x, B.withResumeToken(E.resumeToken, d)) } }), _.targetMismatches.forEach(E => { const x = a.du.get(E); if (!x) return; a.du.set(E, x.withResumeToken(sl.EMPTY_BYTE_STRING, x.snapshotVersion)), pA(a, E); const B = new dm(x.target, E, 1, x.sequenceNumber); ND(a, B) }), a.remoteSyncer.applyRemoteEvent(_) }(n, t)) } catch (r) { Mn("RemoteStore", "Failed to raise snapshot:", r), yield wE(n, r) } var r }), LD.apply(this, arguments) } function wE(n, e, t) { return BD.apply(this, arguments) } function BD() { return BD = (0, cn.Z)(function* (n, e, t) { if (!sh(e)) throw e; n._u.add(1), yield zv(n), n.gu.set("Offline"), t || (t = () => rA(n.localStore)), n.asyncQueue.enqueueRetryable((0, cn.Z)(function* () { Mn("RemoteStore", "Retrying IndexedDB access"), yield t(), n._u.delete(1), yield Aw(n) })) }), BD.apply(this, arguments) } function mA(n, e) { return e().catch(t => wE(n, t, e)) } function Gv(n) { return VD.apply(this, arguments) } function VD() { return VD = (0, cn.Z)(function* (n) { const e = Wn(n), t = gm(e); let r = e.fu.length > 0 ? e.fu[e.fu.length - 1].batchId : -1; for (; WM(e);)try { const a = yield MM(e.localStore, r); if (null === a) { 0 === e.fu.length && t.Fo(); break } r = a.batchId, ZM(e, a) } catch (a) { yield wE(e, a) } _A(e) && yA(e) }), VD.apply(this, arguments) } function WM(n) { return ag(n) && n.fu.length < 10 } function ZM(n, e) { n.fu.push(e); const t = gm(n); t.ko() && t.Yo && t.Xo(e.mutations) } function _A(n) { return ag(n) && !gm(n).No() && n.fu.length > 0 } function yA(n) { gm(n).start() } function qM(n) { return UD.apply(this, arguments) } function UD() { return UD = (0, cn.Z)(function* (n) { gm(n).eu() }), UD.apply(this, arguments) } function YM(n) { return HD.apply(this, arguments) } function HD() { return HD = (0, cn.Z)(function* (n) { const e = gm(n); for (const t of n.fu) e.Xo(t.mutations) }), HD.apply(this, arguments) } function KM(n, e, t) { return zD.apply(this, arguments) } function zD() { return zD = (0, cn.Z)(function* (n, e, t) { const r = n.fu.shift(), a = oD.from(r, e, t); yield mA(n, () => n.remoteSyncer.applySuccessfulWrite(a)), yield Gv(n) }), zD.apply(this, arguments) } function JM(n, e) { return GD.apply(this, arguments) } function GD() { return GD = (0, cn.Z)(function* (n, e) { var t; e && gm(n).Yo && (yield (t = (0, cn.Z)(function* (r, a) { if (YT(d = a.code) && d !== en.ABORTED) { const _ = r.fu.shift(); gm(r).Mo(), yield mA(r, () => r.remoteSyncer.rejectFailedWrite(_.batchId, a)), yield Gv(r) } var d }), function (r, a) { return t.apply(this, arguments) })(n, e)), _A(n) && yA(n) }), GD.apply(this, arguments) } function vA(n, e) { return jD.apply(this, arguments) } function jD() { return jD = (0, cn.Z)(function* (n, e) { const t = Wn(n); t.asyncQueue.verifyOperationInProgress(), Mn("RemoteStore", "RemoteStore received new credentials"); const r = ag(t); t._u.add(3), yield zv(t), r && t.gu.set("Unknown"), yield t.remoteSyncer.handleCredentialChange(e), t._u.delete(3), yield Aw(t) }), jD.apply(this, arguments) } function $D(n, e) { return WD.apply(this, arguments) } function WD() { return WD = (0, cn.Z)(function* (n, e) { const t = Wn(n); e ? (t._u.delete(2), yield Aw(t)) : e || (t._u.add(2), yield zv(t), t.gu.set("Unknown")) }), WD.apply(this, arguments) } function jv(n) { return n.pu || (n.pu = function (e, t, r) { const a = Wn(e); return a.su(), new LM(t, a.connection, a.authCredentials, a.appCheckCredentials, a.yt, r) }(n.datastore, n.asyncQueue, { Yr: GM.bind(null, n), Zr: jM.bind(null, n), Wo: $M.bind(null, n) }), n.wu.push(function () { var e = (0, cn.Z)(function* (t) { t ? (n.pu.Mo(), PD(n) ? kD(n) : n.gu.set("Unknown")) : (yield n.pu.stop(), gA(n)) }); return function (t) { return e.apply(this, arguments) } }())), n.pu } function gm(n) { return n.Iu || (n.Iu = function (e, t, r) { const a = Wn(e); return a.su(), new BM(t, a.connection, a.authCredentials, a.appCheckCredentials, a.yt, r) }(n.datastore, n.asyncQueue, { Yr: qM.bind(null, n), Zr: JM.bind(null, n), tu: YM.bind(null, n), Zo: KM.bind(null, n) }), n.wu.push(function () { var e = (0, cn.Z)(function* (t) { t ? (n.Iu.Mo(), yield Gv(n)) : (yield n.Iu.stop(), n.fu.length > 0 && (Mn("RemoteStore", `Stopping write stream with ${n.fu.length} pending writes`), n.fu = [])) }); return function (t) { return e.apply(this, arguments) } }())), n.Iu } class ZD { constructor(e, t, r, a, d) { this.asyncQueue = e, this.timerId = t, this.targetTimeMs = r, this.op = a, this.removalCallback = d, this.deferred = new ja, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch(_ => { }) } static createAndSchedule(e, t, r, a, d) { const _ = Date.now() + r, E = new ZD(e, t, _, a, d); return E.start(r), E } start(e) { this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e) } skipDelay() { return this.handleDelayElapsed() } cancel(e) { null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new Cn(en.CANCELLED, "Operation cancelled" + (e ? ": " + e : "")))) } handleDelayElapsed() { this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then(e => this.deferred.resolve(e))) : Promise.resolve()) } clearTimeout() { null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null) } } function $v(n, e) { if (Ga("AsyncQueue", `${e}: ${n}`), sh(n)) return new Cn(en.UNAVAILABLE, `${e}: ${n}`); throw n } class Wv { constructor(e) { this.comparator = e ? (t, r) => e(t, r) || Gn.comparator(t.key, r.key) : (t, r) => Gn.comparator(t.key, r.key), this.keyedMap = H_(), this.sortedSet = new Na(this.comparator) } static emptySet(e) { return new Wv(e.comparator) } has(e) { return null != this.keyedMap.get(e) } get(e) { return this.keyedMap.get(e) } first() { return this.sortedSet.minKey() } last() { return this.sortedSet.maxKey() } isEmpty() { return this.sortedSet.isEmpty() } indexOf(e) { const t = this.keyedMap.get(e); return t ? this.sortedSet.indexOf(t) : -1 } get size() { return this.sortedSet.size } forEach(e) { this.sortedSet.inorderTraversal((t, r) => (e(t), !1)) } add(e) { const t = this.delete(e.key); return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null)) } delete(e) { const t = this.get(e); return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this } isEqual(e) { if (!(e instanceof Wv) || this.size !== e.size) return !1; const t = this.sortedSet.getIterator(), r = e.sortedSet.getIterator(); for (; t.hasNext();) { const a = t.getNext().key, d = r.getNext().key; if (!a.isEqual(d)) return !1 } return !0 } toString() { const e = []; return this.forEach(t => { e.push(t.toString()) }), 0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)" } copy(e, t) { const r = new Wv; return r.comparator = this.comparator, r.keyedMap = e, r.sortedSet = t, r } } class bA { constructor() { this.Tu = new Na(Gn.comparator) } track(e) { const t = e.doc.key, r = this.Tu.get(t); r ? 0 !== e.type && 3 === r.type ? this.Tu = this.Tu.insert(t, e) : 3 === e.type && 1 !== r.type ? this.Tu = this.Tu.insert(t, { type: r.type, doc: e.doc }) : 2 === e.type && 2 === r.type ? this.Tu = this.Tu.insert(t, { type: 2, doc: e.doc }) : 2 === e.type && 0 === r.type ? this.Tu = this.Tu.insert(t, { type: 0, doc: e.doc }) : 1 === e.type && 0 === r.type ? this.Tu = this.Tu.remove(t) : 1 === e.type && 2 === r.type ? this.Tu = this.Tu.insert(t, { type: 1, doc: r.doc }) : 0 === e.type && 1 === r.type ? this.Tu = this.Tu.insert(t, { type: 2, doc: e.doc }) : rr() : this.Tu = this.Tu.insert(t, e) } Eu() { const e = []; return this.Tu.inorderTraversal((t, r) => { e.push(r) }), e } } class Zv { constructor(e, t, r, a, d, _, E, x, B) { this.query = e, this.docs = t, this.oldDocs = r, this.docChanges = a, this.mutatedKeys = d, this.fromCache = _, this.syncStateChanged = E, this.excludesMetadataChanges = x, this.hasCachedResults = B } static fromInitialDocuments(e, t, r, a, d) { const _ = []; return t.forEach(E => { _.push({ type: 0, doc: E }) }), new Zv(e, t, Wv.emptySet(t), _, r, a, !0, !1, d) } get hasPendingWrites() { return !this.mutatedKeys.isEmpty() } isEqual(e) { if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && am(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1; const t = this.docChanges, r = e.docChanges; if (t.length !== r.length) return !1; for (let a = 0; a < t.length; a++)if (t[a].type !== r[a].type || !t[a].doc.isEqual(r[a].doc)) return !1; return !0 } } class QM { constructor() { this.Au = void 0, this.listeners = [] } } class XM { constructor() { this.queries = new sg(e => zT(e), am), this.onlineState = "Unknown", this.Ru = new Set } } function qD(n, e) { return YD.apply(this, arguments) } function YD() { return YD = (0, cn.Z)(function* (n, e) { const t = Wn(n), r = e.query; let a = !1, d = t.queries.get(r); if (d || (a = !0, d = new QM), a) try { d.Au = yield t.onListen(r) } catch (_) { const E = $v(_, `Initialization of query '${kv(e.query)}' failed`); return void e.onError(E) } t.queries.set(r, d), d.listeners.push(e), e.bu(t.onlineState), d.Au && e.Pu(d.Au) && QD(t) }), YD.apply(this, arguments) } function KD(n, e) { return JD.apply(this, arguments) } function JD() { return JD = (0, cn.Z)(function* (n, e) { const t = Wn(n), r = e.query; let a = !1; const d = t.queries.get(r); if (d) { const _ = d.listeners.indexOf(e); _ >= 0 && (d.listeners.splice(_, 1), a = 0 === d.listeners.length) } if (a) return t.queries.delete(r), t.onUnlisten(r) }), JD.apply(this, arguments) } function eO(n, e) { const t = Wn(n); let r = !1; for (const a of e) { const _ = t.queries.get(a.query); if (_) { for (const E of _.listeners) E.Pu(a) && (r = !0); _.Au = a } } r && QD(t) } function tO(n, e, t) { const r = Wn(n), a = r.queries.get(e); if (a) for (const d of a.listeners) d.onError(t); r.queries.delete(e) } function QD(n) { n.Ru.forEach(e => { e.next() }) } class XD { constructor(e, t, r) { this.query = e, this.vu = t, this.Vu = !1, this.Su = null, this.onlineState = "Unknown", this.options = r || {} } Pu(e) { if (!this.options.includeMetadataChanges) { const r = []; for (const a of e.docChanges) 3 !== a.type && r.push(a); e = new Zv(e.query, e.docs, e.oldDocs, r, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults) } let t = !1; return this.Vu ? this.Du(e) && (this.vu.next(e), t = !0) : this.Cu(e, this.onlineState) && (this.xu(e), t = !0), this.Su = e, t } onError(e) { this.vu.error(e) } bu(e) { this.onlineState = e; let t = !1; return this.Su && !this.Vu && this.Cu(this.Su, e) && (this.xu(this.Su), t = !0), t } Cu(e, t) { return !e.fromCache || (!this.options.Nu || !("Offline" !== t)) && (!e.docs.isEmpty() || e.hasCachedResults || "Offline" === t) } Du(e) { return e.docChanges.length > 0 || !!(e.syncStateChanged || this.Su && this.Su.hasPendingWrites !== e.hasPendingWrites) && !0 === this.options.includeMetadataChanges } xu(e) { e = Zv.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.Vu = !0, this.vu.next(e) } } class nO { constructor(e, t) { this.ku = e, this.byteLength = t } Ou() { return "metadata" in this.ku } } class wA { constructor(e) { this.yt = e } Ji(e) { return Sf(this.yt, e) } Yi(e) { return e.metadata.exists ? D(this.yt, e.document, !1) : yo.newNoDocument(this.Ji(e.metadata.name), this.Xi(e.metadata.readTime)) } Xi(e) { return ol(e) } } class rO { constructor(e, t, r) { this.Mu = e, this.localStore = t, this.yt = r, this.queries = [], this.documents = [], this.collectionGroups = new Set, this.progress = CA(e) } Fu(e) { this.progress.bytesLoaded += e.byteLength; let t = this.progress.documentsLoaded; if (e.ku.namedQuery) this.queries.push(e.ku.namedQuery); else if (e.ku.documentMetadata) { this.documents.push({ metadata: e.ku.documentMetadata }), e.ku.documentMetadata.exists || ++t; const r = is.fromString(e.ku.documentMetadata.name); this.collectionGroups.add(r.get(r.length - 2)) } else e.ku.document && (this.documents[this.documents.length - 1].document = e.ku.document, ++t); return t !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = t, Object.assign({}, this.progress)) : null } $u(e) { const t = new Map, r = new wA(this.yt); for (const a of e) if (a.metadata.queries) { const d = r.Ji(a.metadata.name); for (const _ of a.metadata.queries) { const E = (t.get(_) || Ci()).add(d); t.set(_, E) } } return t } complete() { var e = this; return (0, cn.Z)(function* () { const t = yield function OM(n, e, t, r) { return CD.apply(this, arguments) }(e.localStore, new wA(e.yt), e.documents, e.Mu.id), r = e.$u(e.documents); for (const a of e.queries) yield NM(e.localStore, a, r.get(a.name)); return e.progress.taskState = "Success", { progress: e.progress, Bu: e.collectionGroups, Lu: t } })() } } function CA(n) { return { taskState: "Running", documentsLoaded: 0, bytesLoaded: 0, totalDocuments: n.totalDocuments, totalBytes: n.totalBytes } } class EA { constructor(e) { this.key = e } } class TA { constructor(e) { this.key = e } } class DA { constructor(e, t) { this.query = e, this.qu = t, this.Uu = null, this.hasCachedResults = !1, this.current = !1, this.Ku = Ci(), this.mutatedKeys = Ci(), this.Gu = GT(e), this.Qu = new Wv(this.Gu) } get ju() { return this.qu } Wu(e, t) { const r = t ? t.zu : new bA, a = t ? t.Qu : this.Qu; let d = t ? t.mutatedKeys : this.mutatedKeys, _ = a, E = !1; const x = "F" === this.query.limitType && a.size === this.query.limit ? a.last() : null, B = "L" === this.query.limitType && a.size === this.query.limit ? a.first() : null; if (e.inorderTraversal((K, oe) => { const Me = a.get(K), ot = sw(this.query, oe) ? oe : null, bt = !!Me && this.mutatedKeys.has(Me.key), qt = !!ot && (ot.hasLocalMutations || this.mutatedKeys.has(ot.key) && ot.hasCommittedMutations); let Tn = !1; Me && ot ? Me.data.isEqual(ot.data) ? bt !== qt && (r.track({ type: 3, doc: ot }), Tn = !0) : this.Hu(Me, ot) || (r.track({ type: 2, doc: ot }), Tn = !0, (x && this.Gu(ot, x) > 0 || B && this.Gu(ot, B) < 0) && (E = !0)) : !Me && ot ? (r.track({ type: 0, doc: ot }), Tn = !0) : Me && !ot && (r.track({ type: 1, doc: Me }), Tn = !0, (x || B) && (E = !0)), Tn && (ot ? (_ = _.add(ot), d = qt ? d.add(K) : d.delete(K)) : (_ = _.delete(K), d = d.delete(K))) }), null !== this.query.limit) for (; _.size > this.query.limit;) { const K = "F" === this.query.limitType ? _.last() : _.first(); _ = _.delete(K.key), d = d.delete(K.key), r.track({ type: 1, doc: K }) } return { Qu: _, zu: r, $i: E, mutatedKeys: d } } Hu(e, t) { return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations } applyChanges(e, t, r) { const a = this.Qu; this.Qu = e.Qu, this.mutatedKeys = e.mutatedKeys; const d = e.zu.Eu(); d.sort((B, K) => function (oe, Me) { const ot = bt => { switch (bt) { case 0: return 1; case 2: case 3: return 2; case 1: return 0; default: return rr() } }; return ot(oe) - ot(Me) }(B.type, K.type) || this.Gu(B.doc, K.doc)), this.Ju(r); const _ = t ? this.Yu() : [], E = 0 === this.Ku.size && this.current ? 1 : 0, x = E !== this.Uu; return this.Uu = E, 0 !== d.length || x ? { snapshot: new Zv(this.query, e.Qu, a, d, e.mutatedKeys, 0 === E, x, !1, !!r && r.resumeToken.approximateByteSize() > 0), Xu: _ } : { Xu: _ } } bu(e) { return this.current && "Offline" === e ? (this.current = !1, this.applyChanges({ Qu: this.Qu, zu: new bA, mutatedKeys: this.mutatedKeys, $i: !1 }, !1)) : { Xu: [] } } Zu(e) { return !this.qu.has(e) && !!this.Qu.has(e) && !this.Qu.get(e).hasLocalMutations } Ju(e) { e && (e.addedDocuments.forEach(t => this.qu = this.qu.add(t)), e.modifiedDocuments.forEach(t => { }), e.removedDocuments.forEach(t => this.qu = this.qu.delete(t)), this.current = e.current) } Yu() { if (!this.current) return []; const e = this.Ku; this.Ku = Ci(), this.Qu.forEach(r => { this.Zu(r.key) && (this.Ku = this.Ku.add(r.key)) }); const t = []; return e.forEach(r => { this.Ku.has(r) || t.push(new TA(r)) }), this.Ku.forEach(r => { e.has(r) || t.push(new EA(r)) }), t } tc(e) { this.qu = e.Hi, this.Ku = Ci(); const t = this.Wu(e.documents); return this.applyChanges(t, !0) } ec() { return Zv.fromInitialDocuments(this.query, this.Qu, this.mutatedKeys, 0 === this.Uu, this.hasCachedResults) } } class iO { constructor(e, t, r) { this.query = e, this.targetId = t, this.view = r } } class sO { constructor(e) { this.key = e, this.nc = !1 } } class oO { constructor(e, t, r, a, d, _) { this.localStore = e, this.remoteStore = t, this.eventManager = r, this.sharedClientState = a, this.currentUser = d, this.maxConcurrentLimboResolutions = _, this.sc = {}, this.ic = new sg(E => zT(E), am), this.rc = new Map, this.oc = new Set, this.uc = new Na(Gn.comparator), this.cc = new Map, this.ac = new gD, this.hc = {}, this.lc = new Map, this.fc = Y_.vn(), this.onlineState = "Unknown", this.dc = void 0 } get isPrimaryClient() { return !0 === this.dc } } function aO(n, e) { return eS.apply(this, arguments) } function eS() { return eS = (0, cn.Z)(function* (n, e) { const t = ES(n); let r, a; const d = t.ic.get(e); if (d) r = d.targetId, t.sharedClientState.addLocalQueryTarget(r), a = d.view.ec(); else { const _ = yield Uv(t.localStore, fu(e)); t.isPrimaryClient && bE(t.remoteStore, _); const E = t.sharedClientState.addLocalQueryTarget(_.targetId); r = _.targetId, a = yield tS(t, e, r, "current" === E, _.resumeToken) } return a }), eS.apply(this, arguments) } function tS(n, e, t, r, a) { return nS.apply(this, arguments) } function nS() { return nS = (0, cn.Z)(function* (n, e, t, r, a) { n._c = (oe, Me, ot) => { return (bt = (0, cn.Z)(function* (qt, Tn, cr, $r) { let Rr = Tn.view.Wu(cr); Rr.$i && (Rr = yield mE(qt.localStore, Tn.query, !1).then(({ documents: Pi }) => Tn.view.Wu(Pi, Rr))); const Li = $r && $r.targetChanges.get(Tn.targetId), Ki = Tn.view.applyChanges(Rr, qt.isPrimaryClient, Li); return hS(qt, Tn.targetId, Ki.Xu), Ki.snapshot }), function (qt, Tn, cr, $r) { return bt.apply(this, arguments) })(n, oe, Me, ot); var bt }; const d = yield mE(n.localStore, e, !0), _ = new DA(e, d.Hi), E = _.Wu(d.documents), x = og.createSynthesizedTargetChangeForCurrentChange(t, r && "Offline" !== n.onlineState, a), B = _.applyChanges(E, n.isPrimaryClient, x); hS(n, t, B.Xu); const K = new iO(e, t, _); return n.ic.set(e, K), n.rc.has(t) ? n.rc.get(t).push(e) : n.rc.set(t, [e]), B.snapshot }), nS.apply(this, arguments) } function lO(n, e) { return rS.apply(this, arguments) } function rS() { return rS = (0, cn.Z)(function* (n, e) { const t = Wn(n), r = t.ic.get(e), a = t.rc.get(r.targetId); if (a.length > 1) return t.rc.set(r.targetId, a.filter(d => !am(d, e))), void t.ic.delete(e); t.isPrimaryClient ? (t.sharedClientState.removeLocalQueryTarget(r.targetId), t.sharedClientState.isActiveQueryTarget(r.targetId) || (yield Hv(t.localStore, r.targetId, !1).then(() => { t.sharedClientState.clearQueryState(r.targetId), xw(t.remoteStore, r.targetId), qv(t, r.targetId) }).catch(wf))) : (qv(t, r.targetId), yield Hv(t.localStore, r.targetId, !0)) }), rS.apply(this, arguments) } function iS() { return iS = (0, cn.Z)(function* (n, e, t) { const r = TS(n); try { const a = yield function (d, _) { const E = Wn(d), x = Vo.now(), B = _.reduce((Me, ot) => Me.add(ot.key), Ci()); let K, oe; return E.persistence.runTransaction("Locally write mutations", "readwrite", Me => { let ot = Ru(), bt = Ci(); return E.Gi.getEntries(Me, B).next(qt => { ot = qt, ot.forEach((Tn, cr) => { cr.isValidDocument() || (bt = bt.add(Tn)) }) }).next(() => E.localDocuments.getOverlayedDocuments(Me, ot)).next(qt => { K = qt; const Tn = []; for (const cr of _) { const $r = qT(cr, K.get(cr.key).overlayedDocument); null != $r && Tn.push(new pu(cr.key, $r, GC($r.value.mapValue), fa.exists(!0))) } return E.mutationQueue.addMutationBatch(Me, x, Tn, _) }).next(qt => { oe = qt; const Tn = qt.applyToLocalDocumentSet(K, bt); return E.documentOverlayCache.saveOverlays(Me, qt.batchId, Tn) }) }).then(() => ({ batchId: oe.batchId, changes: XC(K) })) }(r.localStore, e); r.sharedClientState.addPendingMutation(a.batchId), function (d, _, E) { let x = d.hc[d.currentUser.toKey()]; x || (x = new Na(ai)), x = x.insert(_, E), d.hc[d.currentUser.toKey()] = x }(r, a.batchId, t), yield lg(r, a.changes), yield Gv(r.remoteStore) } catch (a) { const d = $v(a, "Failed to persist write"); t.reject(d) } }), iS.apply(this, arguments) } function SA(n, e) { return sS.apply(this, arguments) } function sS() { return sS = (0, cn.Z)(function* (n, e) { const t = Wn(n); try { const r = yield xM(t.localStore, e); e.targetChanges.forEach((a, d) => { const _ = t.cc.get(d); _ && (mr(a.addedDocuments.size + a.modifiedDocuments.size + a.removedDocuments.size <= 1), a.addedDocuments.size > 0 ? _.nc = !0 : a.modifiedDocuments.size > 0 ? mr(_.nc) : a.removedDocuments.size > 0 && (mr(_.nc), _.nc = !1)) }), yield lg(t, r, e) } catch (r) { yield wf(r) } }), sS.apply(this, arguments) } function IA(n, e, t) { const r = Wn(n); if (r.isPrimaryClient && 0 === t || !r.isPrimaryClient && 1 === t) { const a = []; r.ic.forEach((d, _) => { const E = _.view.bu(e); E.snapshot && a.push(E.snapshot) }), function (d, _) { const E = Wn(d); E.onlineState = _; let x = !1; E.queries.forEach((B, K) => { for (const oe of K.listeners) oe.bu(_) && (x = !0) }), x && QD(E) }(r.eventManager, e), a.length && r.sc.Wo(a), r.onlineState = e, r.isPrimaryClient && r.sharedClientState.setOnlineState(e) } } function uO(n, e, t) { return oS.apply(this, arguments) } function oS() { return oS = (0, cn.Z)(function* (n, e, t) { const r = Wn(n); r.sharedClientState.updateQueryState(e, "rejected", t); const a = r.cc.get(e), d = a && a.key; if (d) { let _ = new Na(Gn.comparator); _ = _.insert(d, yo.newNoDocument(d, Ar.min())); const E = Ci().add(d), x = new um(Ar.min(), new Map, new _o(ai), _, E); yield SA(r, x), r.uc = r.uc.remove(d), r.cc.delete(e), fS(r) } else yield Hv(r.localStore, e, !1).then(() => qv(r, e, t)).catch(wf) }), oS.apply(this, arguments) } function dO(n, e) { return aS.apply(this, arguments) } function aS() { return aS = (0, cn.Z)(function* (n, e) { const t = Wn(n), r = e.batch.batchId; try { const a = yield AM(t.localStore, e); dS(t, r, null), uS(t, r), t.sharedClientState.updateMutationState(r, "acknowledged"), yield lg(t, a) } catch (a) { yield wf(a) } }), aS.apply(this, arguments) } function hO(n, e, t) { return lS.apply(this, arguments) } function lS() { return lS = (0, cn.Z)(function* (n, e, t) { const r = Wn(n); try { const a = yield function (d, _) { const E = Wn(d); return E.persistence.runTransaction("Reject batch", "readwrite-primary", x => { let B; return E.mutationQueue.lookupMutationBatch(x, _).next(K => (mr(null !== K), B = K.keys(), E.mutationQueue.removeMutationBatch(x, K))).next(() => E.mutationQueue.performConsistencyCheck(x)).next(() => E.documentOverlayCache.removeOverlaysForBatchId(x, B, _)).next(() => E.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(x, B)).next(() => E.localDocuments.getDocuments(x, B)) }) }(r.localStore, e); dS(r, e, t), uS(r, e), r.sharedClientState.updateMutationState(e, "rejected", t), yield lg(r, a) } catch (a) { yield wf(a) } }), lS.apply(this, arguments) } function cS() { return cS = (0, cn.Z)(function* (n, e) { const t = Wn(n); ag(t.remoteStore) || Mn("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled."); try { const r = yield function (d) { const _ = Wn(d); return _.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", E => _.mutationQueue.getHighestUnacknowledgedBatchId(E)) }(t.localStore); if (-1 === r) return void e.resolve(); const a = t.lc.get(r) || []; a.push(e), t.lc.set(r, a) } catch (r) { const a = $v(r, "Initialization of waitForPendingWrites() operation failed"); e.reject(a) } }), cS.apply(this, arguments) } function uS(n, e) { (n.lc.get(e) || []).forEach(t => { t.resolve() }), n.lc.delete(e) } function dS(n, e, t) { const r = Wn(n); let a = r.hc[r.currentUser.toKey()]; if (a) { const d = a.get(e); d && (t ? d.reject(t) : d.resolve(), a = a.remove(e)), r.hc[r.currentUser.toKey()] = a } } function qv(n, e, t = null) { n.sharedClientState.removeLocalQueryTarget(e); for (const r of n.rc.get(e)) n.ic.delete(r), t && n.sc.wc(r, t); n.rc.delete(e), n.isPrimaryClient && n.ac.ls(e).forEach(r => { n.ac.containsKey(r) || AA(n, r) }) } function AA(n, e) { n.oc.delete(e.path.canonicalString()); const t = n.uc.get(e); null !== t && (xw(n.remoteStore, t), n.uc = n.uc.remove(e), n.cc.delete(t), fS(n)) } function hS(n, e, t) { for (const r of t) r instanceof EA ? (n.ac.addReference(r.key, e), pO(n, r)) : r instanceof TA ? (Mn("SyncEngine", "Document no longer in limbo: " + r.key), n.ac.removeReference(r.key, e), n.ac.containsKey(r.key) || AA(n, r.key)) : rr() } function pO(n, e) { const t = e.key, r = t.path.canonicalString(); n.uc.get(t) || n.oc.has(r) || (Mn("SyncEngine", "New document in limbo: " + t), n.oc.add(r), fS(n)) } function fS(n) { for (; n.oc.size > 0 && n.uc.size < n.maxConcurrentLimboResolutions;) { const e = n.oc.values().next().value; n.oc.delete(e); const t = new Gn(is.fromString(e)), r = n.fc.next(); n.cc.set(r, new sO(t)), n.uc = n.uc.insert(t, r), bE(n.remoteStore, new dm(fu(Xp(t.path)), r, 2, id.at)) } } function lg(n, e, t) { return pS.apply(this, arguments) } function pS() { return pS = (0, cn.Z)(function* (n, e, t) { const r = Wn(n), a = [], d = [], _ = []; var E; r.ic.isEmpty() || (r.ic.forEach((E, x) => { _.push(r._c(x, e, t).then(B => { if ((B || t) && r.isPrimaryClient && r.sharedClientState.updateQueryState(x.targetId, B?.fromCache ? "not-current" : "current"), B) { a.push(B); const K = vD.Ci(x.targetId, B); d.push(K) } })) }), yield Promise.all(_), r.sc.Wo(a), yield (E = (0, cn.Z)(function* (x, B) { const K = Wn(x); try { yield K.persistence.runTransaction("notifyLocalViewChanges", "readwrite", oe => Qt.forEach(B, Me => Qt.forEach(Me.Si, ot => K.persistence.referenceDelegate.addReference(oe, Me.targetId, ot)).next(() => Qt.forEach(Me.Di, ot => K.persistence.referenceDelegate.removeReference(oe, Me.targetId, ot))))) } catch (oe) { if (!sh(oe)) throw oe; Mn("LocalStore", "Failed to update sequence numbers: " + oe) } for (const oe of B) { const Me = oe.targetId; if (!oe.fromCache) { const ot = K.qi.get(Me), qt = ot.withLastLimboFreeSnapshotVersion(ot.snapshotVersion); K.qi = K.qi.insert(Me, qt) } } }), function (x, B) { return E.apply(this, arguments) })(r.localStore, d)) }), pS.apply(this, arguments) } function gO(n, e) { return gS.apply(this, arguments) } function gS() { return gS = (0, cn.Z)(function* (n, e) { const t = Wn(n); if (!t.currentUser.isEqual(e)) { Mn("SyncEngine", "User change. New user:", e.toKey()); const r = yield nA(t.localStore, e); t.currentUser = e, (a = t).lc.forEach(_ => { _.forEach(E => { E.reject(new Cn(en.CANCELLED, "'waitForPendingWrites' promise is rejected due to a user change.")) }) }), a.lc.clear(), t.sharedClientState.handleUserChange(e, r.removedBatchIds, r.addedBatchIds), yield lg(t, r.ji) } var a }), gS.apply(this, arguments) } function mO(n, e) { const t = Wn(n), r = t.cc.get(e); if (r && r.nc) return Ci().add(r.key); { let a = Ci(); const d = t.rc.get(e); if (!d) return a; for (const _ of d) { const E = t.ic.get(_); a = a.unionWith(E.view.ju) } return a } } function _O(n, e) { return mS.apply(this, arguments) } function mS() { return mS = (0, cn.Z)(function* (n, e) { const t = Wn(n), r = yield mE(t.localStore, e.query, !0), a = e.view.tc(r); return t.isPrimaryClient && hS(t, e.targetId, a.Xu), a }), mS.apply(this, arguments) } function yO(n, e) { return _S.apply(this, arguments) } function _S() { return _S = (0, cn.Z)(function* (n, e) { const t = Wn(n); return oA(t.localStore, e).then(r => lg(t, r)) }), _S.apply(this, arguments) } function vO(n, e, t, r) { return yS.apply(this, arguments) } function yS() { return yS = (0, cn.Z)(function* (n, e, t, r) { const a = Wn(n), d = yield function (_, E) { const x = Wn(_), B = Wn(x.mutationQueue); return x.persistence.runTransaction("Lookup mutation documents", "readonly", K => B.Tn(K, E).next(oe => oe ? x.localDocuments.getDocuments(K, oe) : Qt.resolve(null))) }(a.localStore, e); var E; null !== d ? ("pending" === t ? yield Gv(a.remoteStore) : "acknowledged" === t || "rejected" === t ? (dS(a, e, r || null), uS(a, e), E = e, Wn(Wn(a.localStore).mutationQueue).An(E)) : rr(), yield lg(a, d)) : Mn("SyncEngine", "Cannot apply mutation batch with id: " + e) }), yS.apply(this, arguments) } function vS() { return vS = (0, cn.Z)(function* (n, e) { const t = Wn(n); if (ES(t), TS(t), !0 === e && !0 !== t.dc) { const r = t.sharedClientState.getAllActiveQueryTargets(), a = yield xA(t, r.toArray()); t.dc = !0, yield $D(t.remoteStore, !0); for (const d of a) bE(t.remoteStore, d) } else if (!1 === e && !1 !== t.dc) { const r = []; let a = Promise.resolve(); t.rc.forEach((d, _) => { t.sharedClientState.isLocalQueryTarget(_) ? r.push(_) : a = a.then(() => (qv(t, _), Hv(t.localStore, _, !0))), xw(t.remoteStore, _) }), yield a, yield xA(t, r), function (d) { const _ = Wn(d); _.cc.forEach((E, x) => { xw(_.remoteStore, x) }), _.ac.fs(), _.cc = new Map, _.uc = new Na(Gn.comparator) }(t), t.dc = !1, yield $D(t.remoteStore, !1) } }), vS.apply(this, arguments) } function xA(n, e, t) { return bS.apply(this, arguments) } function bS() { return bS = (0, cn.Z)(function* (n, e, t) { const r = Wn(n), a = [], d = []; for (const _ of e) { let E; const x = r.rc.get(_); if (x && 0 !== x.length) { E = yield Uv(r.localStore, fu(x[0])); for (const B of x) { const K = r.ic.get(B), oe = yield _O(r, K); oe.snapshot && d.push(oe.snapshot) } } else { const B = yield sA(r.localStore, _); E = yield Uv(r.localStore, B), yield tS(r, MA(B), _, !1, E.resumeToken) } a.push(E) } return r.sc.Wo(d), a }), bS.apply(this, arguments) } function MA(n) { return Df(n.path, n.collectionGroup, n.orderBy, n.filters, n.limit, "F", n.startAt, n.endAt) } function wO(n) { const e = Wn(n); return Wn(Wn(e.localStore).persistence).vi() } function CO(n, e, t, r) { return wS.apply(this, arguments) } function wS() { return wS = (0, cn.Z)(function* (n, e, t, r) { const a = Wn(n); if (a.dc) return void Mn("SyncEngine", "Ignoring unexpected query state notification."); const d = a.rc.get(e); if (d && d.length > 0) switch (t) { case "current": case "not-current": { const _ = yield oA(a.localStore, ow(d[0])), E = um.createSynthesizedRemoteEventForCurrentChange(e, "current" === t, sl.EMPTY_BYTE_STRING); yield lg(a, _, E); break } case "rejected": yield Hv(a.localStore, e, !0), qv(a, e, r); break; default: rr() } }), wS.apply(this, arguments) } function EO(n, e, t) { return CS.apply(this, arguments) } function CS() { return CS = (0, cn.Z)(function* (n, e, t) { const r = ES(n); if (r.dc) { for (const a of e) { if (r.rc.has(a)) { Mn("SyncEngine", "Adding an already active target " + a); continue } const d = yield sA(r.localStore, a), _ = yield Uv(r.localStore, d); yield tS(r, MA(d), _.targetId, !1, _.resumeToken), bE(r.remoteStore, _) } for (const a of t) r.rc.has(a) && (yield Hv(r.localStore, a, !1).then(() => { xw(r.remoteStore, a), qv(r, a) }).catch(wf)) } }), CS.apply(this, arguments) } function ES(n) { const e = Wn(n); return e.remoteStore.remoteSyncer.applyRemoteEvent = SA.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = mO.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = uO.bind(null, e), e.sc.Wo = eO.bind(null, e.eventManager), e.sc.wc = tO.bind(null, e.eventManager), e } function TS(n) { const e = Wn(n); return e.remoteStore.remoteSyncer.applySuccessfulWrite = dO.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = hO.bind(null, e), e } class OA { constructor() { this.synchronizeTabs = !1 } initialize(e) { var t = this; return (0, cn.Z)(function* () { t.yt = Iw(e.databaseInfo.databaseId), t.sharedClientState = t.gc(e), t.persistence = t.yc(e), yield t.persistence.start(), t.localStore = t.Ic(e), t.gcScheduler = t.Tc(e, t.localStore), t.indexBackfillerScheduler = t.Ec(e, t.localStore) })() } Tc(e, t) { return null } Ec(e, t) { return null } Ic(e) { return tA(this.persistence, new eA, e.initialUser, this.yt) } yc(e) { return new QI(pE.Bs, this.yt) } gc(e) { return new uA } terminate() { var e = this; return (0, cn.Z)(function* () { e.gcScheduler && e.gcScheduler.stop(), yield e.sharedClientState.shutdown(), yield e.persistence.shutdown() })() } } class NA extends OA { constructor(e, t, r) { super(), this.Ac = e, this.cacheSizeBytes = t, this.forceOwnership = r, this.synchronizeTabs = !1 } initialize(e) { var t = () => super.initialize, r = this; return (0, cn.Z)(function* () { yield t().call(r, e), yield r.Ac.initialize(r, e), yield TS(r.Ac.syncEngine), yield Gv(r.Ac.remoteStore), yield r.persistence.li(() => (r.gcScheduler && !r.gcScheduler.started && r.gcScheduler.start(), r.indexBackfillerScheduler && !r.indexBackfillerScheduler.started && r.indexBackfillerScheduler.start(), Promise.resolve())) })() } Ic(e) { return tA(this.persistence, new eA, e.initialUser, this.yt) } Tc(e, t) { return new fM(this.persistence.referenceDelegate.garbageCollector, e.asyncQueue, t) } Ec(e, t) { const r = new nm(t, this.persistence); return new AC(e.asyncQueue, r) } yc(e) { const t = yD(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey), r = void 0 !== this.cacheSizeBytes ? Ld.withCacheSize(this.cacheSizeBytes) : Ld.DEFAULT; return new _D(this.synchronizeTabs, t, e.clientId, r, e.asyncQueue, hA(), vE(), this.yt, this.sharedClientState, !!this.forceOwnership) } gc(e) { return new uA } } class DO extends NA { constructor(e, t) { super(e, t, !1), this.Ac = e, this.cacheSizeBytes = t, this.synchronizeTabs = !0 } initialize(e) { var t = () => super.initialize, r = this; return (0, cn.Z)(function* () { yield t().call(r, e); const a = r.Ac.syncEngine; r.sharedClientState instanceof ID && (r.sharedClientState.syncEngine = { Fr: vO.bind(null, a), $r: CO.bind(null, a), Br: EO.bind(null, a), vi: wO.bind(null, a), Mr: yO.bind(null, a) }, yield r.sharedClientState.start()), yield r.persistence.li(function () { var d = (0, cn.Z)(function* (_) { yield function bO(n, e) { return vS.apply(this, arguments) }(r.Ac.syncEngine, _), r.gcScheduler && (_ && !r.gcScheduler.started ? r.gcScheduler.start() : _ || r.gcScheduler.stop()), r.indexBackfillerScheduler && (_ && !r.indexBackfillerScheduler.started ? r.indexBackfillerScheduler.start() : _ || r.indexBackfillerScheduler.stop()) }); return function (_) { return d.apply(this, arguments) } }()) })() } gc(e) { const t = hA(); if (!ID.C(t)) throw new Cn(en.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage."); const r = yD(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey); return new ID(t, e.asyncQueue, r, e.clientId, e.initialUser) } } class DS { initialize(e, t) { var r = this; return (0, cn.Z)(function* () { r.localStore || (r.localStore = e.localStore, r.sharedClientState = e.sharedClientState, r.datastore = r.createDatastore(t), r.remoteStore = r.createRemoteStore(t), r.eventManager = r.createEventManager(t), r.syncEngine = r.createSyncEngine(t, !e.synchronizeTabs), r.sharedClientState.onlineStateHandler = a => IA(r.syncEngine, a, 1), r.remoteStore.remoteSyncer.handleCredentialChange = gO.bind(null, r.syncEngine), yield $D(r.remoteStore, r.syncEngine.isPrimaryClient)) })() } createEventManager(e) { return new XM } createDatastore(e) { const t = Iw(e.databaseInfo.databaseId), r = new FM(e.databaseInfo); return new VM(e.authCredentials, e.appCheckCredentials, r, t) } createRemoteStore(e) { return t = this.localStore, r = this.datastore, a = e.asyncQueue, d = E => IA(this.syncEngine, E, 0), _ = dA.C() ? new dA : new kM, new zM(t, r, a, d, _); var t, r, a, d, _ } createSyncEngine(e, t) { return function (r, a, d, _, E, x, B) { const K = new oO(r, a, d, _, E, x); return B && (K.dc = !0), K }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t) } terminate() { return (e = (0, cn.Z)(function* (t) { const r = Wn(t); Mn("RemoteStore", "RemoteStore shutting down."), r._u.add(5), yield zv(r), r.mu.shutdown(), r.gu.set("Unknown") }), function (t) { return e.apply(this, arguments) })(this.remoteStore); var e } } function SS(n, e, t) { if (!t) throw new Cn(en.INVALID_ARGUMENT, `Function ${n}() cannot be called with an empty ${e}.`) } function kA(n, e, t, r) { if (!0 === e && !0 === r) throw new Cn(en.INVALID_ARGUMENT, `${n} and ${t} cannot be used together.`) } function PA(n) { if (!Gn.isDocumentKey(n)) throw new Cn(en.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`) } function RA(n) { if (Gn.isDocumentKey(n)) throw new Cn(en.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`) } function CE(n) { if (void 0 === n) return "undefined"; if (null === n) return "null"; if ("string" == typeof n) return n.length > 20 && (n = `${n.substring(0, 20)}...`), JSON.stringify(n); if ("number" == typeof n || "boolean" == typeof n) return "" + n; if ("object" == typeof n) { if (n instanceof Array) return "an array"; { const e = (t = n).constructor ? t.constructor.name : null; return e ? `a custom ${e} object` : "an object" } } var t; return "function" == typeof n ? "a function" : rr() } function ms(n, e) { if ("_delegate" in n && (n = n._delegate), !(n instanceof e)) { if (e.name === n.constructor.name) throw new Cn(en.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); { const t = CE(n); throw new Cn(en.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${t}`) } } return n } function FA(n, e) { if (e <= 0) throw new Cn(en.INVALID_ARGUMENT, `Function ${n}() requires a positive number, but it was: ${e}.`) } const LA = new Map; class BA { constructor(e) { var t; if (void 0 === e.host) { if (void 0 !== e.ssl) throw new Cn(en.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set"); this.host = "firestore.googleapis.com", this.ssl = !0 } else this.host = e.host, this.ssl = null === (t = e.ssl) || void 0 === t || t; if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, void 0 === e.cacheSizeBytes) this.cacheSizeBytes = 41943040; else { if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576) throw new Cn(en.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576"); this.cacheSizeBytes = e.cacheSizeBytes } this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.useFetchStreams = !!e.useFetchStreams, kA("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling) } isEqual(e) { return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams } } class Mw { constructor(e, t, r, a) { this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = r, this._app = a, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new BA({}), this._settingsFrozen = !1 } get app() { if (!this._app) throw new Cn(en.FAILED_PRECONDITION, "Firestore was not initialized using the MasterSDK. 'app' is not available"); return this._app } get _initialized() { return this._settingsFrozen } get _terminated() { return void 0 !== this._terminateTask } _setSettings(e) { if (this._settingsFrozen) throw new Cn(en.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."); this._settings = new BA(e), void 0 !== e.credentials && (this._authCredentials = function (t) { if (!t) return new Vb; switch (t.type) { case "gapi": return new zb(t.client, t.sessionIndex || "0", t.iamToken || null, t.authTokenFactory || null); case "provider": return t.client; default: throw new Cn(en.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type") } }(e.credentials)) } _getSettings() { return this._settings } _freezeSettings() { return this._settingsFrozen = !0, this._settings } _delete() { return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask } toJSON() { return { app: this._app, databaseId: this._databaseId, settings: this._settings } } _terminate() { return function (e) { const t = LA.get(e); t && (Mn("ComponentProvider", "Removing Datastore"), LA.delete(e), t.terminate()) }(this), Promise.resolve() } } class ga { constructor(e, t, r) { this.converter = t, this._key = r, this.type = "document", this.firestore = e } get _path() { return this._key.path } get id() { return this._key.path.lastSegment() } get path() { return this._key.path.canonicalString() } get parent() { return new lp(this.firestore, this.converter, this._key.path.popLast()) } withConverter(e) { return new ga(this.firestore, e, this._key) } } class gu { constructor(e, t, r) { this.converter = t, this._query = r, this.type = "query", this.firestore = e } withConverter(e) { return new gu(this.firestore, e, this._query) } } class lp extends gu { constructor(e, t, r) { super(e, t, Xp(r)), this._path = r, this.type = "collection" } get id() { return this._query.path.lastSegment() } get path() { return this._query.path.canonicalString() } get parent() { const e = this._path.popLast(); return e.isEmpty() ? null : new ga(this.firestore, null, new Gn(e)) } withConverter(e) { return new lp(this.firestore, e, this._path) } } function UA(n, e, ...t) { if (n = (0, Pe.m9)(n), SS("collection", "path", e), n instanceof Mw) { const r = is.fromString(e, ...t); return RA(r), new lp(n, null, r) } { if (!(n instanceof ga || n instanceof lp)) throw new Cn(en.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const r = n._path.child(is.fromString(e, ...t)); return RA(r), new lp(n.firestore, null, r) } } function EE(n, e, ...t) { if (n = (0, Pe.m9)(n), 1 === arguments.length && (e = Gb.R()), SS("doc", "path", e), n instanceof Mw) { const r = is.fromString(e, ...t); return PA(r), new ga(n, null, new Gn(r)) } { if (!(n instanceof ga || n instanceof lp)) throw new Cn(en.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const r = n._path.child(is.fromString(e, ...t)); return PA(r), new ga(n.firestore, n instanceof lp ? n.converter : null, new Gn(r)) } } function HA(n, e) { return n = (0, Pe.m9)(n), e = (0, Pe.m9)(e), (n instanceof ga || n instanceof lp) && (e instanceof ga || e instanceof lp) && n.firestore === e.firestore && n.path === e.path && n.converter === e.converter } function IS(n, e) { return n = (0, Pe.m9)(n), e = (0, Pe.m9)(e), n instanceof gu && e instanceof gu && n.firestore === e.firestore && am(n._query, e._query) && n.converter === e.converter } function zA(n, e = 10240) { let t = 0; return { read: () => (0, cn.Z)(function* () { if (t < n.byteLength) { const r = { value: n.slice(t, t + e), done: !1 }; return t += e, r } return { done: !0 } })(), cancel: () => (0, cn.Z)(function* () { })(), releaseLock() { }, closed: Promise.reject("unimplemented") } } class TE { constructor(e) { this.observer = e, this.muted = !1 } next(e) { this.observer.next && this.Rc(this.observer.next, e) } error(e) { this.observer.error ? this.Rc(this.observer.error, e) : Ga("Uncaught Error in snapshot listener:", e.toString()) } bc() { this.muted = !0 } Rc(e, t) { this.muted || setTimeout(() => { this.muted || e(t) }, 0) } } class IO { constructor(e, t) { this.Pc = e, this.yt = t, this.metadata = new ja, this.buffer = new Uint8Array, this.vc = new TextDecoder("utf-8"), this.Vc().then(r => { r && r.Ou() ? this.metadata.resolve(r.ku.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(r?.ku)}`)) }, r => this.metadata.reject(r)) } close() { return this.Pc.cancel() } getMetadata() { var e = this; return (0, cn.Z)(function* () { return e.metadata.promise })() } mc() { var e = this; return (0, cn.Z)(function* () { return yield e.getMetadata(), e.Vc() })() } Vc() { var e = this; return (0, cn.Z)(function* () { const t = yield e.Sc(); if (null === t) return null; const r = e.vc.decode(t), a = Number(r); isNaN(a) && e.Dc(`length string (${r}) is not valid number`); const d = yield e.Cc(a); return new nO(JSON.parse(d), t.length + a) })() } xc() { return this.buffer.findIndex(e => e === "{".charCodeAt(0)) } Sc() { var e = this; return (0, cn.Z)(function* () { for (; e.xc() < 0 && !(yield e.Nc());); if (0 === e.buffer.length) return null; const t = e.xc(); t < 0 && e.Dc("Reached the end of bundle when a length string is expected."); const r = e.buffer.slice(0, t); return e.buffer = e.buffer.slice(t), r })() } Cc(e) { var t = this; return (0, cn.Z)(function* () { for (; t.buffer.length < e;)(yield t.Nc()) && t.Dc("Reached the end of bundle when more is expected."); const r = t.vc.decode(t.buffer.slice(0, e)); return t.buffer = t.buffer.slice(e), r })() } Dc(e) { throw this.Pc.cancel(), new Error(`Invalid bundle format: ${e}`) } Nc() { var e = this; return (0, cn.Z)(function* () { const t = yield e.Pc.read(); if (!t.done) { const r = new Uint8Array(e.buffer.length + t.value.length); r.set(e.buffer), r.set(t.value, e.buffer.length), e.buffer = r } return t.done })() } } class MO { constructor(e) { this.datastore = e, this.readVersions = new Map, this.mutations = [], this.committed = !1, this.lastWriteError = null, this.writtenDocs = new Set } lookup(e) { var t = this; return (0, cn.Z)(function* () { if (t.ensureCommitNotCalled(), t.mutations.length > 0) throw new Cn(en.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes."); const r = yield (a = (0, cn.Z)(function* (d, _) { const E = Wn(d), x = u(E.yt) + "/documents", B = { documents: _.map(ot => G_(E.yt, ot)) }, K = yield E._o("BatchGetDocuments", x, B, _.length), oe = new Map; K.forEach(ot => { const bt = function N(n, e) { return "found" in e ? function (t, r) { mr(!!r.found); const a = Sf(t, r.found.name), d = ol(r.found.updateTime), _ = r.found.createTime ? ol(r.found.createTime) : Ar.min(), E = new vc({ mapValue: { fields: r.found.fields } }); return yo.newFoundDocument(a, d, _, E) }(n, e) : "missing" in e ? function (t, r) { mr(!!r.missing), mr(!!r.readTime); const a = Sf(t, r.missing), d = ol(r.readTime); return yo.newNoDocument(a, d) }(n, e) : rr() }(E.yt, ot); oe.set(bt.key.toString(), bt) }); const Me = []; return _.forEach(ot => { const bt = oe.get(ot.toString()); mr(!!bt), Me.push(bt) }), Me }), function (d, _) { return a.apply(this, arguments) })(t.datastore, e); var a; return r.forEach(a => t.recordVersion(a)), r })() } set(e, t) { this.write(t.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } update(e, t) { try { this.write(t.toMutation(e, this.preconditionForUpdate(e))) } catch (r) { this.lastWriteError = r } this.writtenDocs.add(e.toString()) } delete(e) { this.write(new lm(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } commit() { var e = this; return (0, cn.Z)(function* () { if (e.ensureCommitNotCalled(), e.lastWriteError) throw e.lastWriteError; const t = e.readVersions; var r; e.mutations.forEach(r => { t.delete(r.key.toString()) }), t.forEach((r, a) => { const d = Gn.fromPath(a); e.mutations.push(new U_(d, e.precondition(d))) }), yield (r = (0, cn.Z)(function* (a, d) { const _ = Wn(a), E = u(_.yt) + "/documents", x = { writes: d.map(B => j(_.yt, B)) }; yield _.ao("Commit", E, x) }), function (a, d) { return r.apply(this, arguments) })(e.datastore, e.mutations), e.committed = !0 })() } recordVersion(e) { let t; if (e.isFoundDocument()) t = e.version; else { if (!e.isNoDocument()) throw rr(); t = Ar.min() } const r = this.readVersions.get(e.key.toString()); if (r) { if (!t.isEqual(r)) throw new Cn(en.ABORTED, "Document version changed between two reads.") } else this.readVersions.set(e.key.toString(), t) } precondition(e) { const t = this.readVersions.get(e.toString()); return !this.writtenDocs.has(e.toString()) && t ? t.isEqual(Ar.min()) ? fa.exists(!1) : fa.updateTime(t) : fa.none() } preconditionForUpdate(e) { const t = this.readVersions.get(e.toString()); if (!this.writtenDocs.has(e.toString()) && t) { if (t.isEqual(Ar.min())) throw new Cn(en.INVALID_ARGUMENT, "Can't update a document that doesn't exist."); return fa.updateTime(t) } return fa.exists(!0) } write(e) { this.ensureCommitNotCalled(), this.mutations.push(e) } ensureCommitNotCalled() { } } class OO { constructor(e, t, r, a, d) { this.asyncQueue = e, this.datastore = t, this.options = r, this.updateFunction = a, this.deferred = d, this.kc = r.maxAttempts, this.xo = new AD(this.asyncQueue, "transaction_retry") } run() { this.kc -= 1, this.Oc() } Oc() { var e = this; this.xo.Ro((0, cn.Z)(function* () { const t = new MO(e.datastore), r = e.Mc(t); r && r.then(a => { e.asyncQueue.enqueueAndForget(() => t.commit().then(() => { e.deferred.resolve(a) }).catch(d => { e.Fc(d) })) }).catch(a => { e.Fc(a) }) })) } Mc(e) { try { const t = this.updateFunction(e); return !T_(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")), null) } catch (t) { return this.deferred.reject(t), null } } Fc(e) { this.kc > 0 && this.$c(e) ? (this.kc -= 1, this.asyncQueue.enqueueAndForget(() => (this.Oc(), Promise.resolve()))) : this.deferred.reject(e) } $c(e) { if ("FirebaseError" === e.name) { const t = e.code; return "aborted" === t || "failed-precondition" === t || "already-exists" === t || !YT(t) } return !1 } } class NO { constructor(e, t, r, a) { var d = this; this.authCredentials = e, this.appCheckCredentials = t, this.asyncQueue = r, this.databaseInfo = a, this.user = $l.UNAUTHENTICATED, this.clientId = Gb.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(r, function () { var _ = (0, cn.Z)(function* (E) { Mn("FirestoreClient", "Received user=", E.uid), yield d.authCredentialListener(E), d.user = E }); return function (E) { return _.apply(this, arguments) } }()), this.appCheckCredentials.start(r, _ => (Mn("FirestoreClient", "Received new app check token=", _), this.appCheckCredentialListener(_, this.user))) } getConfiguration() { var e = this; return (0, cn.Z)(function* () { return { asyncQueue: e.asyncQueue, databaseInfo: e.databaseInfo, clientId: e.clientId, authCredentials: e.authCredentials, appCheckCredentials: e.appCheckCredentials, initialUser: e.user, maxConcurrentLimboResolutions: 100 } })() } setCredentialChangeListener(e) { this.authCredentialListener = e } setAppCheckTokenChangeListener(e) { this.appCheckCredentialListener = e } verifyNotTerminated() { if (this.asyncQueue.isShuttingDown) throw new Cn(en.FAILED_PRECONDITION, "The client has already been terminated.") } terminate() { var e = this; this.asyncQueue.enterRestrictedMode(); const t = new ja; return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((0, cn.Z)(function* () { try { e.onlineComponents && (yield e.onlineComponents.terminate()), e.offlineComponents && (yield e.offlineComponents.terminate()), e.authCredentials.shutdown(), e.appCheckCredentials.shutdown(), t.resolve() } catch (r) { const a = $v(r, "Failed to shutdown persistence"); t.reject(a) } })), t.promise } } function GA(n, e) { return AS.apply(this, arguments) } function AS() { return AS = (0, cn.Z)(function* (n, e) { n.asyncQueue.verifyOperationInProgress(), Mn("FirestoreClient", "Initializing OfflineComponentProvider"); const t = yield n.getConfiguration(); yield e.initialize(t); let r = t.initialUser; n.setCredentialChangeListener(function () { var a = (0, cn.Z)(function* (d) { r.isEqual(d) || (yield nA(e.localStore, d), r = d) }); return function (d) { return a.apply(this, arguments) } }()), e.persistence.setDatabaseDeletedListener(() => n.terminate()), n.offlineComponents = e }), AS.apply(this, arguments) } function jA(n, e) { return xS.apply(this, arguments) } function xS() { return xS = (0, cn.Z)(function* (n, e) { n.asyncQueue.verifyOperationInProgress(); const t = yield MS(n); Mn("FirestoreClient", "Initializing OnlineComponentProvider"); const r = yield n.getConfiguration(); yield e.initialize(t, r), n.setCredentialChangeListener(a => vA(e.remoteStore, a)), n.setAppCheckTokenChangeListener((a, d) => vA(e.remoteStore, d)), n.onlineComponents = e }), xS.apply(this, arguments) } function MS(n) { return OS.apply(this, arguments) } function OS() { return OS = (0, cn.Z)(function* (n) { return n.offlineComponents || (Mn("FirestoreClient", "Using default OfflineComponentProvider"), yield GA(n, new OA)), n.offlineComponents }), OS.apply(this, arguments) } function DE(n) { return NS.apply(this, arguments) } function NS() { return NS = (0, cn.Z)(function* (n) { return n.onlineComponents || (Mn("FirestoreClient", "Using default OnlineComponentProvider"), yield jA(n, new DS)), n.onlineComponents }), NS.apply(this, arguments) } function $A(n) { return MS(n).then(e => e.persistence) } function SE(n) { return MS(n).then(e => e.localStore) } function kS(n) { return DE(n).then(e => e.remoteStore) } function PS(n) { return DE(n).then(e => e.syncEngine) } function Yv(n) { return RS.apply(this, arguments) } function RS() { return RS = (0, cn.Z)(function* (n) { const e = yield DE(n), t = e.eventManager; return t.onListen = aO.bind(null, e.syncEngine), t.onUnlisten = lO.bind(null, e.syncEngine), t }), RS.apply(this, arguments) } function ZA(n, e, t = {}) { const r = new ja; return n.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return function (a, d, _, E, x) { const B = new TE({ next: oe => { d.enqueueAndForget(() => KD(a, K)); const Me = oe.docs.has(_); !Me && oe.fromCache ? x.reject(new Cn(en.UNAVAILABLE, "Failed to get document because the client is offline.")) : Me && oe.fromCache && E && "server" === E.source ? x.reject(new Cn(en.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : x.resolve(oe) }, error: oe => x.reject(oe) }), K = new XD(Xp(_.path), B, { includeMetadataChanges: !0, Nu: !0 }); return qD(a, K) }(yield Yv(n), n.asyncQueue, e, t, r) })), r.promise } function qA(n, e, t = {}) { const r = new ja; return n.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return function (a, d, _, E, x) { const B = new TE({ next: oe => { d.enqueueAndForget(() => KD(a, K)), oe.fromCache && "server" === E.source ? x.reject(new Cn(en.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : x.resolve(oe) }, error: oe => x.reject(oe) }), K = new XD(_, B, { includeMetadataChanges: !0, Nu: !0 }); return qD(a, K) }(yield Yv(n), n.asyncQueue, e, t, r) })), r.promise } class UO { constructor() { this.Bc = Promise.resolve(), this.Lc = [], this.qc = !1, this.Uc = [], this.Kc = null, this.Gc = !1, this.Qc = !1, this.jc = [], this.xo = new AD(this, "async_queue_retry"), this.Wc = () => { const t = vE(); t && Mn("AsyncQueue", "Visibility state changed to " + t.visibilityState), this.xo.Po() }; const e = vE(); e && "function" == typeof e.addEventListener && e.addEventListener("visibilitychange", this.Wc) } get isShuttingDown() { return this.qc } enqueueAndForget(e) { this.enqueue(e) } enqueueAndForgetEvenWhileRestricted(e) { this.zc(), this.Hc(e) } enterRestrictedMode(e) { if (!this.qc) { this.qc = !0, this.Qc = e || !1; const t = vE(); t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.Wc) } } enqueue(e) { if (this.zc(), this.qc) return new Promise(() => { }); const t = new ja; return this.Hc(() => this.qc && this.Qc ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise)).then(() => t.promise) } enqueueRetryable(e) { this.enqueueAndForget(() => (this.Lc.push(e), this.Jc())) } Jc() { var e = this; return (0, cn.Z)(function* () { if (0 !== e.Lc.length) { try { yield e.Lc[0](), e.Lc.shift(), e.xo.reset() } catch (t) { if (!sh(t)) throw t; Mn("AsyncQueue", "Operation failed with retryable error: " + t) } e.Lc.length > 0 && e.xo.Ro(() => e.Jc()) } })() } Hc(e) { const t = this.Bc.then(() => (this.Gc = !0, e().catch(r => { throw this.Kc = r, this.Gc = !1, Ga("INTERNAL UNHANDLED ERROR: ", function (d) { let _ = d.message || ""; return d.stack && (_ = d.stack.includes(d.message) ? d.stack : d.message + "\n" + d.stack), _ }(r)), r }).then(r => (this.Gc = !1, r)))); return this.Bc = t, t } enqueueAfterDelay(e, t, r) { this.zc(), this.jc.indexOf(e) > -1 && (t = 0); const a = ZD.createAndSchedule(this, e, t, r, d => this.Yc(d)); return this.Uc.push(a), a } zc() { this.Kc && rr() } verifyOperationInProgress() { } Xc() { var e = this; return (0, cn.Z)(function* () { let t; do { t = e.Bc, yield t } while (t !== e.Bc) })() } Zc(e) { for (const t of this.Uc) if (t.timerId === e) return !0; return !1 } ta(e) { return this.Xc().then(() => { this.Uc.sort((t, r) => t.targetTimeMs - r.targetTimeMs); for (const t of this.Uc) if (t.skipDelay(), "all" !== e && t.timerId === e) break; return this.Xc() }) } ea(e) { this.jc.push(e) } Yc(e) { const t = this.Uc.indexOf(e); this.Uc.splice(t, 1) } } function FS(n) { return function (e, t) { if ("object" != typeof e || null === e) return !1; const r = e; for (const a of ["next", "error", "complete"]) if (a in r && "function" == typeof r[a]) return !0; return !1 }(n) } class HO { constructor() { this._progressObserver = {}, this._taskCompletionResolver = new ja, this._lastProgress = { taskState: "Running", totalBytes: 0, totalDocuments: 0, bytesLoaded: 0, documentsLoaded: 0 } } onProgress(e, t, r) { this._progressObserver = { next: e, error: t, complete: r } } catch(e) { return this._taskCompletionResolver.promise.catch(e) } then(e, t) { return this._taskCompletionResolver.promise.then(e, t) } _completeWith(e) { this._updateProgress(e), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(e) } _failWith(e) { this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(e), this._taskCompletionResolver.reject(e) } _updateProgress(e) { this._lastProgress = e, this._progressObserver.next && this._progressObserver.next(e) } } class ma extends Mw { constructor(e, t, r, a) { super(e, t, r, a), this.type = "firestore", this._queue = new UO, this._persistenceKey = a?.name || "[DEFAULT]" } _terminate() { return this._firestoreClient || YA(this), this._firestoreClient.terminate() } } function Al(n) { return n._firestoreClient || YA(n), n._firestoreClient.verifyNotTerminated(), n._firestoreClient } function YA(n) { var e; const t = n._freezeSettings(), r = (d = (null === (e = n._app) || void 0 === e ? void 0 : e.options.appId) || "", new xC(n._databaseId, d, n._persistenceKey, (E = t).host, E.ssl, E.experimentalForceLongPolling, E.experimentalAutoDetectLongPolling, E.useFetchStreams)); var d, E; n._firestoreClient = new NO(n._authCredentials, n._appCheckCredentials, n._queue, r) } function KA(n, e, t) { const r = new ja; return n.asyncQueue.enqueue((0, cn.Z)(function* () { try { yield GA(n, t), yield jA(n, e), r.resolve() } catch (a) { const d = a; if (!("FirebaseError" === (_ = d).name ? _.code === en.FAILED_PRECONDITION || _.code === en.UNIMPLEMENTED : !(typeof DOMException < "u" && _ instanceof DOMException) || 22 === _.code || 20 === _.code || 11 === _.code)) throw d; Zp("Error enabling offline persistence. Falling back to persistence disabled: " + d), r.reject(d) } var _ })).then(() => r.promise) } function JA(n) { if (n._initialized || n._terminated) throw new Cn(en.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.") } class cp { constructor(e) { this._byteString = e } static fromBase64String(e) { try { return new cp(sl.fromBase64String(e)) } catch (t) { throw new Cn(en.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t) } } static fromUint8Array(e) { return new cp(sl.fromUint8Array(e)) } toBase64() { return this._byteString.toBase64() } toUint8Array() { return this._byteString.toUint8Array() } toString() { return "Bytes(base64: " + this.toBase64() + ")" } isEqual(e) { return this._byteString.isEqual(e._byteString) } } class cg { constructor(...e) { for (let t = 0; t < e.length; ++t)if (0 === e[t].length) throw new Cn(en.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty."); this._internalPath = new Oa(e) } isEqual(e) { return this._internalPath.isEqual(e._internalPath) } } class J_ { constructor(e) { this._methodName = e } } class IE { constructor(e, t) { if (!isFinite(e) || e < -90 || e > 90) throw new Cn(en.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e); if (!isFinite(t) || t < -180 || t > 180) throw new Cn(en.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + t); this._lat = e, this._long = t } get latitude() { return this._lat } get longitude() { return this._long } isEqual(e) { return this._lat === e._lat && this._long === e._long } toJSON() { return { latitude: this._lat, longitude: this._long } } _compareTo(e) { return ai(this._lat, e._lat) || ai(this._long, e._long) } } const JO = /^__.*__$/; class QO { constructor(e, t, r) { this.data = e, this.fieldMask = t, this.fieldTransforms = r } toMutation(e, t) { return null !== this.fieldMask ? new pu(e, this.data, this.fieldMask, t, this.fieldTransforms) : new ig(e, this.data, t, this.fieldTransforms) } } class QA { constructor(e, t, r) { this.data = e, this.fieldMask = t, this.fieldTransforms = r } toMutation(e, t) { return new pu(e, this.data, this.fieldMask, t, this.fieldTransforms) } } function XA(n) { switch (n) { case 0: case 2: case 1: return !0; case 3: case 4: return !1; default: throw rr() } } class AE { constructor(e, t, r, a, d, _) { this.settings = e, this.databaseId = t, this.yt = r, this.ignoreUndefinedProperties = a, void 0 === d && this.na(), this.fieldTransforms = d || [], this.fieldMask = _ || [] } get path() { return this.settings.path } get sa() { return this.settings.sa } ia(e) { return new AE(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.yt, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask) } ra(e) { var t; const r = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), a = this.ia({ path: r, oa: !1 }); return a.ua(e), a } ca(e) { var t; const r = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), a = this.ia({ path: r, oa: !1 }); return a.na(), a } aa(e) { return this.ia({ path: void 0, oa: !0 }) } ha(e) { return OE(e, this.settings.methodName, this.settings.la || !1, this.path, this.settings.fa) } contains(e) { return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field)) } na() { if (this.path) for (let e = 0; e < this.path.length; e++)this.ua(this.path.get(e)) } ua(e) { if (0 === e.length) throw this.ha("Document fields must not be empty"); if (XA(this.sa) && JO.test(e)) throw this.ha('Document fields cannot begin and end with "__"') } } class XO { constructor(e, t, r) { this.databaseId = e, this.ignoreUndefinedProperties = t, this.yt = r || Iw(e) } da(e, t, r, a = !1) { return new AE({ sa: e, methodName: t, fa: r, path: Oa.emptyPath(), oa: !1, la: a }, this.databaseId, this.yt, this.ignoreUndefinedProperties) } } function Q_(n) { const e = n._freezeSettings(), t = Iw(n._databaseId); return new XO(n._databaseId, !!e.ignoreUndefinedProperties, t) } function xE(n, e, t, r, a, d = {}) { const _ = n.da(d.merge || d.mergeFields ? 2 : 0, e, t, a); US("Data must be an object, but it was:", _, r); const E = nx(r, _); let x, B; if (d.merge) x = new hu(_.fieldMask), B = _.fieldTransforms; else if (d.mergeFields) { const K = []; for (const oe of d.mergeFields) { const Me = HS(e, oe, t); if (!_.contains(Me)) throw new Cn(en.INVALID_ARGUMENT, `Field '${Me}' is specified in your field mask but missing from your input data.`); ix(K, Me) || K.push(Me) } x = new hu(K), B = _.fieldTransforms.filter(oe => x.covers(oe.field)) } else x = null, B = _.fieldTransforms; return new QO(new vc(E), x, B) } class Ow extends J_ { _toFieldTransform(e) { if (2 !== e.sa) throw e.ha(1 === e.sa ? `${this._methodName}() can only appear at the top level of your update data` : `${this._methodName}() cannot be used with set() unless you pass {merge:true}`); return e.fieldMask.push(e.path), null } isEqual(e) { return e instanceof Ow } } function ex(n, e, t) { return new AE({ sa: 3, fa: e.settings.fa, methodName: n._methodName, oa: t }, e.databaseId, e.yt, e.ignoreUndefinedProperties) } class LS extends J_ { _toFieldTransform(e) { return new V_(e.path, new tg) } isEqual(e) { return e instanceof LS } } class eN extends J_ { constructor(e, t) { super(e), this._a = t } _toFieldTransform(e) { const t = ex(this, e, !0), r = this._a.map(d => X_(d, t)), a = new ng(r); return new V_(e.path, a) } isEqual(e) { return this === e } } class tN extends J_ { constructor(e, t) { super(e), this._a = t } _toFieldTransform(e) { const t = ex(this, e, !0), r = this._a.map(d => X_(d, t)), a = new rg(r); return new V_(e.path, a) } isEqual(e) { return this === e } } class nN extends J_ { constructor(e, t) { super(e), this.wa = t } _toFieldTransform(e) { const t = new B_(e.yt, uw(e.yt, this.wa)); return new V_(e.path, t) } isEqual(e) { return this === e } } function BS(n, e, t, r) { const a = n.da(1, e, t); US("Data must be an object, but it was:", a, r); const d = [], _ = vc.empty(); Yp(r, (x, B) => { const K = ME(e, x, t); B = (0, Pe.m9)(B); const oe = a.ca(K); if (B instanceof Ow) d.push(K); else { const Me = X_(B, oe); null != Me && (d.push(K), _.set(K, Me)) } }); const E = new hu(d); return new QA(_, E, a.fieldTransforms) } function VS(n, e, t, r, a, d) { const _ = n.da(1, e, t), E = [HS(e, r, t)], x = [a]; if (d.length % 2 != 0) throw new Cn(en.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`); for (let Me = 0; Me < d.length; Me += 2)E.push(HS(e, d[Me])), x.push(d[Me + 1]); const B = [], K = vc.empty(); for (let Me = E.length - 1; Me >= 0; --Me)if (!ix(B, E[Me])) { const ot = E[Me]; let bt = x[Me]; bt = (0, Pe.m9)(bt); const qt = _.ca(ot); if (bt instanceof Ow) B.push(ot); else { const Tn = X_(bt, qt); null != Tn && (B.push(ot), K.set(ot, Tn)) } } const oe = new hu(B); return new QA(K, oe, _.fieldTransforms) } function tx(n, e, t, r = !1) { return X_(t, n.da(r ? 4 : 3, e)) } function X_(n, e) { if (rx(n = (0, Pe.m9)(n))) return US("Unsupported field value:", e, n), nx(n, e); if (n instanceof J_) return function (t, r) { if (!XA(r.sa)) throw r.ha(`${t._methodName}() can only be used with update() and set()`); if (!r.path) throw r.ha(`${t._methodName}() is not currently supported inside arrays`); const a = t._toFieldTransform(r); a && r.fieldTransforms.push(a) }(n, e), null; if (void 0 === n && e.ignoreUndefinedProperties) return null; if (e.path && e.fieldMask.push(e.path), n instanceof Array) { if (e.settings.oa && 4 !== e.sa) throw e.ha("Nested arrays are not supported"); return function (t, r) { const a = []; let d = 0; for (const _ of t) { let E = X_(_, r.aa(d)); null == E && (E = { nullValue: "NULL_VALUE" }), a.push(E), d++ } return { arrayValue: { values: a } } }(n, e) } return function (t, r) { if (null === (t = (0, Pe.m9)(t))) return { nullValue: "NULL_VALUE" }; if ("number" == typeof t) return uw(r.yt, t); if ("boolean" == typeof t) return { booleanValue: t }; if ("string" == typeof t) return { stringValue: t }; if (t instanceof Date) { const a = Vo.fromDate(t); return { timestampValue: z_(r.yt, a) } } if (t instanceof Vo) { const a = new Vo(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3)); return { timestampValue: z_(r.yt, a) } } if (t instanceof IE) return { geoPointValue: { latitude: t.latitude, longitude: t.longitude } }; if (t instanceof cp) return { bytesValue: rE(r.yt, t._byteString) }; if (t instanceof ga) { const a = r.databaseId, d = t.firestore._databaseId; if (!d.isEqual(a)) throw r.ha(`Document reference is for database ${d.projectId}/${d.database} but should be for database ${a.projectId}/${a.database}`); return { referenceValue: iE(t.firestore._databaseId || r.databaseId, t._key.path) } } throw r.ha(`Unsupported field value: ${CE(t)}`) }(n, e) } function nx(n, e) { const t = {}; return kT(n) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : Yp(n, (r, a) => { const d = X_(a, e.ra(r)); null != d && (t[r] = d) }), { mapValue: { fields: t } } } function rx(n) { return !("object" != typeof n || null === n || n instanceof Array || n instanceof Date || n instanceof Vo || n instanceof IE || n instanceof cp || n instanceof ga || n instanceof J_) } function US(n, e, t) { if (!rx(t) || "object" != typeof (r = t) || null === r || Object.getPrototypeOf(r) !== Object.prototype && null !== Object.getPrototypeOf(r)) { const r = CE(t); throw e.ha("an object" === r ? n + " a custom object" : n + " " + r) } var r } function HS(n, e, t) { if ((e = (0, Pe.m9)(e)) instanceof cg) return e._internalPath; if ("string" == typeof e) return ME(n, e); throw OE("Field path arguments must be of type string or ", n, !1, void 0, t) } const rN = new RegExp("[~\\*/\\[\\]]"); function ME(n, e, t) { if (e.search(rN) >= 0) throw OE(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, n, !1, void 0, t); try { return new cg(...e.split("."))._internalPath } catch { throw OE(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, n, !1, void 0, t) } } function OE(n, e, t, r, a) { const d = r && !r.isEmpty(), _ = void 0 !== a; let E = `Function ${e}() called with invalid data`; t && (E += " (via `toFirestore()`)"), E += ". "; let x = ""; return (d || _) && (x += " (found", d && (x += ` in field ${r}`), _ && (x += ` in document ${a}`), x += ")"), new Cn(en.INVALID_ARGUMENT, E + n + x) } function ix(n, e) { return n.some(t => t.isEqual(e)) } class Nw { constructor(e, t, r, a, d) { this._firestore = e, this._userDataWriter = t, this._key = r, this._document = a, this._converter = d } get id() { return this._key.path.lastSegment() } get ref() { return new ga(this._firestore, this._converter, this._key) } exists() { return null !== this._document } data() { if (this._document) { if (this._converter) { const e = new iN(this._firestore, this._userDataWriter, this._key, this._document, null); return this._converter.fromFirestore(e) } return this._userDataWriter.convertValue(this._document.data.value) } } get(e) { if (this._document) { const t = this._document.data.field(NE("DocumentSnapshot.get", e)); if (null !== t) return this._userDataWriter.convertValue(t) } } } class iN extends Nw { data() { return super.data() } } function NE(n, e) { return "string" == typeof e ? ME(n, e) : e instanceof cg ? e._internalPath : e._delegate._internalPath } function sx(n) { if ("L" === n.limitType && 0 === n.explicitOrderBy.length) throw new Cn(en.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause") } class zS { } class kw extends zS { } function mm(n, e, ...t) { let r = []; e instanceof zS && r.push(e), r = r.concat(t), function (a) { const d = a.filter(E => E instanceof Kv).length, _ = a.filter(E => E instanceof Pw).length; if (d > 1 || d > 0 && _ > 0) throw new Cn(en.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.") }(r); for (const a of r) n = a._apply(n); return n } class Pw extends kw { constructor(e, t, r) { super(), this._field = e, this._op = t, this._value = r, this.type = "where" } static _create(e, t, r) { return new Pw(e, t, r) } _apply(e) { const t = this._parse(e); return cx(e._query, t), new gu(e.firestore, e.converter, iw(e._query, t)) } _parse(e) { const t = Q_(e.firestore); return function (a, d, _, E, x, B, K) { let oe; if (x.isKeyField()) { if ("array-contains" === B || "array-contains-any" === B) throw new Cn(en.INVALID_ARGUMENT, `Invalid Query. You can't perform '${B}' queries on documentId().`); if ("in" === B || "not-in" === B) { lx(K, B); const Me = []; for (const ot of K) Me.push(ax(E, a, ot)); oe = { arrayValue: { values: Me } } } else oe = ax(E, a, K) } else "in" !== B && "not-in" !== B && "array-contains-any" !== B || lx(K, B), oe = tx(_, "where", K, "in" === B || "not-in" === B); return ns.create(x, B, oe) }(e._query, 0, t, e.firestore._databaseId, this._field, this._op, this._value) } } class Kv extends zS { constructor(e, t) { super(), this.type = e, this._queryConstraints = t } static _create(e, t) { return new Kv(e, t) } _parse(e) { const t = this._queryConstraints.map(r => r._parse(e)).filter(r => r.getFilters().length > 0); return 1 === t.length ? t[0] : qs.create(t, this._getOperator()) } _apply(e) { const t = this._parse(e); return 0 === t.getFilters().length ? e : (function (r, a) { let d = r; const _ = a.getFlattenedFilters(); for (const E of _) cx(d, E), d = iw(d, E) }(e._query, t), new gu(e.firestore, e.converter, iw(e._query, t))) } _getQueryConstraints() { return this._queryConstraints } _getOperator() { return "and" === this.type ? "and" : "or" } } class GS extends kw { constructor(e, t) { super(), this._field = e, this._direction = t, this.type = "orderBy" } static _create(e, t) { return new GS(e, t) } _apply(e) { const t = function (r, a, d) { if (null !== r.startAt) throw new Cn(en.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy()."); if (null !== r.endAt) throw new Cn(en.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy()."); const _ = new P_(a, d); return function (E, x) { if (null === ch(E)) { const B = Ov(E); null !== B && ux(0, B, x.field) } }(r, _), _ }(e._query, this._field, this._direction); return new gu(e.firestore, e.converter, function (r, a) { const d = r.explicitOrderBy.concat([a]); return new lh(r.path, r.collectionGroup, d, r.filters.slice(), r.limit, r.limitType, r.startAt, r.endAt) }(e._query, t)) } } class kE extends kw { constructor(e, t, r) { super(), this.type = e, this._limit = t, this._limitType = r } static _create(e, t, r) { return new kE(e, t, r) } _apply(e) { return new gu(e.firestore, e.converter, Nv(e._query, this._limit, this._limitType)) } } class PE extends kw { constructor(e, t, r) { super(), this.type = e, this._docOrFields = t, this._inclusive = r } static _create(e, t, r) { return new PE(e, t, r) } _apply(e) { const t = ox(e, this.type, this._docOrFields, this._inclusive); return new gu(e.firestore, e.converter, (a = t, new lh((r = e._query).path, r.collectionGroup, r.explicitOrderBy.slice(), r.filters.slice(), r.limit, r.limitType, a, r.endAt))); var r, a } } class RE extends kw { constructor(e, t, r) { super(), this.type = e, this._docOrFields = t, this._inclusive = r } static _create(e, t, r) { return new RE(e, t, r) } _apply(e) { const t = ox(e, this.type, this._docOrFields, this._inclusive); return new gu(e.firestore, e.converter, (a = t, new lh((r = e._query).path, r.collectionGroup, r.explicitOrderBy.slice(), r.filters.slice(), r.limit, r.limitType, r.startAt, a))); var r, a } } function ox(n, e, t, r) { if (t[0] = (0, Pe.m9)(t[0]), t[0] instanceof Nw) return function (a, d, _, E, x) { if (!E) throw new Cn(en.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${_}().`); const B = []; for (const K of eg(a)) if (K.field.isKeyField()) B.push(rm(d, E.key)); else { const oe = E.data.field(K.field); if (Qb(oe)) throw new Cn(en.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + K.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)'); if (null === oe) { const Me = K.field.canonicalString(); throw new Cn(en.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${Me}' (used as the orderBy) does not exist.`) } B.push(oe) } return new Tf(B, x) }(n._query, n.firestore._databaseId, e, t[0]._document, r); { const a = Q_(n.firestore); return function (d, _, E, x, B, K) { const oe = d.explicitOrderBy; if (B.length > oe.length) throw new Cn(en.INVALID_ARGUMENT, `Too many arguments provided to ${x}(). The number of arguments must be less than or equal to the number of orderBy() clauses`); const Me = []; for (let ot = 0; ot < B.length; ot++) { const bt = B[ot]; if (oe[ot].field.isKeyField()) { if ("string" != typeof bt) throw new Cn(en.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${x}(), but got a ${typeof bt}`); if (!WC(d) && -1 !== bt.indexOf("/")) throw new Cn(en.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${x}() must be a plain document ID, but '${bt}' contains a slash.`); const qt = d.path.child(is.fromString(bt)); if (!Gn.isDocumentKey(qt)) throw new Cn(en.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${x}() must result in a valid document path, but '${qt}' is not because it contains an odd number of segments.`); const Tn = new Gn(qt); Me.push(rm(_, Tn)) } else { const qt = tx(E, x, bt); Me.push(qt) } } return new Tf(Me, K) }(n._query, n.firestore._databaseId, a, e, t, r) } } function ax(n, e, t) { if ("string" == typeof (t = (0, Pe.m9)(t))) { if ("" === t) throw new Cn(en.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string."); if (!WC(e) && -1 !== t.indexOf("/")) throw new Cn(en.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${t}' contains a '/' character.`); const r = e.path.child(is.fromString(t)); if (!Gn.isDocumentKey(r)) throw new Cn(en.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`); return rm(n, new Gn(r)) } if (t instanceof ga) return rm(n, t._key); throw new Cn(en.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${CE(t)}.`) } function lx(n, e) { if (!Array.isArray(n) || 0 === n.length) throw new Cn(en.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`); if (n.length > 10) throw new Cn(en.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`) } function cx(n, e) { if (e.isInequality()) { const r = Ov(n), a = e.field; if (null !== r && !r.isEqual(a)) throw new Cn(en.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${r.toString()}' and '${a.toString()}'`); const d = ch(n); null !== d && ux(0, a, d) } const t = function (r, a) { for (const d of r) for (const _ of d.getFlattenedFilters()) if (a.indexOf(_.op) >= 0) return _.op; return null }(n.filters, function (r) { switch (r) { case "!=": return ["!=", "not-in"]; case "array-contains": return ["array-contains", "array-contains-any", "not-in"]; case "in": return ["array-contains-any", "in", "not-in"]; case "array-contains-any": return ["array-contains", "array-contains-any", "in", "not-in"]; case "not-in": return ["array-contains", "array-contains-any", "in", "not-in", "!="]; default: return [] } }(e.op)); if (null !== t) throw new Cn(en.INVALID_ARGUMENT, t === e.op ? `Invalid query. You cannot use more than one '${e.op.toString()}' filter.` : `Invalid query. You cannot use '${e.op.toString()}' filters with '${t.toString()}' filters.`) } function ux(n, e, t) { if (!t.isEqual(e)) throw new Cn(en.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${t.toString()}' instead.`) } class jS { convertValue(e, t = "none") { switch (ip(e)) { case 0: return null; case 1: return e.booleanValue; case 2: return ha(e.integerValue || e.doubleValue); case 3: return this.convertTimestamp(e.timestampValue); case 4: return this.convertServerTimestamp(e, t); case 5: return e.stringValue; case 6: return this.convertBytes(Kp(e.bytesValue)); case 7: return this.convertReference(e.referenceValue); case 8: return this.convertGeoPoint(e.geoPointValue); case 9: return this.convertArray(e.arrayValue, t); case 10: return this.convertObject(e.mapValue, t); default: throw rr() } } convertObject(e, t) { const r = {}; return Yp(e.fields, (a, d) => { r[a] = this.convertValue(d, t) }), r } convertGeoPoint(e) { return new IE(ha(e.latitude), ha(e.longitude)) } convertArray(e, t) { return (e.values || []).map(r => this.convertValue(r, t)) } convertServerTimestamp(e, t) { switch (t) { case "previous": const r = Xb(e); return null == r ? null : this.convertValue(r, t); case "estimate": return this.convertTimestamp(S_(e)); default: return null } } convertTimestamp(e) { const t = Cf(e); return new Vo(t.seconds, t.nanos) } convertDocumentKey(e, t) { const r = is.fromString(e); mr(rD(r)); const a = new Lh(r.get(1), r.get(3)), d = new Gn(r.popFirst(5)); return a.isEqual(t) || Ga(`Document ${d} contains a document reference within a different database (${a.projectId}/${a.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`), d } } function FE(n, e, t) { let r; return r = n ? t && (t.merge || t.mergeFields) ? n.toFirestore(e, t) : n.toFirestore(e) : e, r } class fN extends jS { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new cp(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new ga(this.firestore, null, t) } } class ey { constructor(e, t) { this.hasPendingWrites = e, this.fromCache = t } isEqual(e) { return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache } } class ug extends Nw { constructor(e, t, r, a, d, _) { super(e, t, r, a, _), this._firestore = e, this._firestoreImpl = e, this.metadata = d } exists() { return super.exists() } data(e = {}) { if (this._document) { if (this._converter) { const t = new Rw(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null); return this._converter.fromFirestore(t, e) } return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps) } } get(e, t = {}) { if (this._document) { const r = this._document.data.field(NE("DocumentSnapshot.get", e)); if (null !== r) return this._userDataWriter.convertValue(r, t.serverTimestamps) } } } class Rw extends ug { data(e = {}) { return super.data(e) } } class _m { constructor(e, t, r, a) { this._firestore = e, this._userDataWriter = t, this._snapshot = a, this.metadata = new ey(a.hasPendingWrites, a.fromCache), this.query = r } get docs() { const e = []; return this.forEach(t => e.push(t)), e } get size() { return this._snapshot.docs.size } get empty() { return 0 === this.size } forEach(e, t) { this._snapshot.docs.forEach(r => { e.call(t, new Rw(this._firestore, this._userDataWriter, r.key, r, new ey(this._snapshot.mutatedKeys.has(r.key), this._snapshot.fromCache), this.query.converter)) }) } docChanges(e = {}) { const t = !!e.includeMetadataChanges; if (t && this._snapshot.excludesMetadataChanges) throw new Cn(en.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot()."); return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t || (this._cachedChanges = function (r, a) { if (r._snapshot.oldDocs.isEmpty()) { let d = 0; return r._snapshot.docChanges.map(_ => ({ type: "added", doc: new Rw(r._firestore, r._userDataWriter, _.doc.key, _.doc, new ey(r._snapshot.mutatedKeys.has(_.doc.key), r._snapshot.fromCache), r.query.converter), oldIndex: -1, newIndex: d++ })) } { let d = r._snapshot.oldDocs; return r._snapshot.docChanges.filter(_ => a || 3 !== _.type).map(_ => { const E = new Rw(r._firestore, r._userDataWriter, _.doc.key, _.doc, new ey(r._snapshot.mutatedKeys.has(_.doc.key), r._snapshot.fromCache), r.query.converter); let x = -1, B = -1; return 0 !== _.type && (x = d.indexOf(_.doc.key), d = d.delete(_.doc.key)), 1 !== _.type && (d = d.add(_.doc), B = d.indexOf(_.doc.key)), { type: pN(_.type), doc: E, oldIndex: x, newIndex: B } }) } }(this, t), this._cachedChangesIncludeMetadataChanges = t), this._cachedChanges } } function pN(n) { switch (n) { case 0: return "added"; case 2: case 3: return "modified"; case 1: return "removed"; default: return rr() } } function hx(n, e) { return n instanceof ug && e instanceof ug ? n._firestore === e._firestore && n._key.isEqual(e._key) && (null === n._document ? null === e._document : n._document.isEqual(e._document)) && n._converter === e._converter : n instanceof _m && e instanceof _m && n._firestore === e._firestore && IS(n.query, e.query) && n.metadata.isEqual(e.metadata) && n._snapshot.isEqual(e._snapshot) } class ym extends jS { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new cp(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new ga(this.firestore, null, t) } } function fx(n, e, t) { n = ms(n, ga); const r = ms(n.firestore, ma), a = FE(n.converter, e, t); return Jv(r, [xE(Q_(r), "setDoc", n._key, a, null !== n.converter, t).toMutation(n._key, fa.none())]) } function px(n, e, t, ...r) { n = ms(n, ga); const a = ms(n.firestore, ma), d = Q_(a); let _; return _ = "string" == typeof (e = (0, Pe.m9)(e)) || e instanceof cg ? VS(d, "updateDoc", n._key, e, t, r) : BS(d, "updateDoc", n._key, e), Jv(a, [_.toMutation(n._key, fa.exists(!0))]) } function gx(n, ...e) { var t, r, a; n = (0, Pe.m9)(n); let d = { includeMetadataChanges: !1 }, _ = 0; "object" != typeof e[_] || FS(e[_]) || (d = e[_], _++); const E = { includeMetadataChanges: d.includeMetadataChanges }; if (FS(e[_])) { const oe = e[_]; e[_] = null === (t = oe.next) || void 0 === t ? void 0 : t.bind(oe), e[_ + 1] = null === (r = oe.error) || void 0 === r ? void 0 : r.bind(oe), e[_ + 2] = null === (a = oe.complete) || void 0 === a ? void 0 : a.bind(oe) } let x, B, K; if (n instanceof ga) B = ms(n.firestore, ma), K = Xp(n._key.path), x = { next: oe => { e[_] && e[_]($S(B, n, oe)) }, error: e[_ + 1], complete: e[_ + 2] }; else { const oe = ms(n, gu); B = ms(oe.firestore, ma), K = oe._query; const Me = new ym(B); x = { next: ot => { e[_] && e[_](new _m(B, Me, oe, ot)) }, error: e[_ + 1], complete: e[_ + 2] }, sx(n._query) } return function (oe, Me, ot, bt) { const qt = new TE(bt), Tn = new XD(Me, qt, ot); return oe.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return qD(yield Yv(oe), Tn) })), () => { qt.bc(), oe.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return KD(yield Yv(oe), Tn) })) } }(Al(B), K, E, x) } function Jv(n, e) { return function (t, r) { const a = new ja; return t.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return function cO(n, e, t) { return iS.apply(this, arguments) }(yield PS(t), r, a) })), a.promise }(Al(n), e) } function $S(n, e, t) { const r = t.docs.get(e._key), a = new ym(n); return new ug(n, a, e._key, r, new ey(t.hasPendingWrites, t.fromCache), e.converter) } const TN = { maxAttempts: 5 }; class mx { constructor(e, t) { this._firestore = e, this._commitHandler = t, this._mutations = [], this._committed = !1, this._dataReader = Q_(e) } set(e, t, r) { this._verifyNotCommitted(); const a = vm(e, this._firestore), d = FE(a.converter, t, r), _ = xE(this._dataReader, "WriteBatch.set", a._key, d, null !== a.converter, r); return this._mutations.push(_.toMutation(a._key, fa.none())), this } update(e, t, r, ...a) { this._verifyNotCommitted(); const d = vm(e, this._firestore); let _; return _ = "string" == typeof (t = (0, Pe.m9)(t)) || t instanceof cg ? VS(this._dataReader, "WriteBatch.update", d._key, t, r, a) : BS(this._dataReader, "WriteBatch.update", d._key, t), this._mutations.push(_.toMutation(d._key, fa.exists(!0))), this } delete(e) { this._verifyNotCommitted(); const t = vm(e, this._firestore); return this._mutations = this._mutations.concat(new lm(t._key, fa.none())), this } commit() { return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve() } _verifyNotCommitted() { if (this._committed) throw new Cn(en.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.") } } function vm(n, e) { if ((n = (0, Pe.m9)(n)).firestore !== e) throw new Cn(en.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance."); return n } class DN extends class { constructor(e, t) { this._firestore = e, this._transaction = t, this._dataReader = Q_(e) } get(e) { const t = vm(e, this._firestore), r = new fN(this._firestore); return this._transaction.lookup([t._key]).then(a => { if (!a || 1 !== a.length) return rr(); const d = a[0]; if (d.isFoundDocument()) return new Nw(this._firestore, r, d.key, d, t.converter); if (d.isNoDocument()) return new Nw(this._firestore, r, t._key, null, t.converter); throw rr() }) } set(e, t, r) { const a = vm(e, this._firestore), d = FE(a.converter, t, r), _ = xE(this._dataReader, "Transaction.set", a._key, d, null !== a.converter, r); return this._transaction.set(a._key, _), this } update(e, t, r, ...a) { const d = vm(e, this._firestore); let _; return _ = "string" == typeof (t = (0, Pe.m9)(t)) || t instanceof cg ? VS(this._dataReader, "Transaction.update", d._key, t, r, a) : BS(this._dataReader, "Transaction.update", d._key, t), this._transaction.update(d._key, _), this } delete(e) { const t = vm(e, this._firestore); return this._transaction.delete(t._key), this } }{ constructor(e, t) { super(e, t), this._firestore = e } get(e) { const t = vm(e, this._firestore), r = new ym(this._firestore); return super.get(e).then(a => new ug(this._firestore, r, t._key, a._document, new ey(!1, !1), t.converter)) } } function WS(n, e) { if (void 0 === e) return { merge: !1 }; if (void 0 !== e.mergeFields && void 0 !== e.merge) throw new Cn("invalid-argument", `Invalid options passed to function ${n}(): You cannot specify both "merge" and "mergeFields".`); return e } function yx() { if (typeof Uint8Array > "u") throw new Cn("unimplemented", "Uint8Arrays are not available in this environment.") } function vx() { if (!function OC() { return typeof atob < "u" }()) throw new Cn("unimplemented", "Blobs are unavailable in Firestore in this environment.") } !function (n, e = !0) { rp = tl.SDK_VERSION, (0, tl._registerComponent)(new Oc.wA("firestore", (t, { instanceIdentifier: r, options: a }) => { const d = t.getProvider("app").getImmediate(), _ = new ma(new EC(t.getProvider("auth-internal")), new xT(t.getProvider("app-check-internal")), function (E, x) { if (!Object.prototype.hasOwnProperty.apply(E.options, ["projectId"])) throw new Cn(en.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.'); return new Lh(E.options.projectId, x) }(d, r), d); return a = Object.assign({ useFetchStreams: e }, a), _._setSettings(a), _ }, "PUBLIC").setMultipleInstances(!0)), (0, tl.registerVersion)(Xg, "3.8.0", n), (0, tl.registerVersion)(Xg, "3.8.0", "esm2017") }(); class Fw { constructor(e) { this._delegate = e } static fromBase64String(e) { return vx(), new Fw(cp.fromBase64String(e)) } static fromUint8Array(e) { return yx(), new Fw(cp.fromUint8Array(e)) } toBase64() { return vx(), this._delegate.toBase64() } toUint8Array() { return yx(), this._delegate.toUint8Array() } isEqual(e) { return this._delegate.isEqual(e._delegate) } toString() { return "Blob(base64: " + this.toBase64() + ")" } } function ZS(n) { return function PN(n, e) { if ("object" != typeof n || null === n) return !1; const t = n; for (const r of e) if (r in t && "function" == typeof t[r]) return !0; return !1 }(n, ["next", "error", "complete"]) } class RN { enableIndexedDbPersistence(e, t) { return function GO(n, e) { JA(n = ms(n, ma)); const t = Al(n), r = n._freezeSettings(), a = new DS; return KA(t, a, new NA(a, r.cacheSizeBytes, e?.forceOwnership)) }(e._delegate, { forceOwnership: t }) } enableMultiTabIndexedDbPersistence(e) { return function jO(n) { JA(n = ms(n, ma)); const e = Al(n), t = n._freezeSettings(), r = new DS; return KA(e, r, new DO(r, t.cacheSizeBytes)) }(e._delegate) } clearIndexedDbPersistence(e) { return function $O(n) { if (n._initialized && !n._terminated) throw new Cn(en.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated."); const e = new ja; return n._queue.enqueueAndForgetEvenWhileRestricted((0, cn.Z)(function* () { try { yield (t = (0, cn.Z)(function* (r) { if (!rd.C()) return Promise.resolve(); const a = r + "main"; yield rd.delete(a) }), function (r) { return t.apply(this, arguments) })(yD(n._databaseId, n._persistenceKey)), e.resolve() } catch (t) { e.reject(t) } var t })), e.promise }(e._delegate) } } class bx { constructor(e, t, r) { this._delegate = t, this._persistenceProvider = r, this.INTERNAL = { delete: () => this.terminate() }, e instanceof Lh || (this._appCompat = e) } get _databaseId() { return this._delegate._databaseId } settings(e) { const t = this._delegate._getSettings(); !e.merge && t.host !== e.host && Zp("You are overriding the original host. If you did not intend to override your settings, use {merge: true}."), e.merge && delete (e = Object.assign(Object.assign({}, t), e)).merge, this._delegate._setSettings(e) } useEmulator(e, t, r = {}) { !function VA(n, e, t, r = {}) { var a; const d = (n = ms(n, Mw))._getSettings(); if ("firestore.googleapis.com" !== d.host && d.host !== e && Zp("Host has been set in both settings() and useEmulator(), emulator host will be used"), n._setSettings(Object.assign(Object.assign({}, d), { host: `${e}:${t}`, ssl: !1 })), r.mockUserToken) { let _, E; if ("string" == typeof r.mockUserToken) _ = r.mockUserToken, E = $l.MOCK_USER; else { _ = (0, Pe.Sg)(r.mockUserToken, null === (a = n._app) || void 0 === a ? void 0 : a.options.projectId); const x = r.mockUserToken.sub || r.mockUserToken.user_id; if (!x) throw new Cn(en.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!"); E = new $l(x) } n._authCredentials = new Ub(new Bb(_, E)) } }(this._delegate, e, t, r) } enableNetwork() { return function ZO(n) { return function kO(n) { return n.asyncQueue.enqueue((0, cn.Z)(function* () { const e = yield $A(n), t = yield kS(n); return e.setNetworkEnabled(!0), function (r) { const a = Wn(r); return a._u.delete(0), Aw(a) }(t) })) }(Al(n = ms(n, ma))) }(this._delegate) } disableNetwork() { return function qO(n) { return function PO(n) { return n.asyncQueue.enqueue((0, cn.Z)(function* () { const e = yield $A(n), t = yield kS(n); return e.setNetworkEnabled(!1), (r = (0, cn.Z)(function* (a) { const d = Wn(a); d._u.add(0), yield zv(d), d.gu.set("Offline") }), function (a) { return r.apply(this, arguments) })(t); var r })) }(Al(n = ms(n, ma))) }(this._delegate) } enablePersistence(e) { let t = !1, r = !1; return e && (t = !!e.synchronizeTabs, r = !!e.experimentalForceOwningTab, kA("synchronizeTabs", t, "experimentalForceOwningTab", r)), t ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, r) } clearPersistence() { return this._persistenceProvider.clearIndexedDbPersistence(this) } terminate() { return this._appCompat && (this._appCompat._removeServiceInstance("firestore-compat"), this._appCompat._removeServiceInstance("firestore")), this._delegate._delete() } waitForPendingWrites() { return function WO(n) { return function (e) { const t = new ja; return e.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return function fO(n, e) { return cS.apply(this, arguments) }(yield PS(e), t) })), t.promise }(Al(n = ms(n, ma))) }(this._delegate) } onSnapshotsInSync(e) { return function EN(n, e) { return function LO(n, e) { const t = new TE(e); return n.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return r = yield Yv(n), a = t, Wn(r).Ru.add(a), void a.next(); var r, a })), () => { t.bc(), n.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return r = yield Yv(n), a = t, void Wn(r).Ru.delete(a); var r, a })) } }(Al(n = ms(n, ma)), FS(e) ? e : { next: e }) }(this._delegate, e) } get app() { if (!this._appCompat) throw new Cn("failed-precondition", "Firestore was not initialized using the MasterSDK. 'app' is not available"); return this._appCompat } collection(e) { try { return new Qv(this, UA(this._delegate, e)) } catch (t) { throw ad(t, "collection()", "Firestore.collection()") } } doc(e) { try { return new Bh(this, EE(this._delegate, e)) } catch (t) { throw ad(t, "doc()", "Firestore.doc()") } } collectionGroup(e) { try { return new ld(this, function SO(n, e) { if (n = ms(n, Mw), SS("collectionGroup", "collection id", e), e.indexOf("/") >= 0) throw new Cn(en.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`); return new gu(n, null, (t = e, new lh(is.emptyPath(), t))); var t }(this._delegate, e)) } catch (t) { throw ad(t, "collectionGroup()", "Firestore.collectionGroup()") } } runTransaction(e) { return function SN(n, e, t) { n = ms(n, ma); const r = Object.assign(Object.assign({}, TN), t); return function (a) { if (a.maxAttempts < 1) throw new Cn(en.INVALID_ARGUMENT, "Max attempts must be at least 1") }(r), function (a, d, _) { const E = new ja; return a.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { const x = yield function WA(n) { return DE(n).then(e => e.datastore) }(a); new OO(a.asyncQueue, x, _, d, E).run() })), E.promise }(Al(n), a => e(new DN(n, a)), r) }(this._delegate, t => e(new wx(this, t))) } batch() { return Al(this._delegate), new Cx(new mx(this._delegate, e => Jv(this._delegate, e))) } loadBundle(e) { return function YO(n, e) { const t = Al(n = ms(n, ma)), r = new HO; return function BO(n, e, t, r) { const a = function (d, _) { let E; return E = "string" == typeof d ? (new TextEncoder).encode(d) : d, x = function (x, B) { if (x instanceof Uint8Array) return zA(x, B); if (x instanceof ArrayBuffer) return zA(new Uint8Array(x), B); if (x instanceof ReadableStream) return x.getReader(); throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream") }(E), new IO(x, _); var x }(t, Iw(e)); n.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { !function TO(n, e, t) { const r = Wn(n); var a; (a = (0, cn.Z)(function* (d, _, E) { try { const x = yield _.getMetadata(); if (yield function (Me, ot) { const bt = Wn(Me), qt = ol(ot.createTime); return bt.persistence.runTransaction("hasNewerBundle", "readonly", Tn => bt.Ns.getBundleMetadata(Tn, ot.id)).then(Tn => !!Tn && Tn.createTime.compareTo(qt) >= 0) }(d.localStore, x)) return yield _.close(), E._completeWith({ taskState: "Success", documentsLoaded: (Me = x).totalDocuments, bytesLoaded: Me.totalBytes, totalDocuments: Me.totalDocuments, totalBytes: Me.totalBytes }), Promise.resolve(new Set); E._updateProgress(CA(x)); const B = new rO(x, d.localStore, _.yt); let K = yield _.mc(); for (; K;) { const Me = yield B.Fu(K); Me && E._updateProgress(Me), K = yield _.mc() } const oe = yield B.complete(); return yield lg(d, oe.Lu, void 0), yield function (Me, ot) { const bt = Wn(Me); return bt.persistence.runTransaction("Save bundle", "readwrite", qt => bt.Ns.saveBundleMetadata(qt, ot)) }(d.localStore, x), E._completeWith(oe.progress), Promise.resolve(oe.Bu) } catch (x) { return Zp("SyncEngine", `Loading bundle failed with ${x}`), E._failWith(x), Promise.resolve(new Set) } var Me }), function (d, _, E) { return a.apply(this, arguments) })(r, e, t).then(a => { r.sharedClientState.notifyBundleLoaded(a) }) }(yield PS(n), a, r) })) }(t, n._databaseId, e, r), r }(this._delegate, e) } namedQuery(e) { return function KO(n, e) { return function VO(n, e) { return n.asyncQueue.enqueue((0, cn.Z)(function* () { return function (t, r) { const a = Wn(t); return a.persistence.runTransaction("Get named query", "readonly", d => a.Ns.getNamedQuery(d, r)) }(yield SE(n), e) })) }(Al(n = ms(n, ma)), e).then(t => t ? new gu(n, null, t.query) : null) }(this._delegate, e).then(t => t ? new ld(this, t) : null) } } class LE extends jS { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new Fw(new cp(e)) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return Bh.forKey(t, this.firestore, null) } } class wx { constructor(e, t) { this._firestore = e, this._delegate = t, this._userDataWriter = new LE(e) } get(e) { const t = ny(e); return this._delegate.get(t).then(r => new Lw(this._firestore, new ug(this._firestore._delegate, this._userDataWriter, r._key, r._document, r.metadata, t.converter))) } set(e, t, r) { const a = ny(e); return r ? (WS("Transaction.set", r), this._delegate.set(a, t, r)) : this._delegate.set(a, t), this } update(e, t, r, ...a) { const d = ny(e); return 2 === arguments.length ? this._delegate.update(d, t) : this._delegate.update(d, t, r, ...a), this } delete(e) { const t = ny(e); return this._delegate.delete(t), this } } class Cx { constructor(e) { this._delegate = e } set(e, t, r) { const a = ny(e); return r ? (WS("WriteBatch.set", r), this._delegate.set(a, t, r)) : this._delegate.set(a, t), this } update(e, t, r, ...a) { const d = ny(e); return 2 === arguments.length ? this._delegate.update(d, t) : this._delegate.update(d, t, r, ...a), this } delete(e) { const t = ny(e); return this._delegate.delete(t), this } commit() { return this._delegate.commit() } } class ty { constructor(e, t, r) { this._firestore = e, this._userDataWriter = t, this._delegate = r } fromFirestore(e, t) { const r = new Rw(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, null); return this._delegate.fromFirestore(new Bw(this._firestore, r), t ?? {}) } toFirestore(e, t) { return t ? this._delegate.toFirestore(e, t) : this._delegate.toFirestore(e) } static getInstance(e, t) { const r = ty.INSTANCES; let a = r.get(e); a || (a = new WeakMap, r.set(e, a)); let d = a.get(t); return d || (d = new ty(e, new LE(e), t), a.set(t, d)), d } } ty.INSTANCES = new WeakMap; class Bh { constructor(e, t) { this.firestore = e, this._delegate = t, this._userDataWriter = new LE(e) } static forPath(e, t, r) { if (e.length % 2 != 0) throw new Cn("invalid-argument", `Invalid document reference. Document references must have an even number of segments, but ${e.canonicalString()} has ${e.length}`); return new Bh(t, new ga(t._delegate, r, new Gn(e))) } static forKey(e, t, r) { return new Bh(t, new ga(t._delegate, r, e)) } get id() { return this._delegate.id } get parent() { return new Qv(this.firestore, this._delegate.parent) } get path() { return this._delegate.path } collection(e) { try { return new Qv(this.firestore, UA(this._delegate, e)) } catch (t) { throw ad(t, "collection()", "DocumentReference.collection()") } } isEqual(e) { return (e = (0, Pe.m9)(e)) instanceof ga && HA(this._delegate, e) } set(e, t) { t = WS("DocumentReference.set", t); try { return t ? fx(this._delegate, e, t) : fx(this._delegate, e) } catch (r) { throw ad(r, "setDoc()", "DocumentReference.set()") } } update(e, t, ...r) { try { return 1 === arguments.length ? px(this._delegate, e) : px(this._delegate, e, t, ...r) } catch (a) { throw ad(a, "updateDoc()", "DocumentReference.update()") } } delete() { return function wN(n) { return Jv(ms(n.firestore, ma), [new lm(n._key, fa.none())]) }(this._delegate) } onSnapshot(...e) { const t = Ex(e), r = Tx(e, a => new Lw(this.firestore, new ug(this.firestore._delegate, this._userDataWriter, a._key, a._document, a.metadata, this._delegate.converter))); return gx(this._delegate, t, r) } get(e) { let t; return t = "cache" === e?.source ? function mN(n) { n = ms(n, ga); const e = ms(n.firestore, ma), t = Al(e), r = new ym(e); return function RO(n, e) { const t = new ja; return n.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return (r = (0, cn.Z)(function* (a, d, _) { try { const E = yield function (x, B) { const K = Wn(x); return K.persistence.runTransaction("read document", "readonly", oe => K.localDocuments.getDocument(oe, B)) }(a, d); E.isFoundDocument() ? _.resolve(E) : E.isNoDocument() ? _.resolve(null) : _.reject(new Cn(en.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)")) } catch (E) { const x = $v(E, `Failed to get document '${d} from cache`); _.reject(x) } }), function (a, d, _) { return r.apply(this, arguments) })(yield SE(n), e, t); var r })), t.promise }(t, n._key).then(a => new ug(e, r, n._key, a, new ey(null !== a && a.hasLocalMutations, !0), n.converter)) }(this._delegate) : "server" === e?.source ? function _N(n) { n = ms(n, ga); const e = ms(n.firestore, ma); return ZA(Al(e), n._key, { source: "server" }).then(t => $S(e, n, t)) }(this._delegate) : function gN(n) { n = ms(n, ga); const e = ms(n.firestore, ma); return ZA(Al(e), n._key).then(t => $S(e, n, t)) }(this._delegate), t.then(r => new Lw(this.firestore, new ug(this.firestore._delegate, this._userDataWriter, r._key, r._document, r.metadata, this._delegate.converter))) } withConverter(e) { return new Bh(this.firestore, this._delegate.withConverter(e ? ty.getInstance(this.firestore, e) : null)) } } function ad(n, e, t) { return n.message = n.message.replace(e, t), n } function Ex(n) { for (const e of n) if ("object" == typeof e && !ZS(e)) return e; return {} } function Tx(n, e) { var t, r; let a; return a = ZS(n[0]) ? n[0] : ZS(n[1]) ? n[1] : "function" == typeof n[0] ? { next: n[0], error: n[1], complete: n[2] } : { next: n[1], error: n[2], complete: n[3] }, { next: d => { a.next && a.next(e(d)) }, error: null === (t = a.error) || void 0 === t ? void 0 : t.bind(a), complete: null === (r = a.complete) || void 0 === r ? void 0 : r.bind(a) } } class Lw { constructor(e, t) { this._firestore = e, this._delegate = t } get ref() { return new Bh(this._firestore, this._delegate.ref) } get id() { return this._delegate.id } get metadata() { return this._delegate.metadata } get exists() { return this._delegate.exists() } data(e) { return this._delegate.data(e) } get(e, t) { return this._delegate.get(e, t) } isEqual(e) { return hx(this._delegate, e._delegate) } } class Bw extends Lw { data(e) { const t = this._delegate.data(e); return function AT(n, e) { n || rr() }(void 0 !== t), t } } class ld { constructor(e, t) { this.firestore = e, this._delegate = t, this._userDataWriter = new LE(e) } where(e, t, r) { try { return new ld(this.firestore, mm(this._delegate, function sN(n, e, t) { const r = e, a = NE("where", n); return Pw._create(a, r, t) }(e, t, r))) } catch (a) { throw ad(a, /(orderBy|where)\(\)/, "Query.$1()") } } orderBy(e, t) { try { return new ld(this.firestore, mm(this._delegate, function oN(n, e = "asc") { const t = e, r = NE("orderBy", n); return GS._create(r, t) }(e, t))) } catch (r) { throw ad(r, /(orderBy|where)\(\)/, "Query.$1()") } } limit(e) { try { return new ld(this.firestore, mm(this._delegate, function aN(n) { return FA("limit", n), kE._create("limit", n, "F") }(e))) } catch (t) { throw ad(t, "limit()", "Query.limit()") } } limitToLast(e) { try { return new ld(this.firestore, mm(this._delegate, function lN(n) { return FA("limitToLast", n), kE._create("limitToLast", n, "L") }(e))) } catch (t) { throw ad(t, "limitToLast()", "Query.limitToLast()") } } startAt(...e) { try { return new ld(this.firestore, mm(this._delegate, function cN(...n) { return PE._create("startAt", n, !0) }(...e))) } catch (t) { throw ad(t, "startAt()", "Query.startAt()") } } startAfter(...e) { try { return new ld(this.firestore, mm(this._delegate, function uN(...n) { return PE._create("startAfter", n, !1) }(...e))) } catch (t) { throw ad(t, "startAfter()", "Query.startAfter()") } } endBefore(...e) { try { return new ld(this.firestore, mm(this._delegate, function dN(...n) { return RE._create("endBefore", n, !1) }(...e))) } catch (t) { throw ad(t, "endBefore()", "Query.endBefore()") } } endAt(...e) { try { return new ld(this.firestore, mm(this._delegate, function hN(...n) { return RE._create("endAt", n, !0) }(...e))) } catch (t) { throw ad(t, "endAt()", "Query.endAt()") } } isEqual(e) { return IS(this._delegate, e._delegate) } get(e) { let t; return t = "cache" === e?.source ? function vN(n) { n = ms(n, gu); const e = ms(n.firestore, ma), t = Al(e), r = new ym(e); return function FO(n, e) { const t = new ja; return n.asyncQueue.enqueueAndForget((0, cn.Z)(function* () { return (r = (0, cn.Z)(function* (a, d, _) { try { const E = yield mE(a, d, !0), x = new DA(d, E.Hi), B = x.Wu(E.documents), K = x.applyChanges(B, !1); _.resolve(K.snapshot) } catch (E) { const x = $v(E, `Failed to execute query '${d} against cache`); _.reject(x) } }), function (a, d, _) { return r.apply(this, arguments) })(yield SE(n), e, t); var r })), t.promise }(t, n._query).then(a => new _m(e, r, n, a)) }(this._delegate) : "server" === e?.source ? function bN(n) { n = ms(n, gu); const e = ms(n.firestore, ma), t = Al(e), r = new ym(e); return qA(t, n._query, { source: "server" }).then(a => new _m(e, r, n, a)) }(this._delegate) : function yN(n) { n = ms(n, gu); const e = ms(n.firestore, ma), t = Al(e), r = new ym(e); return sx(n._query), qA(t, n._query).then(a => new _m(e, r, n, a)) }(this._delegate), t.then(r => new qS(this.firestore, new _m(this.firestore._delegate, this._userDataWriter, this._delegate, r._snapshot))) } onSnapshot(...e) { const t = Ex(e), r = Tx(e, a => new qS(this.firestore, new _m(this.firestore._delegate, this._userDataWriter, this._delegate, a._snapshot))); return gx(this._delegate, t, r) } withConverter(e) { return new ld(this.firestore, this._delegate.withConverter(e ? ty.getInstance(this.firestore, e) : null)) } } class LN { constructor(e, t) { this._firestore = e, this._delegate = t } get type() { return this._delegate.type } get doc() { return new Bw(this._firestore, this._delegate.doc) } get oldIndex() { return this._delegate.oldIndex } get newIndex() { return this._delegate.newIndex } } class qS { constructor(e, t) { this._firestore = e, this._delegate = t } get query() { return new ld(this._firestore, this._delegate.query) } get metadata() { return this._delegate.metadata } get size() { return this._delegate.size } get empty() { return this._delegate.empty } get docs() { return this._delegate.docs.map(e => new Bw(this._firestore, e)) } docChanges(e) { return this._delegate.docChanges(e).map(t => new LN(this._firestore, t)) } forEach(e, t) { this._delegate.forEach(r => { e.call(t, new Bw(this._firestore, r)) }) } isEqual(e) { return hx(this._delegate, e._delegate) } } class Qv extends ld { constructor(e, t) { super(e, t), this.firestore = e, this._delegate = t } get id() { return this._delegate.id } get path() { return this._delegate.path } get parent() { const e = this._delegate.parent; return e ? new Bh(this.firestore, e) : null } doc(e) { try { return new Bh(this.firestore, void 0 === e ? EE(this._delegate) : EE(this._delegate, e)) } catch (t) { throw ad(t, "doc()", "CollectionReference.doc()") } } add(e) { return function CN(n, e) { const t = ms(n.firestore, ma), r = EE(n), a = FE(n.converter, e); return Jv(t, [xE(Q_(n.firestore), "addDoc", r._key, a, null !== n.converter, {}).toMutation(r._key, fa.exists(!1))]).then(() => r) }(this._delegate, e).then(t => new Bh(this.firestore, t)) } isEqual(e) { return HA(this._delegate, e._delegate) } withConverter(e) { return new Qv(this.firestore, this._delegate.withConverter(e ? ty.getInstance(this.firestore, e) : null)) } } function ny(n) { return ms(n, ga) } class YS { constructor(...e) { this._delegate = new cg(...e) } static documentId() { return new YS(Oa.keyField().canonicalString()) } isEqual(e) { return (e = (0, Pe.m9)(e)) instanceof cg && this._delegate._internalPath.isEqual(e._internalPath) } } class ry { constructor(e) { this._delegate = e } static serverTimestamp() { const e = function AN() { return new LS("serverTimestamp") }(); return e._methodName = "FieldValue.serverTimestamp", new ry(e) } static delete() { const e = function IN() { return new Ow("deleteField") }(); return e._methodName = "FieldValue.delete", new ry(e) } static arrayUnion(...e) { const t = function xN(...n) { return new eN("arrayUnion", n) }(...e); return t._methodName = "FieldValue.arrayUnion", new ry(t) } static arrayRemove(...e) { const t = function MN(...n) { return new tN("arrayRemove", n) }(...e); return t._methodName = "FieldValue.arrayRemove", new ry(t) } static increment(e) { const t = function ON(n) { return new nN("increment", n) }(e); return t._methodName = "FieldValue.increment", new ry(t) } isEqual(e) { return this._delegate.isEqual(e._delegate) } } const BN = { Firestore: bx, GeoPoint: IE, Timestamp: Vo, Blob: Fw, Transaction: wx, WriteBatch: Cx, DocumentReference: Bh, DocumentSnapshot: Lw, Query: ld, QueryDocumentSnapshot: Bw, QuerySnapshot: qS, CollectionReference: Qv, FieldPath: YS, FieldValue: ry, setLogLevel: function FN(n) { !function bv(n) { gc.setLogLevel(n) }(n) }, CACHE_SIZE_UNLIMITED: -1 }; function Dx(n, e) { return function HN(n, e = Ko.z) { return new Bu.y(t => { let r; return null != e ? e.schedule(() => { r = n.onSnapshot({ includeMetadataChanges: !0 }, t) }) : r = n.onSnapshot({ includeMetadataChanges: !0 }, t), () => { r?.() } }) }(n, e) } function KS(n, e) { return Dx(n, e).pipe((0, ao.U)(t => ({ payload: t, type: "query" }))) } function BE(n, e) { return KS(n, e).pipe((0, R0.O)(void 0), (0, jy.G)(), (0, ao.U)(([t, r]) => { const a = r.payload.docChanges(), d = a.map(_ => ({ type: _.type, payload: _ })); return t && JSON.stringify(t.payload.metadata) !== JSON.stringify(r.payload.metadata) && r.payload.docs.forEach((_, E) => { const x = a.find(K => K.doc.ref.isEqual(_.ref)), B = t?.payload.docs.find(K => K.ref.isEqual(_.ref)); x && JSON.stringify(x.doc.metadata) === JSON.stringify(_.metadata) || !x && B && JSON.stringify(B.metadata) === JSON.stringify(_.metadata) || d.push({ type: "modified", payload: { oldIndex: E, newIndex: E, type: "modified", doc: _ } }) }), d })) } function Sx(n, e, t) { return BE(n, t).pipe((0, Ia.R)((r, a) => function GN(n, e, t) { return e.forEach(r => { t.indexOf(r.type) > -1 && (n = function jN(n, e) { switch (e.type) { case "added": if (!n[e.newIndex] || !n[e.newIndex].doc.ref.isEqual(e.doc.ref)) return JS(n, e.newIndex, 0, e); break; case "modified": if (null == n[e.oldIndex] || n[e.oldIndex].doc.ref.isEqual(e.doc.ref)) { if (e.oldIndex !== e.newIndex) { const t = n.slice(); return t.splice(e.oldIndex, 1), t.splice(e.newIndex, 0, e), t } return JS(n, e.newIndex, 1, e) } break; case "removed": if (n[e.oldIndex] && n[e.oldIndex].doc.ref.isEqual(e.doc.ref)) return JS(n, e.oldIndex, 1) }return n }(n, r)) }), n }(r, a.map(d => d.payload), e), []), (0, Vs.x)(), (0, ao.U)(r => r.map(a => ({ type: a.type, payload: a })))) } function JS(n, e, t, ...r) { const a = n.slice(); return a.splice(e, t, ...r), a } function Ix(n) { return (!n || 0 === n.length) && (n = ["added", "removed", "modified"]), n } !function UN(n) { (function VN(n, e) { n.INTERNAL.registerComponent(new Oc.wA("firestore-compat", t => { const r = t.getProvider("app-compat").getImmediate(), a = t.getProvider("firestore").getImmediate(); return e(r, a) }, "PUBLIC").setServiceProps(Object.assign({}, BN))) })(n, (e, t) => new bx(e, t, new RN)), n.registerVersion("@firebase/firestore-compat", "0.3.0") }(Mc.Z); class Ax { constructor(e, t, r) { this.ref = e, this.query = t, this.afs = r } stateChanges(e) { let t = BE(this.query, this.afs.schedulers.outsideAngular); return e && e.length > 0 && (t = t.pipe((0, ao.U)(r => r.filter(a => e.indexOf(a.type) > -1)))), t.pipe((0, R0.O)(void 0), (0, jy.G)(), (0, F0.h)(([r, a]) => a.length > 0 || !r), (0, ao.U)(([r, a]) => a), ci.iC) } auditTrail(e) { return this.stateChanges(e).pipe((0, Ia.R)((t, r) => [...t, ...r], [])) } snapshotChanges(e) { const t = Ix(e); return Sx(this.query, t, this.afs.schedulers.outsideAngular).pipe(ci.iC) } valueChanges(e = {}) { return KS(this.query, this.afs.schedulers.outsideAngular).pipe((0, ao.U)(t => t.payload.docs.map(r => e.idField ? Object.assign(Object.assign({}, r.data()), { [e.idField]: r.id }) : r.data())), ci.iC) } get(e) { return (0, Km.D)(this.query.get(e)).pipe(ci.iC) } add(e) { return this.ref.add(e) } doc(e) { return new xx(this.ref.doc(e), this.afs) } } class xx { constructor(e, t) { this.ref = e, this.afs = t } set(e, t) { return this.ref.set(e, t) } update(e) { return this.ref.update(e) } delete() { return this.ref.delete() } collection(e, t) { const r = this.ref.collection(e), { ref: a, query: d } = Nx(r, t); return new Ax(a, d, this.afs) } snapshotChanges() { return function zN(n, e) { return Dx(n, e).pipe((0, R0.O)(void 0), (0, jy.G)(), (0, ao.U)(([t, r]) => r.exists ? t?.exists ? { payload: r, type: "modified" } : { payload: r, type: "added" } : { payload: r, type: "removed" })) }(this.ref, this.afs.schedulers.outsideAngular).pipe(ci.iC) } valueChanges(e = {}) { return this.snapshotChanges().pipe((0, ao.U)(({ payload: t }) => e.idField ? Object.assign(Object.assign({}, t.data()), { [e.idField]: t.id }) : t.data())) } get(e) { return (0, Km.D)(this.ref.get(e)).pipe(ci.iC) } } class $N { constructor(e, t) { this.query = e, this.afs = t } stateChanges(e) { return e && 0 !== e.length ? BE(this.query, this.afs.schedulers.outsideAngular).pipe((0, ao.U)(t => t.filter(r => e.indexOf(r.type) > -1)), (0, F0.h)(t => t.length > 0), ci.iC) : BE(this.query, this.afs.schedulers.outsideAngular).pipe(ci.iC) } auditTrail(e) { return this.stateChanges(e).pipe((0, Ia.R)((t, r) => [...t, ...r], [])) } snapshotChanges(e) { const t = Ix(e); return Sx(this.query, t, this.afs.schedulers.outsideAngular).pipe(ci.iC) } valueChanges(e = {}) { return KS(this.query, this.afs.schedulers.outsideAngular).pipe((0, ao.U)(r => r.payload.docs.map(a => e.idField ? Object.assign({ [e.idField]: a.id }, a.data()) : a.data())), ci.iC) } get(e) { return (0, Km.D)(this.query.get(e)).pipe(ci.iC) } } const Mx = new m.OlP("angularfire2.enableFirestorePersistence"), Ox = new m.OlP("angularfire2.firestore.persistenceSettings"), WN = new m.OlP("angularfire2.firestore.settings"), ZN = new m.OlP("angularfire2.firestore.use-emulator"); function Nx(n, e = (t => t)) { return { query: e(n), ref: n } } let qN = (() => { class n { constructor(t, r, a, d, _, E, x, B, K, oe, Me, ot, bt, qt, Tn, cr, $r) { this.schedulers = x; const Rr = (0, Aa.on)(t, E, r), Li = K; oe && (0, Hl.nw)(Rr, E, Me, bt, qt, Tn, ot, cr), [this.firestore, this.persistenceEnabled$] = (0, Aa.cc)(`${Rr.name}.firestore`, "AngularFirestore", Rr.name, () => { const Ki = E.runOutsideAngular(() => Rr.firestore()); if (d && Ki.settings(d), Li && Ki.useEmulator(...Li), a && !(0, rt.PM)(_)) { const Pi = () => { try { return (0, Km.D)(Ki.enablePersistence(B || void 0).then(() => !0, () => !1)) } catch (Es) { return typeof console < "u" && console.warn(Es), (0, Qc.of)(!1) } }; return [Ki, E.runOutsideAngular(Pi)] } return [Ki, (0, Qc.of)(!1)] }, [d, Li, a]) } collection(t, r) { let a; a = "string" == typeof t ? this.firestore.collection(t) : t; const { ref: d, query: _ } = Nx(a, r), E = this.schedulers.ngZone.run(() => d); return new Ax(E, _, this) } collectionGroup(t, r) { const a = r || (_ => _), d = this.firestore.collectionGroup(t); return new $N(a(d), this) } doc(t) { let r; r = "string" == typeof t ? this.firestore.doc(t) : t; const a = this.schedulers.ngZone.run(() => r); return new xx(a, this) } createId() { return this.firestore.collection("_").doc().id } } return n.\u0275fac = function (t) { return new (t || n)(m.LFG(Aa.Dh), m.LFG(Aa.xv, 8), m.LFG(Mx, 8), m.LFG(WN, 8), m.LFG(m.Lbi), m.LFG(m.R0b), m.LFG(ci.HU), m.LFG(Ox, 8), m.LFG(ZN, 8), m.LFG(Hl.zQ, 8), m.LFG(Hl.Qv, 8), m.LFG(Hl.L6, 8), m.LFG(Hl._Q, 8), m.LFG(Hl.rT, 8), m.LFG(Hl.lh, 8), m.LFG(Hl.f7, 8), m.LFG(zy.nm, 8)) }, n.\u0275prov = m.Yz7({ token: n, factory: n.\u0275fac, providedIn: "any" }), n })(), YN = (() => { class n { constructor() { qm.Z.registerVersion("angularfire", ci.q4.full, "fst-compat") } static enablePersistence(t) { return { ngModule: n, providers: [{ provide: Mx, useValue: !0 }, { provide: Ox, useValue: t }] } } } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275mod = m.oAB({ type: n }), n.\u0275inj = m.cJS({ providers: [qN] }), n })(), KN = (() => { class n { } return n.\u0275fac = function (t) { return new (t || n) }, n.\u0275mod = m.oAB({ type: n, bootstrap: [Zt] }), n.\u0275inj = m.cJS({ providers: [xe], imports: [i.b2, qe, Lu, ia.JF, Ac.Rh.forRoot(), Ac.L4, Aa.hO.initializeApp(S1_firebase), YN, Hl.ww, ur.To, el.e4, Yo.FP, iT] }), n })(); (0, m.G48)(), i.q6().bootstrapModule(KN).catch(n => console.error(n)) }, 1345: un => { var Ce = "function" == typeof Float32Array; function we(Se, rt) { return 1 - 3 * rt + 3 * Se } function Te(Se, rt) { return 3 * rt - 6 * Se } function Ee(Se) { return 3 * Se } function _e(Se, rt, wt) { return ((we(rt, wt) * Se + Te(rt, wt)) * Se + Ee(rt)) * Se } function ae(Se, rt, wt) { return 3 * we(rt, wt) * Se * Se + 2 * Te(rt, wt) * Se + Ee(rt) } function gt(Se) { return Se } un.exports = function (rt, wt, De, je) { if (!(0 <= rt && rt <= 1 && 0 <= De && De <= 1)) throw new Error("bezier x values must be in [0, 1] range"); if (rt === wt && De === je) return gt; for (var _t = Ce ? new Float32Array(11) : new Array(11), Qe = 0; Qe < 11; ++Qe)_t[Qe] = _e(.1 * Qe, rt, De); return function (Ve) { return 0 === Ve ? 0 : 1 === Ve ? 1 : _e(function ct(Oe) { for (var Ve = 0, Be = 1; 10 !== Be && _t[Be] <= Oe; ++Be)Ve += .1; --Be; var tt = Ve + (Oe - _t[Be]) / (_t[Be + 1] - _t[Be]) * .1, Fe = ae(tt, rt, De); return Fe >= .001 ? function xe(Se, rt, wt, De) { for (var je = 0; je < 4; ++je) { var _t = ae(rt, wt, De); if (0 === _t) return rt; rt -= (_e(rt, wt, De) - Se) / _t } return rt }(Oe, tt, rt, De) : 0 === Fe ? tt : function ve(Se, rt, wt, De, je) { var _t, Qe, ct = 0; do { (_t = _e(Qe = rt + (wt - rt) / 2, De, je) - Se) > 0 ? wt = Qe : rt = Qe } while (Math.abs(_t) > 1e-7 && ++ct < 10); return Qe }(Oe, Ve, Ve + .1, rt, De) }(Ve), wt, je) } } }, 1135: (un, Je, L) => { "use strict"; L.d(Je, { X: () => m }); var i = L(7579); class m extends i.x { constructor(ye) { super(), this._value = ye } get value() { return this.getValue() } _subscribe(ye) { const Ce = super._subscribe(ye); return !Ce.closed && ye.next(this._value), Ce } getValue() { const { hasError: ye, thrownError: Ce, _value: we } = this; if (ye) throw Ce; return this._throwIfClosed(), we } next(ye) { super.next(this._value = ye) } } }, 9751: (un, Je, L) => { "use strict"; L.d(Je, { y: () => Ee }); var i = L(930), m = L(727), J = L(8822), ye = L(9635), Ce = L(2416), we = L(576), Te = L(2806); let Ee = (() => { class xe { constructor(Se) { Se && (this._subscribe = Se) } lift(Se) { const rt = new xe; return rt.source = this, rt.operator = Se, rt } subscribe(Se, rt, wt) { const De = function ve(xe) { return xe && xe instanceof i.Lv || function ae(xe) { return xe && (0, we.m)(xe.next) && (0, we.m)(xe.error) && (0, we.m)(xe.complete) }(xe) && (0, m.Nn)(xe) }(Se) ? Se : new i.Hp(Se, rt, wt); return (0, Te.x)(() => { const { operator: je, source: _t } = this; De.add(je ? je.call(De, _t) : _t ? this._subscribe(De) : this._trySubscribe(De)) }), De } _trySubscribe(Se) { try { return this._subscribe(Se) } catch (rt) { Se.error(rt) } } forEach(Se, rt) { return new (rt = _e(rt))((wt, De) => { const je = new i.Hp({ next: _t => { try { Se(_t) } catch (Qe) { De(Qe), je.unsubscribe() } }, error: De, complete: wt }); this.subscribe(je) }) } _subscribe(Se) { var rt; return null === (rt = this.source) || void 0 === rt ? void 0 : rt.subscribe(Se) } [J.L]() { return this } pipe(...Se) { return (0, ye.U)(Se)(this) } toPromise(Se) { return new (Se = _e(Se))((rt, wt) => { let De; this.subscribe(je => De = je, je => wt(je), () => rt(De)) }) } } return xe.create = gt => new xe(gt), xe })(); function _e(xe) { var gt; return null !== (gt = xe ?? Ce.v.Promise) && void 0 !== gt ? gt : Promise } }, 4707: (un, Je, L) => { "use strict"; L.d(Je, { t: () => J }); var i = L(7579), m = L(6063); class J extends i.x { constructor(Ce = 1 / 0, we = 1 / 0, Te = m.l) { super(), this._bufferSize = Ce, this._windowTime = we, this._timestampProvider = Te, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = we === 1 / 0, this._bufferSize = Math.max(1, Ce), this._windowTime = Math.max(1, we) } next(Ce) { const { isStopped: we, _buffer: Te, _infiniteTimeWindow: Ee, _timestampProvider: _e, _windowTime: ae } = this; we || (Te.push(Ce), !Ee && Te.push(_e.now() + ae)), this._trimBuffer(), super.next(Ce) } _subscribe(Ce) { this._throwIfClosed(), this._trimBuffer(); const we = this._innerSubscribe(Ce), { _infiniteTimeWindow: Te, _buffer: Ee } = this, _e = Ee.slice(); for (let ae = 0; ae < _e.length && !Ce.closed; ae += Te ? 1 : 2)Ce.next(_e[ae]); return this._checkFinalizedStatuses(Ce), we } _trimBuffer() { const { _bufferSize: Ce, _timestampProvider: we, _buffer: Te, _infiniteTimeWindow: Ee } = this, _e = (Ee ? 1 : 2) * Ce; if (Ce < 1 / 0 && _e < Te.length && Te.splice(0, Te.length - _e), !Ee) { const ae = we.now(); let ve = 0; for (let xe = 1; xe < Te.length && Te[xe] <= ae; xe += 2)ve = xe; ve && Te.splice(0, ve + 1) } } } }, 7579: (un, Je, L) => { "use strict"; L.d(Je, { x: () => Te }); var i = L(9751), m = L(727); const ye = (0, L(3888).d)(_e => function () { _e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); var Ce = L(8737), we = L(2806); let Te = (() => { class _e extends i.y { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(ve) { const xe = new Ee(this, this); return xe.operator = ve, xe } _throwIfClosed() { if (this.closed) throw new ye } next(ve) { (0, we.x)(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const xe of this.currentObservers) xe.next(ve) } }) } error(ve) { (0, we.x)(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = ve; const { observers: xe } = this; for (; xe.length;)xe.shift().error(ve) } }) } complete() { (0, we.x)(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: ve } = this; for (; ve.length;)ve.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var ve; return (null === (ve = this.observers) || void 0 === ve ? void 0 : ve.length) > 0 } _trySubscribe(ve) { return this._throwIfClosed(), super._trySubscribe(ve) } _subscribe(ve) { return this._throwIfClosed(), this._checkFinalizedStatuses(ve), this._innerSubscribe(ve) } _innerSubscribe(ve) { const { hasError: xe, isStopped: gt, observers: Se } = this; return xe || gt ? m.Lc : (this.currentObservers = null, Se.push(ve), new m.w0(() => { this.currentObservers = null, (0, Ce.P)(Se, ve) })) } _checkFinalizedStatuses(ve) { const { hasError: xe, thrownError: gt, isStopped: Se } = this; xe ? ve.error(gt) : Se && ve.complete() } asObservable() { const ve = new i.y; return ve.source = this, ve } } return _e.create = (ae, ve) => new Ee(ae, ve), _e })(); class Ee extends Te { constructor(ae, ve) { super(), this.destination = ae, this.source = ve } next(ae) { var ve, xe; null === (xe = null === (ve = this.destination) || void 0 === ve ? void 0 : ve.next) || void 0 === xe || xe.call(ve, ae) } error(ae) { var ve, xe; null === (xe = null === (ve = this.destination) || void 0 === ve ? void 0 : ve.error) || void 0 === xe || xe.call(ve, ae) } complete() { var ae, ve; null === (ve = null === (ae = this.destination) || void 0 === ae ? void 0 : ae.complete) || void 0 === ve || ve.call(ae) } _subscribe(ae) { var ve, xe; return null !== (xe = null === (ve = this.source) || void 0 === ve ? void 0 : ve.subscribe(ae)) && void 0 !== xe ? xe : m.Lc } } }, 930: (un, Je, L) => { "use strict"; L.d(Je, { Hp: () => wt, Lv: () => xe }); var i = L(576), m = L(727), J = L(2416), ye = L(7849), Ce = L(5032); const we = _e("C", void 0, void 0); function _e(ct, Oe, Ve) { return { kind: ct, value: Oe, error: Ve } } var ae = L(3410), ve = L(2806); class xe extends m.w0 { constructor(Oe) { super(), this.isStopped = !1, Oe ? (this.destination = Oe, (0, m.Nn)(Oe) && Oe.add(this)) : this.destination = Qe } static create(Oe, Ve, Be) { return new wt(Oe, Ve, Be) } next(Oe) { this.isStopped ? _t(function Ee(ct) { return _e("N", ct, void 0) }(Oe), this) : this._next(Oe) } error(Oe) { this.isStopped ? _t(function Te(ct) { return _e("E", void 0, ct) }(Oe), this) : (this.isStopped = !0, this._error(Oe)) } complete() { this.isStopped ? _t(we, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(Oe) { this.destination.next(Oe) } _error(Oe) { try { this.destination.error(Oe) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const gt = Function.prototype.bind; function Se(ct, Oe) { return gt.call(ct, Oe) } class rt { constructor(Oe) { this.partialObserver = Oe } next(Oe) { const { partialObserver: Ve } = this; if (Ve.next) try { Ve.next(Oe) } catch (Be) { De(Be) } } error(Oe) { const { partialObserver: Ve } = this; if (Ve.error) try { Ve.error(Oe) } catch (Be) { De(Be) } else De(Oe) } complete() { const { partialObserver: Oe } = this; if (Oe.complete) try { Oe.complete() } catch (Ve) { De(Ve) } } } class wt extends xe { constructor(Oe, Ve, Be) { let nt; if (super(), (0, i.m)(Oe) || !Oe) nt = { next: Oe ?? void 0, error: Ve ?? void 0, complete: Be ?? void 0 }; else { let Ne; this && J.v.useDeprecatedNextContext ? (Ne = Object.create(Oe), Ne.unsubscribe = () => this.unsubscribe(), nt = { next: Oe.next && Se(Oe.next, Ne), error: Oe.error && Se(Oe.error, Ne), complete: Oe.complete && Se(Oe.complete, Ne) }) : nt = Oe } this.destination = new rt(nt) } } function De(ct) { J.v.useDeprecatedSynchronousErrorHandling ? (0, ve.O)(ct) : (0, ye.h)(ct) } function _t(ct, Oe) { const { onStoppedNotification: Ve } = J.v; Ve && ae.z.setTimeout(() => Ve(ct, Oe)) } const Qe = { closed: !0, next: Ce.Z, error: function je(ct) { throw ct }, complete: Ce.Z } }, 727: (un, Je, L) => { "use strict"; L.d(Je, { Lc: () => we, w0: () => Ce, Nn: () => Te }); var i = L(576); const J = (0, L(3888).d)(_e => function (ve) { _e(this), this.message = ve ? `${ve.length} errors occurred during unsubscription:\n${ve.map((xe, gt) => `${gt + 1}) ${xe.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = ve }); var ye = L(8737); class Ce { constructor(ae) { this.initialTeardown = ae, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let ae; if (!this.closed) { this.closed = !0; const { _parentage: ve } = this; if (ve) if (this._parentage = null, Array.isArray(ve)) for (const Se of ve) Se.remove(this); else ve.remove(this); const { initialTeardown: xe } = this; if ((0, i.m)(xe)) try { xe() } catch (Se) { ae = Se instanceof J ? Se.errors : [Se] } const { _finalizers: gt } = this; if (gt) { this._finalizers = null; for (const Se of gt) try { Ee(Se) } catch (rt) { ae = ae ?? [], rt instanceof J ? ae = [...ae, ...rt.errors] : ae.push(rt) } } if (ae) throw new J(ae) } } add(ae) { var ve; if (ae && ae !== this) if (this.closed) Ee(ae); else { if (ae instanceof Ce) { if (ae.closed || ae._hasParent(this)) return; ae._addParent(this) } (this._finalizers = null !== (ve = this._finalizers) && void 0 !== ve ? ve : []).push(ae) } } _hasParent(ae) { const { _parentage: ve } = this; return ve === ae || Array.isArray(ve) && ve.includes(ae) } _addParent(ae) { const { _parentage: ve } = this; this._parentage = Array.isArray(ve) ? (ve.push(ae), ve) : ve ? [ve, ae] : ae } _removeParent(ae) { const { _parentage: ve } = this; ve === ae ? this._parentage = null : Array.isArray(ve) && (0, ye.P)(ve, ae) } remove(ae) { const { _finalizers: ve } = this; ve && (0, ye.P)(ve, ae), ae instanceof Ce && ae._removeParent(this) } } Ce.EMPTY = (() => { const _e = new Ce; return _e.closed = !0, _e })(); const we = Ce.EMPTY; function Te(_e) { return _e instanceof Ce || _e && "closed" in _e && (0, i.m)(_e.remove) && (0, i.m)(_e.add) && (0, i.m)(_e.unsubscribe) } function Ee(_e) { (0, i.m)(_e) ? _e() : _e.unsubscribe() } }, 2416: (un, Je, L) => { "use strict"; L.d(Je, { v: () => i }); const i = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 } }, 4033: (un, Je, L) => { "use strict"; L.d(Je, { c: () => we }); var i = L(9751), m = L(727), J = L(8343), ye = L(5403), Ce = L(4482); class we extends i.y { constructor(Ee, _e) { super(), this.source = Ee, this.subjectFactory = _e, this._subject = null, this._refCount = 0, this._connection = null, (0, Ce.A)(Ee) && (this.lift = Ee.lift) } _subscribe(Ee) { return this.getSubject().subscribe(Ee) } getSubject() { const Ee = this._subject; return (!Ee || Ee.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: Ee } = this; this._subject = this._connection = null, Ee?.unsubscribe() } connect() { let Ee = this._connection; if (!Ee) { Ee = this._connection = new m.w0; const _e = this.getSubject(); Ee.add(this.source.subscribe((0, ye.x)(_e, void 0, () => { this._teardown(), _e.complete() }, ae => { this._teardown(), _e.error(ae) }, () => this._teardown()))), Ee.closed && (this._connection = null, Ee = m.w0.EMPTY) } return Ee } refCount() { return (0, J.x)()(this) } } }, 9841: (un, Je, L) => { "use strict"; L.d(Je, { a: () => ae }); var i = L(9751), m = L(4742), J = L(8996), ye = L(4671), Ce = L(3268), we = L(3269), Te = L(1810), Ee = L(5403), _e = L(9672); function ae(...gt) { const Se = (0, we.yG)(gt), rt = (0, we.jO)(gt), { args: wt, keys: De } = (0, m.D)(gt); if (0 === wt.length) return (0, J.D)([], Se); const je = new i.y(function ve(gt, Se, rt = ye.y) { return wt => { xe(Se, () => { const { length: De } = gt, je = new Array(De); let _t = De, Qe = De; for (let ct = 0; ct < De; ct++)xe(Se, () => { const Oe = (0, J.D)(gt[ct], Se); let Ve = !1; Oe.subscribe((0, Ee.x)(wt, Be => { je[ct] = Be, Ve || (Ve = !0, Qe--), Qe || wt.next(rt(je.slice())) }, () => { --_t || wt.complete() })) }, wt) }, wt) } }(wt, Se, De ? _t => (0, Te.n)(De, _t) : ye.y)); return rt ? je.pipe((0, Ce.Z)(rt)) : je } function xe(gt, Se, rt) { gt ? (0, _e.f)(rt, gt, Se) : Se() } }, 7272: (un, Je, L) => { "use strict"; L.d(Je, { z: () => Ce }); var i = L(8189), J = L(3269), ye = L(8996); function Ce(...we) { return function m() { return (0, i.J)(1) }()((0, ye.D)(we, (0, J.yG)(we))) } }, 9770: (un, Je, L) => { "use strict"; L.d(Je, { P: () => J }); var i = L(9751), m = L(8421); function J(ye) { return new i.y(Ce => { (0, m.Xf)(ye()).subscribe(Ce) }) } }, 515: (un, Je, L) => { "use strict"; L.d(Je, { E: () => m }); const m = new (L(9751).y)(Ce => Ce.complete()) }, 4128: (un, Je, L) => { "use strict"; L.d(Je, { D: () => Ee }); var i = L(9751), m = L(4742), J = L(8421), ye = L(3269), Ce = L(5403), we = L(3268), Te = L(1810); function Ee(..._e) { const ae = (0, ye.jO)(_e), { args: ve, keys: xe } = (0, m.D)(_e), gt = new i.y(Se => { const { length: rt } = ve; if (!rt) return void Se.complete(); const wt = new Array(rt); let De = rt, je = rt; for (let _t = 0; _t < rt; _t++) { let Qe = !1; (0, J.Xf)(ve[_t]).subscribe((0, Ce.x)(Se, ct => { Qe || (Qe = !0, je--), wt[_t] = ct }, () => De--, void 0, () => { (!De || !Qe) && (je || Se.next(xe ? (0, Te.n)(xe, wt) : wt), Se.complete()) })) } }); return ae ? gt.pipe((0, we.Z)(ae)) : gt } }, 8996: (un, Je, L) => { "use strict"; L.d(Je, { D: () => Oe }); var i = L(8421), m = L(5363), J = L(9468), we = L(9751), Ee = L(2202), _e = L(576), ae = L(9672); function xe(Ve, Be) { if (!Ve) throw new Error("Iterable cannot be null"); return new we.y(nt => { (0, ae.f)(nt, Be, () => { const Ne = Ve[Symbol.asyncIterator](); (0, ae.f)(nt, Be, () => { Ne.next().then(tt => { tt.done ? nt.complete() : nt.next(tt.value) }) }, 0, !0) }) }) } var gt = L(3670), Se = L(8239), rt = L(1144), wt = L(6495), De = L(2206), je = L(4532), _t = L(3260); function Oe(Ve, Be) { return Be ? function ct(Ve, Be) { if (null != Ve) { if ((0, gt.c)(Ve)) return function ye(Ve, Be) { return (0, i.Xf)(Ve).pipe((0, J.R)(Be), (0, m.Q)(Be)) }(Ve, Be); if ((0, rt.z)(Ve)) return function Te(Ve, Be) { return new we.y(nt => { let Ne = 0; return Be.schedule(function () { Ne === Ve.length ? nt.complete() : (nt.next(Ve[Ne++]), nt.closed || this.schedule()) }) }) }(Ve, Be); if ((0, Se.t)(Ve)) return function Ce(Ve, Be) { return (0, i.Xf)(Ve).pipe((0, J.R)(Be), (0, m.Q)(Be)) }(Ve, Be); if ((0, De.D)(Ve)) return xe(Ve, Be); if ((0, wt.T)(Ve)) return function ve(Ve, Be) { return new we.y(nt => { let Ne; return (0, ae.f)(nt, Be, () => { Ne = Ve[Ee.h](), (0, ae.f)(nt, Be, () => { let tt, Fe; try { ({ value: tt, done: Fe } = Ne.next()) } catch (Ue) { return void nt.error(Ue) } Fe ? nt.complete() : nt.next(tt) }, 0, !0) }), () => (0, _e.m)(Ne?.return) && Ne.return() }) }(Ve, Be); if ((0, _t.L)(Ve)) return function Qe(Ve, Be) { return xe((0, _t.Q)(Ve), Be) }(Ve, Be) } throw (0, je.z)(Ve) }(Ve, Be) : (0, i.Xf)(Ve) } }, 4968: (un, Je, L) => { "use strict"; L.d(Je, { R: () => ae }); var i = L(8421), m = L(9751), J = L(6099), ye = L(1144), Ce = L(576), we = L(3268); const Te = ["addListener", "removeListener"], Ee = ["addEventListener", "removeEventListener"], _e = ["on", "off"]; function ae(rt, wt, De, je) { if ((0, Ce.m)(De) && (je = De, De = void 0), je) return ae(rt, wt, De).pipe((0, we.Z)(je)); const [_t, Qe] = function Se(rt) { return (0, Ce.m)(rt.addEventListener) && (0, Ce.m)(rt.removeEventListener) }(rt) ? Ee.map(ct => Oe => rt[ct](wt, Oe, De)) : function xe(rt) { return (0, Ce.m)(rt.addListener) && (0, Ce.m)(rt.removeListener) }(rt) ? Te.map(ve(rt, wt)) : function gt(rt) { return (0, Ce.m)(rt.on) && (0, Ce.m)(rt.off) }(rt) ? _e.map(ve(rt, wt)) : []; if (!_t && (0, ye.z)(rt)) return (0, J.z)(ct => ae(ct, wt, De))((0, i.Xf)(rt)); if (!_t) throw new TypeError("Invalid event target"); return new m.y(ct => { const Oe = (...Ve) => ct.next(1 < Ve.length ? Ve : Ve[0]); return _t(Oe), () => Qe(Oe) }) } function ve(rt, wt) { return De => je => rt[De](wt, je) } }, 8421: (un, Je, L) => { "use strict"; L.d(Je, { Xf: () => gt }); var i = L(655), m = L(1144), J = L(8239), ye = L(9751), Ce = L(3670), we = L(2206), Te = L(4532), Ee = L(6495), _e = L(3260), ae = L(576), ve = L(7849), xe = L(8822); function gt(ct) { if (ct instanceof ye.y) return ct; if (null != ct) { if ((0, Ce.c)(ct)) return function Se(ct) { return new ye.y(Oe => { const Ve = ct[xe.L](); if ((0, ae.m)(Ve.subscribe)) return Ve.subscribe(Oe); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(ct); if ((0, m.z)(ct)) return function rt(ct) { return new ye.y(Oe => { for (let Ve = 0; Ve < ct.length && !Oe.closed; Ve++)Oe.next(ct[Ve]); Oe.complete() }) }(ct); if ((0, J.t)(ct)) return function wt(ct) { return new ye.y(Oe => { ct.then(Ve => { Oe.closed || (Oe.next(Ve), Oe.complete()) }, Ve => Oe.error(Ve)).then(null, ve.h) }) }(ct); if ((0, we.D)(ct)) return je(ct); if ((0, Ee.T)(ct)) return function De(ct) { return new ye.y(Oe => { for (const Ve of ct) if (Oe.next(Ve), Oe.closed) return; Oe.complete() }) }(ct); if ((0, _e.L)(ct)) return function _t(ct) { return je((0, _e.Q)(ct)) }(ct) } throw (0, Te.z)(ct) } function je(ct) { return new ye.y(Oe => { (function Qe(ct, Oe) { var Ve, Be, nt, Ne; return (0, i.mG)(this, void 0, void 0, function* () { try { for (Ve = (0, i.KL)(ct); !(Be = yield Ve.next()).done;)if (Oe.next(Be.value), Oe.closed) return } catch (tt) { nt = { error: tt } } finally { try { Be && !Be.done && (Ne = Ve.return) && (yield Ne.call(Ve)) } finally { if (nt) throw nt.error } } Oe.complete() }) })(ct, Oe).catch(Ve => Oe.error(Ve)) }) } }, 6451: (un, Je, L) => { "use strict"; L.d(Je, { T: () => we }); var i = L(8189), m = L(8421), J = L(515), ye = L(3269), Ce = L(8996); function we(...Te) { const Ee = (0, ye.yG)(Te), _e = (0, ye._6)(Te, 1 / 0), ae = Te; return ae.length ? 1 === ae.length ? (0, m.Xf)(ae[0]) : (0, i.J)(_e)((0, Ce.D)(ae, Ee)) : J.E } }, 9646: (un, Je, L) => { "use strict"; L.d(Je, { of: () => J }); var i = L(3269), m = L(8996); function J(...ye) { const Ce = (0, i.yG)(ye); return (0, m.D)(ye, Ce) } }, 2843: (un, Je, L) => { "use strict"; L.d(Je, { _: () => J }); var i = L(9751), m = L(576); function J(ye, Ce) { const we = (0, m.m)(ye) ? ye : () => ye, Te = Ee => Ee.error(we()); return new i.y(Ce ? Ee => Ce.schedule(Te, 0, Ee) : Te) } }, 5963: (un, Je, L) => { "use strict"; L.d(Je, { H: () => Ce }); var i = L(9751), m = L(4986), J = L(3532); function Ce(we = 0, Te, Ee = m.P) { let _e = -1; return null != Te && ((0, J.K)(Te) ? Ee = Te : _e = Te), new i.y(ae => { let ve = function ye(we) { return we instanceof Date && !isNaN(we) }(we) ? +we - Ee.now() : we; ve < 0 && (ve = 0); let xe = 0; return Ee.schedule(function () { ae.closed || (ae.next(xe++), 0 <= _e ? this.schedule(void 0, _e) : ae.complete()) }, ve) }) } }, 2557: (un, Je, L) => { "use strict"; L.d(Je, { $: () => Te }); var i = L(9751), m = L(8421), J = L(5797), ye = L(515), Ce = L(5403), we = L(3269); function Te(...Ee) { const _e = (0, we.jO)(Ee), ae = (0, J.k)(Ee); return ae.length ? new i.y(ve => { let xe = ae.map(() => []), gt = ae.map(() => !1); ve.add(() => { xe = gt = null }); for (let Se = 0; !ve.closed && Se < ae.length; Se++)(0, m.Xf)(ae[Se]).subscribe((0, Ce.x)(ve, rt => { if (xe[Se].push(rt), xe.every(wt => wt.length)) { const wt = xe.map(De => De.shift()); ve.next(_e ? _e(...wt) : wt), xe.some((De, je) => !De.length && gt[je]) && ve.complete() } }, () => { gt[Se] = !0, !xe[Se].length && ve.complete() })); return () => { xe = gt = null } }) : ye.E } }, 5403: (un, Je, L) => { "use strict"; L.d(Je, { x: () => m }); var i = L(930); function m(ye, Ce, we, Te, Ee) { return new J(ye, Ce, we, Te, Ee) } class J extends i.Lv { constructor(Ce, we, Te, Ee, _e, ae) { super(Ce), this.onFinalize = _e, this.shouldUnsubscribe = ae, this._next = we ? function (ve) { try { we(ve) } catch (xe) { Ce.error(xe) } } : super._next, this._error = Ee ? function (ve) { try { Ee(ve) } catch (xe) { Ce.error(xe) } finally { this.unsubscribe() } } : super._error, this._complete = Te ? function () { try { Te() } catch (ve) { Ce.error(ve) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var Ce; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: we } = this; super.unsubscribe(), !we && (null === (Ce = this.onFinalize) || void 0 === Ce || Ce.call(this)) } } } }, 3601: (un, Je, L) => { "use strict"; L.d(Je, { e: () => Te }); var i = L(4986), m = L(4482), J = L(8421), ye = L(5403), we = L(5963); function Te(Ee, _e = i.z) { return function Ce(Ee) { return (0, m.e)((_e, ae) => { let ve = !1, xe = null, gt = null, Se = !1; const rt = () => { if (gt?.unsubscribe(), gt = null, ve) { ve = !1; const De = xe; xe = null, ae.next(De) } Se && ae.complete() }, wt = () => { gt = null, Se && ae.complete() }; _e.subscribe((0, ye.x)(ae, De => { ve = !0, xe = De, gt || (0, J.Xf)(Ee(De)).subscribe(gt = (0, ye.x)(ae, rt, wt)) }, () => { Se = !0, (!ve || !gt || gt.closed) && ae.complete() })) }) }(() => (0, we.H)(Ee, _e)) } }, 262: (un, Je, L) => { "use strict"; L.d(Je, { K: () => ye }); var i = L(8421), m = L(5403), J = L(4482); function ye(Ce) { return (0, J.e)((we, Te) => { let ae, Ee = null, _e = !1; Ee = we.subscribe((0, m.x)(Te, void 0, void 0, ve => { ae = (0, i.Xf)(Ce(ve, ye(Ce)(we))), Ee ? (Ee.unsubscribe(), Ee = null, ae.subscribe(Te)) : _e = !0 })), _e && (Ee.unsubscribe(), Ee = null, ae.subscribe(Te)) }) } }, 4351: (un, Je, L) => { "use strict"; L.d(Je, { b: () => J }); var i = L(6099), m = L(576); function J(ye, Ce) { return (0, m.m)(Ce) ? (0, i.z)(ye, Ce, 1) : (0, i.z)(ye, 1) } }, 8372: (un, Je, L) => { "use strict"; L.d(Je, { b: () => ye }); var i = L(4986), m = L(4482), J = L(5403); function ye(Ce, we = i.z) { return (0, m.e)((Te, Ee) => { let _e = null, ae = null, ve = null; const xe = () => { if (_e) { _e.unsubscribe(), _e = null; const Se = ae; ae = null, Ee.next(Se) } }; function gt() { const Se = ve + Ce, rt = we.now(); if (rt < Se) return _e = this.schedule(void 0, Se - rt), void Ee.add(_e); xe() } Te.subscribe((0, J.x)(Ee, Se => { ae = Se, ve = we.now(), _e || (_e = we.schedule(gt, Ce), Ee.add(_e)) }, () => { xe(), Ee.complete() }, void 0, () => { ae = _e = null })) }) } }, 6590: (un, Je, L) => { "use strict"; L.d(Je, { d: () => J }); var i = L(4482), m = L(5403); function J(ye) { return (0, i.e)((Ce, we) => { let Te = !1; Ce.subscribe((0, m.x)(we, Ee => { Te = !0, we.next(Ee) }, () => { Te || we.next(ye), we.complete() })) }) } }, 1005: (un, Je, L) => { "use strict"; L.d(Je, { g: () => xe }); var i = L(4986), m = L(7272), J = L(5698), ye = L(4482), Ce = L(5403), we = L(5032), Ee = L(9718), _e = L(6099); function ae(gt, Se) { return Se ? rt => (0, m.z)(Se.pipe((0, J.q)(1), function Te() { return (0, ye.e)((gt, Se) => { gt.subscribe((0, Ce.x)(Se, we.Z)) }) }()), rt.pipe(ae(gt))) : (0, _e.z)((rt, wt) => gt(rt, wt).pipe((0, J.q)(1), (0, Ee.h)(rt))) } var ve = L(5963); function xe(gt, Se = i.z) { const rt = (0, ve.H)(gt, Se); return ae(() => rt) } }, 1884: (un, Je, L) => { "use strict"; L.d(Je, { x: () => ye }); var i = L(4671), m = L(4482), J = L(5403); function ye(we, Te = i.y) { return we = we ?? Ce, (0, m.e)((Ee, _e) => { let ae, ve = !0; Ee.subscribe((0, J.x)(_e, xe => { const gt = Te(xe); (ve || !we(ae, gt)) && (ve = !1, ae = gt, _e.next(xe)) })) }) } function Ce(we, Te) { return we === Te } }, 9300: (un, Je, L) => { "use strict"; L.d(Je, { h: () => J }); var i = L(4482), m = L(5403); function J(ye, Ce) { return (0, i.e)((we, Te) => { let Ee = 0; we.subscribe((0, m.x)(Te, _e => ye.call(Ce, _e, Ee++) && Te.next(_e))) }) } }, 8746: (un, Je, L) => { "use strict"; L.d(Je, { x: () => m }); var i = L(4482); function m(J) { return (0, i.e)((ye, Ce) => { try { ye.subscribe(Ce) } finally { Ce.add(J) } }) } }, 590: (un, Je, L) => { "use strict"; L.d(Je, { P: () => Te }); var i = L(6805), m = L(9300), J = L(5698), ye = L(6590), Ce = L(8068), we = L(4671); function Te(Ee, _e) { const ae = arguments.length >= 2; return ve => ve.pipe(Ee ? (0, m.h)((xe, gt) => Ee(xe, gt, ve)) : we.y, (0, J.q)(1), ae ? (0, ye.d)(_e) : (0, Ce.T)(() => new i.K)) } }, 4004: (un, Je, L) => { "use strict"; L.d(Je, { U: () => J }); var i = L(4482), m = L(5403); function J(ye, Ce) { return (0, i.e)((we, Te) => { let Ee = 0; we.subscribe((0, m.x)(Te, _e => { Te.next(ye.call(Ce, _e, Ee++)) })) }) } }, 9718: (un, Je, L) => { "use strict"; L.d(Je, { h: () => m }); var i = L(4004); function m(J) { return (0, i.U)(() => J) } }, 8189: (un, Je, L) => { "use strict"; L.d(Je, { J: () => J }); var i = L(6099), m = L(4671); function J(ye = 1 / 0) { return (0, i.z)(m.y, ye) } }, 2733: (un, Je, L) => { "use strict"; L.d(Je, { p: () => ye }); var i = L(8421), m = L(9672), J = L(5403); function ye(Ce, we, Te, Ee, _e, ae, ve, xe) { const gt = []; let Se = 0, rt = 0, wt = !1; const De = () => { wt && !gt.length && !Se && we.complete() }, je = Qe => Se < Ee ? _t(Qe) : gt.push(Qe), _t = Qe => { ae && we.next(Qe), Se++; let ct = !1; (0, i.Xf)(Te(Qe, rt++)).subscribe((0, J.x)(we, Oe => { _e?.(Oe), ae ? je(Oe) : we.next(Oe) }, () => { ct = !0 }, void 0, () => { if (ct) try { for (Se--; gt.length && Se < Ee;) { const Oe = gt.shift(); ve ? (0, m.f)(we, ve, () => _t(Oe)) : _t(Oe) } De() } catch (Oe) { we.error(Oe) } })) }; return Ce.subscribe((0, J.x)(we, je, () => { wt = !0, De() })), () => { xe?.() } } }, 6099: (un, Je, L) => { "use strict"; L.d(Je, { z: () => we }); var i = L(4004), m = L(8421), J = L(4482), ye = L(2733), Ce = L(576); function we(Te, Ee, _e = 1 / 0) { return (0, Ce.m)(Ee) ? we((ae, ve) => (0, i.U)((xe, gt) => Ee(ae, xe, ve, gt))((0, m.Xf)(Te(ae, ve))), _e) : ("number" == typeof Ee && (_e = Ee), (0, J.e)((ae, ve) => (0, ye.p)(ae, ve, Te, _e))) } }, 5363: (un, Je, L) => { "use strict"; L.d(Je, { Q: () => ye }); var i = L(9672), m = L(4482), J = L(5403); function ye(Ce, we = 0) { return (0, m.e)((Te, Ee) => { Te.subscribe((0, J.x)(Ee, _e => (0, i.f)(Ee, Ce, () => Ee.next(_e), we), () => (0, i.f)(Ee, Ce, () => Ee.complete(), we), _e => (0, i.f)(Ee, Ce, () => Ee.error(_e), we))) }) } }, 1520: (un, Je, L) => { "use strict"; L.d(Je, { G: () => J }); var i = L(4482), m = L(5403); function J() { return (0, i.e)((ye, Ce) => { let we, Te = !1; ye.subscribe((0, m.x)(Ce, Ee => { const _e = we; we = Ee, Te && Ce.next([_e, Ee]), Te = !0 })) }) } }, 8343: (un, Je, L) => { "use strict"; L.d(Je, { x: () => J }); var i = L(4482), m = L(5403); function J() { return (0, i.e)((ye, Ce) => { let we = null; ye._refCount++; const Te = (0, m.x)(Ce, void 0, void 0, void 0, () => { if (!ye || ye._refCount <= 0 || 0 < --ye._refCount) return void (we = null); const Ee = ye._connection, _e = we; we = null, Ee && (!_e || Ee === _e) && Ee.unsubscribe(), Ce.unsubscribe() }); ye.subscribe(Te), Te.closed || (we = ye.connect()) }) } }, 2940: (un, Je, L) => { "use strict"; L.d(Je, { R: () => J }); var i = L(4482), m = L(7359); function J(ye, Ce) { return (0, i.e)((0, m.U)(ye, Ce, arguments.length >= 2, !0)) } }, 7359: (un, Je, L) => { "use strict"; L.d(Je, { U: () => m }); var i = L(5403); function m(J, ye, Ce, we, Te) { return (Ee, _e) => { let ae = Ce, ve = ye, xe = 0; Ee.subscribe((0, i.x)(_e, gt => { const Se = xe++; ve = ae ? J(ve, gt, Se) : (ae = !0, gt), we && _e.next(ve) }, Te && (() => { ae && _e.next(ve), _e.complete() }))) } } }, 3099: (un, Je, L) => { "use strict"; L.d(Je, { B: () => Ce }); var i = L(8421), m = L(7579), J = L(930), ye = L(4482); function Ce(Te = {}) { const { connector: Ee = (() => new m.x), resetOnError: _e = !0, resetOnComplete: ae = !0, resetOnRefCountZero: ve = !0 } = Te; return xe => { let gt, Se, rt, wt = 0, De = !1, je = !1; const _t = () => { Se?.unsubscribe(), Se = void 0 }, Qe = () => { _t(), gt = rt = void 0, De = je = !1 }, ct = () => { const Oe = gt; Qe(), Oe?.unsubscribe() }; return (0, ye.e)((Oe, Ve) => { wt++, !je && !De && _t(); const Be = rt = rt ?? Ee(); Ve.add(() => { wt--, 0 === wt && !je && !De && (Se = we(ct, ve)) }), Be.subscribe(Ve), !gt && wt > 0 && (gt = new J.Hp({ next: nt => Be.next(nt), error: nt => { je = !0, _t(), Se = we(Qe, _e, nt), Be.error(nt) }, complete: () => { De = !0, _t(), Se = we(Qe, ae), Be.complete() } }), (0, i.Xf)(Oe).subscribe(gt)) })(xe) } } function we(Te, Ee, ..._e) { if (!0 === Ee) return void Te(); if (!1 === Ee) return; const ae = new J.Hp({ next: () => { ae.unsubscribe(), Te() } }); return Ee(..._e).subscribe(ae) } }, 4782: (un, Je, L) => { "use strict"; L.d(Je, { d: () => J }); var i = L(4707), m = L(3099); function J(ye, Ce, we) { let Te, Ee = !1; return ye && "object" == typeof ye ? ({ bufferSize: Te = 1 / 0, windowTime: Ce = 1 / 0, refCount: Ee = !1, scheduler: we } = ye) : Te = ye ?? 1 / 0, (0, m.B)({ connector: () => new i.t(Te, Ce, we), resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: Ee }) } }, 5684: (un, Je, L) => { "use strict"; L.d(Je, { T: () => m }); var i = L(9300); function m(J) { return (0, i.h)((ye, Ce) => J <= Ce) } }, 8675: (un, Je, L) => { "use strict"; L.d(Je, { O: () => ye }); var i = L(7272), m = L(3269), J = L(4482); function ye(...Ce) { const we = (0, m.yG)(Ce); return (0, J.e)((Te, Ee) => { (we ? (0, i.z)(Ce, Te, we) : (0, i.z)(Ce, Te)).subscribe(Ee) }) } }, 9468: (un, Je, L) => { "use strict"; L.d(Je, { R: () => m }); var i = L(4482); function m(J, ye = 0) { return (0, i.e)((Ce, we) => { we.add(J.schedule(() => Ce.subscribe(we), ye)) }) } }, 3900: (un, Je, L) => { "use strict"; L.d(Je, { w: () => ye }); var i = L(8421), m = L(4482), J = L(5403); function ye(Ce, we) { return (0, m.e)((Te, Ee) => { let _e = null, ae = 0, ve = !1; const xe = () => ve && !_e && Ee.complete(); Te.subscribe((0, J.x)(Ee, gt => { _e?.unsubscribe(); let Se = 0; const rt = ae++; (0, i.Xf)(Ce(gt, rt)).subscribe(_e = (0, J.x)(Ee, wt => Ee.next(we ? we(gt, wt, rt, Se++) : wt), () => { _e = null, xe() })) }, () => { ve = !0, xe() })) }) } }, 6304: (un, Je, L) => { "use strict"; L.d(Je, { c: () => J }); var i = L(3900), m = L(576); function J(ye, Ce) { return (0, m.m)(Ce) ? (0, i.w)(() => ye, Ce) : (0, i.w)(() => ye) } }, 5698: (un, Je, L) => { "use strict"; L.d(Je, { q: () => ye }); var i = L(515), m = L(4482), J = L(5403); function ye(Ce) { return Ce <= 0 ? () => i.E : (0, m.e)((we, Te) => { let Ee = 0; we.subscribe((0, J.x)(Te, _e => { ++Ee <= Ce && (Te.next(_e), Ce <= Ee && Te.complete()) })) }) } }, 2035: (un, Je, L) => { "use strict"; L.d(Je, { h: () => ye }); var i = L(515), m = L(4482), J = L(5403); function ye(Ce) { return Ce <= 0 ? () => i.E : (0, m.e)((we, Te) => { let Ee = []; we.subscribe((0, J.x)(Te, _e => { Ee.push(_e), Ce < Ee.length && Ee.shift() }, () => { for (const _e of Ee) Te.next(_e); Te.complete() }, void 0, () => { Ee = null })) }) } }, 2722: (un, Je, L) => { "use strict"; L.d(Je, { R: () => Ce }); var i = L(4482), m = L(5403), J = L(8421), ye = L(5032); function Ce(we) { return (0, i.e)((Te, Ee) => { (0, J.Xf)(we).subscribe((0, m.x)(Ee, () => Ee.complete(), ye.Z)), !Ee.closed && Te.subscribe(Ee) }) } }, 2529: (un, Je, L) => { "use strict"; L.d(Je, { o: () => J }); var i = L(4482), m = L(5403); function J(ye, Ce = !1) { return (0, i.e)((we, Te) => { let Ee = 0; we.subscribe((0, m.x)(Te, _e => { const ae = ye(_e, Ee++); (ae || Ce) && Te.next(_e), !ae && Te.complete() })) }) } }, 8505: (un, Je, L) => { "use strict"; L.d(Je, { b: () => Ce }); var i = L(576), m = L(4482), J = L(5403), ye = L(4671); function Ce(we, Te, Ee) { const _e = (0, i.m)(we) || Te || Ee ? { next: we, error: Te, complete: Ee } : we; return _e ? (0, m.e)((ae, ve) => { var xe; null === (xe = _e.subscribe) || void 0 === xe || xe.call(_e); let gt = !0; ae.subscribe((0, J.x)(ve, Se => { var rt; null === (rt = _e.next) || void 0 === rt || rt.call(_e, Se), ve.next(Se) }, () => { var Se; gt = !1, null === (Se = _e.complete) || void 0 === Se || Se.call(_e), ve.complete() }, Se => { var rt; gt = !1, null === (rt = _e.error) || void 0 === rt || rt.call(_e, Se), ve.error(Se) }, () => { var Se, rt; gt && (null === (Se = _e.unsubscribe) || void 0 === Se || Se.call(_e)), null === (rt = _e.finalize) || void 0 === rt || rt.call(_e) })) }) : ye.y } }, 8068: (un, Je, L) => { "use strict"; L.d(Je, { T: () => ye }); var i = L(6805), m = L(4482), J = L(5403); function ye(we = Ce) { return (0, m.e)((Te, Ee) => { let _e = !1; Te.subscribe((0, J.x)(Ee, ae => { _e = !0, Ee.next(ae) }, () => _e ? Ee.complete() : Ee.error(we()))) }) } function Ce() { return new i.K } }, 1365: (un, Je, L) => { "use strict"; L.d(Je, { M: () => Te }); var i = L(4482), m = L(5403), J = L(8421), ye = L(4671), Ce = L(5032), we = L(3269); function Te(...Ee) { const _e = (0, we.jO)(Ee); return (0, i.e)((ae, ve) => { const xe = Ee.length, gt = new Array(xe); let Se = Ee.map(() => !1), rt = !1; for (let wt = 0; wt < xe; wt++)(0, J.Xf)(Ee[wt]).subscribe((0, m.x)(ve, De => { gt[wt] = De, !rt && !Se[wt] && (Se[wt] = !0, (rt = Se.every(ye.y)) && (Se = null)) }, Ce.Z)); ae.subscribe((0, m.x)(ve, wt => { if (rt) { const De = [wt, ...gt]; ve.next(_e ? _e(...De) : De) } })) }) } }, 4408: (un, Je, L) => { "use strict"; L.d(Je, { o: () => Ce }); var i = L(727); class m extends i.w0 { constructor(Te, Ee) { super() } schedule(Te, Ee = 0) { return this } } const J = { setInterval(we, Te, ...Ee) { const { delegate: _e } = J; return _e?.setInterval ? _e.setInterval(we, Te, ...Ee) : setInterval(we, Te, ...Ee) }, clearInterval(we) { const { delegate: Te } = J; return (Te?.clearInterval || clearInterval)(we) }, delegate: void 0 }; var ye = L(8737); class Ce extends m { constructor(Te, Ee) { super(Te, Ee), this.scheduler = Te, this.work = Ee, this.pending = !1 } schedule(Te, Ee = 0) { var _e; if (this.closed) return this; this.state = Te; const ae = this.id, ve = this.scheduler; return null != ae && (this.id = this.recycleAsyncId(ve, ae, Ee)), this.pending = !0, this.delay = Ee, this.id = null !== (_e = this.id) && void 0 !== _e ? _e : this.requestAsyncId(ve, this.id, Ee), this } requestAsyncId(Te, Ee, _e = 0) { return J.setInterval(Te.flush.bind(Te, this), _e) } recycleAsyncId(Te, Ee, _e = 0) { if (null != _e && this.delay === _e && !1 === this.pending) return Ee; null != Ee && J.clearInterval(Ee) } execute(Te, Ee) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const _e = this._execute(Te, Ee); if (_e) return _e; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(Te, Ee) { let ae, _e = !1; try { this.work(Te) } catch (ve) { _e = !0, ae = ve || new Error("Scheduled action threw falsy error") } if (_e) return this.unsubscribe(), ae } unsubscribe() { if (!this.closed) { const { id: Te, scheduler: Ee } = this, { actions: _e } = Ee; this.work = this.state = this.scheduler = null, this.pending = !1, (0, ye.P)(_e, this), null != Te && (this.id = this.recycleAsyncId(Ee, Te, null)), this.delay = null, super.unsubscribe() } } } }, 7565: (un, Je, L) => { "use strict"; L.d(Je, { v: () => J }); var i = L(6063); class m { constructor(Ce, we = m.now) { this.schedulerActionCtor = Ce, this.now = we } schedule(Ce, we = 0, Te) { return new this.schedulerActionCtor(this, Ce).schedule(Te, we) } } m.now = i.l.now; class J extends m { constructor(Ce, we = m.now) { super(Ce, we), this.actions = [], this._active = !1 } flush(Ce) { const { actions: we } = this; if (this._active) return void we.push(Ce); let Te; this._active = !0; do { if (Te = Ce.execute(Ce.state, Ce.delay)) break } while (Ce = we.shift()); if (this._active = !1, Te) { for (; Ce = we.shift();)Ce.unsubscribe(); throw Te } } } }, 6406: (un, Je, L) => { "use strict"; L.d(Je, { Z: () => Te }); var i = L(4408), m = L(727); const J = { schedule(_e) { let ae = requestAnimationFrame, ve = cancelAnimationFrame; const { delegate: xe } = J; xe && (ae = xe.requestAnimationFrame, ve = xe.cancelAnimationFrame); const gt = ae(Se => { ve = void 0, _e(Se) }); return new m.w0(() => ve?.(gt)) }, requestAnimationFrame(..._e) { const { delegate: ae } = J; return (ae?.requestAnimationFrame || requestAnimationFrame)(..._e) }, cancelAnimationFrame(..._e) { const { delegate: ae } = J; return (ae?.cancelAnimationFrame || cancelAnimationFrame)(..._e) }, delegate: void 0 }; var Ce = L(7565); const Te = new class we extends Ce.v { flush(ae) { this._active = !0; const ve = this._scheduled; this._scheduled = void 0; const { actions: xe } = this; let gt; ae = ae || xe.shift(); do { if (gt = ae.execute(ae.state, ae.delay)) break } while ((ae = xe[0]) && ae.id === ve && xe.shift()); if (this._active = !1, gt) { for (; (ae = xe[0]) && ae.id === ve && xe.shift();)ae.unsubscribe(); throw gt } } }(class ye extends i.o { constructor(ae, ve) { super(ae, ve), this.scheduler = ae, this.work = ve } requestAsyncId(ae, ve, xe = 0) { return null !== xe && xe > 0 ? super.requestAsyncId(ae, ve, xe) : (ae.actions.push(this), ae._scheduled || (ae._scheduled = J.requestAnimationFrame(() => ae.flush(void 0)))) } recycleAsyncId(ae, ve, xe = 0) { var gt; if (null != xe ? xe > 0 : this.delay > 0) return super.recycleAsyncId(ae, ve, xe); const { actions: Se } = ae; null != ve && (null === (gt = Se[Se.length - 1]) || void 0 === gt ? void 0 : gt.id) !== ve && (J.cancelAnimationFrame(ve), ae._scheduled = void 0) } }) }, 4986: (un, Je, L) => { "use strict"; L.d(Je, { P: () => ye, z: () => J }); var i = L(4408); const J = new (L(7565).v)(i.o), ye = J }, 6063: (un, Je, L) => { "use strict"; L.d(Je, { l: () => i }); const i = { now: () => (i.delegate || Date).now(), delegate: void 0 } }, 3410: (un, Je, L) => { "use strict"; L.d(Je, { z: () => i }); const i = { setTimeout(m, J, ...ye) { const { delegate: Ce } = i; return Ce?.setTimeout ? Ce.setTimeout(m, J, ...ye) : setTimeout(m, J, ...ye) }, clearTimeout(m) { const { delegate: J } = i; return (J?.clearTimeout || clearTimeout)(m) }, delegate: void 0 } }, 2202: (un, Je, L) => { "use strict"; L.d(Je, { h: () => m }); const m = function i() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }() }, 8822: (un, Je, L) => { "use strict"; L.d(Je, { L: () => i }); const i = "function" == typeof Symbol && Symbol.observable || "@@observable" }, 6805: (un, Je, L) => { "use strict"; L.d(Je, { K: () => m }); const m = (0, L(3888).d)(J => function () { J(this), this.name = "EmptyError", this.message = "no elements in sequence" }) }, 3269: (un, Je, L) => { "use strict"; L.d(Je, { _6: () => we, jO: () => ye, yG: () => Ce }); var i = L(576), m = L(3532); function J(Te) { return Te[Te.length - 1] } function ye(Te) { return (0, i.m)(J(Te)) ? Te.pop() : void 0 } function Ce(Te) { return (0, m.K)(J(Te)) ? Te.pop() : void 0 } function we(Te, Ee) { return "number" == typeof J(Te) ? Te.pop() : Ee } }, 4742: (un, Je, L) => { "use strict"; L.d(Je, { D: () => Ce }); const { isArray: i } = Array, { getPrototypeOf: m, prototype: J, keys: ye } = Object; function Ce(Te) { if (1 === Te.length) { const Ee = Te[0]; if (i(Ee)) return { args: Ee, keys: null }; if (function we(Te) { return Te && "object" == typeof Te && m(Te) === J }(Ee)) { const _e = ye(Ee); return { args: _e.map(ae => Ee[ae]), keys: _e } } } return { args: Te, keys: null } } }, 5797: (un, Je, L) => { "use strict"; L.d(Je, { k: () => m }); const { isArray: i } = Array; function m(J) { return 1 === J.length && i(J[0]) ? J[0] : J } }, 8737: (un, Je, L) => { "use strict"; function i(m, J) { if (m) { const ye = m.indexOf(J); 0 <= ye && m.splice(ye, 1) } } L.d(Je, { P: () => i }) }, 3888: (un, Je, L) => { "use strict"; function i(m) { const ye = m(Ce => { Error.call(Ce), Ce.stack = (new Error).stack }); return ye.prototype = Object.create(Error.prototype), ye.prototype.constructor = ye, ye } L.d(Je, { d: () => i }) }, 1810: (un, Je, L) => { "use strict"; function i(m, J) { return m.reduce((ye, Ce, we) => (ye[Ce] = J[we], ye), {}) } L.d(Je, { n: () => i }) }, 2806: (un, Je, L) => { "use strict"; L.d(Je, { O: () => ye, x: () => J }); var i = L(2416); let m = null; function J(Ce) { if (i.v.useDeprecatedSynchronousErrorHandling) { const we = !m; if (we && (m = { errorThrown: !1, error: null }), Ce(), we) { const { errorThrown: Te, error: Ee } = m; if (m = null, Te) throw Ee } } else Ce() } function ye(Ce) { i.v.useDeprecatedSynchronousErrorHandling && m && (m.errorThrown = !0, m.error = Ce) } }, 9672: (un, Je, L) => { "use strict"; function i(m, J, ye, Ce = 0, we = !1) { const Te = J.schedule(function () { ye(), we ? m.add(this.schedule(null, Ce)) : this.unsubscribe() }, Ce); if (m.add(Te), !we) return Te } L.d(Je, { f: () => i }) }, 4671: (un, Je, L) => { "use strict"; function i(m) { return m } L.d(Je, { y: () => i }) }, 1144: (un, Je, L) => { "use strict"; L.d(Je, { z: () => i }); const i = m => m && "number" == typeof m.length && "function" != typeof m }, 2206: (un, Je, L) => { "use strict"; L.d(Je, { D: () => m }); var i = L(576); function m(J) { return Symbol.asyncIterator && (0, i.m)(J?.[Symbol.asyncIterator]) } }, 576: (un, Je, L) => { "use strict"; function i(m) { return "function" == typeof m } L.d(Je, { m: () => i }) }, 3670: (un, Je, L) => { "use strict"; L.d(Je, { c: () => J }); var i = L(8822), m = L(576); function J(ye) { return (0, m.m)(ye[i.L]) } }, 6495: (un, Je, L) => { "use strict"; L.d(Je, { T: () => J }); var i = L(2202), m = L(576); function J(ye) { return (0, m.m)(ye?.[i.h]) } }, 8239: (un, Je, L) => { "use strict"; L.d(Je, { t: () => m }); var i = L(576); function m(J) { return (0, i.m)(J?.then) } }, 3260: (un, Je, L) => { "use strict"; L.d(Je, { L: () => ye, Q: () => J }); var i = L(655), m = L(576); function J(Ce) { return (0, i.FC)(this, arguments, function* () { const Te = Ce.getReader(); try { for (; ;) { const { value: Ee, done: _e } = yield (0, i.qq)(Te.read()); if (_e) return yield (0, i.qq)(void 0); yield yield (0, i.qq)(Ee) } } finally { Te.releaseLock() } }) } function ye(Ce) { return (0, m.m)(Ce?.getReader) } }, 3532: (un, Je, L) => { "use strict"; L.d(Je, { K: () => m }); var i = L(576); function m(J) { return J && (0, i.m)(J.schedule) } }, 4482: (un, Je, L) => { "use strict"; L.d(Je, { A: () => m, e: () => J }); var i = L(576); function m(ye) { return (0, i.m)(ye?.lift) } function J(ye) { return Ce => { if (m(Ce)) return Ce.lift(function (we) { try { return ye(we, this) } catch (Te) { this.error(Te) } }); throw new TypeError("Unable to lift unknown Observable type") } } }, 3268: (un, Je, L) => { "use strict"; L.d(Je, { Z: () => ye }); var i = L(4004); const { isArray: m } = Array; function ye(Ce) { return (0, i.U)(we => function J(Ce, we) { return m(we) ? Ce(...we) : Ce(we) }(Ce, we)) } }, 5032: (un, Je, L) => { "use strict"; function i() { } L.d(Je, { Z: () => i }) }, 9635: (un, Je, L) => { "use strict"; L.d(Je, { U: () => J, z: () => m }); var i = L(4671); function m(...ye) { return J(ye) } function J(ye) { return 0 === ye.length ? i.y : 1 === ye.length ? ye[0] : function (we) { return ye.reduce((Te, Ee) => Ee(Te), we) } } }, 7849: (un, Je, L) => { "use strict"; L.d(Je, { h: () => J }); var i = L(2416), m = L(3410); function J(ye) { m.z.setTimeout(() => { const { onUnhandledError: Ce } = i.v; if (!Ce) throw ye; Ce(ye) }) } }, 4532: (un, Je, L) => { "use strict"; function i(m) { return new TypeError(`You provided ${null !== m && "object" == typeof m ? "an invalid object" : `'${m}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } L.d(Je, { z: () => i }) }, 655: (un, Je, L) => { "use strict"; L.d(Je, { FC: () => je, KL: () => Qe, _T: () => ye, gn: () => Ce, mG: () => Ee, pi: () => J, qq: () => De }); var J = function () { return J = Object.assign || function (Ue) { for (var st, ht = 1, Kt = arguments.length; ht < Kt; ht++)for (var rn in st = arguments[ht]) Object.prototype.hasOwnProperty.call(st, rn) && (Ue[rn] = st[rn]); return Ue }, J.apply(this, arguments) }; function ye(Fe, Ue) { var st = {}; for (var ht in Fe) Object.prototype.hasOwnProperty.call(Fe, ht) && Ue.indexOf(ht) < 0 && (st[ht] = Fe[ht]); if (null != Fe && "function" == typeof Object.getOwnPropertySymbols) { var Kt = 0; for (ht = Object.getOwnPropertySymbols(Fe); Kt < ht.length; Kt++)Ue.indexOf(ht[Kt]) < 0 && Object.prototype.propertyIsEnumerable.call(Fe, ht[Kt]) && (st[ht[Kt]] = Fe[ht[Kt]]) } return st } function Ce(Fe, Ue, st, ht) { var On, Kt = arguments.length, rn = Kt < 3 ? Ue : null === ht ? ht = Object.getOwnPropertyDescriptor(Ue, st) : ht; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) rn = Reflect.decorate(Fe, Ue, st, ht); else for (var qn = Fe.length - 1; qn >= 0; qn--)(On = Fe[qn]) && (rn = (Kt < 3 ? On(rn) : Kt > 3 ? On(Ue, st, rn) : On(Ue, st)) || rn); return Kt > 3 && rn && Object.defineProperty(Ue, st, rn), rn } function Ee(Fe, Ue, st, ht) { return new (st || (st = Promise))(function (rn, On) { function qn(fn) { try { kn(ht.next(fn)) } catch (It) { On(It) } } function nr(fn) { try { kn(ht.throw(fn)) } catch (It) { On(It) } } function kn(fn) { fn.done ? rn(fn.value) : function Kt(rn) { return rn instanceof st ? rn : new st(function (On) { On(rn) }) }(fn.value).then(qn, nr) } kn((ht = ht.apply(Fe, Ue || [])).next()) }) } function De(Fe) { return this instanceof De ? (this.v = Fe, this) : new De(Fe) } function je(Fe, Ue, st) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var Kt, ht = st.apply(Fe, Ue || []), rn = []; return Kt = {}, On("next"), On("throw"), On("return"), Kt[Symbol.asyncIterator] = function () { return this }, Kt; function On(Yt) { ht[Yt] && (Kt[Yt] = function (pt) { return new Promise(function (Pt, Ze) { rn.push([Yt, pt, Pt, Ze]) > 1 || qn(Yt, pt) }) }) } function qn(Yt, pt) { try { !function nr(Yt) { Yt.value instanceof De ? Promise.resolve(Yt.value.v).then(kn, fn) : It(rn[0][2], Yt) }(ht[Yt](pt)) } catch (Pt) { It(rn[0][3], Pt) } } function kn(Yt) { qn("next", Yt) } function fn(Yt) { qn("throw", Yt) } function It(Yt, pt) { Yt(pt), rn.shift(), rn.length && qn(rn[0][0], rn[0][1]) } } function Qe(Fe) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var st, Ue = Fe[Symbol.asyncIterator]; return Ue ? Ue.call(Fe) : (Fe = function xe(Fe) { var Ue = "function" == typeof Symbol && Symbol.iterator, st = Ue && Fe[Ue], ht = 0; if (st) return st.call(Fe); if (Fe && "number" == typeof Fe.length) return { next: function () { return Fe && ht >= Fe.length && (Fe = void 0), { value: Fe && Fe[ht++], done: !Fe } } }; throw new TypeError(Ue ? "Object is not iterable." : "Symbol.iterator is not defined.") }(Fe), st = {}, ht("next"), ht("throw"), ht("return"), st[Symbol.asyncIterator] = function () { return this }, st); function ht(rn) { st[rn] = Fe[rn] && function (On) { return new Promise(function (qn, nr) { !function Kt(rn, On, qn, nr) { Promise.resolve(nr).then(function (kn) { rn({ value: kn, done: qn }) }, On) }(qn, nr, (On = Fe[rn](On)).done, On.value) }) } } } }, 7340: (un, Je, L) => { "use strict"; L.d(Je, { EY: () => wt, F4: () => ae, IO: () => rt, LC: () => m, SB: () => _e, X$: () => ye, ZE: () => _t, ZN: () => je, _j: () => i, eR: () => ve, jt: () => Ce, k1: () => Qe, l3: () => J, oB: () => Ee, pV: () => gt, ru: () => we, vP: () => Te }); class i { } class m { } const J = "*"; function ye(ct, Oe) { return { type: 7, name: ct, definitions: Oe, options: {} } } function Ce(ct, Oe = null) { return { type: 4, styles: Oe, timings: ct } } function we(ct, Oe = null) { return { type: 3, steps: ct, options: Oe } } function Te(ct, Oe = null) { return { type: 2, steps: ct, options: Oe } } function Ee(ct) { return { type: 6, styles: ct, offset: null } } function _e(ct, Oe, Ve) { return { type: 0, name: ct, styles: Oe, options: Ve } } function ae(ct) { return { type: 5, steps: ct } } function ve(ct, Oe, Ve = null) { return { type: 1, expr: ct, animation: Oe, options: Ve } } function gt(ct = null) { return { type: 9, options: ct } } function rt(ct, Oe, Ve = null) { return { type: 11, selector: ct, animation: Oe, options: Ve } } function wt(ct, Oe) { return { type: 12, timings: ct, animation: Oe } } function De(ct) { Promise.resolve().then(ct) } class je { constructor(Oe = 0, Ve = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = Oe + Ve } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(Oe => Oe()), this._onDoneFns = []) } onStart(Oe) { this._originalOnStartFns.push(Oe), this._onStartFns.push(Oe) } onDone(Oe) { this._originalOnDoneFns.push(Oe), this._onDoneFns.push(Oe) } onDestroy(Oe) { this._onDestroyFns.push(Oe) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { De(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(Oe => Oe()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(Oe => Oe()), this._onDestroyFns = []) } reset() { this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } setPosition(Oe) { this._position = this.totalTime ? Oe * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(Oe) { const Ve = "start" == Oe ? this._onStartFns : this._onDoneFns; Ve.forEach(Be => Be()), Ve.length = 0 } } class _t { constructor(Oe) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = Oe; let Ve = 0, Be = 0, nt = 0; const Ne = this.players.length; 0 == Ne ? De(() => this._onFinish()) : this.players.forEach(tt => { tt.onDone(() => { ++Ve == Ne && this._onFinish() }), tt.onDestroy(() => { ++Be == Ne && this._onDestroy() }), tt.onStart(() => { ++nt == Ne && this._onStart() }) }), this.totalTime = this.players.reduce((tt, Fe) => Math.max(tt, Fe.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(Oe => Oe()), this._onDoneFns = []) } init() { this.players.forEach(Oe => Oe.init()) } onStart(Oe) { this._onStartFns.push(Oe) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(Oe => Oe()), this._onStartFns = []) } onDone(Oe) { this._onDoneFns.push(Oe) } onDestroy(Oe) { this._onDestroyFns.push(Oe) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(Oe => Oe.play()) } pause() { this.players.forEach(Oe => Oe.pause()) } restart() { this.players.forEach(Oe => Oe.restart()) } finish() { this._onFinish(), this.players.forEach(Oe => Oe.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(Oe => Oe.destroy()), this._onDestroyFns.forEach(Oe => Oe()), this._onDestroyFns = []) } reset() { this.players.forEach(Oe => Oe.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(Oe) { const Ve = Oe * this.totalTime; this.players.forEach(Be => { const nt = Be.totalTime ? Math.min(1, Ve / Be.totalTime) : 1; Be.setPosition(nt) }) } getPosition() { const Oe = this.players.reduce((Ve, Be) => null === Ve || Be.totalTime > Ve.totalTime ? Be : Ve, null); return null != Oe ? Oe.getPosition() : 0 } beforeDestroy() { this.players.forEach(Oe => { Oe.beforeDestroy && Oe.beforeDestroy() }) } triggerCallback(Oe) { const Ve = "start" == Oe ? this._onStartFns : this._onDoneFns; Ve.forEach(Be => Be()), Ve.length = 0 } } const Qe = "!" }, 445: (un, Je, L) => { "use strict"; L.d(Je, { Is: () => Te, vT: () => _e }); var i = L(4650), m = L(6895); const J = new i.OlP("cdk-dir-doc", { providedIn: "root", factory: function ye() { return (0, i.f3M)(m.K0) } }), Ce = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let Te = (() => { class ae { constructor(xe) { this.value = "ltr", this.change = new i.vpe, xe && (this.value = function we(ae) { const ve = ae?.toLowerCase() || ""; return "auto" === ve && typeof navigator < "u" && navigator?.language ? Ce.test(navigator.language) ? "rtl" : "ltr" : "rtl" === ve ? "rtl" : "ltr" }((xe.body ? xe.body.dir : null) || (xe.documentElement ? xe.documentElement.dir : null) || "ltr")) } ngOnDestroy() { this.change.complete() } } return ae.\u0275fac = function (xe) { return new (xe || ae)(i.LFG(J, 8)) }, ae.\u0275prov = i.Yz7({ token: ae, factory: ae.\u0275fac, providedIn: "root" }), ae })(), _e = (() => { class ae { } return ae.\u0275fac = function (xe) { return new (xe || ae) }, ae.\u0275mod = i.oAB({ type: ae }), ae.\u0275inj = i.cJS({}), ae })() }, 1281: (un, Je, L) => { "use strict"; L.d(Je, { Eq: () => Ce, HM: () => we, Ig: () => m, du: () => Ee, fI: () => Te, su: () => J, t6: () => ye }); var i = L(4650); function m(_e) { return null != _e && "false" != `${_e}` } function J(_e, ae = 0) { return ye(_e) ? Number(_e) : ae } function ye(_e) { return !isNaN(parseFloat(_e)) && !isNaN(Number(_e)) } function Ce(_e) { return Array.isArray(_e) ? _e : [_e] } function we(_e) { return null == _e ? "" : "string" == typeof _e ? _e : `${_e}px` } function Te(_e) { return _e instanceof i.SBq ? _e.nativeElement : _e } function Ee(_e, ae = /\s+/) { const ve = []; if (null != _e) { const xe = Array.isArray(_e) ? _e : `${_e}`.split(ae); for (const gt of xe) { const Se = `${gt}`.trim(); Se && ve.push(Se) } } return ve } }, 2289: (un, Je, L) => { "use strict"; L.d(Je, { Yg: () => Qe, u3: () => Oe }); var i = L(4650), m = L(1281), J = L(7579), ye = L(9841), Ce = L(7272), we = L(9751), Te = L(5698), Ee = L(5684), _e = L(8372), ae = L(4004), ve = L(8675), xe = L(2722), gt = L(3353); const rt = new Set; let wt, De = (() => { class Ve { constructor(nt) { this._platform = nt, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : _t } matchMedia(nt) { return (this._platform.WEBKIT || this._platform.BLINK) && function je(Ve) { if (!rt.has(Ve)) try { wt || (wt = document.createElement("style"), wt.setAttribute("type", "text/css"), document.head.appendChild(wt)), wt.sheet && (wt.sheet.insertRule(`@media ${Ve} {body{ }}`, 0), rt.add(Ve)) } catch (Be) { console.error(Be) } }(nt), this._matchMedia(nt) } } return Ve.\u0275fac = function (nt) { return new (nt || Ve)(i.LFG(gt.t4)) }, Ve.\u0275prov = i.Yz7({ token: Ve, factory: Ve.\u0275fac, providedIn: "root" }), Ve })(); function _t(Ve) { return { matches: "all" === Ve || "" === Ve, media: Ve, addListener: () => { }, removeListener: () => { } } } let Qe = (() => { class Ve { constructor(nt, Ne) { this._mediaMatcher = nt, this._zone = Ne, this._queries = new Map, this._destroySubject = new J.x } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(nt) { return ct((0, m.Eq)(nt)).some(tt => this._registerQuery(tt).mql.matches) } observe(nt) { const tt = ct((0, m.Eq)(nt)).map(Ue => this._registerQuery(Ue).observable); let Fe = (0, ye.a)(tt); return Fe = (0, Ce.z)(Fe.pipe((0, Te.q)(1)), Fe.pipe((0, Ee.T)(1), (0, _e.b)(0))), Fe.pipe((0, ae.U)(Ue => { const st = { matches: !1, breakpoints: {} }; return Ue.forEach(({ matches: ht, query: Kt }) => { st.matches = st.matches || ht, st.breakpoints[Kt] = ht }), st })) } _registerQuery(nt) { if (this._queries.has(nt)) return this._queries.get(nt); const Ne = this._mediaMatcher.matchMedia(nt), Fe = { observable: new we.y(Ue => { const st = ht => this._zone.run(() => Ue.next(ht)); return Ne.addListener(st), () => { Ne.removeListener(st) } }).pipe((0, ve.O)(Ne), (0, ae.U)(({ matches: Ue }) => ({ query: nt, matches: Ue })), (0, xe.R)(this._destroySubject)), mql: Ne }; return this._queries.set(nt, Fe), Fe } } return Ve.\u0275fac = function (nt) { return new (nt || Ve)(i.LFG(De), i.LFG(i.R0b)) }, Ve.\u0275prov = i.Yz7({ token: Ve, factory: Ve.\u0275fac, providedIn: "root" }), Ve })(); function ct(Ve) { return Ve.map(Be => Be.split(",")).reduce((Be, nt) => Be.concat(nt)).map(Be => Be.trim()) } const Oe = { XSmall: "(max-width: 599.98px)", Small: "(min-width: 600px) and (max-width: 959.98px)", Medium: "(min-width: 960px) and (max-width: 1279.98px)", Large: "(min-width: 1280px) and (max-width: 1919.98px)", XLarge: "(min-width: 1920px)", Handset: "(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)", Tablet: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), (min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)", Web: "(min-width: 840px) and (orientation: portrait), (min-width: 1280px) and (orientation: landscape)", HandsetPortrait: "(max-width: 599.98px) and (orientation: portrait)", TabletPortrait: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)", WebPortrait: "(min-width: 840px) and (orientation: portrait)", HandsetLandscape: "(max-width: 959.98px) and (orientation: landscape)", TabletLandscape: "(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)", WebLandscape: "(min-width: 1280px) and (orientation: landscape)" } }, 3353: (un, Je, L) => { "use strict"; L.d(Je, { Mq: () => Se, Oy: () => ct, _i: () => rt, ht: () => _t, i$: () => ve, kV: () => je, qK: () => Ee, sA: () => Qe, t4: () => ye, ud: () => Ce }); var i = L(4650), m = L(6895); let J; try { J = typeof Intl < "u" && Intl.v8BreakIterator } catch { J = !1 } let we, ye = (() => { class Oe { constructor(Be) { this._platformId = Be, this.isBrowser = this._platformId ? (0, m.NF)(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !J) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return Oe.\u0275fac = function (Be) { return new (Be || Oe)(i.LFG(i.Lbi)) }, Oe.\u0275prov = i.Yz7({ token: Oe, factory: Oe.\u0275fac, providedIn: "root" }), Oe })(), Ce = (() => { class Oe { } return Oe.\u0275fac = function (Be) { return new (Be || Oe) }, Oe.\u0275mod = i.oAB({ type: Oe }), Oe.\u0275inj = i.cJS({}), Oe })(); const Te = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function Ee() { if (we) return we; if ("object" != typeof document || !document) return we = new Set(Te), we; let Oe = document.createElement("input"); return we = new Set(Te.filter(Ve => (Oe.setAttribute("type", Ve), Oe.type === Ve))), we } let _e, xe, gt, wt; function ve(Oe) { return function ae() { if (null == _e && typeof window < "u") try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => _e = !0 })) } finally { _e = _e || !1 } return _e }() ? Oe : !!Oe.capture } function Se() { if (null == gt) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return gt = !1, gt; if ("scrollBehavior" in document.documentElement.style) gt = !0; else { const Oe = Element.prototype.scrollTo; gt = !!Oe && !/\{\s*\[native code\]\s*\}/.test(Oe.toString()) } } return gt } function rt() { if ("object" != typeof document || !document) return 0; if (null == xe) { const Oe = document.createElement("div"), Ve = Oe.style; Oe.dir = "rtl", Ve.width = "1px", Ve.overflow = "auto", Ve.visibility = "hidden", Ve.pointerEvents = "none", Ve.position = "absolute"; const Be = document.createElement("div"), nt = Be.style; nt.width = "2px", nt.height = "1px", Oe.appendChild(Be), document.body.appendChild(Oe), xe = 0, 0 === Oe.scrollLeft && (Oe.scrollLeft = 1, xe = 0 === Oe.scrollLeft ? 1 : 2), Oe.remove() } return xe } function je(Oe) { if (function De() { if (null == wt) { const Oe = typeof document < "u" ? document.head : null; wt = !(!Oe || !Oe.createShadowRoot && !Oe.attachShadow) } return wt }()) { const Ve = Oe.getRootNode ? Oe.getRootNode() : null; if (typeof ShadowRoot < "u" && ShadowRoot && Ve instanceof ShadowRoot) return Ve } return null } function _t() { let Oe = typeof document < "u" && document ? document.activeElement : null; for (; Oe && Oe.shadowRoot;) { const Ve = Oe.shadowRoot.activeElement; if (Ve === Oe) break; Oe = Ve } return Oe } function Qe(Oe) { return Oe.composedPath ? Oe.composedPath()[0] : Oe.target } function ct() { return typeof __karma__ < "u" && !!__karma__ || typeof jasmine < "u" && !!jasmine || typeof jest < "u" && !!jest || typeof Mocha < "u" && !!Mocha } }, 4080: (un, Je, L) => { "use strict"; L.d(Je, { C5: () => ae, Pl: () => _t, UE: () => ve, eL: () => ct, en: () => gt, u0: () => rt }); var i = L(4650), m = L(6895); class _e { attach(Be) { return this._attachedHost = Be, Be.attach(this) } detach() { let Be = this._attachedHost; null != Be && (this._attachedHost = null, Be.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(Be) { this._attachedHost = Be } } class ae extends _e { constructor(Be, nt, Ne, tt, Fe) { super(), this.component = Be, this.viewContainerRef = nt, this.injector = Ne, this.componentFactoryResolver = tt, this.projectableNodes = Fe } } class ve extends _e { constructor(Be, nt, Ne, tt) { super(), this.templateRef = Be, this.viewContainerRef = nt, this.context = Ne, this.injector = tt } get origin() { return this.templateRef.elementRef } attach(Be, nt = this.context) { return this.context = nt, super.attach(Be) } detach() { return this.context = void 0, super.detach() } } class xe extends _e { constructor(Be) { super(), this.element = Be instanceof i.SBq ? Be.nativeElement : Be } } class gt { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(Be) { return Be instanceof ae ? (this._attachedPortal = Be, this.attachComponentPortal(Be)) : Be instanceof ve ? (this._attachedPortal = Be, this.attachTemplatePortal(Be)) : this.attachDomPortal && Be instanceof xe ? (this._attachedPortal = Be, this.attachDomPortal(Be)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(Be) { this._disposeFn = Be } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class rt extends gt { constructor(Be, nt, Ne, tt, Fe) { super(), this.outletElement = Be, this._componentFactoryResolver = nt, this._appRef = Ne, this._defaultInjector = tt, this.attachDomPortal = Ue => { const st = Ue.element, ht = this._document.createComment("dom-portal"); st.parentNode.insertBefore(ht, st), this.outletElement.appendChild(st), this._attachedPortal = Ue, super.setDisposeFn(() => { ht.parentNode && ht.parentNode.replaceChild(st, ht) }) }, this._document = Fe } attachComponentPortal(Be) { const Ne = (Be.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(Be.component); let tt; return Be.viewContainerRef ? (tt = Be.viewContainerRef.createComponent(Ne, Be.viewContainerRef.length, Be.injector || Be.viewContainerRef.injector, Be.projectableNodes || void 0), this.setDisposeFn(() => tt.destroy())) : (tt = Ne.create(Be.injector || this._defaultInjector || i.zs3.NULL), this._appRef.attachView(tt.hostView), this.setDisposeFn(() => { this._appRef.viewCount > 0 && this._appRef.detachView(tt.hostView), tt.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(tt)), this._attachedPortal = Be, tt } attachTemplatePortal(Be) { let nt = Be.viewContainerRef, Ne = nt.createEmbeddedView(Be.templateRef, Be.context, { injector: Be.injector }); return Ne.rootNodes.forEach(tt => this.outletElement.appendChild(tt)), Ne.detectChanges(), this.setDisposeFn(() => { let tt = nt.indexOf(Ne); -1 !== tt && nt.remove(tt) }), this._attachedPortal = Be, Ne } dispose() { super.dispose(), this.outletElement.remove() } _getComponentRootNode(Be) { return Be.hostView.rootNodes[0] } } let _t = (() => { class Ve extends gt { constructor(nt, Ne, tt) { super(), this._componentFactoryResolver = nt, this._viewContainerRef = Ne, this._isInitialized = !1, this.attached = new i.vpe, this.attachDomPortal = Fe => { const Ue = Fe.element, st = this._document.createComment("dom-portal"); Fe.setAttachedHost(this), Ue.parentNode.insertBefore(st, Ue), this._getRootNode().appendChild(Ue), this._attachedPortal = Fe, super.setDisposeFn(() => { st.parentNode && st.parentNode.replaceChild(Ue, st) }) }, this._document = tt } get portal() { return this._attachedPortal } set portal(nt) { this.hasAttached() && !nt && !this._isInitialized || (this.hasAttached() && super.detach(), nt && super.attach(nt), this._attachedPortal = nt || null) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedRef = this._attachedPortal = null } attachComponentPortal(nt) { nt.setAttachedHost(this); const Ne = null != nt.viewContainerRef ? nt.viewContainerRef : this._viewContainerRef, Fe = (nt.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(nt.component), Ue = Ne.createComponent(Fe, Ne.length, nt.injector || Ne.injector, nt.projectableNodes || void 0); return Ne !== this._viewContainerRef && this._getRootNode().appendChild(Ue.hostView.rootNodes[0]), super.setDisposeFn(() => Ue.destroy()), this._attachedPortal = nt, this._attachedRef = Ue, this.attached.emit(Ue), Ue } attachTemplatePortal(nt) { nt.setAttachedHost(this); const Ne = this._viewContainerRef.createEmbeddedView(nt.templateRef, nt.context, { injector: nt.injector }); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = nt, this._attachedRef = Ne, this.attached.emit(Ne), Ne } _getRootNode() { const nt = this._viewContainerRef.element.nativeElement; return nt.nodeType === nt.ELEMENT_NODE ? nt : nt.parentNode } } return Ve.\u0275fac = function (nt) { return new (nt || Ve)(i.Y36(i._Vd), i.Y36(i.s_b), i.Y36(m.K0)) }, Ve.\u0275dir = i.lG2({ type: Ve, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [i.qOj] }), Ve })(), ct = (() => { class Ve { } return Ve.\u0275fac = function (nt) { return new (nt || Ve) }, Ve.\u0275mod = i.oAB({ type: Ve }), Ve.\u0275inj = i.cJS({}), Ve })() }, 6895: (un, Je, L) => { "use strict"; L.d(Je, { Do: () => _t, ED: () => ls, EM: () => Wo, Gx: () => Jr, HT: () => ye, JF: () => Ks, JJ: () => io, K0: () => we, Mn: () => qn, Mx: () => Qi, NF: () => wo, Nd: () => Si, O5: () => js, OU: () => so, Ov: () => lr, PC: () => cs, PM: () => ho, RF: () => al, S$: () => wt, Tn: () => Ue, Ts: () => Xn, UT: () => nr, V_: () => _e, Ye: () => Qe, b0: () => je, bD: () => Zl, ez: () => na, mk: () => pr, n9: () => Vi, p6: () => Qn, q: () => J, sg: () => _s, tP: () => ro, uU: () => us, w_: () => Ce, x: () => Fe }); var i = L(4650); let m = null; function J() { return m } function ye(z) { m || (m = z) } class Ce { } const we = new i.OlP("DocumentToken"); let Te = (() => { class z { historyGo(Z) { throw new Error("Not implemented") } } return z.\u0275fac = function (Z) { return new (Z || z) }, z.\u0275prov = i.Yz7({ token: z, factory: function () { return function Ee() { return (0, i.LFG)(ae) }() }, providedIn: "platform" }), z })(); const _e = new i.OlP("Location Initialized"); let ae = (() => { class z extends Te { constructor(Z) { super(), this._doc = Z, this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return J().getBaseHref(this._doc) } onPopState(Z) { const he = J().getGlobalEventTarget(this._doc, "window"); return he.addEventListener("popstate", Z, !1), () => he.removeEventListener("popstate", Z) } onHashChange(Z) { const he = J().getGlobalEventTarget(this._doc, "window"); return he.addEventListener("hashchange", Z, !1), () => he.removeEventListener("hashchange", Z) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(Z) { this._location.pathname = Z } pushState(Z, he, $e) { ve() ? this._history.pushState(Z, he, $e) : this._location.hash = $e } replaceState(Z, he, $e) { ve() ? this._history.replaceState(Z, he, $e) : this._location.hash = $e } forward() { this._history.forward() } back() { this._history.back() } historyGo(Z = 0) { this._history.go(Z) } getState() { return this._history.state } } return z.\u0275fac = function (Z) { return new (Z || z)(i.LFG(we)) }, z.\u0275prov = i.Yz7({ token: z, factory: function () { return function xe() { return new ae((0, i.LFG)(we)) }() }, providedIn: "platform" }), z })(); function ve() { return !!window.history.pushState } function gt(z, re) { if (0 == z.length) return re; if (0 == re.length) return z; let Z = 0; return z.endsWith("/") && Z++, re.startsWith("/") && Z++, 2 == Z ? z + re.substring(1) : 1 == Z ? z + re : z + "/" + re } function Se(z) { const re = z.match(/#|\?|$/), Z = re && re.index || z.length; return z.slice(0, Z - ("/" === z[Z - 1] ? 1 : 0)) + z.slice(Z) } function rt(z) { return z && "?" !== z[0] ? "?" + z : z } let wt = (() => { class z { historyGo(Z) { throw new Error("Not implemented") } } return z.\u0275fac = function (Z) { return new (Z || z) }, z.\u0275prov = i.Yz7({ token: z, factory: function () { return (0, i.f3M)(je) }, providedIn: "root" }), z })(); const De = new i.OlP("appBaseHref"); let je = (() => { class z extends wt { constructor(Z, he) { super(), this._platformLocation = Z, this._removeListenerFns = [], this._baseHref = he ?? this._platformLocation.getBaseHrefFromDOM() ?? (0, i.f3M)(we).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(Z) { this._removeListenerFns.push(this._platformLocation.onPopState(Z), this._platformLocation.onHashChange(Z)) } getBaseHref() { return this._baseHref } prepareExternalUrl(Z) { return gt(this._baseHref, Z) } path(Z = !1) { const he = this._platformLocation.pathname + rt(this._platformLocation.search), $e = this._platformLocation.hash; return $e && Z ? `${he}${$e}` : he } pushState(Z, he, $e, Ft) { const Xt = this.prepareExternalUrl($e + rt(Ft)); this._platformLocation.pushState(Z, he, Xt) } replaceState(Z, he, $e, Ft) { const Xt = this.prepareExternalUrl($e + rt(Ft)); this._platformLocation.replaceState(Z, he, Xt) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(Z = 0) { this._platformLocation.historyGo?.(Z) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.LFG(Te), i.LFG(De, 8)) }, z.\u0275prov = i.Yz7({ token: z, factory: z.\u0275fac, providedIn: "root" }), z })(), _t = (() => { class z extends wt { constructor(Z, he) { super(), this._platformLocation = Z, this._baseHref = "", this._removeListenerFns = [], null != he && (this._baseHref = he) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(Z) { this._removeListenerFns.push(this._platformLocation.onPopState(Z), this._platformLocation.onHashChange(Z)) } getBaseHref() { return this._baseHref } path(Z = !1) { let he = this._platformLocation.hash; return null == he && (he = "#"), he.length > 0 ? he.substring(1) : he } prepareExternalUrl(Z) { const he = gt(this._baseHref, Z); return he.length > 0 ? "#" + he : he } pushState(Z, he, $e, Ft) { let Xt = this.prepareExternalUrl($e + rt(Ft)); 0 == Xt.length && (Xt = this._platformLocation.pathname), this._platformLocation.pushState(Z, he, Xt) } replaceState(Z, he, $e, Ft) { let Xt = this.prepareExternalUrl($e + rt(Ft)); 0 == Xt.length && (Xt = this._platformLocation.pathname), this._platformLocation.replaceState(Z, he, Xt) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(Z = 0) { this._platformLocation.historyGo?.(Z) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.LFG(Te), i.LFG(De, 8)) }, z.\u0275prov = i.Yz7({ token: z, factory: z.\u0275fac }), z })(), Qe = (() => { class z { constructor(Z) { this._subject = new i.vpe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = Z; const he = this._locationStrategy.getBaseHref(); this._basePath = function Be(z) { if (new RegExp("^(https?:)?//").test(z)) { const [, Z] = z.split(/\/\/[^\/]+/); return Z } return z }(Se(Ve(he))), this._locationStrategy.onPopState($e => { this._subject.emit({ url: this.path(!0), pop: !0, state: $e.state, type: $e.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(Z = !1) { return this.normalize(this._locationStrategy.path(Z)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(Z, he = "") { return this.path() == this.normalize(Z + rt(he)) } normalize(Z) { return z.stripTrailingSlash(function Oe(z, re) { return z && new RegExp(`^${z}([/;?#]|$)`).test(re) ? re.substring(z.length) : re }(this._basePath, Ve(Z))) } prepareExternalUrl(Z) { return Z && "/" !== Z[0] && (Z = "/" + Z), this._locationStrategy.prepareExternalUrl(Z) } go(Z, he = "", $e = null) { this._locationStrategy.pushState($e, "", Z, he), this._notifyUrlChangeListeners(this.prepareExternalUrl(Z + rt(he)), $e) } replaceState(Z, he = "", $e = null) { this._locationStrategy.replaceState($e, "", Z, he), this._notifyUrlChangeListeners(this.prepareExternalUrl(Z + rt(he)), $e) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(Z = 0) { this._locationStrategy.historyGo?.(Z) } onUrlChange(Z) { return this._urlChangeListeners.push(Z), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(he => { this._notifyUrlChangeListeners(he.url, he.state) })), () => { const he = this._urlChangeListeners.indexOf(Z); this._urlChangeListeners.splice(he, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(Z = "", he) { this._urlChangeListeners.forEach($e => $e(Z, he)) } subscribe(Z, he, $e) { return this._subject.subscribe({ next: Z, error: he, complete: $e }) } } return z.normalizeQueryParams = rt, z.joinWithSlash = gt, z.stripTrailingSlash = Se, z.\u0275fac = function (Z) { return new (Z || z)(i.LFG(wt)) }, z.\u0275prov = i.Yz7({ token: z, factory: function () { return function ct() { return new Qe((0, i.LFG)(wt)) }() }, providedIn: "root" }), z })(); function Ve(z) { return z.replace(/\/index.html$/, "") } var Ne = (() => ((Ne = Ne || {})[Ne.Decimal = 0] = "Decimal", Ne[Ne.Percent = 1] = "Percent", Ne[Ne.Currency = 2] = "Currency", Ne[Ne.Scientific = 3] = "Scientific", Ne))(), tt = (() => ((tt = tt || {})[tt.Zero = 0] = "Zero", tt[tt.One = 1] = "One", tt[tt.Two = 2] = "Two", tt[tt.Few = 3] = "Few", tt[tt.Many = 4] = "Many", tt[tt.Other = 5] = "Other", tt))(), Fe = (() => ((Fe = Fe || {})[Fe.Format = 0] = "Format", Fe[Fe.Standalone = 1] = "Standalone", Fe))(), Ue = (() => ((Ue = Ue || {})[Ue.Narrow = 0] = "Narrow", Ue[Ue.Abbreviated = 1] = "Abbreviated", Ue[Ue.Wide = 2] = "Wide", Ue[Ue.Short = 3] = "Short", Ue))(), st = (() => ((st = st || {})[st.Short = 0] = "Short", st[st.Medium = 1] = "Medium", st[st.Long = 2] = "Long", st[st.Full = 3] = "Full", st))(), ht = (() => ((ht = ht || {})[ht.Decimal = 0] = "Decimal", ht[ht.Group = 1] = "Group", ht[ht.List = 2] = "List", ht[ht.PercentSign = 3] = "PercentSign", ht[ht.PlusSign = 4] = "PlusSign", ht[ht.MinusSign = 5] = "MinusSign", ht[ht.Exponential = 6] = "Exponential", ht[ht.SuperscriptingExponent = 7] = "SuperscriptingExponent", ht[ht.PerMille = 8] = "PerMille", ht[ht.Infinity = 9] = "Infinity", ht[ht.NaN = 10] = "NaN", ht[ht.TimeSeparator = 11] = "TimeSeparator", ht[ht.CurrencyDecimal = 12] = "CurrencyDecimal", ht[ht.CurrencyGroup = 13] = "CurrencyGroup", ht))(); function qn(z, re, Z) { const he = (0, i.cg1)(z), Ft = dn([he[i.wAp.DaysFormat], he[i.wAp.DaysStandalone]], re); return dn(Ft, Z) } function nr(z, re, Z) { const he = (0, i.cg1)(z), Ft = dn([he[i.wAp.MonthsFormat], he[i.wAp.MonthsStandalone]], re); return dn(Ft, Z) } function Yt(z, re) { return dn((0, i.cg1)(z)[i.wAp.DateFormat], re) } function pt(z, re) { return dn((0, i.cg1)(z)[i.wAp.TimeFormat], re) } function Pt(z, re) { return dn((0, i.cg1)(z)[i.wAp.DateTimeFormat], re) } function Ze(z, re) { const Z = (0, i.cg1)(z), he = Z[i.wAp.NumberSymbols][re]; if (typeof he > "u") { if (re === ht.CurrencyDecimal) return Z[i.wAp.NumberSymbols][ht.Decimal]; if (re === ht.CurrencyGroup) return Z[i.wAp.NumberSymbols][ht.Group] } return he } const jt = i.kL8; function wn(z) { if (!z[i.wAp.ExtraData]) throw new Error(`Missing extra locale data for the locale "${z[i.wAp.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`) } function dn(z, re) { for (let Z = re; Z > -1; Z--)if (typeof z[Z] < "u") return z[Z]; throw new Error("Locale data API: locale data undefined") } function ue(z) { const [re, Z] = z.split(":"); return { hours: +re, minutes: +Z } } const gn = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/, Hn = {}, _r = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/; var pn = (() => ((pn = pn || {})[pn.Short = 0] = "Short", pn[pn.ShortGMT = 1] = "ShortGMT", pn[pn.Long = 2] = "Long", pn[pn.Extended = 3] = "Extended", pn))(), Fn = (() => ((Fn = Fn || {})[Fn.FullYear = 0] = "FullYear", Fn[Fn.Month = 1] = "Month", Fn[Fn.Date = 2] = "Date", Fn[Fn.Hours = 3] = "Hours", Fn[Fn.Minutes = 4] = "Minutes", Fn[Fn.Seconds = 5] = "Seconds", Fn[Fn.FractionalSeconds = 6] = "FractionalSeconds", Fn[Fn.Day = 7] = "Day", Fn))(), yn = (() => ((yn = yn || {})[yn.DayPeriods = 0] = "DayPeriods", yn[yn.Days = 1] = "Days", yn[yn.Months = 2] = "Months", yn[yn.Eras = 3] = "Eras", yn))(); function Qn(z, re, Z, he) { let $e = function An(z) { if (sr(z)) return z; if ("number" == typeof z && !isNaN(z)) return new Date(z); if ("string" == typeof z) { if (z = z.trim(), /^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(z)) { const [$e, Ft = 1, Xt = 1] = z.split("-").map(Nn => +Nn); return ur($e, Ft - 1, Xt) } const Z = parseFloat(z); if (!isNaN(z - Z)) return new Date(Z); let he; if (he = z.match(gn)) return function ar(z) { const re = new Date(0); let Z = 0, he = 0; const $e = z[8] ? re.setUTCFullYear : re.setFullYear, Ft = z[8] ? re.setUTCHours : re.setHours; z[9] && (Z = Number(z[9] + z[10]), he = Number(z[9] + z[11])), $e.call(re, Number(z[1]), Number(z[2]) - 1, Number(z[3])); const Xt = Number(z[4] || 0) - Z, Nn = Number(z[5] || 0) - he, ri = Number(z[6] || 0), Nr = Math.floor(1e3 * parseFloat("0." + (z[7] || 0))); return Ft.call(re, Xt, Nn, ri, Nr), re }(he) } const re = new Date(z); if (!sr(re)) throw new Error(`Unable to convert "${z}" into a date`); return re }(z); re = dr(Z, re) || re; let Nn, Xt = []; for (; re;) { if (Nn = _r.exec(re), !Nn) { Xt.push(re); break } { Xt = Xt.concat(Nn.slice(1)); const kr = Xt.pop(); if (!kr) break; re = kr } } let ri = $e.getTimezoneOffset(); he && (ri = et(he, ri), $e = function mt(z, re, Z) { const he = Z ? -1 : 1, $e = z.getTimezoneOffset(); return function Lt(z, re) { return (z = new Date(z.getTime())).setMinutes(z.getMinutes() + re), z }(z, he * (et(re, $e) - $e)) }($e, he, !0)); let Nr = ""; return Xt.forEach(kr => { const Or = function ke(z) { if (fe[z]) return fe[z]; let re; switch (z) { case "G": case "GG": case "GGG": re = Et(yn.Eras, Ue.Abbreviated); break; case "GGGG": re = Et(yn.Eras, Ue.Wide); break; case "GGGGG": re = Et(yn.Eras, Ue.Narrow); break; case "y": re = ln(Fn.FullYear, 1, 0, !1, !0); break; case "yy": re = ln(Fn.FullYear, 2, 0, !0, !0); break; case "yyy": re = ln(Fn.FullYear, 3, 0, !1, !0); break; case "yyyy": re = ln(Fn.FullYear, 4, 0, !1, !0); break; case "Y": re = Zt(1); break; case "YY": re = Zt(2, !0); break; case "YYY": re = Zt(3); break; case "YYYY": re = Zt(4); break; case "M": case "L": re = ln(Fn.Month, 1, 1); break; case "MM": case "LL": re = ln(Fn.Month, 2, 1); break; case "MMM": re = Et(yn.Months, Ue.Abbreviated); break; case "MMMM": re = Et(yn.Months, Ue.Wide); break; case "MMMMM": re = Et(yn.Months, Ue.Narrow); break; case "LLL": re = Et(yn.Months, Ue.Abbreviated, Fe.Standalone); break; case "LLLL": re = Et(yn.Months, Ue.Wide, Fe.Standalone); break; case "LLLLL": re = Et(yn.Months, Ue.Narrow, Fe.Standalone); break; case "w": re = qe(1); break; case "ww": re = qe(2); break; case "W": re = qe(1, !0); break; case "d": re = ln(Fn.Date, 1); break; case "dd": re = ln(Fn.Date, 2); break; case "c": case "cc": re = ln(Fn.Day, 1); break; case "ccc": re = Et(yn.Days, Ue.Abbreviated, Fe.Standalone); break; case "cccc": re = Et(yn.Days, Ue.Wide, Fe.Standalone); break; case "ccccc": re = Et(yn.Days, Ue.Narrow, Fe.Standalone); break; case "cccccc": re = Et(yn.Days, Ue.Short, Fe.Standalone); break; case "E": case "EE": case "EEE": re = Et(yn.Days, Ue.Abbreviated); break; case "EEEE": re = Et(yn.Days, Ue.Wide); break; case "EEEEE": re = Et(yn.Days, Ue.Narrow); break; case "EEEEEE": re = Et(yn.Days, Ue.Short); break; case "a": case "aa": case "aaa": re = Et(yn.DayPeriods, Ue.Abbreviated); break; case "aaaa": re = Et(yn.DayPeriods, Ue.Wide); break; case "aaaaa": re = Et(yn.DayPeriods, Ue.Narrow); break; case "b": case "bb": case "bbb": re = Et(yn.DayPeriods, Ue.Abbreviated, Fe.Standalone, !0); break; case "bbbb": re = Et(yn.DayPeriods, Ue.Wide, Fe.Standalone, !0); break; case "bbbbb": re = Et(yn.DayPeriods, Ue.Narrow, Fe.Standalone, !0); break; case "B": case "BB": case "BBB": re = Et(yn.DayPeriods, Ue.Abbreviated, Fe.Format, !0); break; case "BBBB": re = Et(yn.DayPeriods, Ue.Wide, Fe.Format, !0); break; case "BBBBB": re = Et(yn.DayPeriods, Ue.Narrow, Fe.Format, !0); break; case "h": re = ln(Fn.Hours, 1, -12); break; case "hh": re = ln(Fn.Hours, 2, -12); break; case "H": re = ln(Fn.Hours, 1); break; case "HH": re = ln(Fn.Hours, 2); break; case "m": re = ln(Fn.Minutes, 1); break; case "mm": re = ln(Fn.Minutes, 2); break; case "s": re = ln(Fn.Seconds, 1); break; case "ss": re = ln(Fn.Seconds, 2); break; case "S": re = ln(Fn.FractionalSeconds, 1); break; case "SS": re = ln(Fn.FractionalSeconds, 2); break; case "SSS": re = ln(Fn.FractionalSeconds, 3); break; case "Z": case "ZZ": case "ZZZ": re = bn(pn.Short); break; case "ZZZZZ": re = bn(pn.Extended); break; case "O": case "OO": case "OOO": case "z": case "zz": case "zzz": re = bn(pn.ShortGMT); break; case "OOOO": case "ZZZZ": case "zzzz": re = bn(pn.Long); break; default: return null }return fe[z] = re, re }(kr); Nr += Or ? Or($e, Z, ri) : "''" === kr ? "'" : kr.replace(/(^'|'$)/g, "").replace(/''/g, "'") }), Nr } function ur(z, re, Z) { const he = new Date(0); return he.setFullYear(z, re, Z), he.setHours(0, 0, 0), he } function dr(z, re) { const Z = function rn(z) { return (0, i.cg1)(z)[i.wAp.LocaleId] }(z); if (Hn[Z] = Hn[Z] || {}, Hn[Z][re]) return Hn[Z][re]; let he = ""; switch (re) { case "shortDate": he = Yt(z, st.Short); break; case "mediumDate": he = Yt(z, st.Medium); break; case "longDate": he = Yt(z, st.Long); break; case "fullDate": he = Yt(z, st.Full); break; case "shortTime": he = pt(z, st.Short); break; case "mediumTime": he = pt(z, st.Medium); break; case "longTime": he = pt(z, st.Long); break; case "fullTime": he = pt(z, st.Full); break; case "short": const $e = dr(z, "shortTime"), Ft = dr(z, "shortDate"); he = Kr(Pt(z, st.Short), [$e, Ft]); break; case "medium": const Xt = dr(z, "mediumTime"), Nn = dr(z, "mediumDate"); he = Kr(Pt(z, st.Medium), [Xt, Nn]); break; case "long": const ri = dr(z, "longTime"), Nr = dr(z, "longDate"); he = Kr(Pt(z, st.Long), [ri, Nr]); break; case "full": const kr = dr(z, "fullTime"), Or = dr(z, "fullDate"); he = Kr(Pt(z, st.Full), [kr, Or]) }return he && (Hn[Z][re] = he), he } function Kr(z, re) { return re && (z = z.replace(/\{([^}]+)}/g, function (Z, he) { return null != re && he in re ? re[he] : Z })), z } function vr(z, re, Z = "-", he, $e) { let Ft = ""; (z < 0 || $e && z <= 0) && ($e ? z = 1 - z : (z = -z, Ft = Z)); let Xt = String(z); for (; Xt.length < re;)Xt = "0" + Xt; return he && (Xt = Xt.slice(Xt.length - re)), Ft + Xt } function ln(z, re, Z = 0, he = !1, $e = !1) { return function (Ft, Xt) { let Nn = function Ae(z, re) { switch (z) { case Fn.FullYear: return re.getFullYear(); case Fn.Month: return re.getMonth(); case Fn.Date: return re.getDate(); case Fn.Hours: return re.getHours(); case Fn.Minutes: return re.getMinutes(); case Fn.Seconds: return re.getSeconds(); case Fn.FractionalSeconds: return re.getMilliseconds(); case Fn.Day: return re.getDay(); default: throw new Error(`Unknown DateType value "${z}".`) } }(z, Ft); if ((Z > 0 || Nn > -Z) && (Nn += Z), z === Fn.Hours) 0 === Nn && -12 === Z && (Nn = 12); else if (z === Fn.FractionalSeconds) return function At(z, re) { return vr(z, 3).substring(0, re) }(Nn, re); const ri = Ze(Xt, ht.MinusSign); return vr(Nn, re, ri, he, $e) } } function Et(z, re, Z = Fe.Format, he = !1) { return function ($e, Ft) { return function Gt(z, re, Z, he, $e, Ft) { switch (Z) { case yn.Months: return nr(re, $e, he)[z.getMonth()]; case yn.Days: return qn(re, $e, he)[z.getDay()]; case yn.DayPeriods: const Xt = z.getHours(), Nn = z.getMinutes(); if (Ft) { const Nr = function Jn(z) { const re = (0, i.cg1)(z); return wn(re), (re[i.wAp.ExtraData][2] || []).map(he => "string" == typeof he ? ue(he) : [ue(he[0]), ue(he[1])]) }(re), kr = function or(z, re, Z) { const he = (0, i.cg1)(z); wn(he); const Ft = dn([he[i.wAp.ExtraData][0], he[i.wAp.ExtraData][1]], re) || []; return dn(Ft, Z) || [] }(re, $e, he), Or = Nr.findIndex(fs => { if (Array.isArray(fs)) { const [xr, Os] = fs, mi = Xt >= xr.hours && Nn >= xr.minutes, bs = Xt < Os.hours || Xt === Os.hours && Nn < Os.minutes; if (xr.hours < Os.hours) { if (mi && bs) return !0 } else if (mi || bs) return !0 } else if (fs.hours === Xt && fs.minutes === Nn) return !0; return !1 }); if (-1 !== Or) return kr[Or] } return function On(z, re, Z) { const he = (0, i.cg1)(z), Ft = dn([he[i.wAp.DayPeriodsFormat], he[i.wAp.DayPeriodsStandalone]], re); return dn(Ft, Z) }(re, $e, he)[Xt < 12 ? 0 : 1]; case yn.Eras: return function kn(z, re) { return dn((0, i.cg1)(z)[i.wAp.Eras], re) }(re, he)[z.getFullYear() <= 0 ? 0 : 1]; default: throw new Error(`unexpected translation type ${Z}`) } }($e, Ft, z, re, Z, he) } } function bn(z) { return function (re, Z, he) { const $e = -1 * he, Ft = Ze(Z, ht.MinusSign), Xt = $e > 0 ? Math.floor($e / 60) : Math.ceil($e / 60); switch (z) { case pn.Short: return ($e >= 0 ? "+" : "") + vr(Xt, 2, Ft) + vr(Math.abs($e % 60), 2, Ft); case pn.ShortGMT: return "GMT" + ($e >= 0 ? "+" : "") + vr(Xt, 1, Ft); case pn.Long: return "GMT" + ($e >= 0 ? "+" : "") + vr(Xt, 2, Ft) + ":" + vr(Math.abs($e % 60), 2, Ft); case pn.Extended: return 0 === he ? "Z" : ($e >= 0 ? "+" : "") + vr(Xt, 2, Ft) + ":" + vr(Math.abs($e % 60), 2, Ft); default: throw new Error(`Unknown zone width "${z}"`) } } } function Le(z) { return ur(z.getFullYear(), z.getMonth(), z.getDate() + (4 - z.getDay())) } function qe(z, re = !1) { return function (Z, he) { let $e; if (re) { const Ft = new Date(Z.getFullYear(), Z.getMonth(), 1).getDay() - 1, Xt = Z.getDate(); $e = 1 + Math.floor((Xt + Ft) / 7) } else { const Ft = Le(Z), Xt = function vt(z) { const re = ur(z, 0, 1).getDay(); return ur(z, 0, 1 + (re <= 4 ? 4 : 11) - re) }(Ft.getFullYear()), Nn = Ft.getTime() - Xt.getTime(); $e = 1 + Math.round(Nn / 6048e5) } return vr($e, z, Ze(he, ht.MinusSign)) } } function Zt(z, re = !1) { return function (Z, he) { return vr(Le(Z).getFullYear(), z, Ze(he, ht.MinusSign), re) } } const fe = {}; function et(z, re) { z = z.replace(/:/g, ""); const Z = Date.parse("Jan 01, 1970 00:00:00 " + z) / 6e4; return isNaN(Z) ? re : Z } function sr(z) { return z instanceof Date && !isNaN(z.valueOf()) } const Fr = /^(\d+)?\.((\d+)(-(\d+))?)?$/; function va(z) { const re = parseInt(z); if (isNaN(re)) throw new Error("Invalid integer literal when parsing " + z); return re } let Hr = (() => { class z { } return z.\u0275fac = function (Z) { return new (Z || z) }, z.\u0275prov = i.Yz7({ token: z, factory: function (Z) { let he = null; return Z ? he = new Z : ($e = i.LFG(i.soG), he = new Ei($e)), he; var $e }, providedIn: "root" }), z })(); let Ei = (() => { class z extends Hr { constructor(Z) { super(), this.locale = Z } getPluralCategory(Z, he) { switch (jt(he || this.locale)(Z)) { case tt.Zero: return "zero"; case tt.One: return "one"; case tt.Two: return "two"; case tt.Few: return "few"; case tt.Many: return "many"; default: return "other" } } } return z.\u0275fac = function (Z) { return new (Z || z)(i.LFG(i.soG)) }, z.\u0275prov = i.Yz7({ token: z, factory: z.\u0275fac }), z })(); function Qi(z, re) { re = encodeURIComponent(re); for (const Z of z.split(";")) { const he = Z.indexOf("="), [$e, Ft] = -1 == he ? [Z, ""] : [Z.slice(0, he), Z.slice(he + 1)]; if ($e.trim() === re) return decodeURIComponent(Ft) } return null } const Gs = /\s+/, Ln = []; let pr = (() => { class z { constructor(Z, he, $e, Ft) { this._iterableDiffers = Z, this._keyValueDiffers = he, this._ngEl = $e, this._renderer = Ft, this.initialClasses = Ln, this.stateMap = new Map } set klass(Z) { this.initialClasses = null != Z ? Z.trim().split(Gs) : Ln } set ngClass(Z) { this.rawClass = "string" == typeof Z ? Z.trim().split(Gs) : Z } ngDoCheck() { for (const he of this.initialClasses) this._updateState(he, !0); const Z = this.rawClass; if (Array.isArray(Z) || Z instanceof Set) for (const he of Z) this._updateState(he, !0); else if (null != Z) for (const he of Object.keys(Z)) this._updateState(he, Boolean(Z[he])); this._applyStateDiff() } _updateState(Z, he) { const $e = this.stateMap.get(Z); void 0 !== $e ? ($e.enabled !== he && ($e.changed = !0, $e.enabled = he), $e.touched = !0) : this.stateMap.set(Z, { enabled: he, changed: !0, touched: !0 }) } _applyStateDiff() { for (const Z of this.stateMap) { const he = Z[0], $e = Z[1]; $e.changed ? (this._toggleClass(he, $e.enabled), $e.changed = !1) : $e.touched || ($e.enabled && this._toggleClass(he, !1), this.stateMap.delete(he)), $e.touched = !1 } } _toggleClass(Z, he) { (Z = Z.trim()).length > 0 && Z.split(Gs).forEach($e => { he ? this._renderer.addClass(this._ngEl.nativeElement, $e) : this._renderer.removeClass(this._ngEl.nativeElement, $e) }) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.ZZ4), i.Y36(i.aQg), i.Y36(i.SBq), i.Y36(i.Qsj)) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }), z })(); class Ti { constructor(re, Z, he, $e) { this.$implicit = re, this.ngForOf = Z, this.index = he, this.count = $e } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let _s = (() => { class z { set ngForOf(Z) { this._ngForOf = Z, this._ngForOfDirty = !0 } set ngForTrackBy(Z) { this._trackByFn = Z } get ngForTrackBy() { return this._trackByFn } constructor(Z, he, $e) { this._viewContainer = Z, this._template = he, this._differs = $e, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(Z) { Z && (this._template = Z) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const Z = this._ngForOf; !this._differ && Z && (this._differ = this._differs.find(Z).create(this.ngForTrackBy)) } if (this._differ) { const Z = this._differ.diff(this._ngForOf); Z && this._applyChanges(Z) } } _applyChanges(Z) { const he = this._viewContainer; Z.forEachOperation(($e, Ft, Xt) => { if (null == $e.previousIndex) he.createEmbeddedView(this._template, new Ti($e.item, this._ngForOf, -1, -1), null === Xt ? void 0 : Xt); else if (null == Xt) he.remove(null === Ft ? void 0 : Ft); else if (null !== Ft) { const Nn = he.get(Ft); he.move(Nn, Xt), Di(Nn, $e) } }); for (let $e = 0, Ft = he.length; $e < Ft; $e++) { const Nn = he.get($e).context; Nn.index = $e, Nn.count = Ft, Nn.ngForOf = this._ngForOf } Z.forEachIdentityChange($e => { Di(he.get($e.currentIndex), $e) }) } static ngTemplateContextGuard(Z, he) { return !0 } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.s_b), i.Y36(i.Rgc), i.Y36(i.ZZ4)) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), z })(); function Di(z, re) { z.context.$implicit = re.item } let js = (() => { class z { constructor(Z, he) { this._viewContainer = Z, this._context = new Mr, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = he } set ngIf(Z) { this._context.$implicit = this._context.ngIf = Z, this._updateView() } set ngIfThen(Z) { ba("ngIfThen", Z), this._thenTemplateRef = Z, this._thenViewRef = null, this._updateView() } set ngIfElse(Z) { ba("ngIfElse", Z), this._elseTemplateRef = Z, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(Z, he) { return !0 } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.s_b), i.Y36(i.Rgc)) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), z })(); class Mr { constructor() { this.$implicit = null, this.ngIf = null } } function ba(z, re) { if (re && !re.createEmbeddedView) throw new Error(`${z} must be a TemplateRef, but received '${(0, i.AaK)(re)}'.`) } class So { constructor(re, Z) { this._viewContainerRef = re, this._templateRef = Z, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(re) { re && !this._created ? this.create() : !re && this._created && this.destroy() } } let al = (() => { class z { constructor() { this._defaultViews = [], this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(Z) { this._ngSwitch = Z, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(Z) { this._defaultViews.push(Z) } _matchCase(Z) { const he = Z == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || he, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), he } _updateDefaultCases(Z) { if (this._defaultViews.length > 0 && Z !== this._defaultUsed) { this._defaultUsed = Z; for (const he of this._defaultViews) he.enforceState(Z) } } } return z.\u0275fac = function (Z) { return new (Z || z) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" }, standalone: !0 }), z })(), Vi = (() => { class z { constructor(Z, he, $e) { this.ngSwitch = $e, $e._addCase(), this._view = new So(Z, he) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.s_b), i.Y36(i.Rgc), i.Y36(al, 9)) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" }, standalone: !0 }), z })(), ls = (() => { class z { constructor(Z, he, $e) { $e._addDefault(new So(Z, he)) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.s_b), i.Y36(i.Rgc), i.Y36(al, 9)) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngSwitchDefault", ""]], standalone: !0 }), z })(), cs = (() => { class z { constructor(Z, he, $e) { this._ngEl = Z, this._differs = he, this._renderer = $e, this._ngStyle = null, this._differ = null } set ngStyle(Z) { this._ngStyle = Z, !this._differ && Z && (this._differ = this._differs.find(Z).create()) } ngDoCheck() { if (this._differ) { const Z = this._differ.diff(this._ngStyle); Z && this._applyChanges(Z) } } _setStyle(Z, he) { const [$e, Ft] = Z.split("."), Xt = -1 === $e.indexOf("-") ? void 0 : i.JOm.DashCase; null != he ? this._renderer.setStyle(this._ngEl.nativeElement, $e, Ft ? `${he}${Ft}` : he, Xt) : this._renderer.removeStyle(this._ngEl.nativeElement, $e, Xt) } _applyChanges(Z) { Z.forEachRemovedItem(he => this._setStyle(he.key, null)), Z.forEachAddedItem(he => this._setStyle(he.key, he.currentValue)), Z.forEachChangedItem(he => this._setStyle(he.key, he.currentValue)) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.SBq), i.Y36(i.aQg), i.Y36(i.Qsj)) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" }, standalone: !0 }), z })(), ro = (() => { class z { constructor(Z) { this._viewContainerRef = Z, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(Z) { if (Z.ngTemplateOutlet || Z.ngTemplateOutletInjector) { const he = this._viewContainerRef; if (this._viewRef && he.remove(he.indexOf(this._viewRef)), this.ngTemplateOutlet) { const { ngTemplateOutlet: $e, ngTemplateOutletContext: Ft, ngTemplateOutletInjector: Xt } = this; this._viewRef = he.createEmbeddedView($e, Ft, Xt ? { injector: Xt } : void 0) } else this._viewRef = null } else this._viewRef && Z.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.s_b)) }, z.\u0275dir = i.lG2({ type: z, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, standalone: !0, features: [i.TTD] }), z })(); function dt(z, re) { return new i.vHH(2100, !1) } class Mt { createSubscription(re, Z) { return re.subscribe({ next: Z, error: he => { throw he } }) } dispose(re) { re.unsubscribe() } } class hn { createSubscription(re, Z) { return re.then(Z, he => { throw he }) } dispose(re) { } } const Sn = new hn, Yn = new Mt; let lr = (() => { class z { constructor(Z) { this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null, this._ref = Z } ngOnDestroy() { this._subscription && this._dispose(), this._ref = null } transform(Z) { return this._obj ? Z !== this._obj ? (this._dispose(), this.transform(Z)) : this._latestValue : (Z && this._subscribe(Z), this._latestValue) } _subscribe(Z) { this._obj = Z, this._strategy = this._selectStrategy(Z), this._subscription = this._strategy.createSubscription(Z, he => this._updateLatestValue(Z, he)) } _selectStrategy(Z) { if ((0, i.QGY)(Z)) return Sn; if ((0, i.F4k)(Z)) return Yn; throw dt() } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(Z, he) { Z === this._obj && (this._latestValue = he, this._ref.markForCheck()) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.sBO, 16)) }, z.\u0275pipe = i.Yjl({ name: "async", type: z, pure: !1, standalone: !0 }), z })(); const gr = new i.OlP("DATE_PIPE_DEFAULT_TIMEZONE"), xl = new i.OlP("DATE_PIPE_DEFAULT_OPTIONS"); let us = (() => { class z { constructor(Z, he, $e) { this.locale = Z, this.defaultTimezone = he, this.defaultOptions = $e } transform(Z, he, $e, Ft) { if (null == Z || "" === Z || Z != Z) return null; try { return Qn(Z, he ?? this.defaultOptions?.dateFormat ?? "mediumDate", Ft || this.locale, $e ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0) } catch (Xt) { throw dt() } } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.soG, 16), i.Y36(gr, 24), i.Y36(xl, 24)) }, z.\u0275pipe = i.Yjl({ name: "date", type: z, pure: !0, standalone: !0 }), z })(); const bo = /#/g; let Jr = (() => { class z { constructor(Z) { this._localization = Z } transform(Z, he, $e) { if (null == Z) return ""; if ("object" != typeof he || null === he) throw dt(); return he[function Ji(z, re, Z, he) { let $e = `=${z}`; if (re.indexOf($e) > -1 || ($e = Z.getPluralCategory(z, he), re.indexOf($e) > -1)) return $e; if (re.indexOf("other") > -1) return "other"; throw new Error(`No plural message found for value "${z}"`) }(Z, Object.keys(he), this._localization, $e)].replace(bo, Z.toString()) } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(Hr, 16)) }, z.\u0275pipe = i.Yjl({ name: "i18nPlural", type: z, pure: !0, standalone: !0 }), z })(), Xn = (() => { class z { transform(Z) { return JSON.stringify(Z, null, 2) } } return z.\u0275fac = function (Z) { return new (Z || z) }, z.\u0275pipe = i.Yjl({ name: "json", type: z, pure: !1, standalone: !0 }), z })(), Si = (() => { class z { constructor(Z) { this.differs = Z, this.keyValues = [], this.compareFn = ka } transform(Z, he = ka) { if (!Z || !(Z instanceof Map) && "object" != typeof Z) return null; this.differ || (this.differ = this.differs.find(Z).create()); const $e = this.differ.diff(Z), Ft = he !== this.compareFn; return $e && (this.keyValues = [], $e.forEachItem(Xt => { this.keyValues.push(function uo(z, re) { return { key: z, value: re } }(Xt.key, Xt.currentValue)) })), ($e || Ft) && (this.keyValues.sort(he), this.compareFn = he), this.keyValues } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.aQg, 16)) }, z.\u0275pipe = i.Yjl({ name: "keyvalue", type: z, pure: !1, standalone: !0 }), z })(); function ka(z, re) { const Z = z.key, he = re.key; if (Z === he) return 0; if (void 0 === Z) return 1; if (void 0 === he) return -1; if (null === Z) return 1; if (null === he) return -1; if ("string" == typeof Z && "string" == typeof he) return Z < he ? -1 : 1; if ("number" == typeof Z && "number" == typeof he) return Z - he; if ("boolean" == typeof Z && "boolean" == typeof he) return Z < he ? -1 : 1; const $e = String(Z), Ft = String(he); return $e == Ft ? 0 : $e < Ft ? -1 : 1 } let io = (() => { class z { constructor(Z) { this._locale = Z } transform(Z, he, $e) { if (!function Ys(z) { return !(null == z || "" === z || z != z) }(Z)) return null; $e = $e || this._locale; try { return function vo(z, re, Z) { return function Br(z, re, Z, he, $e, Ft, Xt = !1) { let Nn = "", ri = !1; if (isFinite(z)) { let Nr = function _a(z) { let he, $e, Ft, Xt, Nn, re = Math.abs(z) + "", Z = 0; for (($e = re.indexOf(".")) > -1 && (re = re.replace(".", "")), (Ft = re.search(/e/i)) > 0 ? ($e < 0 && ($e = Ft), $e += +re.slice(Ft + 1), re = re.substring(0, Ft)) : $e < 0 && ($e = re.length), Ft = 0; "0" === re.charAt(Ft); Ft++); if (Ft === (Nn = re.length)) he = [0], $e = 1; else { for (Nn--; "0" === re.charAt(Nn);)Nn--; for ($e -= Ft, he = [], Xt = 0; Ft <= Nn; Ft++, Xt++)he[Xt] = Number(re.charAt(Ft)) } return $e > 22 && (he = he.splice(0, 21), Z = $e - 1, $e = 1), { digits: he, exponent: Z, integerLen: $e } }(z); Xt && (Nr = function Bi(z) { if (0 === z.digits[0]) return z; const re = z.digits.length - z.integerLen; return z.exponent ? z.exponent += 2 : (0 === re ? z.digits.push(0, 0) : 1 === re && z.digits.push(0), z.integerLen += 2), z }(Nr)); let kr = re.minInt, Or = re.minFrac, fs = re.maxFrac; if (Ft) { const go = Ft.match(Fr); if (null === go) throw new Error(`${Ft} is not a valid digit info`); const Ba = go[1], Va = go[3], xi = go[5]; null != Ba && (kr = va(Ba)), null != Va && (Or = va(Va)), null != xi ? fs = va(xi) : null != Va && Or > fs && (fs = Or) } !function ya(z, re, Z) { if (re > Z) throw new Error(`The minimum number of digits after fraction (${re}) is higher than the maximum (${Z}).`); let he = z.digits, $e = he.length - z.integerLen; const Ft = Math.min(Math.max(re, $e), Z); let Xt = Ft + z.integerLen, Nn = he[Xt]; if (Xt > 0) { he.splice(Math.max(z.integerLen, Xt)); for (let Or = Xt; Or < he.length; Or++)he[Or] = 0 } else { $e = Math.max(0, $e), z.integerLen = 1, he.length = Math.max(1, Xt = Ft + 1), he[0] = 0; for (let Or = 1; Or < Xt; Or++)he[Or] = 0 } if (Nn >= 5) if (Xt - 1 < 0) { for (let Or = 0; Or > Xt; Or--)he.unshift(0), z.integerLen++; he.unshift(1), z.integerLen++ } else he[Xt - 1]++; for (; $e < Math.max(0, Ft); $e++)he.push(0); let ri = 0 !== Ft; const Nr = re + z.integerLen, kr = he.reduceRight(function (Or, fs, xr, Os) { return Os[xr] = (fs += Or) < 10 ? fs : fs - 10, ri && (0 === Os[xr] && xr >= Nr ? Os.pop() : ri = !1), fs >= 10 ? 1 : 0 }, 0); kr && (he.unshift(kr), z.integerLen++) }(Nr, Or, fs); let xr = Nr.digits, Os = Nr.integerLen; const mi = Nr.exponent; let bs = []; for (ri = xr.every(go => !go); Os < kr; Os++)xr.unshift(0); for (; Os < 0; Os++)xr.unshift(0); Os > 0 ? bs = xr.splice(Os, xr.length) : (bs = xr, xr = [0]); const To = []; for (xr.length >= re.lgSize && To.unshift(xr.splice(-re.lgSize, xr.length).join("")); xr.length > re.gSize;)To.unshift(xr.splice(-re.gSize, xr.length).join("")); xr.length && To.unshift(xr.join("")), Nn = To.join(Ze(Z, he)), bs.length && (Nn += Ze(Z, $e) + bs.join("")), mi && (Nn += Ze(Z, ht.Exponential) + "+" + mi) } else Nn = Ze(Z, ht.Infinity); return Nn = z < 0 && !ri ? re.negPre + Nn + re.negSuf : re.posPre + Nn + re.posSuf, Nn }(z, function Dr(z, re = "-") { const Z = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 }, he = z.split(";"), $e = he[0], Ft = he[1], Xt = -1 !== $e.indexOf(".") ? $e.split(".") : [$e.substring(0, $e.lastIndexOf("0") + 1), $e.substring($e.lastIndexOf("0") + 1)], Nn = Xt[0], ri = Xt[1] || ""; Z.posPre = Nn.substring(0, Nn.indexOf("#")); for (let kr = 0; kr < ri.length; kr++) { const Or = ri.charAt(kr); "0" === Or ? Z.minFrac = Z.maxFrac = kr + 1 : "#" === Or ? Z.maxFrac = kr + 1 : Z.posSuf += Or } const Nr = Nn.split(","); if (Z.gSize = Nr[1] ? Nr[1].length : 0, Z.lgSize = Nr[2] || Nr[1] ? (Nr[2] || Nr[1]).length : 0, Ft) { const kr = $e.length - Z.posPre.length - Z.posSuf.length, Or = Ft.indexOf("#"); Z.negPre = Ft.substring(0, Or).replace(/'/g, ""), Z.negSuf = Ft.slice(Or + kr).replace(/'/g, "") } else Z.negPre = re + Z.posPre, Z.negSuf = Z.posSuf; return Z }(function Ot(z, re) { return (0, i.cg1)(z)[i.wAp.NumberFormats][re] }(re, Ne.Decimal), Ze(re, ht.MinusSign)), re, ht.Group, ht.Decimal, Z) }(function Go(z) { if ("string" == typeof z && !isNaN(Number(z) - parseFloat(z))) return Number(z); if ("number" != typeof z) throw new Error(`${z} is not a number`); return z }(Z), $e, he) } catch (Ft) { throw dt() } } } return z.\u0275fac = function (Z) { return new (Z || z)(i.Y36(i.soG, 16)) }, z.\u0275pipe = i.Yjl({ name: "number", type: z, pure: !0, standalone: !0 }), z })(); let so = (() => { class z { transform(Z, he, $e) { if (null == Z) return null; if (!this.supports(Z)) throw dt(); return Z.slice(he, $e) } supports(Z) { return "string" == typeof Z || Array.isArray(Z) } } return z.\u0275fac = function (Z) { return new (Z || z) }, z.\u0275pipe = i.Yjl({ name: "slice", type: z, pure: !1, standalone: !0 }), z })(), na = (() => { class z { } return z.\u0275fac = function (Z) { return new (Z || z) }, z.\u0275mod = i.oAB({ type: z }), z.\u0275inj = i.cJS({}), z })(); const Zl = "browser"; function wo(z) { return z === Zl } function ho(z) { return "server" === z } let Wo = (() => { class z { } return z.\u0275prov = (0, i.Yz7)({ token: z, providedIn: "root", factory: () => new Za((0, i.LFG)(we), window) }), z })(); class Za { constructor(re, Z) { this.document = re, this.window = Z, this.offset = () => [0, 0] } setOffset(re) { this.offset = Array.isArray(re) ? () => re : re } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(re) { this.supportsScrolling() && this.window.scrollTo(re[0], re[1]) } scrollToAnchor(re) { if (!this.supportsScrolling()) return; const Z = function As(z, re) { const Z = z.getElementById(re) || z.getElementsByName(re)[0]; if (Z) return Z; if ("function" == typeof z.createTreeWalker && z.body && (z.body.createShadowRoot || z.body.attachShadow)) { const he = z.createTreeWalker(z.body, NodeFilter.SHOW_ELEMENT); let $e = he.currentNode; for (; $e;) { const Ft = $e.shadowRoot; if (Ft) { const Xt = Ft.getElementById(re) || Ft.querySelector(`[name="${re}"]`); if (Xt) return Xt } $e = he.nextNode() } } return null }(this.document, re); Z && (this.scrollToElement(Z), Z.focus()) } setHistoryScrollRestoration(re) { if (this.supportScrollRestoration()) { const Z = this.window.history; Z && Z.scrollRestoration && (Z.scrollRestoration = re) } } scrollToElement(re) { const Z = re.getBoundingClientRect(), he = Z.left + this.window.pageXOffset, $e = Z.top + this.window.pageYOffset, Ft = this.offset(); this.window.scrollTo(he - Ft[0], $e - Ft[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const re = fo(this.window.history) || fo(Object.getPrototypeOf(this.window.history)); return !(!re || !re.writable && !re.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function fo(z) { return Object.getOwnPropertyDescriptor(z, "scrollRestoration") } class Ks { } }, 529: (un, Je, L) => { "use strict"; L.d(Je, { JF: () => bn, eN: () => rn }); var i = L(6895), m = L(4650), J = L(9646), ye = L(9751), Ce = L(4351), we = L(9300), Te = L(4004); class Ee { } class _e { } class ae { constructor(Le) { this.normalizedNames = new Map, this.lazyUpdate = null, Le ? this.lazyInit = "string" == typeof Le ? () => { this.headers = new Map, Le.split("\n").forEach(qe => { const Zt = qe.indexOf(":"); if (Zt > 0) { const fe = qe.slice(0, Zt), ke = fe.toLowerCase(), et = qe.slice(Zt + 1).trim(); this.maybeSetNormalizedName(fe, ke), this.headers.has(ke) ? this.headers.get(ke).push(et) : this.headers.set(ke, [et]) } }) } : () => { this.headers = new Map, Object.keys(Le).forEach(qe => { let Zt = Le[qe]; const fe = qe.toLowerCase(); "string" == typeof Zt && (Zt = [Zt]), Zt.length > 0 && (this.headers.set(fe, Zt), this.maybeSetNormalizedName(qe, fe)) }) } : this.headers = new Map } has(Le) { return this.init(), this.headers.has(Le.toLowerCase()) } get(Le) { this.init(); const qe = this.headers.get(Le.toLowerCase()); return qe && qe.length > 0 ? qe[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(Le) { return this.init(), this.headers.get(Le.toLowerCase()) || null } append(Le, qe) { return this.clone({ name: Le, value: qe, op: "a" }) } set(Le, qe) { return this.clone({ name: Le, value: qe, op: "s" }) } delete(Le, qe) { return this.clone({ name: Le, value: qe, op: "d" }) } maybeSetNormalizedName(Le, qe) { this.normalizedNames.has(qe) || this.normalizedNames.set(qe, Le) } init() { this.lazyInit && (this.lazyInit instanceof ae ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(Le => this.applyUpdate(Le)), this.lazyUpdate = null)) } copyFrom(Le) { Le.init(), Array.from(Le.headers.keys()).forEach(qe => { this.headers.set(qe, Le.headers.get(qe)), this.normalizedNames.set(qe, Le.normalizedNames.get(qe)) }) } clone(Le) { const qe = new ae; return qe.lazyInit = this.lazyInit && this.lazyInit instanceof ae ? this.lazyInit : this, qe.lazyUpdate = (this.lazyUpdate || []).concat([Le]), qe } applyUpdate(Le) { const qe = Le.name.toLowerCase(); switch (Le.op) { case "a": case "s": let Zt = Le.value; if ("string" == typeof Zt && (Zt = [Zt]), 0 === Zt.length) return; this.maybeSetNormalizedName(Le.name, qe); const fe = ("a" === Le.op ? this.headers.get(qe) : void 0) || []; fe.push(...Zt), this.headers.set(qe, fe); break; case "d": const ke = Le.value; if (ke) { let et = this.headers.get(qe); if (!et) return; et = et.filter(Lt => -1 === ke.indexOf(Lt)), 0 === et.length ? (this.headers.delete(qe), this.normalizedNames.delete(qe)) : this.headers.set(qe, et) } else this.headers.delete(qe), this.normalizedNames.delete(qe) } } forEach(Le) { this.init(), Array.from(this.normalizedNames.keys()).forEach(qe => Le(this.normalizedNames.get(qe), this.headers.get(qe))) } } class xe { encodeKey(Le) { return wt(Le) } encodeValue(Le) { return wt(Le) } decodeKey(Le) { return decodeURIComponent(Le) } decodeValue(Le) { return decodeURIComponent(Le) } } const Se = /%(\d[a-f0-9])/gi, rt = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function wt(vt) { return encodeURIComponent(vt).replace(Se, (Le, qe) => rt[qe] ?? Le) } function De(vt) { return `${vt}` } class je { constructor(Le = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = Le.encoder || new xe, Le.fromString) { if (Le.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function gt(vt, Le) { const qe = new Map; return vt.length > 0 && vt.replace(/^\?/, "").split("&").forEach(fe => { const ke = fe.indexOf("="), [et, Lt] = -1 == ke ? [Le.decodeKey(fe), ""] : [Le.decodeKey(fe.slice(0, ke)), Le.decodeValue(fe.slice(ke + 1))], mt = qe.get(et) || []; mt.push(Lt), qe.set(et, mt) }), qe }(Le.fromString, this.encoder) } else Le.fromObject ? (this.map = new Map, Object.keys(Le.fromObject).forEach(qe => { const Zt = Le.fromObject[qe], fe = Array.isArray(Zt) ? Zt.map(De) : [De(Zt)]; this.map.set(qe, fe) })) : this.map = null } has(Le) { return this.init(), this.map.has(Le) } get(Le) { this.init(); const qe = this.map.get(Le); return qe ? qe[0] : null } getAll(Le) { return this.init(), this.map.get(Le) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(Le, qe) { return this.clone({ param: Le, value: qe, op: "a" }) } appendAll(Le) { const qe = []; return Object.keys(Le).forEach(Zt => { const fe = Le[Zt]; Array.isArray(fe) ? fe.forEach(ke => { qe.push({ param: Zt, value: ke, op: "a" }) }) : qe.push({ param: Zt, value: fe, op: "a" }) }), this.clone(qe) } set(Le, qe) { return this.clone({ param: Le, value: qe, op: "s" }) } delete(Le, qe) { return this.clone({ param: Le, value: qe, op: "d" }) } toString() { return this.init(), this.keys().map(Le => { const qe = this.encoder.encodeKey(Le); return this.map.get(Le).map(Zt => qe + "=" + this.encoder.encodeValue(Zt)).join("&") }).filter(Le => "" !== Le).join("&") } clone(Le) { const qe = new je({ encoder: this.encoder }); return qe.cloneFrom = this.cloneFrom || this, qe.updates = (this.updates || []).concat(Le), qe } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(Le => this.map.set(Le, this.cloneFrom.map.get(Le))), this.updates.forEach(Le => { switch (Le.op) { case "a": case "s": const qe = ("a" === Le.op ? this.map.get(Le.param) : void 0) || []; qe.push(De(Le.value)), this.map.set(Le.param, qe); break; case "d": if (void 0 === Le.value) { this.map.delete(Le.param); break } { let Zt = this.map.get(Le.param) || []; const fe = Zt.indexOf(De(Le.value)); -1 !== fe && Zt.splice(fe, 1), Zt.length > 0 ? this.map.set(Le.param, Zt) : this.map.delete(Le.param) } } }), this.cloneFrom = this.updates = null) } } class Qe { constructor() { this.map = new Map } set(Le, qe) { return this.map.set(Le, qe), this } get(Le) { return this.map.has(Le) || this.map.set(Le, Le.defaultValue()), this.map.get(Le) } delete(Le) { return this.map.delete(Le), this } has(Le) { return this.map.has(Le) } keys() { return this.map.keys() } } function Oe(vt) { return typeof ArrayBuffer < "u" && vt instanceof ArrayBuffer } function Ve(vt) { return typeof Blob < "u" && vt instanceof Blob } function Be(vt) { return typeof FormData < "u" && vt instanceof FormData } class Ne { constructor(Le, qe, Zt, fe) { let ke; if (this.url = qe, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = Le.toUpperCase(), function ct(vt) { switch (vt) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || fe ? (this.body = void 0 !== Zt ? Zt : null, ke = fe) : ke = Zt, ke && (this.reportProgress = !!ke.reportProgress, this.withCredentials = !!ke.withCredentials, ke.responseType && (this.responseType = ke.responseType), ke.headers && (this.headers = ke.headers), ke.context && (this.context = ke.context), ke.params && (this.params = ke.params)), this.headers || (this.headers = new ae), this.context || (this.context = new Qe), this.params) { const et = this.params.toString(); if (0 === et.length) this.urlWithParams = qe; else { const Lt = qe.indexOf("?"); this.urlWithParams = qe + (-1 === Lt ? "?" : Lt < qe.length - 1 ? "&" : "") + et } } else this.params = new je, this.urlWithParams = qe } serializeBody() { return null === this.body ? null : Oe(this.body) || Ve(this.body) || Be(this.body) || function nt(vt) { return typeof URLSearchParams < "u" && vt instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof je ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || Be(this.body) ? null : Ve(this.body) ? this.body.type || null : Oe(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof je ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(Le = {}) { const qe = Le.method || this.method, Zt = Le.url || this.url, fe = Le.responseType || this.responseType, ke = void 0 !== Le.body ? Le.body : this.body, et = void 0 !== Le.withCredentials ? Le.withCredentials : this.withCredentials, Lt = void 0 !== Le.reportProgress ? Le.reportProgress : this.reportProgress; let mt = Le.headers || this.headers, An = Le.params || this.params; const ar = Le.context ?? this.context; return void 0 !== Le.setHeaders && (mt = Object.keys(Le.setHeaders).reduce((sr, Fr) => sr.set(Fr, Le.setHeaders[Fr]), mt)), Le.setParams && (An = Object.keys(Le.setParams).reduce((sr, Fr) => sr.set(Fr, Le.setParams[Fr]), An)), new Ne(qe, Zt, ke, { params: An, headers: mt, context: ar, reportProgress: Lt, responseType: fe, withCredentials: et }) } } var tt = (() => ((tt = tt || {})[tt.Sent = 0] = "Sent", tt[tt.UploadProgress = 1] = "UploadProgress", tt[tt.ResponseHeader = 2] = "ResponseHeader", tt[tt.DownloadProgress = 3] = "DownloadProgress", tt[tt.Response = 4] = "Response", tt[tt.User = 5] = "User", tt))(); class Fe { constructor(Le, qe = 200, Zt = "OK") { this.headers = Le.headers || new ae, this.status = void 0 !== Le.status ? Le.status : qe, this.statusText = Le.statusText || Zt, this.url = Le.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Ue extends Fe { constructor(Le = {}) { super(Le), this.type = tt.ResponseHeader } clone(Le = {}) { return new Ue({ headers: Le.headers || this.headers, status: void 0 !== Le.status ? Le.status : this.status, statusText: Le.statusText || this.statusText, url: Le.url || this.url || void 0 }) } } class st extends Fe { constructor(Le = {}) { super(Le), this.type = tt.Response, this.body = void 0 !== Le.body ? Le.body : null } clone(Le = {}) { return new st({ body: void 0 !== Le.body ? Le.body : this.body, headers: Le.headers || this.headers, status: void 0 !== Le.status ? Le.status : this.status, statusText: Le.statusText || this.statusText, url: Le.url || this.url || void 0 }) } } class ht extends Fe { constructor(Le) { super(Le, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${Le.url || "(unknown url)"}` : `Http failure response for ${Le.url || "(unknown url)"}: ${Le.status} ${Le.statusText}`, this.error = Le.error || null } } function Kt(vt, Le) { return { body: Le, headers: vt.headers, context: vt.context, observe: vt.observe, params: vt.params, reportProgress: vt.reportProgress, responseType: vt.responseType, withCredentials: vt.withCredentials } } let rn = (() => { class vt { constructor(qe) { this.handler = qe } request(qe, Zt, fe = {}) { let ke; if (qe instanceof Ne) ke = qe; else { let mt, An; mt = fe.headers instanceof ae ? fe.headers : new ae(fe.headers), fe.params && (An = fe.params instanceof je ? fe.params : new je({ fromObject: fe.params })), ke = new Ne(qe, Zt, void 0 !== fe.body ? fe.body : null, { headers: mt, context: fe.context, params: An, reportProgress: fe.reportProgress, responseType: fe.responseType || "json", withCredentials: fe.withCredentials }) } const et = (0, J.of)(ke).pipe((0, Ce.b)(mt => this.handler.handle(mt))); if (qe instanceof Ne || "events" === fe.observe) return et; const Lt = et.pipe((0, we.h)(mt => mt instanceof st)); switch (fe.observe || "body") { case "body": switch (ke.responseType) { case "arraybuffer": return Lt.pipe((0, Te.U)(mt => { if (null !== mt.body && !(mt.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return mt.body })); case "blob": return Lt.pipe((0, Te.U)(mt => { if (null !== mt.body && !(mt.body instanceof Blob)) throw new Error("Response is not a Blob."); return mt.body })); case "text": return Lt.pipe((0, Te.U)(mt => { if (null !== mt.body && "string" != typeof mt.body) throw new Error("Response is not a string."); return mt.body })); default: return Lt.pipe((0, Te.U)(mt => mt.body)) }case "response": return Lt; default: throw new Error(`Unreachable: unhandled observe type ${fe.observe}}`) } } delete(qe, Zt = {}) { return this.request("DELETE", qe, Zt) } get(qe, Zt = {}) { return this.request("GET", qe, Zt) } head(qe, Zt = {}) { return this.request("HEAD", qe, Zt) } jsonp(qe, Zt) { return this.request("JSONP", qe, { params: (new je).append(Zt, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(qe, Zt = {}) { return this.request("OPTIONS", qe, Zt) } patch(qe, Zt, fe = {}) { return this.request("PATCH", qe, Kt(fe, Zt)) } post(qe, Zt, fe = {}) { return this.request("POST", qe, Kt(fe, Zt)) } put(qe, Zt, fe = {}) { return this.request("PUT", qe, Kt(fe, Zt)) } } return vt.\u0275fac = function (qe) { return new (qe || vt)(m.LFG(Ee)) }, vt.\u0275prov = m.Yz7({ token: vt, factory: vt.\u0275fac }), vt })(); function On(vt, Le) { return Le(vt) } function qn(vt, Le) { return (qe, Zt) => Le.intercept(qe, { handle: fe => vt(fe, Zt) }) } const kn = new m.OlP("HTTP_INTERCEPTORS"), fn = new m.OlP("HTTP_INTERCEPTOR_FNS"); function It() { let vt = null; return (Le, qe) => (null === vt && (vt = ((0, m.f3M)(kn, { optional: !0 }) ?? []).reduceRight(qn, On)), vt(Le, qe)) } let Yt = (() => { class vt extends Ee { constructor(qe, Zt) { super(), this.backend = qe, this.injector = Zt, this.chain = null } handle(qe) { if (null === this.chain) { const Zt = Array.from(new Set(this.injector.get(fn))); this.chain = Zt.reduceRight((fe, ke) => function nr(vt, Le, qe) { return (Zt, fe) => qe.runInContext(() => Le(Zt, ke => vt(ke, fe))) }(fe, ke, this.injector), On) } return this.chain(qe, Zt => this.backend.handle(Zt)) } } return vt.\u0275fac = function (qe) { return new (qe || vt)(m.LFG(_e), m.LFG(m.lqb)) }, vt.\u0275prov = m.Yz7({ token: vt, factory: vt.\u0275fac }), vt })(); const or = /^\)\]\}',?\n/; let dn = (() => { class vt { constructor(qe) { this.xhrFactory = qe } handle(qe) { if ("JSONP" === qe.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new ye.y(Zt => { const fe = this.xhrFactory.build(); if (fe.open(qe.method, qe.urlWithParams), qe.withCredentials && (fe.withCredentials = !0), qe.headers.forEach((ze, Ye) => fe.setRequestHeader(ze, Ye.join(","))), qe.headers.has("Accept") || fe.setRequestHeader("Accept", "application/json, text/plain, */*"), !qe.headers.has("Content-Type")) { const ze = qe.detectContentTypeHeader(); null !== ze && fe.setRequestHeader("Content-Type", ze) } if (qe.responseType) { const ze = qe.responseType.toLowerCase(); fe.responseType = "json" !== ze ? ze : "text" } const ke = qe.serializeBody(); let et = null; const Lt = () => { if (null !== et) return et; const ze = fe.statusText || "OK", Ye = new ae(fe.getAllResponseHeaders()), Ie = function Ht(vt) { return "responseURL" in vt && vt.responseURL ? vt.responseURL : /^X-Request-URL:/m.test(vt.getAllResponseHeaders()) ? vt.getResponseHeader("X-Request-URL") : null }(fe) || qe.url; return et = new Ue({ headers: Ye, status: fe.status, statusText: ze, url: Ie }), et }, mt = () => { let { headers: ze, status: Ye, statusText: Ie, url: Ct } = Lt(), nn = null; 204 !== Ye && (nn = typeof fe.response > "u" ? fe.responseText : fe.response), 0 === Ye && (Ye = nn ? 200 : 0); let xn = Ye >= 200 && Ye < 300; if ("json" === qe.responseType && "string" == typeof nn) { const zn = nn; nn = nn.replace(or, ""); try { nn = "" !== nn ? JSON.parse(nn) : null } catch (ti) { nn = zn, xn && (xn = !1, nn = { error: ti, text: nn }) } } xn ? (Zt.next(new st({ body: nn, headers: ze, status: Ye, statusText: Ie, url: Ct || void 0 })), Zt.complete()) : Zt.error(new ht({ error: nn, headers: ze, status: Ye, statusText: Ie, url: Ct || void 0 })) }, An = ze => { const { url: Ye } = Lt(), Ie = new ht({ error: ze, status: fe.status || 0, statusText: fe.statusText || "Unknown Error", url: Ye || void 0 }); Zt.error(Ie) }; let ar = !1; const sr = ze => { ar || (Zt.next(Lt()), ar = !0); let Ye = { type: tt.DownloadProgress, loaded: ze.loaded }; ze.lengthComputable && (Ye.total = ze.total), "text" === qe.responseType && fe.responseText && (Ye.partialText = fe.responseText), Zt.next(Ye) }, Fr = ze => { let Ye = { type: tt.UploadProgress, loaded: ze.loaded }; ze.lengthComputable && (Ye.total = ze.total), Zt.next(Ye) }; return fe.addEventListener("load", mt), fe.addEventListener("error", An), fe.addEventListener("timeout", An), fe.addEventListener("abort", An), qe.reportProgress && (fe.addEventListener("progress", sr), null !== ke && fe.upload && fe.upload.addEventListener("progress", Fr)), fe.send(ke), Zt.next({ type: tt.Sent }), () => { fe.removeEventListener("error", An), fe.removeEventListener("abort", An), fe.removeEventListener("load", mt), fe.removeEventListener("timeout", An), qe.reportProgress && (fe.removeEventListener("progress", sr), null !== ke && fe.upload && fe.upload.removeEventListener("progress", Fr)), fe.readyState !== fe.DONE && fe.abort() } }) } } return vt.\u0275fac = function (qe) { return new (qe || vt)(m.LFG(i.JF)) }, vt.\u0275prov = m.Yz7({ token: vt, factory: vt.\u0275fac }), vt })(); const ue = new m.OlP("XSRF_ENABLED"), it = "XSRF-TOKEN", lt = new m.OlP("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => it }), Nt = "X-XSRF-TOKEN", gn = new m.OlP("XSRF_HEADER_NAME", { providedIn: "root", factory: () => Nt }); class Hn { } let _r = (() => { class vt { constructor(qe, Zt, fe) { this.doc = qe, this.platform = Zt, this.cookieName = fe, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const qe = this.doc.cookie || ""; return qe !== this.lastCookieString && (this.parseCount++, this.lastToken = (0, i.Mx)(qe, this.cookieName), this.lastCookieString = qe), this.lastToken } } return vt.\u0275fac = function (qe) { return new (qe || vt)(m.LFG(i.K0), m.LFG(m.Lbi), m.LFG(lt)) }, vt.\u0275prov = m.Yz7({ token: vt, factory: vt.\u0275fac }), vt })(); function pn(vt, Le) { const qe = vt.url.toLowerCase(); if (!(0, m.f3M)(ue) || "GET" === vt.method || "HEAD" === vt.method || qe.startsWith("http://") || qe.startsWith("https://")) return Le(vt); const Zt = (0, m.f3M)(Hn).getToken(), fe = (0, m.f3M)(gn); return null != Zt && !vt.headers.has(fe) && (vt = vt.clone({ headers: vt.headers.set(fe, Zt) })), Le(vt) } var yn = (() => ((yn = yn || {})[yn.Interceptors = 0] = "Interceptors", yn[yn.LegacyInterceptors = 1] = "LegacyInterceptors", yn[yn.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", yn[yn.NoXsrfProtection = 3] = "NoXsrfProtection", yn[yn.JsonpSupport = 4] = "JsonpSupport", yn[yn.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", yn))(); function Qn(vt, Le) { return { \u0275kind: vt, \u0275providers: Le } } function ur(...vt) { const Le = [rn, dn, Yt, { provide: Ee, useExisting: Yt }, { provide: _e, useExisting: dn }, { provide: fn, useValue: pn, multi: !0 }, { provide: ue, useValue: !0 }, { provide: Hn, useClass: _r }]; for (const qe of vt) Le.push(...qe.\u0275providers); return (0, m.MR2)(Le) } const Kr = new m.OlP("LEGACY_INTERCEPTOR_FN"); function At({ cookieName: vt, headerName: Le }) { const qe = []; return void 0 !== vt && qe.push({ provide: lt, useValue: vt }), void 0 !== Le && qe.push({ provide: gn, useValue: Le }), Qn(yn.CustomXsrfConfiguration, qe) } let bn = (() => { class vt { } return vt.\u0275fac = function (qe) { return new (qe || vt) }, vt.\u0275mod = m.oAB({ type: vt }), vt.\u0275inj = m.cJS({ providers: [ur(Qn(yn.LegacyInterceptors, [{ provide: Kr, useFactory: It }, { provide: fn, useExisting: Kr, multi: !0 }]), At({ cookieName: it, headerName: Nt }))] }), vt })() }, 4650: (un, Je, L) => { "use strict"; L.d(Je, { $8M: () => Vu, $WT: () => Gi, $Z: () => Ty, AFp: () => ew, ALo: () => bC, AaK: () => Ee, Akn: () => nd, AsE: () => qy, BQk: () => Hy, CHM: () => ll, CRH: () => Ar, CZH: () => O_, CqO: () => g1, D6c: () => nE, DdM: () => vv, Dn7: () => CC, EJc: () => BC, EiD: () => Ih, EpF: () => S0, F$t: () => y1, F4k: () => p1, FYo: () => Uf, FiY: () => vi, G48: () => rg, Gf: () => jb, GfV: () => Xd, GkF: () => D0, Gpc: () => ve, Gre: () => k1, HTZ: () => xb, Hh0: () => Mb, Hsn: () => Hl, IIB: () => x_, Ikx: () => r_, JOm: () => vl, JVY: () => Tt, JZr: () => wt, Jf7: () => oy, KtG: () => qc, L6J: () => Dv, L6k: () => tn, LAX: () => tr, LFG: () => sn, LMc: () => G_, LSH: () => Vc, Lbi: () => ns, Lck: () => uC, MAs: () => h1, MGl: () => qm, MMx: () => gv, MR2: () => Un, MT6: () => Qy, NdJ: () => A0, O4$: () => Ja, OlP: () => Mi, Oqu: () => Zy, P3R: () => Y, PXZ: () => fu, Q2q: () => Ly, Q6J: () => E0, QGY: () => I0, QbO: () => nw, Qsj: () => Em, QtT: () => pb, R0b: () => sd, RDi: () => oc, Rgc: () => Mn, SBq: () => nf, SDv: () => dv, Sil: () => HT, Suo: () => Vo, TTD: () => Is, TgZ: () => By, Tol: () => I1, Udp: () => Lp, VKq: () => Sb, W1O: () => E_, WFA: () => kh, WLB: () => b_, X6Q: () => qC, XFs: () => it, Xpm: () => Br, Xts: () => Vt, Y36: () => qf, YKP: () => da, YNc: () => d1, Yjl: () => va, Yz7: () => Ze, Z0I: () => kt, ZZ4: () => _w, _Bn: () => Jg, _UZ: () => f1, _Vd: () => tf, _c5: () => tD, _uU: () => Bp, aQ5: () => Pe, aQg: () => og, c2e: () => FC, cJS: () => le, cg1: () => Q0, d8E: () => i_, dDg: () => xv, dqk: () => pn, eBb: () => Pn, eFA: () => kv, ekj: () => B0, eoX: () => rw, evT: () => Tm, f3M: () => vt, g9A: () => tw, gM2: () => w_, gxx: () => Wt, h0i: () => Qg, hGG: () => tE, hij: () => jg, i9L: () => ml, iGM: () => qp, ifc: () => sr, ip1: () => RC, jDz: () => __, kEZ: () => Ib, kL8: () => X0, kYT: () => Bi, kcU: () => yi, l5B: () => Ab, lG2: () => ya, lcZ: () => wC, lqb: () => Ul, lri: () => om, mCW: () => su, n5z: () => Qc, n_E: () => bv, oAB: () => Dr, oJD: () => ou, oxw: () => _1, pB0: () => br, pQV: () => hv, q3G: () => ks, q4F: () => Ad, qLn: () => Ah, qOj: () => _0, qZA: () => Vy, qbA: () => tp, qzn: () => ie, rFY: () => Ob, rWj: () => R_, r_U: () => PC, s9C: () => zy, sBO: () => YC, s_b: () => mr, soG: () => k_, tBr: () => ps, tb: () => qs, tp0: () => ee, uIk: () => w0, uOi: () => v, vHH: () => De, vpe: () => gc, wAp: () => Ur, xi3: () => Rb, xp6: () => eh, yDS: () => $d, ynx: () => Uy, z2F: () => Pv, z3N: () => F, zSh: () => Fo, zs3: () => Mh }); var i = L(7579), m = L(727), J = L(9751), ye = L(6451), Ce = L(3099); function we(o) { for (let c in o) if (o[c] === we) return c; throw Error("Could not find renamed property on target object.") } function Te(o, c) { for (const u in c) c.hasOwnProperty(u) && !o.hasOwnProperty(u) && (o[u] = c[u]) } function Ee(o) { if ("string" == typeof o) return o; if (Array.isArray(o)) return "[" + o.map(Ee).join(", ") + "]"; if (null == o) return "" + o; if (o.overriddenName) return `${o.overriddenName}`; if (o.name) return `${o.name}`; const c = o.toString(); if (null == c) return "" + c; const u = c.indexOf("\n"); return -1 === u ? c : c.substring(0, u) } function _e(o, c) { return null == o || "" === o ? null === c ? "" : c : null == c || "" === c ? o : o + " " + c } const ae = we({ __forward_ref__: we }); function ve(o) { return o.__forward_ref__ = ve, o.toString = function () { return Ee(this()) }, o } function xe(o) { return gt(o) ? o() : o } function gt(o) { return "function" == typeof o && o.hasOwnProperty(ae) && o.__forward_ref__ === ve } function Se(o) { return o && !!o.\u0275providers } const wt = "https://g.co/ng/security#xss"; class De extends Error { constructor(c, u) { super(function je(o, c) { return `NG0${Math.abs(o)}${c ? ": " + c.trim() : ""}` }(c, u)), this.code = c } } function _t(o) { return "string" == typeof o ? o : null == o ? "" : String(o) } function Be(o, c) { throw new De(-201, !1) } function It(o, c, u, g) { throw new Error(`ASSERTION ERROR: ${o}` + (null == g ? "" : ` [Expected=> ${u} ${g} ${c} <=Actual]`)) } function Ze(o) { return { token: o.token, providedIn: o.providedIn || null, factory: o.factory, value: void 0 } } function le(o) { return { providers: o.providers || [], imports: o.imports || [] } } function Xe(o) { return an(o, or) || an(o, dn) } function kt(o) { return null !== Xe(o) } function an(o, c) { return o.hasOwnProperty(c) ? o[c] : null } function Jn(o) { return o && (o.hasOwnProperty(Ht) || o.hasOwnProperty(ue)) ? o[Ht] : null } const or = we({ \u0275prov: we }), Ht = we({ \u0275inj: we }), dn = we({ ngInjectableDef: we }), ue = we({ ngInjectorDef: we }); var it = (() => ((it = it || {})[it.Default = 0] = "Default", it[it.Host = 1] = "Host", it[it.Self = 2] = "Self", it[it.SkipSelf = 4] = "SkipSelf", it[it.Optional = 8] = "Optional", it))(); let lt; function gn(o) { const c = lt; return lt = o, c } function Hn(o, c, u) { const g = Xe(o); return g && "root" == g.providedIn ? void 0 === g.value ? g.value = g.factory() : g.value : u & it.Optional ? null : void 0 !== c ? c : void Be(Ee(o)) } const pn = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), ur = {}, dr = "__NG_DI_FLAG__", Kr = "ngTempTokenPath", At = /\n/gm, Ae = "__source"; let Et; function Gt(o) { const c = Et; return Et = o, c } function bn(o, c = it.Default) { if (void 0 === Et) throw new De(-203, !1); return null === Et ? Hn(o, void 0, c) : Et.get(o, c & it.Optional ? null : void 0, c) } function sn(o, c = it.Default) { return (function Nt() { return lt }() || bn)(xe(o), c) } function vt(o, c = it.Default) { return sn(o, Le(c)) } function Le(o) { return typeof o > "u" || "number" == typeof o ? o : 0 | (o.optional && 8) | (o.host && 1) | (o.self && 2) | (o.skipSelf && 4) } function qe(o) { const c = []; for (let u = 0; u < o.length; u++) { const g = xe(o[u]); if (Array.isArray(g)) { if (0 === g.length) throw new De(900, !1); let b, D = it.Default; for (let N = 0; N < g.length; N++) { const U = g[N], j = fe(U); "number" == typeof j ? -1 === j ? b = U.token : D |= j : b = U } c.push(sn(b, D)) } else c.push(sn(g)) } return c } function Zt(o, c) { return o[dr] = c, o.prototype[dr] = c, o } function fe(o) { return o[dr] } function Lt(o) { return { toString: o }.toString() } var mt = (() => ((mt = mt || {})[mt.OnPush = 0] = "OnPush", mt[mt.Default = 1] = "Default", mt))(), sr = (() => { return (o = sr || (sr = {}))[o.Emulated = 0] = "Emulated", o[o.None = 2] = "None", o[o.ShadowDom = 3] = "ShadowDom", sr; var o })(); const Fr = {}, ze = [], Ye = we({ \u0275cmp: we }), Ie = we({ \u0275dir: we }), Ct = we({ \u0275pipe: we }), nn = we({ \u0275mod: we }), xn = we({ \u0275fac: we }), zn = we({ __NG_ELEMENT_ID__: we }); let ti = 0; function Br(o) { return Lt(() => { const u = !0 === o.standalone, g = {}, b = { type: o.type, providersResolver: null, decls: o.decls, vars: o.vars, factory: null, template: o.template || null, consts: o.consts || null, ngContentSelectors: o.ngContentSelectors, hostBindings: o.hostBindings || null, hostVars: o.hostVars || 0, hostAttrs: o.hostAttrs || null, contentQueries: o.contentQueries || null, declaredInputs: g, inputs: null, outputs: null, exportAs: o.exportAs || null, onPush: o.changeDetection === mt.OnPush, directiveDefs: null, pipeDefs: null, standalone: u, dependencies: u && o.dependencies || null, getStandaloneInjector: null, selectors: o.selectors || ze, viewQuery: o.viewQuery || null, features: o.features || null, data: o.data || {}, encapsulation: o.encapsulation || sr.Emulated, id: "c" + ti++, styles: o.styles || ze, _: null, setInput: null, schemas: o.schemas || null, tView: null, findHostDirectiveDefs: null, hostDirectives: null }, D = o.dependencies, N = o.features; return b.inputs = _a(o.inputs, g), b.outputs = _a(o.outputs), N && N.forEach(U => U(b)), b.directiveDefs = D ? () => ("function" == typeof D ? D() : D).map(Ps).filter(vo) : null, b.pipeDefs = D ? () => ("function" == typeof D ? D() : D).map(Ei).filter(vo) : null, b }) } function Ps(o) { return Hr(o) || Ji(o) } function vo(o) { return null !== o } function Dr(o) { return Lt(() => ({ type: o.type, bootstrap: o.bootstrap || ze, declarations: o.declarations || ze, imports: o.imports || ze, exports: o.exports || ze, transitiveCompileScopes: null, schemas: o.schemas || null, id: o.id || null })) } function Bi(o, c) { return Lt(() => { const u = Qi(o, !0); u.declarations = c.declarations || ze, u.imports = c.imports || ze, u.exports = c.exports || ze }) } function _a(o, c) { if (null == o) return Fr; const u = {}; for (const g in o) if (o.hasOwnProperty(g)) { let b = o[g], D = b; Array.isArray(b) && (D = b[1], b = b[0]), u[b] = g, c && (c[b] = D) } return u } const ya = Br; function va(o) { return { type: o.type, name: o.name, factory: null, pure: !1 !== o.pure, standalone: !0 === o.standalone, onDestroy: o.type.prototype.ngOnDestroy || null } } function Hr(o) { return o[Ye] || null } function Ji(o) { return o[Ie] || null } function Ei(o) { return o[Ct] || null } function Gi(o) { const c = Hr(o) || Ji(o) || Ei(o); return null !== c && c.standalone } function Qi(o, c) { const u = o[nn] || null; if (!u && !0 === c) throw new Error(`Type ${Ee(o)} does not have '\u0275mod' property.`); return u } function Ai(o) { return Array.isArray(o) && "object" == typeof o[1] } function Ts(o) { return Array.isArray(o) && !0 === o[1] } function Ds(o) { return 0 != (4 & o.flags) } function gr(o) { return o.componentOffset > -1 } function xl(o) { return 1 == (1 & o.flags) } function us(o) { return null !== o.template } function bo(o) { return 0 != (256 & o[2]) } function Ao(o, c) { return o.hasOwnProperty(xn) ? o[xn] : null } class rs { constructor(c, u, g) { this.previousValue = c, this.currentValue = u, this.firstChange = g } isFirstChange() { return this.firstChange } } function Is() { return Wo } function Wo(o) { return o.type.prototype.ngOnChanges && (o.setInput = fo), Za } function Za() { const o = Pa(this), c = o?.current; if (c) { const u = o.previous; if (u === Fr) o.previous = c; else for (let g in c) u[g] = c[g]; o.current = null, this.ngOnChanges(c) } } function fo(o, c, u, g) { const b = this.declaredInputs[u], D = Pa(o) || function Ks(o, c) { return o[As] = c }(o, { previous: Fr, current: null }), N = D.current || (D.current = {}), U = D.previous, j = U[b]; N[b] = new rs(j && j.currentValue, c, U === Fr), o[g] = c } Is.ngInherit = !0; const As = "__ngSimpleChanges__"; function Pa(o) { return o[As] || null } function ds(o) { for (; Array.isArray(o);)o = o[0]; return o } function Ra(o, c) { return ds(c[o]) } function gi(o, c) { return ds(c[o.index]) } function wa(o, c) { return o.data[c] } function Qs(o, c) { return o[c] } function Zr(o, c) { const u = c[o]; return Ai(u) ? u : u[0] } function xs(o) { return 64 == (64 & o[2]) } function Hi(o, c) { return null == c ? null : o[c] } function qa(o) { o[18] = 0 } function ys(o, c) { o[5] += c; let u = o, g = o[3]; for (; null !== g && (1 === c && 1 === u[5] || -1 === c && 0 === u[5]);)g[5] += c, u = g, g = g[3] } const hr = { lFrame: Ya(null), bindingsEnabled: !0 }; function Rt() { return hr.bindingsEnabled } function Jt() { return hr.lFrame.lView } function zr() { return hr.lFrame.tView } function ll(o) { return hr.lFrame.contextLView = o, o[8] } function qc(o) { return hr.lFrame.contextLView = null, o } function vs() { let o = ql(); for (; null !== o && 64 === o.type;)o = o.parent; return o } function ql() { return hr.lFrame.currentTNode } function cl() { const o = hr.lFrame, c = o.currentTNode; return o.isParent ? c : c.parent } function po(o, c) { const u = hr.lFrame; u.currentTNode = o, u.isParent = c } function Fa() { return hr.lFrame.isParent } function ul() { hr.lFrame.isParent = !1 } function Ms() { const o = hr.lFrame; let c = o.bindingRootIndex; return -1 === c && (c = o.bindingRootIndex = o.tView.bindingStartIndex), c } function hs() { return hr.lFrame.bindingIndex } function hl() { return hr.lFrame.bindingIndex++ } function Co(o) { const c = hr.lFrame, u = c.bindingIndex; return c.bindingIndex = c.bindingIndex + o, u } function Ea(o) { hr.lFrame.inI18n = o } function Jl(o, c) { const u = hr.lFrame; u.bindingIndex = u.bindingRootIndex = o, Ql(c) } function Ql(o) { hr.lFrame.currentDirectiveIndex = o } function No(o) { const c = hr.lFrame.currentDirectiveIndex; return -1 === c ? null : o[c] } function Cc() { return hr.lFrame.currentQueryIndex } function fl(o) { hr.lFrame.currentQueryIndex = o } function mu(o) { const c = o[1]; return 2 === c.type ? c.declTNode : 1 === c.type ? o[6] : null } function Ta(o, c, u) { if (u & it.SkipSelf) { let b = c, D = o; for (; !(b = b.parent, null !== b || u & it.Host || (b = mu(D), null === b || (D = D[15], 10 & b.type)));); if (null === b) return !1; c = b, o = D } const g = hr.lFrame = Ol(); return g.currentTNode = c, g.lView = o, !0 } function Ec(o) { const c = Ol(), u = o[1]; hr.lFrame = c, c.currentTNode = u.firstChild, c.lView = o, c.tView = u, c.contextLView = o, c.bindingIndex = u.bindingStartIndex, c.inI18n = !1 } function Ol() { const o = hr.lFrame, c = null === o ? null : o.child; return null === c ? Ya(o) : c } function Ya(o) { const c = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: o, child: null, inI18n: !1 }; return null !== o && (o.child = c), c } function Tc() { const o = hr.lFrame; return hr.lFrame = o.parent, o.currentTNode = null, o.lView = null, o } const Xl = Tc; function Bd() { const o = Tc(); o.isParent = !0, o.tView = null, o.selectedIndex = -1, o.contextLView = null, o.elementDepthCount = 0, o.currentDirectiveIndex = -1, o.currentNamespace = null, o.bindingRootIndex = -1, o.bindingIndex = -1, o.currentQueryIndex = 0 } function Eo() { return hr.lFrame.selectedIndex } function La(o) { hr.lFrame.selectedIndex = o } function es() { const o = hr.lFrame; return wa(o.tView, o.selectedIndex) } function Ja() { hr.lFrame.currentNamespace = "svg" } function yi() { !function Da() { hr.lFrame.currentNamespace = null }() } function kl(o, c) { for (let u = c.directiveStart, g = c.directiveEnd; u < g; u++) { const D = o.data[u].type.prototype, { ngAfterContentInit: N, ngAfterContentChecked: U, ngAfterViewInit: j, ngAfterViewChecked: ne, ngOnDestroy: pe } = D; N && (o.contentHooks || (o.contentHooks = [])).push(-u, N), U && ((o.contentHooks || (o.contentHooks = [])).push(u, U), (o.contentCheckHooks || (o.contentCheckHooks = [])).push(u, U)), j && (o.viewHooks || (o.viewHooks = [])).push(-u, j), ne && ((o.viewHooks || (o.viewHooks = [])).push(u, ne), (o.viewCheckHooks || (o.viewCheckHooks = [])).push(u, ne)), null != pe && (o.destroyHooks || (o.destroyHooks = [])).push(u, pe) } } function z(o, c, u) { he(o, c, 3, u) } function re(o, c, u, g) { (3 & o[2]) === u && he(o, c, u, g) } function Z(o, c) { let u = o[2]; (3 & u) === c && (u &= 2047, u += 1, o[2] = u) } function he(o, c, u, g) { const D = g ?? -1, N = c.length - 1; let U = 0; for (let j = void 0 !== g ? 65535 & o[18] : 0; j < N; j++)if ("number" == typeof c[j + 1]) { if (U = c[j], null != g && U >= g) break } else c[j] < 0 && (o[18] += 65536), (U < D || -1 == D) && ($e(o, u, c, j), o[18] = (4294901760 & o[18]) + j + 2), j++ } function $e(o, c, u, g) { const b = u[g] < 0, D = u[g + 1], U = o[b ? -u[g] : u[g]]; if (b) { if (o[2] >> 11 < o[18] >> 16 && (3 & o[2]) === c) { o[2] += 2048; try { D.call(U) } finally { } } } else try { D.call(U) } finally { } } class Xt { constructor(c, u, g) { this.factory = c, this.resolving = !1, this.canSeeViewProviders = u, this.injectImpl = g } } function mi(o, c, u) { let g = 0; for (; g < u.length;) { const b = u[g]; if ("number" == typeof b) { if (0 !== b) break; g++; const D = u[g++], N = u[g++], U = u[g++]; o.setAttribute(c, N, U, D) } else { const D = b, N = u[++g]; To(D) ? o.setProperty(c, D, N) : o.setAttribute(c, D, N), g++ } } return g } function bs(o) { return 3 === o || 4 === o || 6 === o } function To(o) { return 64 === o.charCodeAt(0) } function go(o, c) { if (null !== c && 0 !== c.length) if (null === o || 0 === o.length) o = c.slice(); else { let u = -1; for (let g = 0; g < c.length; g++) { const b = c[g]; "number" == typeof b ? u = b : 0 === u || Ba(o, u, b, null, -1 === u || 2 === u ? c[++g] : null) } } return o } function Ba(o, c, u, g, b) { let D = 0, N = o.length; if (-1 === c) N = -1; else for (; D < o.length;) { const U = o[D++]; if ("number" == typeof U) { if (U === c) { N = -1; break } if (U > c) { N = D - 1; break } } } for (; D < o.length;) { const U = o[D]; if ("number" == typeof U) break; if (U === u) { if (null === g) return void (null !== b && (o[D + 1] = b)); if (g === o[D + 1]) return void (o[D + 2] = b) } D++, null !== g && D++, null !== b && D++ } -1 !== N && (o.splice(N, 0, c), D = N + 1), o.splice(D++, 0, u), null !== g && o.splice(D++, 0, g), null !== b && o.splice(D++, 0, b) } function Va(o) { return -1 !== o } function xi(o) { return 32767 & o } function Yc(o, c) { let u = function Dc(o) { return o >> 16 }(o), g = c; for (; u > 0;)g = g[15], u--; return g } let Zo = !0; function qo(o) { const c = Zo; return Zo = o, c } let Rl = 0; const $s = {}; function Bs(o, c) { const u = Xa(o, c); if (-1 !== u) return u; const g = c[1]; g.firstCreatePass && (o.injectorIndex = c.length, Qa(g.data, o), Qa(c, null), Qa(g.blueprint, null)); const b = Kc(o, c), D = o.injectorIndex; if (Va(b)) { const N = xi(b), U = Yc(b, c), j = U[1].data; for (let ne = 0; ne < 8; ne++)c[D + ne] = U[N + ne] | j[N + ne] } return c[D + 8] = b, D } function Qa(o, c) { o.push(0, 0, 0, 0, 0, 0, 0, 0, c) } function Xa(o, c) { return -1 === o.injectorIndex || o.parent && o.parent.injectorIndex === o.injectorIndex || null === c[o.injectorIndex + 8] ? -1 : o.injectorIndex } function Kc(o, c) { if (o.parent && -1 !== o.parent.injectorIndex) return o.parent.injectorIndex; let u = 0, g = null, b = c; for (; null !== b;) { if (g = xc(b), null === g) return -1; if (u++, b = b[15], -1 !== g.injectorIndex) return g.injectorIndex | u << 16 } return -1 } function Sc(o, c, u) { !function Fl(o, c, u) { let g; "string" == typeof u ? g = u.charCodeAt(0) || 0 : u.hasOwnProperty(zn) && (g = u[zn]), null == g && (g = u[zn] = Rl++); const b = 255 & g; c.data[o + (b >> 5)] |= 1 << b }(o, c, u) } function Ll(o, c, u) { if (u & it.Optional || void 0 !== o) return o; Be() } function yu(o, c, u, g) { if (u & it.Optional && void 0 === g && (g = null), !(u & (it.Self | it.Host))) { const b = o[9], D = gn(void 0); try { return b ? b.get(c, g, u & it.Optional) : Hn(c, g, u & it.Optional) } finally { gn(D) } } return Ll(g, 0, u) } function Lu(o, c, u, g = it.Default, b) { if (null !== o) { if (1024 & c[2]) { const N = function ao(o, c, u, g, b) { let D = o, N = c; for (; null !== D && null !== N && 1024 & N[2] && !(256 & N[2]);) { const U = eo(D, N, u, g | it.Self, $s); if (U !== $s) return U; let j = D.parent; if (!j) { const ne = N[21]; if (ne) { const pe = ne.get(u, $s, g); if (pe !== $s) return pe } j = xc(N), N = N[15] } D = j } return b }(o, c, u, g, $s); if (N !== $s) return N } const D = eo(o, c, u, g, $s); if (D !== $s) return D } return yu(c, u, g, b) } function eo(o, c, u, g, b) { const D = function Ac(o) { if ("string" == typeof o) return o.charCodeAt(0) || 0; const c = o.hasOwnProperty(zn) ? o[zn] : void 0; return "number" == typeof c ? c >= 0 ? 255 & c : Bu : c }(u); if ("function" == typeof D) { if (!Ta(c, o, g)) return g & it.Host ? Ll(b, 0, g) : yu(c, u, g, b); try { const N = D(g); if (null != N || g & it.Optional) return N; Be() } finally { Xl() } } else if ("number" == typeof D) { let N = null, U = Xa(o, c), j = -1, ne = g & it.Host ? c[16][6] : null; for ((-1 === U || g & it.SkipSelf) && (j = -1 === U ? Kc(o, c) : c[U + 8], -1 !== j && Yo(g, !1) ? (N = c[1], U = xi(j), c = Yc(j, c)) : U = -1); -1 !== U;) { const pe = c[1]; if (el(D, U, pe.data)) { const He = Ic(U, c, u, N, g, ne); if (He !== $s) return He } j = c[U + 8], -1 !== j && Yo(g, c[1].data[U + 8] === ne) && el(D, U, c) ? (N = pe, U = xi(j), c = Yc(j, c)) : U = -1 } } return b } function Ic(o, c, u, g, b, D) { const N = c[1], U = N.data[o + 8], pe = ra(U, N, u, null == g ? gr(U) && Zo : g != N && 0 != (3 & U.type), b & it.Host && D === U); return null !== pe ? ia(c, N, pe, U) : $s } function ra(o, c, u, g, b) { const D = o.providerIndexes, N = c.data, U = 1048575 & D, j = o.directiveStart, pe = D >> 20, Dt = b ? U + pe : o.directiveEnd; for (let Ut = g ? U : U + pe; Ut < Dt; Ut++) { const mn = N[Ut]; if (Ut < j && u === mn || Ut >= j && mn.type === u) return Ut } if (b) { const Ut = N[j]; if (Ut && us(Ut) && Ut.type === u) return j } return null } function ia(o, c, u, g) { let b = o[u]; const D = c.data; if (function Nn(o) { return o instanceof Xt }(b)) { const N = b; N.resolving && function ct(o, c) { const u = c ? `. Dependency path: ${c.join(" > ")} > ${o}` : ""; throw new De(-200, `Circular dependency in DI detected for ${o}${u}`) }(function Qe(o) { return "function" == typeof o ? o.name || o.toString() : "object" == typeof o && null != o && "function" == typeof o.type ? o.type.name || o.type.toString() : _t(o) }(D[u])); const U = qo(N.canSeeViewProviders); N.resolving = !0; const j = N.injectImpl ? gn(N.injectImpl) : null; Ta(o, g, it.Default); try { b = o[u] = N.factory(void 0, D, o, g), c.firstCreatePass && u >= g.directiveStart && function _u(o, c, u) { const { ngOnChanges: g, ngOnInit: b, ngDoCheck: D } = c.type.prototype; if (g) { const N = Wo(c); (u.preOrderHooks || (u.preOrderHooks = [])).push(o, N), (u.preOrderCheckHooks || (u.preOrderCheckHooks = [])).push(o, N) } b && (u.preOrderHooks || (u.preOrderHooks = [])).push(0 - o, b), D && ((u.preOrderHooks || (u.preOrderHooks = [])).push(o, D), (u.preOrderCheckHooks || (u.preOrderCheckHooks = [])).push(o, D)) }(u, D[u], c) } finally { null !== j && gn(j), qo(U), N.resolving = !1, Xl() } } return b } function el(o, c, u) { return !!(u[c + (o >> 5)] & 1 << o) } function Yo(o, c) { return !(o & it.Self || o & it.Host && c) } class Ko { constructor(c, u) { this._tNode = c, this._lView = u } get(c, u, g) { return Lu(this._tNode, this._lView, c, Le(g), u) } } function Bu() { return new Ko(vs(), Jt()) } function Qc(o) { return Lt(() => { const c = o.prototype.constructor, u = c[xn] || Sa(c), g = Object.prototype; let b = Object.getPrototypeOf(o.prototype).constructor; for (; b && b !== g;) { const D = b[xn] || Sa(b); if (D && D !== u) return D; b = Object.getPrototypeOf(b) } return D => new D }) } function Sa(o) { return gt(o) ? () => { const c = Sa(xe(o)); return c && c() } : Ao(o) } function xc(o) { const c = o[1], u = c.type; return 2 === u ? c.declTNode : 1 === u ? o[6] : null } function Vu(o) { return function Jc(o, c) { if ("class" === c) return o.classes; if ("style" === c) return o.styles; const u = o.attrs; if (u) { const g = u.length; let b = 0; for (; b < g;) { const D = u[b]; if (bs(D)) break; if (0 === D) b += 2; else if ("number" == typeof D) for (b++; b < g && "string" == typeof u[b];)b++; else { if (D === c) return u[b + 1]; b += 2 } } } return null }(vs(), o) } const Vs = "__parameters__", ii = "__prop__metadata__"; function ud(o) { return function (...u) { if (o) { const g = o(...u); for (const b in g) this[b] = g[b] } } } function vu(o, c, u) { return Lt(() => { const g = ud(c); function b(...D) { if (this instanceof b) return g.apply(this, D), this; const N = new b(...D); return U.annotation = N, U; function U(j, ne, pe) { const He = j.hasOwnProperty(Vs) ? j[Vs] : Object.defineProperty(j, Vs, { value: [] })[Vs]; for (; He.length <= pe;)He.push(null); return (He[pe] = He[pe] || []).push(N), j } } return u && (b.prototype = Object.create(u.prototype)), b.prototype.ngMetadataName = o, b.annotationCls = b, b }) } function ci(o, c, u, g) { return Lt(() => { const b = ud(c); function D(...N) { if (this instanceof D) return b.apply(this, N), this; const U = new D(...N); return function j(ne, pe) { const He = ne.constructor, Dt = He.hasOwnProperty(ii) ? He[ii] : Object.defineProperty(He, ii, { value: {} })[ii]; Dt[pe] = Dt.hasOwnProperty(pe) && Dt[pe] || [], Dt[pe].unshift(U), g && g(ne, pe, ...N) } } return u && (D.prototype = Object.create(u.prototype)), D.prototype.ngMetadataName = o, D.annotationCls = D, D }) } class Mi { constructor(c, u) { this._desc = c, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof u ? this.__NG_ELEMENT_ID__ = u : void 0 !== u && (this.\u0275prov = Ze({ token: this, providedIn: u.providedIn || "root", factory: u.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } class cn { } const Pe = ci("ContentChild", (o, c = {}) => ({ selector: o, first: !0, isViewQuery: !1, descendants: !0, ...c }), cn), ml = ci("ViewChild", (o, c) => ({ selector: o, first: !0, isViewQuery: !0, descendants: !0, ...c }), cn); function X(o, c) { o.forEach(u => Array.isArray(u) ? X(u, c) : c(u)) } function ce(o, c, u) { c >= o.length ? o.push(u) : o.splice(c, 0, u) } function be(o, c) { return c >= o.length - 1 ? o.pop() : o.splice(c, 1)[0] } function St(o, c) { const u = []; for (let g = 0; g < o; g++)u.push(c); return u } function Gr(o, c, u) { let g = $i(o, c); return g >= 0 ? o[1 | g] = u : (g = ~g, function Vn(o, c, u, g) { let b = o.length; if (b == c) o.push(u, g); else if (1 === b) o.push(g, o[0]), o[0] = u; else { for (b--, o.push(o[b - 1], o[b]); b > c;)o[b] = o[b - 2], b--; o[c] = u, o[c + 1] = g } }(o, g, c, u)), g } function Sr(o, c) { const u = $i(o, c); if (u >= 0) return o[1 | u] } function $i(o, c) { return function sa(o, c, u) { let g = 0, b = o.length >> u; for (; b !== g;) { const D = g + (b - g >> 1), N = o[D << u]; if (c === N) return D << u; N > c ? b = D : g = D + 1 } return ~(b << u) }(o, c, 1) } const ps = Zt(vu("Inject", o => ({ token: o })), -1), vi = Zt(vu("Optional"), 8), ee = Zt(vu("SkipSelf"), 4); var vl = (() => ((vl = vl || {})[vl.Important = 1] = "Important", vl[vl.DashCase = 2] = "DashCase", vl))(); const ph = /^>|^->|<!--|-->|--!>|<!-$/g, Gh = /(<|>)/; const gh = new Map; let Hd = 0; const hd = "__ngContext__"; function Xo(o, c) { Ai(c) ? (o[hd] = c[20], function tu(o) { gh.set(o[20], o) }(c)) : o[hd] = c } let yh; function $h(o, c) { return yh(o, c) } function Gu(o) { const c = o[3]; return Ts(c) ? c[3] : c } function fd(o) { return Oi(o[13]) } function Zi(o) { return Oi(o[4]) } function Oi(o) { for (; null !== o && !Ts(o);)o = o[4]; return o } function Qr(o, c, u, g, b) { if (null != g) { let D, N = !1; Ts(g) ? D = g : Ai(g) && (N = !0, g = g[0]); const U = ds(g); 0 === o && null !== u ? null == b ? gd(c, u, U) : rl(c, u, U, b || null, !0) : 1 === o && null !== u ? rl(c, u, U, b || null, !0) : 2 === o ? to(c, U, N) : 3 === o && c.destroyNode(U), null != D && function wh(o, c, u, g, b) { const D = u[7]; D !== ds(u) && Qr(c, o, g, D, b); for (let U = 10; U < u.length; U++) { const j = u[U]; Ma(j[1], j, o, c, g, D) } }(c, o, D, u, b) } } function rc(o, c) { return o.createText(c) } function ts(o, c, u) { o.setValue(c, u) } function ic(o, c) { return o.createComment(function Ud(o) { return o.replace(ph, c => c.replace(Gh, "\u200b$1\u200b")) }(c)) } function wu(o, c, u) { return o.createElement(c, u) } function pd(o, c) { const u = o[9], g = u.indexOf(c), b = c[3]; 512 & c[2] && (c[2] &= -513, ys(b, -1)), u.splice(g, 1) } function Ua(o, c) { if (o.length <= 10) return; const u = 10 + c, g = o[u]; if (g) { const b = g[17]; null !== b && b !== o && pd(b, g), c > 0 && (o[u - 1][4] = g[4]); const D = be(o, 10 + c); !function Cu(o, c) { Ma(o, c, c[11], 2, null, null), c[0] = null, c[6] = null }(g[1], g); const N = D[19]; null !== N && N.detachView(D[1]), g[3] = null, g[4] = null, g[2] &= -65 } return g } function Zh(o, c) { if (!(128 & c[2])) { const u = c[11]; u.destroyNode && Ma(o, c, u, 3, null, null), function Xr(o) { let c = o[13]; if (!c) return ru(o[1], o); for (; c;) { let u = null; if (Ai(c)) u = c[13]; else { const g = c[10]; g && (u = g) } if (!u) { for (; c && !c[4] && c !== o;)Ai(c) && ru(c[1], c), c = c[3]; null === c && (c = o), Ai(c) && ru(c[1], c), u = c && c[4] } c = u } }(c) } } function ru(o, c) { if (!(128 & c[2])) { c[2] &= -65, c[2] |= 128, function vh(o, c) { let u; if (null != o && null != (u = o.destroyHooks)) for (let g = 0; g < u.length; g += 2) { const b = c[u[g]]; if (!(b instanceof Xt)) { const D = u[g + 1]; if (Array.isArray(D)) for (let N = 0; N < D.length; N += 2) { const U = b[D[N]], j = D[N + 1]; try { j.call(U) } finally { } } else try { D.call(b) } finally { } } } }(o, c), function qh(o, c) { const u = o.cleanup, g = c[7]; let b = -1; if (null !== u) for (let D = 0; D < u.length - 1; D += 2)if ("string" == typeof u[D]) { const N = u[D + 3]; N >= 0 ? g[b = N]() : g[b = -N].unsubscribe(), D += 2 } else { const N = g[b = u[D + 1]]; u[D].call(N) } if (null !== g) { for (let D = b + 1; D < g.length; D++)(0, g[D])(); c[7] = null } }(o, c), 1 === c[1].type && c[11].destroy(); const u = c[17]; if (null !== u && Ts(c[3])) { u !== c[3] && pd(u, c); const g = c[19]; null !== g && g.detachView(o) } !function Mf(o) { gh.delete(o[20]) }(c) } } function iu(o, c, u) { return bh(o, c.parent, u) } function bh(o, c, u) { let g = c; for (; null !== g && 40 & g.type;)g = (c = g).parent; if (null === g) return u[0]; { const { componentOffset: b } = g; if (b > -1) { const { encapsulation: D } = o.data[g.directiveStart + b]; if (D === sr.None || D === sr.Emulated) return null } return gi(g, u) } } function rl(o, c, u, g, b) { o.insertBefore(c, u, g, b) } function gd(o, c, u) { o.appendChild(c, u) } function kf(o, c, u, g, b) { null !== g ? rl(o, c, u, g, b) : gd(o, c, u) } function Wu(o, c) { return o.parentNode(c) } function sc(o, c, u) { return Zu(o, c, u) } function si(o, c, u) { return 40 & o.type ? gi(o, u) : null } let Rc, bd, wd, il, Zu = si; function _d(o, c) { Zu = o, Rc = c } function Po(o, c, u, g) { const b = iu(o, g, c), D = c[11], U = sc(g.parent || c[6], g, c); if (null != b) if (Array.isArray(u)) for (let j = 0; j < u.length; j++)kf(D, b, u[j], U, !1); else kf(D, b, u, U, !1); void 0 !== Rc && Rc(D, g, c, u, b) } function Eu(o, c) { if (null !== c) { const u = c.type; if (3 & u) return gi(c, o); if (4 & u) return Ro(-1, o[c.index]); if (8 & u) { const g = c.child; if (null !== g) return Eu(o, g); { const b = o[c.index]; return Ts(b) ? Ro(-1, b) : ds(b) } } if (32 & u) return $h(c, o)() || ds(o[c.index]); { const g = wl(o, c); return null !== g ? Array.isArray(g) ? g[0] : Eu(Gu(o[16]), g) : Eu(o, c.next) } } return null } function wl(o, c) { return null !== c ? o[16][6].projection[c.projection] : null } function Ro(o, c) { const u = 10 + o + 1; if (u < c.length) { const g = c[u], b = g[1].firstChild; if (null !== b) return Eu(g, b) } return c[7] } function to(o, c, u) { const g = Wu(o, c); g && function Yh(o, c, u, g) { o.removeChild(c, u, g) }(o, g, c, u) } function yd(o, c, u, g, b, D, N) { for (; null != u;) { const U = g[u.index], j = u.type; if (N && 0 === c && (U && Xo(ds(U), g), u.flags |= 2), 32 != (32 & u.flags)) if (8 & j) yd(o, c, u.child, g, b, D, !1), Qr(c, o, b, U, D); else if (32 & j) { const ne = $h(u, g); let pe; for (; pe = ne();)Qr(c, o, b, pe, D); Qr(c, o, b, U, D) } else 16 & j ? jd(o, c, g, u, b, D) : Qr(c, o, b, U, D); u = N ? u.projectionNext : u.next } } function Ma(o, c, u, g, b, D) { yd(u, g, o.firstChild, c, b, D, !1) } function jd(o, c, u, g, b, D) { const N = u[16], j = N[6].projection[g.projection]; if (Array.isArray(j)) for (let ne = 0; ne < j.length; ne++)Qr(c, o, b, j[ne], D); else yd(o, c, j, N[3], b, D, !0) } function El(o, c, u) { "" === u ? o.removeAttribute(c, "class") : o.setAttribute(c, "class", u) } function vd(o, c, u) { const { mergedAttrs: g, classes: b, styles: D } = u; null !== g && mi(o, c, g), null !== b && El(o, c, b), null !== D && function Kh(o, c, u) { o.setAttribute(c, "style", u) }(o, c, D) } function qu(o) { return function Pf() { if (void 0 === bd && (bd = null, pn.trustedTypes)) try { bd = pn.trustedTypes.createPolicy("angular", { createHTML: o => o, createScript: o => o, createScriptURL: o => o }) } catch { } return bd }()?.createHTML(o) || o } function $d(o, c, u) { const g = Jt(), b = es(), D = gi(b, g); if (2 === b.type && "iframe" === c.toLowerCase()) { const N = D; throw N.src = "", N.srcdoc = qu(""), to(g[11], N), new De(-910, !1) } return o } function oc(o) { wd = o } function Tl() { return void 0 !== wd ? wd : typeof document < "u" ? document : void 0 } function ac() { if (void 0 === il && (il = null, pn.trustedTypes)) try { il = pn.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: o => o, createScript: o => o, createScriptURL: o => o }) } catch { } return il } function ei(o) { return ac()?.createHTML(o) || o } function Yu(o) { return ac()?.createScriptURL(o) || o } class Du { constructor(c) { this.changingThisBreaksApplicationSecurity = c } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${wt})` } } class Zs extends Du { getTypeName() { return "HTML" } } class Wd extends Du { getTypeName() { return "Style" } } class O extends Du { getTypeName() { return "Script" } } class C extends Du { getTypeName() { return "URL" } } class S extends Du { getTypeName() { return "ResourceURL" } } function F(o) { return o instanceof Du ? o.changingThisBreaksApplicationSecurity : o } function ie(o, c) { const u = function ge(o) { return o instanceof Du && o.getTypeName() || null }(o); if (null != u && u !== c) { if ("ResourceURL" === u && "URL" === c) return !0; throw new Error(`Required a safe ${c}, got a ${u} (see ${wt})`) } return u === c } function Tt(o) { return new Zs(o) } function tn(o) { return new Wd(o) } function Pn(o) { return new O(o) } function tr(o) { return new C(o) } function br(o) { return new S(o) } function yr(o) { const c = new Dl(o); return function Ku() { try { return !!(new window.DOMParser).parseFromString(qu(""), "text/html") } catch { return !1 } }() ? new Ni(c) : c } class Ni { constructor(c) { this.inertDocumentHelper = c } getInertBodyElement(c) { c = "<body><remove></remove>" + c; try { const u = (new window.DOMParser).parseFromString(qu(c), "text/html").body; return null === u ? this.inertDocumentHelper.getInertBodyElement(c) : (u.removeChild(u.firstChild), u) } catch { return null } } } class Dl { constructor(c) { if (this.defaultDoc = c, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const u = this.inertDocument.createElement("html"); this.inertDocument.appendChild(u); const g = this.inertDocument.createElement("body"); u.appendChild(g) } } getInertBodyElement(c) { const u = this.inertDocument.createElement("template"); if ("content" in u) return u.innerHTML = qu(c), u; const g = this.inertDocument.createElement("body"); return g.innerHTML = qu(c), this.defaultDoc.documentMode && this.stripCustomNsAttrs(g), g } stripCustomNsAttrs(c) { const u = c.attributes; for (let b = u.length - 1; 0 < b; b--) { const N = u.item(b).name; ("xmlns:ns1" === N || 0 === N.indexOf("ns1:")) && c.removeAttribute(N) } let g = c.firstChild; for (; g;)g.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(g), g = g.nextSibling } } const Lf = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi; function su(o) { return (o = String(o)).match(Lf) ? o : "unsafe:" + o } function Fc(o) { const c = {}; for (const u of o.split(",")) c[u] = !0; return c } function lc(...o) { const c = {}; for (const u of o) for (const g in u) u.hasOwnProperty(g) && (c[g] = !0); return c } const Su = Fc("area,br,col,hr,img,wbr"), Eh = Fc("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Lc = Fc("rp,rt"), Cd = lc(Su, lc(Eh, Fc("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), lc(Lc, Fc("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), lc(Lc, Eh)), Ed = Fc("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), wg = lc(Ed, Fc("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Fc("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), Qu = Fc("script,style,template"); class Xu { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(c) { let u = c.firstChild, g = !0; for (; u;)if (u.nodeType === Node.ELEMENT_NODE ? g = this.startElement(u) : u.nodeType === Node.TEXT_NODE ? this.chars(u.nodeValue) : this.sanitizedSomething = !0, g && u.firstChild) u = u.firstChild; else for (; u;) { u.nodeType === Node.ELEMENT_NODE && this.endElement(u); let b = this.checkClobberedElement(u, u.nextSibling); if (b) { u = b; break } u = this.checkClobberedElement(u, u.parentNode) } return this.buf.join("") } startElement(c) { const u = c.nodeName.toLowerCase(); if (!Cd.hasOwnProperty(u)) return this.sanitizedSomething = !0, !Qu.hasOwnProperty(u); this.buf.push("<"), this.buf.push(u); const g = c.attributes; for (let b = 0; b < g.length; b++) { const D = g.item(b), N = D.name, U = N.toLowerCase(); if (!wg.hasOwnProperty(U)) { this.sanitizedSomething = !0; continue } let j = D.value; Ed[U] && (j = su(j)), this.buf.push(" ", N, '="', Bf(j), '"') } return this.buf.push(">"), !0 } endElement(c) { const u = c.nodeName.toLowerCase(); Cd.hasOwnProperty(u) && !Su.hasOwnProperty(u) && (this.buf.push("</"), this.buf.push(u), this.buf.push(">")) } chars(c) { this.buf.push(Bf(c)) } checkClobberedElement(c, u) { if (u && (c.compareDocumentPosition(u) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${c.outerHTML}`); return u } } const Sh = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Bc = /([^\#-~ |!])/g; function Bf(o) { return o.replace(/&/g, "&amp;").replace(Sh, function (c) { return "&#" + (1024 * (c.charCodeAt(0) - 55296) + (c.charCodeAt(1) - 56320) + 65536) + ";" }).replace(Bc, function (c) { return "&#" + c.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Td; function Ih(o, c) { let u = null; try { Td = Td || yr(o); let g = c ? String(c) : ""; u = Td.getInertBodyElement(g); let b = 5, D = g; do { if (0 === b) throw new Error("Failed to sanitize html because the input is unstable"); b--, g = D, D = u.innerHTML, u = Td.getInertBodyElement(g) } while (g !== D); return qu((new Xu).sanitizeChildren(Zd(u) || u)) } finally { if (u) { const g = Zd(u) || u; for (; g.firstChild;)g.removeChild(g.firstChild) } } } function Zd(o) { return "content" in o && function qd(o) { return o.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === o.nodeName }(o) ? o.content : null } var ks = (() => ((ks = ks || {})[ks.NONE = 0] = "NONE", ks[ks.HTML = 1] = "HTML", ks[ks.STYLE = 2] = "STYLE", ks[ks.SCRIPT = 3] = "SCRIPT", ks[ks.URL = 4] = "URL", ks[ks.RESOURCE_URL = 5] = "RESOURCE_URL", ks))(); function ou(o) { const c = yt(); return c ? ei(c.sanitize(ks.HTML, o) || "") : ie(o, "HTML") ? ei(F(o)) : Ih(Tl(), _t(o)) } function Vc(o) { const c = yt(); return c ? c.sanitize(ks.URL, o) || "" : ie(o, "URL") ? F(o) : su(_t(o)) } function v(o) { const c = yt(); if (c) return Yu(c.sanitize(ks.RESOURCE_URL, o) || ""); if (ie(o, "ResourceURL")) return Yu(F(o)); throw new De(904, !1) } function Y(o, c, u) { return function P(o, c) { return "src" === c && ("embed" === o || "frame" === o || "iframe" === o || "media" === o || "script" === o) || "href" === c && ("base" === o || "link" === o) ? v : Vc }(c, u)(o) } function yt() { const o = Jt(); return o && o[12] } const Vt = new Mi("ENVIRONMENT_INITIALIZER"), Wt = new Mi("INJECTOR", -1), vn = new Mi("INJECTOR_DEF_TYPES"); class In { get(c, u = ur) { if (u === ur) { const g = new Error(`NullInjectorError: No provider for ${Ee(c)}!`); throw g.name = "NullInjectorError", g } return u } } function Un(o) { return { \u0275providers: o } } function bi(...o) { return { \u0275providers: Cr(0, o), \u0275fromNgModule: !0 } } function Cr(o, ...c) { const u = [], g = new Set; let b; return X(c, D => { const N = D; oi(N, u, [], g) && (b || (b = []), b.push(N)) }), void 0 !== b && qr(b, u), u } function qr(o, c) { for (let u = 0; u < o.length; u++) { const { providers: b } = o[u]; qi(b, D => { c.push(D) }) } } function oi(o, c, u, g) { if (!(o = xe(o))) return !1; let b = null, D = Jn(o); const N = !D && Hr(o); if (D || N) { if (N && !N.standalone) return !1; b = o } else { const j = o.ngModule; if (D = Jn(j), !D) return !1; b = j } const U = g.has(b); if (N) { if (U) return !1; if (g.add(b), N.dependencies) { const j = "function" == typeof N.dependencies ? N.dependencies() : N.dependencies; for (const ne of j) oi(ne, c, u, g) } } else { if (!D) return !1; { if (null != D.imports && !U) { let ne; g.add(b); try { X(D.imports, pe => { oi(pe, c, u, g) && (ne || (ne = []), ne.push(pe)) }) } finally { } void 0 !== ne && qr(ne, c) } if (!U) { const ne = Ao(b) || (() => new b); c.push({ provide: b, useFactory: ne, deps: ze }, { provide: vn, useValue: b, multi: !0 }, { provide: Vt, useValue: () => sn(b), multi: !0 }) } const j = D.providers; null == j || U || qi(j, pe => { c.push(pe) }) } } return b !== o && void 0 !== o.providers } function qi(o, c) { for (let u of o) Se(u) && (u = u.\u0275providers), Array.isArray(u) ? qi(u, c) : c(u) } const Ri = we({ provide: String, useValue: we }); function di(o) { return null !== o && "object" == typeof o && Ri in o } function Yi(o) { return "function" == typeof o } const Fo = new Mi("Set Injector scope."), co = {}, au = {}; let Ha; function Iu() { return void 0 === Ha && (Ha = new In), Ha } class Ul { } class Sl extends Ul { get destroyed() { return this._destroyed } constructor(c, u, g, b) { super(), this.parent = u, this.source = g, this.scopes = b, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Au(c, N => this.processProvider(N)), this.records.set(Wt, Dd(void 0, this)), b.has("environment") && this.records.set(Ul, Dd(void 0, this)); const D = this.records.get(Fo); null != D && "string" == typeof D.value && this.scopes.add(D.value), this.injectorDefTypes = new Set(this.get(vn.multi, ze, it.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const c of this._ngOnDestroyHooks) c.ngOnDestroy(); for (const c of this._onDestroyHooks) c() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(c) { this._onDestroyHooks.push(c) } runInContext(c) { this.assertNotDestroyed(); const u = Gt(this), g = gn(void 0); try { return c() } finally { Gt(u), gn(g) } } get(c, u = ur, g = it.Default) { this.assertNotDestroyed(), g = Le(g); const b = Gt(this), D = gn(void 0); try { if (!(g & it.SkipSelf)) { let U = this.records.get(c); if (void 0 === U) { const j = function Sd(o) { return "function" == typeof o || "object" == typeof o && o instanceof Mi }(c) && Xe(c); U = j && this.injectableDefInScope(j) ? Dd(cc(c), co) : null, this.records.set(c, U) } if (null != U) return this.hydrate(c, U) } return (g & it.Self ? Iu() : this.parent).get(c, u = g & it.Optional && u === ur ? null : u) } catch (N) { if ("NullInjectorError" === N.name) { if ((N[Kr] = N[Kr] || []).unshift(Ee(c)), b) throw N; return function ke(o, c, u, g) { const b = o[Kr]; throw c[Ae] && b.unshift(c[Ae]), o.message = function et(o, c, u, g = null) { o = o && "\n" === o.charAt(0) && "\u0275" == o.charAt(1) ? o.slice(2) : o; let b = Ee(c); if (Array.isArray(c)) b = c.map(Ee).join(" -> "); else if ("object" == typeof c) { let D = []; for (let N in c) if (c.hasOwnProperty(N)) { let U = c[N]; D.push(N + ":" + ("string" == typeof U ? JSON.stringify(U) : Ee(U))) } b = `{${D.join(", ")}}` } return `${u}${g ? "(" + g + ")" : ""}[${b}]: ${o.replace(At, "\n  ")}` }("\n" + o.message, b, u, g), o.ngTokenPath = b, o[Kr] = null, o }(N, c, "R3InjectorError", this.source) } throw N } finally { gn(D), Gt(b) } } resolveInjectorInitializers() { const c = Gt(this), u = gn(void 0); try { const g = this.get(Vt.multi, ze, it.Self); for (const b of g) b() } finally { Gt(c), gn(u) } } toString() { const c = [], u = this.records; for (const g of u.keys()) c.push(Ee(g)); return `R3Injector[${c.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new De(205, !1) } processProvider(c) { let u = Yi(c = xe(c)) ? c : xe(c && c.provide); const g = function Kd(o) { return di(o) ? Dd(void 0, o.useValue) : Dd(Jh(o), co) }(c); if (Yi(c) || !0 !== c.multi) this.records.get(u); else { let b = this.records.get(u); b || (b = Dd(void 0, co, !0), b.factory = () => qe(b.multi), this.records.set(u, b)), u = c, b.multi.push(c) } this.records.set(u, g) } hydrate(c, u) { return u.value === co && (u.value = au, u.value = u.factory()), "object" == typeof u.value && u.value && function Jd(o) { return null !== o && "object" == typeof o && "function" == typeof o.ngOnDestroy }(u.value) && this._ngOnDestroyHooks.add(u.value), u.value } injectableDefInScope(c) { if (!c.providedIn) return !1; const u = xe(c.providedIn); return "string" == typeof u ? "any" === u || this.scopes.has(u) : this.injectorDefTypes.has(u) } } function cc(o) { const c = Xe(o), u = null !== c ? c.factory : Ao(o); if (null !== u) return u; if (o instanceof Mi) throw new De(204, !1); if (o instanceof Function) return function Vf(o) { const c = o.length; if (c > 0) throw St(c, "?"), new De(204, !1); const u = function jt(o) { const c = o && (o[or] || o[dn]); if (c) { const u = function wn(o) { if (o.hasOwnProperty("name")) return o.name; const c = ("" + o).match(/^function\s*([^\s(]+)/); return null === c ? "" : c[1] }(o); return console.warn(`DEPRECATED: DI is instantiating a token "${u}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${u}" class.`), c } return null }(o); return null !== u ? () => u.factory(o) : () => new o }(o); throw new De(204, !1) } function Jh(o, c, u) { let g; if (Yi(o)) { const b = xe(o); return Ao(b) || cc(b) } if (di(o)) g = () => xe(o.useValue); else if (function gs(o) { return !(!o || !o.useFactory) }(o)) g = () => o.useFactory(...qe(o.deps || [])); else if (function zi(o) { return !(!o || !o.useExisting) }(o)) g = () => sn(xe(o.useExisting)); else { const b = xe(o && (o.useClass || o.provide)); if (!function Qh(o) { return !!o.deps }(o)) return Ao(b) || cc(b); g = () => new b(...qe(o.deps)) } return g } function Dd(o, c, u = !1) { return { factory: o, value: c, multi: u ? [] : void 0 } } function Au(o, c) { for (const u of o) Array.isArray(u) ? Au(u, c) : u && Se(u) ? Au(u.\u0275providers, c) : c(u) } class Qd { } class Xh { } class bp { resolveComponentFactory(c) { throw function ed(o) { const c = Error(`No component factory found for ${Ee(o)}. Did you add it to @NgModule.entryComponents?`); return c.ngComponent = o, c }(c) } } let tf = (() => { class o { } return o.NULL = new bp, o })(); function wp() { return Id(vs(), Jt()) } function Id(o, c) { return new nf(gi(o, c)) } let nf = (() => { class o { constructor(u) { this.nativeElement = u } } return o.__NG_ELEMENT_ID__ = wp, o })(); function Cg(o) { return o instanceof nf ? o.nativeElement : o } class Uf { } let Em = (() => { class o { } return o.__NG_ELEMENT_ID__ = () => function Eg() { const o = Jt(), u = Zr(vs().index, o); return (Ai(u) ? u : o)[11] }(), o })(), xu = (() => { class o { } return o.\u0275prov = Ze({ token: o, providedIn: "root", factory: () => null }), o })(); class Xd { constructor(c) { this.full = c, this.major = c.split(".")[0], this.minor = c.split(".")[1], this.patch = c.split(".").slice(2).join(".") } } const Ad = new Xd("15.1.1"), Hf = {}; function Gf(o) { return o.ngOriginalError } class Ah { constructor() { this._console = console } handleError(c) { const u = this._findOriginalError(c); this._console.error("ERROR", c), u && this._console.error("ORIGINAL ERROR", u) } _findOriginalError(c) { let u = c && Gf(c); for (; u && Gf(u);)u = Gf(u); return u || null } } function oy(o) { return o.ownerDocument.defaultView } function Tm(o) { return o.ownerDocument } function xd(o) { return o instanceof Function ? o() : o } function cy(o, c, u) { let g = o.length; for (; ;) { const b = o.indexOf(c, u); if (-1 === b) return b; if (0 === b || o.charCodeAt(b - 1) <= 32) { const D = c.length; if (b + D === g || o.charCodeAt(b + D) <= 32) return b } u = b + 1 } } const Dg = "ng-template"; function uy(o, c, u) { let g = 0; for (; g < o.length;) { let b = o[g++]; if (u && "class" === b) { if (b = o[g], -1 !== cy(b.toLowerCase(), c, 0)) return !0 } else if (1 === b) { for (; g < o.length && "string" == typeof (b = o[g++]);)if (b.toLowerCase() === c) return !0; return !1 } } return !1 } function dy(o) { return 4 === o.type && o.value !== Dg } function a0(o, c, u) { return c === (4 !== o.type || u ? o.value : Dg) } function jf(o, c, u) { let g = 4; const b = o.attrs || [], D = function Md(o) { for (let c = 0; c < o.length; c++)if (bs(o[c])) return c; return o.length }(b); let N = !1; for (let U = 0; U < c.length; U++) { const j = c[U]; if ("number" != typeof j) { if (!N) if (4 & g) { if (g = 2 | 1 & g, "" !== j && !a0(o, j, u) || "" === j && 1 === c.length) { if (Lo(g)) return !1; N = !0 } } else { const ne = 8 & g ? j : c[++U]; if (8 & g && null !== o.attrs) { if (!uy(o.attrs, ne, u)) { if (Lo(g)) return !1; N = !0 } continue } const He = hy(8 & g ? "class" : j, b, dy(o), u); if (-1 === He) { if (Lo(g)) return !1; N = !0; continue } if ("" !== ne) { let Dt; Dt = He > D ? "" : b[He + 1].toLowerCase(); const Ut = 8 & g ? Dt : null; if (Ut && -1 !== cy(Ut, ne, 0) || 2 & g && ne !== Dt) { if (Lo(g)) return !1; N = !0 } } } } else { if (!N && !Lo(g) && !Lo(j)) return !1; if (N && Lo(j)) continue; N = !1, g = j | 1 & g } } return Lo(g) || N } function Lo(o) { return 0 == (1 & o) } function hy(o, c, u, g) { if (null === c) return -1; let b = 0; if (g || !u) { let D = !1; for (; b < c.length;) { const N = c[b]; if (N === o) return b; if (3 === N || 6 === N) D = !0; else { if (1 === N || 2 === N) { let U = c[++b]; for (; "string" == typeof U;)U = c[++b]; continue } if (4 === N) break; if (0 === N) { b += 4; continue } } b += D ? 1 : 2 } return -1 } return function xh(o, c) { let u = o.indexOf(4); if (u > -1) for (u++; u < o.length;) { const g = o[u]; if ("number" == typeof g) return -1; if (g === c) return u; u++ } return -1 }(c, o) } function Sm(o, c, u = !1) { for (let g = 0; g < c.length; g++)if (jf(o, c[g], u)) return !0; return !1 } function l0(o, c) { e: for (let u = 0; u < c.length; u++) { const g = c[u]; if (o.length === g.length) { for (let b = 0; b < o.length; b++)if (o[b] !== g[b]) continue e; return !0 } } return !1 } function Sg(o, c) { return o ? ":not(" + c.trim() + ")" : c } function fy(o) { let c = o[0], u = 1, g = 2, b = "", D = !1; for (; u < o.length;) { let N = o[u]; if ("string" == typeof N) if (2 & g) { const U = o[++u]; b += "[" + N + (U.length > 0 ? '="' + U + '"' : "") + "]" } else 8 & g ? b += "." + N : 4 & g && (b += " " + N); else "" !== b && !Lo(N) && (c += Sg(D, b), b = ""), g = N, D = D || !Lo(g); u++ } return "" !== b && (c += Sg(D, b)), c } const hi = {}; function eh(o) { $f(zr(), Jt(), Eo() + o, !1) } function $f(o, c, u, g) { if (!g) if (3 == (3 & c[2])) { const D = o.preOrderCheckHooks; null !== D && z(c, D, u) } else { const D = o.preOrderHooks; null !== D && re(c, D, 0, u) } La(u) } function af(o, c = null, u = null, g) { const b = xm(o, c, u, g); return b.resolveInjectorInitializers(), b } function xm(o, c = null, u = null, g, b = new Set) { const D = [u || ze, bi(o)]; return g = g || ("object" == typeof o ? void 0 : Ee(o)), new Sl(D, c || Iu(), g || null, b) } let Mh = (() => { class o { static create(u, g) { if (Array.isArray(u)) return af({ name: "" }, g, u, ""); { const b = u.name ?? ""; return af({ name: b }, u.parent, u.providers, b) } } } return o.THROW_IF_NOT_FOUND = ur, o.NULL = new In, o.\u0275prov = Ze({ token: o, providedIn: "any", factory: () => sn(Wt) }), o.__NG_ELEMENT_ID__ = -1, o })(); function qf(o, c = it.Default) { const u = Jt(); return null === u ? sn(o, c) : Lu(vs(), u, xe(o), c) } function Ty() { throw new Error("invalid") } function Pm(o, c) { const u = o.contentQueries; if (null !== u) for (let g = 0; g < u.length; g += 2) { const D = u[g + 1]; if (-1 !== D) { const N = o.data[D]; fl(u[g]), N.contentQueries(2, c[D], D) } } } function Ap(o, c, u, g, b, D, N, U, j, ne, pe) { const He = c.blueprint.slice(); return He[0] = b, He[2] = 76 | g, (null !== pe || o && 1024 & o[2]) && (He[2] |= 1024), qa(He), He[3] = He[15] = o, He[8] = u, He[10] = N || o && o[10], He[11] = U || o && o[11], He[12] = j || o && o[12] || null, He[9] = ne || o && o[9] || null, He[6] = D, He[20] = function Hu() { return Hd++ }(), He[21] = pe, He[16] = 2 == c.type ? o[16] : He, He } function Od(o, c, u, g, b) { let D = o.data[c]; if (null === D) D = Mu(o, c, u, g, b), function bc() { return hr.lFrame.inI18n }() && (D.flags |= 32); else if (64 & D.type) { D.type = u, D.value = g, D.attrs = b; const N = cl(); D.injectorIndex = null === N ? -1 : N.injectorIndex } return po(D, !0), D } function Mu(o, c, u, g, b) { const D = ql(), N = Fa(), j = o.data[c] = function cu(o, c, u, g, b, D) { return { type: u, index: g, insertBeforeIndex: null, injectorIndex: c ? c.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: b, attrs: D, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: c, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, N ? D : D && D.parent, u, c, g, b); return null === o.firstChild && (o.firstChild = j), null !== D && (N ? null == D.child && null !== j.parent && (D.child = j) : null === D.next && (D.next = j)), j } function Nd(o, c, u, g) { if (0 === u) return -1; const b = c.length; for (let D = 0; D < u; D++)c.push(g), o.blueprint.push(g), o.data.push(null); return b } function Rm(o, c, u) { Ec(c); try { const g = o.viewQuery; null !== g && zm(1, g, u); const b = o.template; null !== b && dc(o, c, b, 1, u), o.firstCreatePass && (o.firstCreatePass = !1), o.staticContentQueries && Pm(o, c), o.staticViewQueries && zm(2, o.viewQuery, u); const D = o.components; null !== D && function Ip(o, c) { for (let u = 0; u < c.length; u++)kd(o, c[u]) }(c, D) } catch (g) { throw o.firstCreatePass && (o.incompleteFirstPass = !0, o.firstCreatePass = !1), g } finally { c[2] &= -5, Bd() } } function xp(o, c, u, g) { const b = c[2]; if (128 != (128 & b)) { Ec(c); try { qa(c), function Ca(o) { return hr.lFrame.bindingIndex = o }(o.bindingStartIndex), null !== u && dc(o, c, u, 2, g); const N = 3 == (3 & b); if (N) { const ne = o.preOrderCheckHooks; null !== ne && z(c, ne, null) } else { const ne = o.preOrderHooks; null !== ne && re(c, ne, 0, null), Z(c, 0) } if (function Mp(o) { for (let c = fd(o); null !== c; c = Zi(c)) { if (!c[2]) continue; const u = c[9]; for (let g = 0; g < u.length; g++) { const b = u[g]; 512 & b[2] || ys(b[3], 1), b[2] |= 512 } } }(c), function Ou(o) { for (let c = fd(o); null !== c; c = Zi(c))for (let u = 10; u < c.length; u++) { const g = c[u], b = g[1]; xs(g) && xp(b, g, b.template, g[8]) } }(c), null !== o.contentQueries && Pm(o, c), N) { const ne = o.contentCheckHooks; null !== ne && z(c, ne) } else { const ne = o.contentHooks; null !== ne && re(c, ne, 1), Z(c, 1) } !function jw(o, c) { const u = o.hostBindingOpCodes; if (null !== u) try { for (let g = 0; g < u.length; g++) { const b = u[g]; if (b < 0) La(~b); else { const D = b, N = u[++g], U = u[++g]; Jl(N, D), U(2, c[D]) } } } finally { La(-1) } }(o, c); const U = o.components; null !== U && function Og(o, c) { for (let u = 0; u < c.length; u++)hf(o, c[u]) }(c, U); const j = o.viewQuery; if (null !== j && zm(2, j, g), N) { const ne = o.viewCheckHooks; null !== ne && z(c, ne) } else { const ne = o.viewHooks; null !== ne && re(c, ne, 2), Z(c, 2) } !0 === o.firstUpdatePass && (o.firstUpdatePass = !1), c[2] &= -41, 512 & c[2] && (c[2] &= -513, ys(c[3], -1)) } finally { Bd() } } } function dc(o, c, u, g, b) { const D = Eo(), N = 2 & g; try { La(-1), N && c.length > 22 && $f(o, c, 22, !1), u(g, b) } finally { La(D) } } function uf(o, c, u) { if (Ds(c)) { const b = c.directiveEnd; for (let D = c.directiveStart; D < b; D++) { const N = o.data[D]; N.contentQueries && N.contentQueries(1, u[D], D) } } } function df(o, c, u) { Rt() && (function I(o, c, u, g) { const b = u.directiveStart, D = u.directiveEnd; gr(u) && function Dn(o, c, u) { const g = gi(c, o), b = lu(u), D = o[10], N = Um(o, Ap(o, b, null, u.onPush ? 32 : 16, g, c, D, D.createRenderer(g, u), null, null, null)); o[c.index] = N }(c, u, o.data[b + u.componentOffset]), o.firstCreatePass || Bs(u, c), Xo(g, c); const N = u.initialInputs; for (let U = b; U < D; U++) { const j = o.data[U], ne = ia(c, o, U, u); Xo(ne, c), null !== N && uu(0, U - b, ne, j, 0, N), us(j) && (Zr(u.index, c)[8] = ia(c, o, U, u)) } }(o, c, u, gi(u, c)), 64 == (64 & u.flags) && k(o, c, u)) } function Fm(o, c, u = gi) { const g = c.localNames; if (null !== g) { let b = c.index + 1; for (let D = 0; D < g.length; D += 2) { const N = g[D + 1], U = -1 === N ? u(c, o) : o[N]; o[b++] = U } } } function lu(o) { const c = o.tView; return null === c || c.incompleteFirstPass ? o.tView = Ng(1, null, o.template, o.decls, o.vars, o.directiveDefs, o.pipeDefs, o.viewQuery, o.schemas, o.consts) : c } function Ng(o, c, u, g, b, D, N, U, j, ne) { const pe = 22 + g, He = pe + b, Dt = function p0(o, c) { const u = []; for (let g = 0; g < c; g++)u.push(g < o ? null : hi); return u }(pe, He), Ut = "function" == typeof ne ? ne() : ne; return Dt[1] = { type: o, blueprint: Dt, template: u, queries: null, viewQuery: U, declTNode: c, data: Dt.slice().fill(null, pe), bindingStartIndex: pe, expandoStartIndex: He, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof D ? D() : D, pipeRegistry: "function" == typeof N ? N() : N, firstChild: null, schemas: j, consts: Ut, incompleteFirstPass: !1 } } function Lm(o, c, u, g) { const b = Ww(c); null === u ? b.push(g) : (b.push(u), o.firstCreatePass && Zw(o).push(g, b.length - 1)) } function Bm(o, c, u, g) { for (let b in o) if (o.hasOwnProperty(b)) { u = null === u ? {} : u; const D = o[b]; null === g ? Dy(u, c, b, D) : g.hasOwnProperty(b) && Dy(u, c, g[b], D) } return u } function Dy(o, c, u, g) { o.hasOwnProperty(u) ? o[u].push(c, g) : o[u] = [c, g] } function Uc(o, c, u, g, b, D, N, U) { const j = gi(c, u); let pe, ne = c.inputs; !U && null != ne && (pe = ne[g]) ? (Oy(o, u, pe, g, b), gr(c) && Ay(u, c.index)) : 3 & c.type && (g = function Iy(o) { return "class" === o ? "className" : "for" === o ? "htmlFor" : "formaction" === o ? "formAction" : "innerHtml" === o ? "innerHTML" : "readonly" === o ? "readOnly" : "tabindex" === o ? "tabIndex" : o }(g), b = null != N ? N(b, c.value || "", g) : b, D.setProperty(j, g, b)) } function Ay(o, c) { const u = Zr(c, o); 16 & u[2] || (u[2] |= 32) } function l(o, c, u, g) { let b = !1; if (Rt()) { const D = null === g ? null : { "": -1 }, N = function te(o, c) { const u = o.directiveRegistry; let g = null, b = null; if (u) for (let D = 0; D < u.length; D++) { const N = u[D]; if (Sm(c, N.selectors, !1)) if (g || (g = []), us(N)) if (null !== N.findHostDirectiveDefs) { const U = []; b = b || new Map, N.findHostDirectiveDefs(N, U, b), g.unshift(...U, N), se(o, c, U.length) } else g.unshift(N), se(o, c, 0); else b = b || new Map, N.findHostDirectiveDefs?.(N, g, b), g.push(N) } return null === g ? null : [g, b] }(o, u); let U, j; null === N ? U = j = null : [U, j] = N, null !== U && (b = !0, h(o, c, u, U, D, j)), D && function Ge(o, c, u) { if (c) { const g = o.localNames = []; for (let b = 0; b < c.length; b += 2) { const D = u[c[b + 1]]; if (null == D) throw new De(-301, !1); g.push(c[b], D) } } }(u, g, D) } return u.mergedAttrs = go(u.mergedAttrs, u.attrs), b } function h(o, c, u, g, b, D) { for (let ne = 0; ne < g.length; ne++)Sc(Bs(u, c), o, g[ne].type); !function ut(o, c, u) { o.flags |= 1, o.directiveStart = c, o.directiveEnd = c + u, o.providerIndexes = c }(u, o.data.length, g.length); for (let ne = 0; ne < g.length; ne++) { const pe = g[ne]; pe.providersResolver && pe.providersResolver(pe) } let N = !1, U = !1, j = Nd(o, c, g.length, null); for (let ne = 0; ne < g.length; ne++) { const pe = g[ne]; u.mergedAttrs = go(u.mergedAttrs, pe.hostAttrs), $t(o, u, c, j, pe), at(j, pe, b), null !== pe.contentQueries && (u.flags |= 4), (null !== pe.hostBindings || null !== pe.hostAttrs || 0 !== pe.hostVars) && (u.flags |= 64); const He = pe.type.prototype; !N && (He.ngOnChanges || He.ngOnInit || He.ngDoCheck) && ((o.preOrderHooks || (o.preOrderHooks = [])).push(u.index), N = !0), !U && (He.ngOnChanges || He.ngDoCheck) && ((o.preOrderCheckHooks || (o.preOrderCheckHooks = [])).push(u.index), U = !0), j++ } !function Sy(o, c, u) { const b = c.directiveEnd, D = o.data, N = c.attrs, U = []; let j = null, ne = null; for (let pe = c.directiveStart; pe < b; pe++) { const He = D[pe], Dt = u ? u.get(He) : null, mn = Dt ? Dt.outputs : null; j = Bm(He.inputs, pe, j, Dt ? Dt.inputs : null), ne = Bm(He.outputs, pe, ne, mn); const Rn = null === j || null === N || dy(c) ? null : za(j, pe, N); U.push(Rn) } null !== j && (j.hasOwnProperty("class") && (c.flags |= 8), j.hasOwnProperty("style") && (c.flags |= 16)), c.initialInputs = U, c.inputs = j, c.outputs = ne }(o, u, D) } function k(o, c, u) { const g = u.directiveStart, b = u.directiveEnd, D = u.index, N = function wc() { return hr.lFrame.currentDirectiveIndex }(); try { La(D); for (let U = g; U < b; U++) { const j = o.data[U], ne = c[U]; Ql(U), (null !== j.hostBindings || 0 !== j.hostVars || null !== j.hostAttrs) && H(j, ne) } } finally { La(-1), Ql(N) } } function H(o, c) { null !== o.hostBindings && o.hostBindings(1, c) } function se(o, c, u) { c.componentOffset = u, (o.components || (o.components = [])).push(c.index) } function at(o, c, u) { if (u) { if (c.exportAs) for (let g = 0; g < c.exportAs.length; g++)u[c.exportAs[g]] = o; us(c) && (u[""] = o) } } function $t(o, c, u, g, b) { o.data[g] = b; const D = b.factory || (b.factory = Ao(b.type)), N = new Xt(D, us(b), qf); o.blueprint[g] = N, u[g] = N, function y(o, c, u, g, b) { const D = b.hostBindings; if (D) { let N = o.hostBindingOpCodes; null === N && (N = o.hostBindingOpCodes = []); const U = ~c.index; (function w(o) { let c = o.length; for (; c > 0;) { const u = o[--c]; if ("number" == typeof u && u < 0) return u } return 0 })(N) != U && N.push(U), N.push(u, g, D) } }(o, c, g, Nd(o, u, b.hostVars, hi), b) } function $n(o, c, u, g, b, D) { const N = gi(o, c); fi(c[11], N, D, o.value, u, g, b) } function fi(o, c, u, g, b, D, N) { if (null == D) o.removeAttribute(c, b, u); else { const U = null == N ? _t(D) : N(D, g || "", b); o.setAttribute(c, b, U, u) } } function uu(o, c, u, g, b, D) { const N = D[c]; if (null !== N) { const U = g.setInput; for (let j = 0; j < N.length;) { const ne = N[j++], pe = N[j++], He = N[j++]; null !== U ? g.setInput(u, He, ne, pe) : u[pe] = He } } } function za(o, c, u) { let g = null, b = 0; for (; b < u.length;) { const D = u[b]; if (0 !== D) if (5 !== D) { if ("number" == typeof D) break; if (o.hasOwnProperty(D)) { null === g && (g = []); const N = o[D]; for (let U = 0; U < N.length; U += 2)if (N[U] === c) { g.push(D, N[U + 1], u[b + 1]); break } } b += 2 } else b += 2; else b += 4 } return g } function hc(o, c, u, g) { return [o, !0, !1, c, null, 0, g, u, null, null] } function hf(o, c) { const u = Zr(c, o); if (xs(u)) { const g = u[1]; 48 & u[2] ? xp(g, u, g.template, u[8]) : u[5] > 0 && Fi(u) } } function Fi(o) { for (let g = fd(o); null !== g; g = Zi(g))for (let b = 10; b < g.length; b++) { const D = g[b]; if (xs(D)) if (512 & D[2]) { const N = D[1]; xp(N, D, N.template, D[8]) } else D[5] > 0 && Fi(D) } const u = o[1].components; if (null !== u) for (let g = 0; g < u.length; g++) { const b = Zr(u[g], o); xs(b) && b[5] > 0 && Fi(b) } } function kd(o, c) { const u = Zr(c, o), g = u[1]; (function Vm(o, c) { for (let u = c.length; u < o.blueprint.length; u++)c.push(o.blueprint[u]) })(g, u), Rm(g, u, u[8]) } function Um(o, c) { return o[13] ? o[14][4] = c : o[13] = c, o[14] = c, c } function xy(o) { for (; o;) { o[2] |= 32; const c = Gu(o); if (bo(o) && !c) return o; o = c } return null } function Hm(o, c, u, g = !0) { const b = c[10]; b.begin && b.begin(); try { xp(o, c, o.template, u) } catch (N) { throw g && qw(c, N), N } finally { b.end && b.end() } } function zm(o, c, u) { fl(0), c(o, u) } function Ww(o) { return o[7] || (o[7] = []) } function Zw(o) { return o.cleanup || (o.cleanup = []) } function My(o, c, u) { return (null === o || us(o)) && (u = function Mo(o) { for (; Array.isArray(o);) { if ("object" == typeof o[1]) return o; o = o[0] } return null }(u[c.index])), u[11] } function qw(o, c) { const u = o[9], g = u ? u.get(Ah, null) : null; g && g.handleError(c) } function Oy(o, c, u, g, b) { for (let D = 0; D < u.length;) { const N = u[D++], U = u[D++], j = c[N], ne = o.data[N]; null !== ne.setInput ? ne.setInput(j, b, g, U) : j[U] = b } } function ff(o, c, u) { const g = Ra(c, o); ts(o[11], g, u) } function Gm(o, c, u) { let g = u ? o.styles : null, b = u ? o.classes : null, D = 0; if (null !== c) for (let N = 0; N < c.length; N++) { const U = c[N]; "number" == typeof U ? D = U : 1 == D ? b = _e(b, U) : 2 == D && (g = _e(g, U + ": " + c[++N] + ";")) } u ? o.styles = g : o.stylesWithoutHost = g, u ? o.classes = b : o.classesWithoutHost = b } function jm(o, c, u, g, b = !1) { for (; null !== u;) { const D = c[u.index]; if (null !== D && g.push(ds(D)), Ts(D)) for (let U = 10; U < D.length; U++) { const j = D[U], ne = j[1].firstChild; null !== ne && jm(j[1], j, ne, g) } const N = u.type; if (8 & N) jm(o, c, u.child, g); else if (32 & N) { const U = $h(u, c); let j; for (; j = U();)g.push(j) } else if (16 & N) { const U = wl(c, u); if (Array.isArray(U)) g.push(...U); else { const j = Gu(c[16]); jm(j[1], j, U, g, !0) } } u = b ? u.projectionNext : u.next } return g } class Op { get rootNodes() { const c = this._lView, u = c[1]; return jm(u, c, u.firstChild, []) } constructor(c, u) { this._lView = c, this._cdRefInjectingView = u, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[8] } set context(c) { this._lView[8] = c } get destroyed() { return 128 == (128 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const c = this._lView[3]; if (Ts(c)) { const u = c[8], g = u ? u.indexOf(this) : -1; g > -1 && (Ua(c, g), be(u, g)) } this._attachedToViewContainer = !1 } Zh(this._lView[1], this._lView) } onDestroy(c) { Lm(this._lView[1], this._lView, null, c) } markForCheck() { xy(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -65 } reattach() { this._lView[2] |= 64 } detectChanges() { Hm(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new De(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function Hs(o, c) { Ma(o, c, c[11], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(c) { if (this._attachedToViewContainer) throw new De(902, !1); this._appRef = c } } class Yw extends Op { constructor(c) { super(c), this._view = c } detectChanges() { const c = this._view; Hm(c[1], c, c[8], !1) } checkNoChanges() { } get context() { return null } } class du extends tf { constructor(c) { super(), this.ngModule = c } resolveComponentFactory(c) { const u = Hr(c); return new Hc(u, this.ngModule) } } function $m(o) { const c = []; for (let u in o) o.hasOwnProperty(u) && c.push({ propName: o[u], templateName: u }); return c } class Ny { constructor(c, u) { this.injector = c, this.parentInjector = u } get(c, u, g) { g = Le(g); const b = this.injector.get(c, Hf, g); return b !== Hf || u === Hf ? b : this.parentInjector.get(c, u, g) } } class Hc extends Xh { get inputs() { return $m(this.componentDef.inputs) } get outputs() { return $m(this.componentDef.outputs) } constructor(c, u) { super(), this.componentDef = c, this.ngModule = u, this.componentType = c.type, this.selector = function sf(o) { return o.map(fy).join(",") }(c.selectors), this.ngContentSelectors = c.ngContentSelectors ? c.ngContentSelectors : [], this.isBoundToModule = !!u } create(c, u, g, b) { let D = (b = b || this.ngModule) instanceof Ul ? b : b?.injector; D && null !== this.componentDef.getStandaloneInjector && (D = this.componentDef.getStandaloneInjector(D) || D); const N = D ? new Ny(c, D) : c, U = N.get(Uf, null); if (null === U) throw new De(407, !1); const j = N.get(xu, null), ne = U.createRenderer(null, this.componentDef), pe = this.componentDef.selectors[0][0] || "div", He = g ? function kg(o, c, u) { return o.selectRootElement(c, u === sr.ShadowDom) }(ne, g, this.componentDef.encapsulation) : wu(ne, pe, function Yf(o) { const c = o.toLowerCase(); return "svg" === c ? "svg" : "math" === c ? "math" : null }(pe)), Dt = this.componentDef.onPush ? 288 : 272, Ut = Ng(0, null, null, 1, 0, null, null, null, null, null), mn = Ap(null, Ut, null, Dt, null, null, U, ne, j, N, null); let Rn, Zn; Ec(mn); try { const fr = this.componentDef; let jr, En = null; fr.findHostDirectiveDefs ? (jr = [], En = new Map, fr.findHostDirectiveDefs(fr, jr, En), jr.push(fr)) : jr = [fr]; const Yr = function Kw(o, c) { const u = o[1]; return o[22] = c, Od(u, 22, 2, "#host", null) }(mn, He), Uo = function kp(o, c, u, g, b, D, N, U) { const j = b[1]; !function XS(o, c, u, g) { for (const b of o) c.mergedAttrs = go(c.mergedAttrs, b.hostAttrs); null !== c.mergedAttrs && (Gm(c, c.mergedAttrs, !0), null !== u && vd(g, u, c)) }(g, o, c, N); const ne = D.createRenderer(c, u), pe = Ap(b, lu(u), null, u.onPush ? 32 : 16, b[o.index], o, D, ne, U || null, null, null); return j.firstCreatePass && se(j, o, g.length - 1), Um(b, pe), b[o.index] = pe }(Yr, He, fr, jr, mn, U, ne); Zn = wa(Ut, 22), He && function zE(o, c, u, g) { if (g) mi(o, u, ["ng-version", Ad.full]); else { const { attrs: b, classes: D } = function Im(o) { const c = [], u = []; let g = 1, b = 2; for (; g < o.length;) { let D = o[g]; if ("string" == typeof D) 2 === b ? "" !== D && c.push(D, o[++g]) : 8 === b && u.push(D); else { if (!Lo(b)) break; b = D } g++ } return { attrs: c, classes: u } }(c.selectors[0]); b && mi(o, u, b), D && D.length > 0 && El(o, u, D.join(" ")) } }(ne, fr, He, g), void 0 !== u && function m0(o, c, u) { const g = o.projection = []; for (let b = 0; b < c.length; b++) { const D = u[b]; g.push(null != D ? Array.from(D) : null) } }(Zn, this.ngContentSelectors, u), Rn = function HE(o, c, u, g, b, D) { const N = vs(), U = b[1], j = gi(N, b); h(U, b, N, u, null, g); for (let pe = 0; pe < u.length; pe++)Xo(ia(b, U, N.directiveStart + pe, N), b); k(U, b, N), j && Xo(j, b); const ne = ia(b, U, N.directiveStart + N.componentOffset, N); if (o[8] = b[8] = ne, null !== D) for (const pe of D) pe(ne, c); return uf(U, N, o), ne }(Uo, fr, jr, En, mn, [GE]), Rm(Ut, mn, null) } finally { Bd() } return new Np(this.componentType, Rn, Id(Zn, mn), mn, Zn) } } class Np extends Qd { constructor(c, u, g, b, D) { super(), this.location = g, this._rootLView = b, this._tNode = D, this.instance = u, this.hostView = this.changeDetectorRef = new Yw(b), this.componentType = c } setInput(c, u) { const g = this._tNode.inputs; let b; if (null !== g && (b = g[c])) { const D = this._rootLView; Oy(D[1], D, b, c, u), Ay(D, this._tNode.index) } } get injector() { return new Ko(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(c) { this.hostView.onDestroy(c) } } function GE() { const o = vs(); kl(Jt()[1], o) } function _0(o) { let c = function Jw(o) { return Object.getPrototypeOf(o.prototype).constructor }(o.type), u = !0; const g = [o]; for (; c;) { let b; if (us(o)) b = c.\u0275cmp || c.\u0275dir; else { if (c.\u0275cmp) throw new De(903, !1); b = c.\u0275dir } if (b) { if (u) { g.push(b); const N = o; N.inputs = Pp(o.inputs), N.declaredInputs = Pp(o.declaredInputs), N.outputs = Pp(o.outputs); const U = b.hostBindings; U && y0(o, U); const j = b.viewQuery, ne = b.contentQueries; if (j && ky(o, j), ne && Wm(o, ne), Te(o.inputs, b.inputs), Te(o.declaredInputs, b.declaredInputs), Te(o.outputs, b.outputs), us(b) && b.data.animation) { const pe = o.data; pe.animation = (pe.animation || []).concat(b.data.animation) } } const D = b.features; if (D) for (let N = 0; N < D.length; N++) { const U = D[N]; U && U.ngInherit && U(o), U === _0 && (u = !1) } } c = Object.getPrototypeOf(c) } !function jE(o) { let c = 0, u = null; for (let g = o.length - 1; g >= 0; g--) { const b = o[g]; b.hostVars = c += b.hostVars, b.hostAttrs = go(b.hostAttrs, u = go(u, b.hostAttrs)) } }(g) } function Pp(o) { return o === Fr ? {} : o === ze ? [] : o } function ky(o, c) { const u = o.viewQuery; o.viewQuery = u ? (g, b) => { c(g, b), u(g, b) } : c } function Wm(o, c) { const u = o.contentQueries; o.contentQueries = u ? (g, b, D) => { c(g, b, D), u(g, b, D) } : c } function y0(o, c) { const u = o.hostBindings; o.hostBindings = u ? (g, b) => { c(g, b), u(g, b) } : c } let Py = null; function Kf() { if (!Py) { const o = pn.Symbol; if (o && o.iterator) Py = o.iterator; else { const c = Object.getOwnPropertyNames(Map.prototype); for (let u = 0; u < c.length; ++u) { const g = c[u]; "entries" !== g && "size" !== g && Map.prototype[g] === Map.prototype.entries && (Py = g) } } } return Py } function Ry(o) { return !!b0(o) && (Array.isArray(o) || !(o instanceof Map) && Kf() in o) } function b0(o) { return null !== o && ("function" == typeof o || "object" == typeof o) } function Nh(o, c, u) { return o[c] = u } function Zm(o, c) { return o[c] } function zc(o, c, u) { return !Object.is(o[c], u) && (o[c] = u, !0) } function Rp(o, c, u, g) { const b = zc(o, c, u); return zc(o, c + 1, g) || b } function Fy(o, c, u, g, b) { const D = Rp(o, c, u, g); return zc(o, c + 2, b) || D } function Rd(o, c, u, g, b, D) { const N = Rp(o, c, u, g); return Rp(o, c + 2, b, D) || N } function w0(o, c, u, g) { const b = Jt(); return zc(b, hl(), c) && (zr(), $n(es(), b, o, c, u, g)), w0 } function Rg(o, c, u, g) { return zc(o, hl(), u) ? c + _t(u) + g : hi } function Fg(o, c, u, g, b, D) { const U = Rp(o, hs(), u, b); return Co(2), U ? c + _t(u) + g + _t(b) + D : hi } function Ly(o, c, u, g, b, D) { const N = Jt(), U = Rg(N, c, u, g); return U !== hi && $n(es(), N, o, U, b, D), Ly } function d1(o, c, u, g, b, D, N, U) { const j = Jt(), ne = zr(), pe = o + 22, He = ne.firstCreatePass ? function YE(o, c, u, g, b, D, N, U, j) { const ne = c.consts, pe = Od(c, o, 4, N || null, Hi(ne, U)); l(c, u, pe, Hi(ne, j)), kl(c, pe); const He = pe.tViews = Ng(2, pe, g, b, D, c.directiveRegistry, c.pipeRegistry, null, c.schemas, ne); return null !== c.queries && (c.queries.template(c, pe), He.queries = c.queries.embeddedTView(pe)), pe }(pe, ne, j, c, u, g, b, D, N) : ne.data[pe]; po(He, !1); const Dt = j[11].createComment(""); Po(ne, j, Dt, He), Xo(Dt, j), Um(j, j[pe] = hc(Dt, j, Dt, He)), xl(He) && df(ne, j, He), null != N && Fm(j, He, U) } function h1(o) { return Qs(function Yl() { return hr.lFrame.contextLView }(), 22 + o) } function E0(o, c, u) { const g = Jt(); return zc(g, hl(), c) && Uc(zr(), es(), g, o, c, g[11], u, !1), E0 } function T0(o, c, u, g, b) { const N = b ? "class" : "style"; Oy(o, u, c.inputs[N], N, g) } function By(o, c, u, g) { const b = Jt(), D = zr(), N = 22 + o, U = b[11], j = b[N] = wu(U, c, function Nl() { return hr.lFrame.currentNamespace }()), ne = D.firstCreatePass ? function JE(o, c, u, g, b, D, N) { const U = c.consts, ne = Od(c, o, 2, b, Hi(U, D)); return l(c, u, ne, Hi(U, N)), null !== ne.attrs && Gm(ne, ne.attrs, !1), null !== ne.mergedAttrs && Gm(ne, ne.mergedAttrs, !0), null !== c.queries && c.queries.elementStart(c, ne), ne }(N, D, b, 0, c, u, g) : D.data[N]; return po(ne, !0), vd(U, j, ne), 32 != (32 & ne.flags) && Po(D, b, j, ne), 0 === function q() { return hr.lFrame.elementDepthCount }() && Xo(j, b), function $() { hr.lFrame.elementDepthCount++ }(), xl(ne) && (df(D, b, ne), uf(D, ne, b)), null !== g && Fm(b, ne), By } function Vy() { let o = vs(); Fa() ? ul() : (o = o.parent, po(o, !1)); const c = o; !function me() { hr.lFrame.elementDepthCount-- }(); const u = zr(); return u.firstCreatePass && (kl(u, o), Ds(o) && u.queries.elementEnd(o)), null != c.classesWithoutHost && function Or(o) { return 0 != (8 & o.flags) }(c) && T0(u, c, Jt(), c.classesWithoutHost, !0), null != c.stylesWithoutHost && function fs(o) { return 0 != (16 & o.flags) }(c) && T0(u, c, Jt(), c.stylesWithoutHost, !1), Vy } function f1(o, c, u, g) { return By(o, c, u, g), Vy(), f1 } function Uy(o, c, u) { const g = Jt(), b = zr(), D = o + 22, N = b.firstCreatePass ? function nI(o, c, u, g, b) { const D = c.consts, N = Hi(D, g), U = Od(c, o, 8, "ng-container", N); return null !== N && Gm(U, N, !0), l(c, u, U, Hi(D, b)), null !== c.queries && c.queries.elementStart(c, U), U }(D, b, g, c, u) : b.data[D]; po(N, !0); const U = g[D] = g[11].createComment(""); return Po(b, g, U, N), Xo(U, g), xl(N) && (df(b, g, N), uf(b, N, g)), null != u && Fm(g, N), Uy } function Hy() { let o = vs(); const c = zr(); return Fa() ? ul() : (o = o.parent, po(o, !1)), c.firstCreatePass && (kl(c, o), Ds(o) && c.queries.elementEnd(o)), Hy } function D0(o, c, u) { return Uy(o, c, u), Hy(), D0 } function S0() { return Jt() } function I0(o) { return !!o && "function" == typeof o.then } function p1(o) { return !!o && "function" == typeof o.subscribe } const g1 = p1; function A0(o, c, u, g) { const b = Jt(), D = zr(), N = vs(); return Nu(D, b, b[11], N, o, c, g), A0 } function kh(o, c) { const u = vs(), g = Jt(), b = zr(); return Nu(b, g, My(No(b.data), u, g), u, o, c), kh } function Nu(o, c, u, g, b, D, N) { const U = xl(g), ne = o.firstCreatePass && Zw(o), pe = c[8], He = Ww(c); let Dt = !0; if (3 & g.type || N) { const Rn = gi(g, c), Zn = N ? N(Rn) : Rn, fr = He.length, jr = N ? Yr => N(ds(Yr[g.index])) : g.index; let En = null; if (!N && U && (En = function fc(o, c, u, g) { const b = o.cleanup; if (null != b) for (let D = 0; D < b.length - 1; D += 2) { const N = b[D]; if (N === u && b[D + 1] === g) { const U = c[7], j = b[D + 2]; return U.length > j ? U[j] : null } "string" == typeof N && (D += 2) } return null }(o, c, b, g.index)), null !== En) (En.__ngLastListenerFn__ || En).__ngNextListenerFn__ = D, En.__ngLastListenerFn__ = D, Dt = !1; else { D = m1(g, c, pe, D, !1); const Yr = u.listen(Zn, b, D); He.push(D, Yr), ne && ne.push(b, jr, fr, fr + 1) } } else D = m1(g, c, pe, D, !1); const Ut = g.outputs; let mn; if (Dt && null !== Ut && (mn = Ut[b])) { const Rn = mn.length; if (Rn) for (let Zn = 0; Zn < Rn; Zn += 2) { const Uo = c[mn[Zn]][mn[Zn + 1]].subscribe(D), $a = He.length; He.push(D, Uo), ne && ne.push(b, g.index, $a, -($a + 1)) } } } function Ug(o, c, u, g) { try { return !1 !== u(g) } catch (b) { return qw(o, b), !1 } } function m1(o, c, u, g, b) { return function D(N) { if (N === Function) return g; xy(o.componentOffset > -1 ? Zr(o.index, c) : c); let j = Ug(c, 0, g, N), ne = D.__ngNextListenerFn__; for (; ne;)j = Ug(c, 0, ne, N) && j, ne = ne.__ngNextListenerFn__; return b && !1 === j && (N.preventDefault(), N.returnValue = !1), j } } function _1(o = 1) { return function pl(o) { return (hr.lFrame.contextLView = function Ka(o, c) { for (; o > 0;)c = c[15], o--; return c }(o, hr.lFrame.contextLView))[8] }(o) } function QE(o, c) { let u = null; const g = function td(o) { const c = o.attrs; if (null != c) { const u = c.indexOf(5); if (!(1 & u)) return c[u + 1] } return null }(o); for (let b = 0; b < c.length; b++) { const D = c[b]; if ("*" !== D) { if (null === g ? Sm(o, D, !0) : l0(g, D)) return b } else u = b } return u } function y1(o) { const c = Jt()[16][6]; if (!c.projection) { const g = c.projection = St(o ? o.length : 1, null), b = g.slice(); let D = c.child; for (; null !== D;) { const N = o ? QE(D, o) : 0; null !== N && (b[N] ? b[N].projectionNext = D : g[N] = D, b[N] = D), D = D.next } } } function Hl(o, c = 0, u) { const g = Jt(), b = zr(), D = Od(b, 22 + o, 16, null, u || null); null === D.projection && (D.projection = c), ul(), 32 != (32 & D.flags) && function Tu(o, c, u) { jd(c[11], 0, c, u, iu(o, u, c), sc(u.parent || c[6], u, c)) }(b, g, D) } function zy(o, c, u) { return qm(o, "", c, "", u), zy } function qm(o, c, u, g, b) { const D = Jt(), N = Rg(D, c, u, g); return N !== hi && Uc(zr(), es(), D, o, N, D[11], b, !1), qm } function Ym(o, c) { return o << 17 | c << 2 } function Qf(o) { return o >> 17 & 32767 } function Gy(o) { return 2 | o } function Xf(o) { return (131068 & o) >> 2 } function k0(o, c) { return -131069 & o | c << 2 } function P0(o) { return 1 | o } function T1(o, c, u, g, b) { const D = o[u + 1], N = null === c; let U = g ? Qf(D) : Xf(D), j = !1; for (; 0 !== U && (!1 === j || N);) { const pe = o[U + 1]; rT(o[U], c) && (j = !0, o[U + 1] = g ? P0(pe) : Gy(pe)), U = g ? Qf(pe) : Xf(pe) } j && (o[u + 1] = g ? Gy(D) : P0(D)) } function rT(o, c) { return null === o || null == c || (Array.isArray(o) ? o[1] : o) === c || !(!Array.isArray(o) || "string" != typeof c) && $i(o, c) >= 0 } const Il = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function D1(o) { return o.substring(Il.key, Il.keyEnd) } function iT(o) { return o.substring(Il.value, Il.valueEnd) } function Km(o, c) { const u = Il.textEnd; return u === c ? -1 : (c = Il.keyEnd = function pf(o, c, u) { for (; c < u && o.charCodeAt(c) > 32;)c++; return c }(o, Il.key = c, u), zg(o, c, u)) } function jy(o, c) { const u = Il.textEnd; let g = Il.key = zg(o, c, u); return u === g ? -1 : (g = Il.keyEnd = function Er(o, c, u) { let g; for (; c < u && (45 === (g = o.charCodeAt(c)) || 95 === g || (-33 & g) >= 65 && (-33 & g) <= 90 || g >= 48 && g <= 57);)c++; return c }(o, g, u), g = $y(o, g, u), g = Il.value = zg(o, g, u), g = Il.valueEnd = function _i(o, c, u) { let g = -1, b = -1, D = -1, N = c, U = N; for (; N < u;) { const j = o.charCodeAt(N++); if (59 === j) return U; 34 === j || 39 === j ? U = N = Jm(o, j, N, u) : c === N - 4 && 85 === D && 82 === b && 76 === g && 40 === j ? U = N = Jm(o, 41, N, u) : j > 32 && (U = N), D = b, b = g, g = -33 & j } return U }(o, g, u), $y(o, g, u)) } function F0(o) { Il.key = 0, Il.keyEnd = 0, Il.value = 0, Il.valueEnd = 0, Il.textEnd = o.length } function zg(o, c, u) { for (; c < u && o.charCodeAt(c) <= 32;)c++; return c } function $y(o, c, u, g) { return (c = zg(o, c, u)) < u && c++, c } function Jm(o, c, u, g) { let b = -1, D = u; for (; D < g;) { const N = o.charCodeAt(D++); if (N == c && 92 !== b) return D; b = 92 == N && 92 === b ? 0 : N } throw new Error } function Lp(o, c, u) { return Do(o, c, u, !1), Lp } function B0(o, c) { return Do(o, c, null, !0), B0 } function nd(o) { ku(U0, sT, o, !1) } function sT(o, c) { for (let u = function R0(o) { return F0(o), jy(o, zg(o, 0, Il.textEnd)) }(c); u >= 0; u = jy(c, u))U0(o, D1(c), iT(c)) } function I1(o) { ku(Gr, Ph, o, !0) } function Ph(o, c) { for (let u = function S1(o) { return F0(o), Km(o, zg(o, 0, Il.textEnd)) }(c); u >= 0; u = Km(c, u))Gr(o, D1(c), !0) } function Do(o, c, u, g) { const b = Jt(), D = zr(), N = Co(2); D.firstUpdatePass && gf(D, o, N, g), c !== hi && zc(b, N, c) && Xm(D, D.data[Eo()], b, b[11], o, b[N + 1] = function aT(o, c) { return null == o || ("string" == typeof c ? o += c : "object" == typeof o && (o = Ee(F(o)))), o }(c, u), g, N) } function ku(o, c, u, g) { const b = zr(), D = Co(2); b.firstUpdatePass && gf(b, null, D, g); const N = Jt(); if (u !== hi && zc(N, D, u)) { const U = b.data[Eo()]; if (M1(U, g) && !zl(b, D)) { let j = g ? U.classesWithoutHost : U.stylesWithoutHost; null !== j && (u = _e(j, u || "")), T0(b, U, N, u, g) } else !function H0(o, c, u, g, b, D, N, U) { b === hi && (b = ze); let j = 0, ne = 0, pe = 0 < b.length ? b[0] : null, He = 0 < D.length ? D[0] : null; for (; null !== pe || null !== He;) { const Dt = j < b.length ? b[j + 1] : void 0, Ut = ne < D.length ? D[ne + 1] : void 0; let Rn, mn = null; pe === He ? (j += 2, ne += 2, Dt !== Ut && (mn = He, Rn = Ut)) : null === He || null !== pe && pe < He ? (j += 2, mn = pe) : (ne += 2, mn = He, Rn = Ut), null !== mn && Xm(o, c, u, g, mn, Rn, N, U), pe = j < b.length ? b[j] : null, He = ne < D.length ? D[ne] : null } }(b, U, N, N[11], N[D + 1], N[D + 1] = function Wy(o, c, u) { if (null == u || "" === u) return ze; const g = [], b = F(u); if (Array.isArray(b)) for (let D = 0; D < b.length; D++)o(g, b[D], !0); else if ("object" == typeof b) for (const D in b) b.hasOwnProperty(D) && o(g, D, b[D]); else "string" == typeof b && c(g, b); return g }(o, c, u), g, D) } } function zl(o, c) { return c >= o.expandoStartIndex } function gf(o, c, u, g) { const b = o.data; if (null === b[u + 1]) { const D = b[Eo()], N = zl(o, u); M1(D, g) && null === c && !N && (c = !1), c = function oT(o, c, u, g) { const b = No(o); let D = g ? c.residualClasses : c.residualStyles; if (null === b) 0 === (g ? c.classBindings : c.styleBindings) && (u = Qm(u = Gl(null, o, c, u, g), c.attrs, g), D = null); else { const N = c.directiveStylingLast; if (-1 === N || o[N] !== b) if (u = Gl(b, o, c, u, g), null === D) { let j = function A1(o, c, u) { const g = u ? c.classBindings : c.styleBindings; if (0 !== Xf(g)) return o[Qf(g)] }(o, c, g); void 0 !== j && Array.isArray(j) && (j = Gl(null, o, c, j[1], g), j = Qm(j, c.attrs, g), function V0(o, c, u, g) { o[Qf(u ? c.classBindings : c.styleBindings)] = g }(o, c, g, j)) } else D = function x1(o, c, u) { let g; const b = c.directiveEnd; for (let D = 1 + c.directiveStylingLast; D < b; D++)g = Qm(g, o[D].hostAttrs, u); return Qm(g, c.attrs, u) }(o, c, g) } return void 0 !== D && (g ? c.residualClasses = D : c.residualStyles = D), u }(b, D, c, g), function nT(o, c, u, g, b, D) { let N = D ? c.classBindings : c.styleBindings, U = Qf(N), j = Xf(N); o[g] = u; let pe, ne = !1; if (Array.isArray(u) ? (pe = u[1], (null === pe || $i(u, pe) > 0) && (ne = !0)) : pe = u, b) if (0 !== j) { const Dt = Qf(o[U + 1]); o[g + 1] = Ym(Dt, U), 0 !== Dt && (o[Dt + 1] = k0(o[Dt + 1], g)), o[U + 1] = function C1(o, c) { return 131071 & o | c << 17 }(o[U + 1], g) } else o[g + 1] = Ym(U, 0), 0 !== U && (o[U + 1] = k0(o[U + 1], g)), U = g; else o[g + 1] = Ym(j, 0), 0 === U ? U = g : o[j + 1] = k0(o[j + 1], g), j = g; ne && (o[g + 1] = Gy(o[g + 1])), T1(o, pe, g, !0), T1(o, pe, g, !1), function E1(o, c, u, g, b) { const D = b ? o.residualClasses : o.residualStyles; null != D && "string" == typeof c && $i(D, c) >= 0 && (u[g + 1] = P0(u[g + 1])) }(c, pe, o, g, D), N = Ym(U, j), D ? c.classBindings = N : c.styleBindings = N }(b, D, c, u, N, g) } } function Gl(o, c, u, g, b) { let D = null; const N = u.directiveEnd; let U = u.directiveStylingLast; for (-1 === U ? U = u.directiveStart : U++; U < N && (D = c[U], g = Qm(g, D.hostAttrs, b), D !== o);)U++; return null !== o && (u.directiveStylingLast = U), g } function Qm(o, c, u) { const g = u ? 1 : 2; let b = -1; if (null !== c) for (let D = 0; D < c.length; D++) { const N = c[D]; "number" == typeof N ? b = N : b === g && (Array.isArray(o) || (o = void 0 === o ? [] : ["", o]), Gr(o, N, !!u || c[++D])) } return void 0 === o ? null : o } function U0(o, c, u) { Gr(o, c, F(u)) } function Xm(o, c, u, g, b, D, N, U) { if (!(3 & c.type)) return; const j = o.data, ne = j[U + 1], pe = function eT(o) { return 1 == (1 & o) }(ne) ? ih(j, c, u, b, Xf(ne), N) : void 0; Gg(pe) || (Gg(D) || function XE(o) { return 2 == (2 & o) }(ne) && (D = ih(j, null, u, b, U, N)), function Cl(o, c, u, g, b) { if (c) b ? o.addClass(u, g) : o.removeClass(u, g); else { let D = -1 === g.indexOf("-") ? void 0 : vl.DashCase; null == b ? o.removeStyle(u, g, D) : ("string" == typeof b && b.endsWith("!important") && (b = b.slice(0, -10), D |= vl.Important), o.setStyle(u, g, b, D)) } }(g, N, Ra(Eo(), u), b, D)) } function ih(o, c, u, g, b, D) { const N = null === c; let U; for (; b > 0;) { const j = o[b], ne = Array.isArray(j), pe = ne ? j[1] : j, He = null === pe; let Dt = u[b + 1]; Dt === hi && (Dt = He ? ze : void 0); let Ut = He ? Sr(Dt, g) : pe === g ? Dt : void 0; if (ne && !Gg(Ut) && (Ut = Sr(j, g)), Gg(Ut) && (U = Ut, N)) return U; const mn = o[b + 1]; b = N ? Qf(mn) : Xf(mn) } if (null !== c) { let j = D ? c.residualClasses : c.residualStyles; null != j && (U = Sr(j, g)) } return U } function Gg(o) { return void 0 !== o } function M1(o, c) { return 0 != (o.flags & (c ? 8 : 16)) } function Bp(o, c = "") { const u = Jt(), g = zr(), b = o + 22, D = g.firstCreatePass ? Od(g, b, 1, c, null) : g.data[b], N = u[b] = rc(u[11], c); Po(g, u, N, D), po(D, !1) } function Zy(o) { return jg("", o, ""), Zy } function jg(o, c, u) { const g = Jt(), b = Rg(g, o, c, u); return b !== hi && ff(g, Eo(), b), jg } function qy(o, c, u, g, b) { const D = Jt(), N = Fg(D, o, c, u, g, b); return N !== hi && ff(D, Eo(), N), qy } function k1(o, c, u) { ku(Gr, Ph, Rg(Jt(), o, c, u), !0) } function Qy(o, c, u, g, b) { ku(Gr, Ph, Fg(Jt(), o, c, u, g, b), !0) } function r_(o, c, u) { const g = Jt(); return zc(g, hl(), c) && Uc(zr(), es(), g, o, c, g[11], u, !0), r_ } function i_(o, c, u) { const g = Jt(); if (zc(g, hl(), c)) { const D = zr(), N = es(); Uc(D, N, g, o, c, My(No(D.data), N, g), u, !0) } return i_ } const mf = void 0; var pc = ["en", [["a", "p"], ["AM", "PM"], mf], [["AM", "PM"], mf, mf], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], mf, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], mf, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", mf, "{1} 'at' {0}", mf], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function jl(o) { const u = Math.floor(Math.abs(o)), g = o.toString().replace(/^[^.]*\.?/, "").length; return 1 === u && 0 === g ? 1 : 5 }]; let _f = {}; function Q0(o) { const c = function eb(o) { return o.toLowerCase().replace(/_/g, "-") }(o); let u = H1(c); if (u) return u; const g = c.split("-")[0]; if (u = H1(g), u) return u; if ("en" === g) return pc; throw new De(701, !1) } function X0(o) { return Q0(o)[Ur.PluralCase] } function H1(o) { return o in _f || (_f[o] = pn.ng && pn.ng.common && pn.ng.common.locales && pn.ng.common.locales[o]), _f[o] } var Ur = (() => ((Ur = Ur || {})[Ur.LocaleId = 0] = "LocaleId", Ur[Ur.DayPeriodsFormat = 1] = "DayPeriodsFormat", Ur[Ur.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", Ur[Ur.DaysFormat = 3] = "DaysFormat", Ur[Ur.DaysStandalone = 4] = "DaysStandalone", Ur[Ur.MonthsFormat = 5] = "MonthsFormat", Ur[Ur.MonthsStandalone = 6] = "MonthsStandalone", Ur[Ur.Eras = 7] = "Eras", Ur[Ur.FirstDayOfWeek = 8] = "FirstDayOfWeek", Ur[Ur.WeekendRange = 9] = "WeekendRange", Ur[Ur.DateFormat = 10] = "DateFormat", Ur[Ur.TimeFormat = 11] = "TimeFormat", Ur[Ur.DateTimeFormat = 12] = "DateTimeFormat", Ur[Ur.NumberSymbols = 13] = "NumberSymbols", Ur[Ur.NumberFormats = 14] = "NumberFormats", Ur[Ur.CurrencyCode = 15] = "CurrencyCode", Ur[Ur.CurrencySymbol = 16] = "CurrencySymbol", Ur[Ur.CurrencyName = 17] = "CurrencyName", Ur[Ur.Currencies = 18] = "Currencies", Ur[Ur.Directionality = 19] = "Directionality", Ur[Ur.PluralCase = 20] = "PluralCase", Ur[Ur.ExtraData = 21] = "ExtraData", Ur))(); const hT = ["zero", "one", "two", "few", "many"], Vp = "en-US", Up = { marker: "element" }, $g = { marker: "ICU" }; var ta = (() => ((ta = ta || {})[ta.SHIFT = 2] = "SHIFT", ta[ta.APPEND_EAGERLY = 1] = "APPEND_EAGERLY", ta[ta.COMMENT = 2] = "COMMENT", ta))(); let z1 = Vp; function Wg(o) { (function fn(o, c) { null == o && It(c, o, null, "!=") })(o, "Expected localeId to be defined"), "string" == typeof o && (z1 = o.toLowerCase().replace(/_/g, "-")) } function nb(o, c, u) { const g = c.insertBeforeIndex, b = Array.isArray(g) ? g[0] : g; return null === b ? si(o, 0, u) : ds(u[b]) } function rb(o, c, u, g, b) { const D = c.insertBeforeIndex; if (Array.isArray(D)) { let N = g, U = null; if (3 & c.type || (U = N, N = b), null !== N && -1 === c.componentOffset) for (let j = 1; j < D.length; j++)rl(o, N, u[D[j]], U, !1) } } function s_(o, c) { if (o.push(c), o.length > 1) for (let u = o.length - 2; u >= 0; u--) { const g = o[u]; j1(g) || gT(g, c) && null === Zg(g) && mT(g, c.index) } } function j1(o) { return !(64 & o.type) } function gT(o, c) { return j1(c) || o.index > c.index } function Zg(o) { const c = o.insertBeforeIndex; return Array.isArray(c) ? c[0] : c } function mT(o, c) { const u = o.insertBeforeIndex; Array.isArray(u) ? u[0] = c : (_d(nb, rb), o.insertBeforeIndex = c) } function o_(o, c) { const u = o.data[c]; return null === u || "string" == typeof u ? null : u.hasOwnProperty("currentCaseLViewIndex") ? u : u.value } function rv(o, c, u) { const g = Mu(o, u, 64, null, null); return s_(c, g), g } function a_(o, c) { const u = c[o.currentCaseLViewIndex]; return null === u ? u : u < 0 ? ~u : u } function qg(o) { return o >>> 17 } function ib(o) { return (131070 & o) >>> 1 } let yf = 0, ep = 0; function ob(o, c, u, g) { const b = u[11]; let N, D = null; for (let U = 0; U < c.length; U++) { const j = c[U]; if ("string" == typeof j) { const ne = c[++U]; null === u[ne] && (u[ne] = rc(b, j)) } else if ("number" == typeof j) switch (1 & j) { case 0: const ne = qg(j); let pe, He; if (null === D && (D = ne, N = Wu(b, g)), ne === D ? (pe = g, He = N) : (pe = null, He = ds(u[ne])), null !== He) { const Rn = ib(j); rl(b, He, u[Rn], pe, !1); const fr = o_(o, Rn); if (null !== fr && "object" == typeof fr) { const jr = a_(fr, u); null !== jr && ob(o, fr.create[jr], u, u[fr.anchorIdx]) } } break; case 1: const Ut = c[++U], mn = c[++U]; fi(b, Ra(j >>> 1, u), null, null, Ut, mn, null) } else switch (j) { case $g: const ne = c[++U], pe = c[++U]; null === u[pe] && Xo(u[pe] = ic(b, ne), u); break; case Up: const He = c[++U], Dt = c[++U]; null === u[Dt] && Xo(u[Dt] = wu(b, He, null), u) } } } function Yg(o, c, u, g, b) { for (let D = 0; D < u.length; D++) { const N = u[D], U = u[++D]; if (N & b) { let j = ""; for (let ne = D + 1; ne <= D + U; ne++) { const pe = u[ne]; if ("string" == typeof pe) j += pe; else if ("number" == typeof pe) if (pe < 0) j += _t(c[g - pe]); else { const He = pe >>> 2; switch (3 & pe) { case 1: const Dt = u[++ne], Ut = u[++ne], mn = o.data[He]; "string" == typeof mn ? fi(c[11], c[He], null, mn, Dt, j, Ut) : Uc(o, mn, c, Dt, j, c[11], Ut, !1); break; case 0: const Rn = c[He]; null !== Rn && ts(c[11], Rn, j); break; case 2: ab(o, o_(o, He), c, j); break; case 3: iv(o, o_(o, He), g, c) } } } } else { const j = u[D + 1]; if (j > 0 && 3 == (3 & j)) { const pe = o_(o, j >>> 2); c[pe.currentCaseLViewIndex] < 0 && iv(o, pe, g, c) } } D += U } } function iv(o, c, u, g) { let b = g[c.currentCaseLViewIndex]; if (null !== b) { let D = yf; b < 0 && (b = g[c.currentCaseLViewIndex] = ~b, D = -1), Yg(o, g, c.update[b], u, D) } } function ab(o, c, u, g) { const b = function ov(o, c) { let u = o.cases.indexOf(c); if (-1 === u) switch (o.type) { case 1: { const g = function tb(o, c) { const u = X0(c)(parseInt(o, 10)), g = hT[u]; return void 0 !== g ? g : "other" }(c, function G1() { return z1 }()); u = o.cases.indexOf(g), -1 === u && "other" !== g && (u = o.cases.indexOf("other")); break } case 0: u = o.cases.indexOf("other") }return -1 === u ? null : u }(c, g); if (a_(c, u) !== b && (sv(o, c, u), u[c.currentCaseLViewIndex] = null === b ? null : ~b, null !== b)) { const N = u[c.anchorIdx]; N && ob(o, c.create[b], u, N) } } function sv(o, c, u) { let g = a_(c, u); if (null !== g) { const b = c.remove[g]; for (let D = 0; D < b.length; D++) { const N = b[D]; if (N > 0) { const U = Ra(N, u); null !== U && to(u[11], U) } else sv(o, o_(o, ~N), u) } } } function l_() { const o = []; let u, g, c = -1; function D(U, j) { c = 0; const ne = a_(U, j); g = null !== ne ? U.remove[ne] : ze } function N() { if (c < g.length) { const U = g[c++]; return U > 0 ? u[U] : (o.push(c, g), D(u[1].data[~U], u), N()) } return 0 === o.length ? null : (g = o.pop(), c = o.pop(), N()) } return function b(U, j) { for (u = j; o.length;)o.pop(); return D(U.value, j), N } } const c_ = /\ufffd(\d+):?\d*\ufffd/gi, J1 = /\ufffd(\d+)\ufffd/, Q1 = /^\s*(\ufffd\d+:?\d*\ufffd)\s*,\s*(select|plural)\s*,/, X1 = /\ufffd\/?\*(\d+:\d+)\ufffd/gi, lv = /\ufffd(\/?[#*]\d+):?\d*\ufffd/gi, u_ = /\uE500/g; function tC(o, c, u, g, b, D, N) { const U = Nd(o, g, 1, null); let j = U << ta.SHIFT, ne = cl(); c === ne && (ne = null), null === ne && (j |= ta.APPEND_EAGERLY), N && (j |= ta.COMMENT, function yp(o) { void 0 === yh && (yh = o()) }(l_)), b.push(j, null === D ? "" : D); const pe = Mu(o, U, N ? 32 : 1, null === D ? "" : D, null); s_(u, pe); const He = pe.index; return po(pe, !1), null !== ne && c !== ne && function $1(o, c) { let u = o.insertBeforeIndex; null === u ? (_d(nb, rb), u = o.insertBeforeIndex = [null, c]) : (function Ue(o, c, u) { o != c && It(u, o, c, "==") }(Array.isArray(u), !0, "Expecting array here"), u.push(c)) }(ne, He), pe } function nC(o, c, u, g, b, D, N) { const U = N.match(c_), j = tC(o, c, u, D, g, U ? null : N, !1); U && d_(b, N, j.index, null, 0, null) } function d_(o, c, u, g, b, D) { const N = o.length, U = N + 1; o.push(null, null); const j = N + 2, ne = c.split(c_); let pe = 0; for (let He = 0; He < ne.length; He++) { const Dt = ne[He]; if (1 & He) { const Ut = b + parseInt(Dt, 10); o.push(-1 - Ut), pe |= Rh(Ut) } else "" !== Dt && o.push(Dt) } return o.push(u << 2 | (g ? 1 : 0)), g && o.push(g, D), o[N] = pe, o[U] = o.length - j, pe } function Rh(o) { return 1 << Math.min(o, 31) } function h_(o) { let c, D, u = "", g = 0, b = !1; for (; null !== (c = X1.exec(o));)b ? c[0] === `\ufffd/*${D}\ufffd` && (g = c.index, b = !1) : (u += o.substring(g, c.index + c[0].length), D = c[1], b = !0); return u += o.slice(g), u } function Bo(o, c, u, g, b, D) { let N = 0; const U = { type: b.type, currentCaseLViewIndex: Nd(o, c, 1, null), anchorIdx: D, cases: [], create: [], remove: [], update: [] }; (function bT(o, c, u) { o.push(Rh(c.mainBinding), 2, -1 - c.mainBinding, u << 2 | 2) })(u, b, D), function Hp(o, c, u) { const g = o.data[c]; null === g ? o.data[c] = u : g.value = u }(o, D, U); const j = b.values; for (let ne = 0; ne < j.length; ne++) { const pe = j[ne], He = []; for (let Dt = 0; Dt < pe.length; Dt++) { const Ut = pe[Dt]; if ("string" != typeof Ut) { const mn = He.push(Ut) - 1; pe[Dt] = `\x3c!--\ufffd${mn}\ufffd--\x3e` } } N = f_(o, U, c, u, g, b.cases[ne], pe.join(""), He) | N } N && function wT(o, c, u) { o.push(c, 1, u << 2 | 3) }(u, N, D) } function uv(o) { const c = [], u = []; let g = 1, b = 0; const D = jp(o = o.replace(Q1, function (N, U, j) { return g = "select" === j ? 0 : 1, b = parseInt(U.slice(1), 10), "" })); for (let N = 0; N < D.length;) { let U = D[N++].trim(); 1 === g && (U = U.replace(/\s*(?:=)?(\w+)\s*/, "$1")), U.length && c.push(U); const j = jp(D[N++]); c.length > u.length && u.push(j) } return { type: g, mainBinding: b, cases: c, values: u } } function jp(o) { if (!o) return []; let c = 0; const u = [], g = [], b = /[{}]/g; let D; for (b.lastIndex = 0; D = b.exec(o);) { const U = D.index; if ("}" == D[0]) { if (u.pop(), 0 == u.length) { const j = o.substring(c, U); Q1.test(j) ? g.push(uv(j)) : g.push(j), c = U + 1 } } else { if (0 == u.length) { const j = o.substring(c, U); g.push(j), c = U + 1 } u.push("{") } } const N = o.substring(c); return g.push(N), g } function f_(o, c, u, g, b, D, N, U) { const j = [], ne = [], pe = []; c.cases.push(D), c.create.push(j), c.remove.push(ne), c.update.push(pe); const Dt = yr(Tl()).getInertBodyElement(N), Ut = Zd(Dt) || Dt; return Ut ? sC(o, c, u, g, j, ne, pe, Ut, b, U, 0) : 0 } function sC(o, c, u, g, b, D, N, U, j, ne, pe) { let He = 0, Dt = U.firstChild; for (; Dt;) { const Ut = Nd(o, u, 1, null); switch (Dt.nodeType) { case Node.ELEMENT_NODE: const mn = Dt, Rn = mn.tagName.toLowerCase(); if (Cd.hasOwnProperty(Rn)) { ub(b, Up, Rn, j, Ut), o.data[Ut] = Rn; const En = mn.attributes; for (let Yr = 0; Yr < En.length; Yr++) { const Uo = En.item(Yr), $a = Uo.name.toLowerCase(); Uo.value.match(c_) ? wg.hasOwnProperty($a) && d_(N, Uo.value, Ut, Uo.name, 0, Ed[$a] ? su : null) : p_(b, Ut, Uo) } He = sC(o, c, u, g, b, D, N, Dt, Ut, ne, pe + 1) | He, cb(D, Ut, pe) } break; case Node.TEXT_NODE: const Zn = Dt.textContent || "", fr = Zn.match(c_); ub(b, null, fr ? "" : Zn, j, Ut), cb(D, Ut, pe), fr && (He = d_(N, Zn, Ut, null, 0, null) | He); break; case Node.COMMENT_NODE: const jr = J1.exec(Dt.textContent || ""); if (jr) { const Yr = ne[parseInt(jr[1], 10)]; ub(b, $g, "", j, Ut), Bo(o, u, g, j, Yr, Ut), vT(D, Ut, pe) } }Dt = Dt.nextSibling } return He } function cb(o, c, u) { 0 === u && o.push(c) } function vT(o, c, u) { 0 === u && (o.push(~c), o.push(c)) } function ub(o, c, u, g, b) { null !== c && o.push(c), o.push(u, b, function W1(o, c, u) { return o | c << 17 | u << 1 }(0, g, b)) } function p_(o, c, u) { o.push(c << 1 | 1, u.name, u.value) } function db(o, c, u = -1) { const g = zr(), b = Jt(), D = 22 + o, N = Hi(g.consts, c), U = cl(); g.firstCreatePass && function yT(o, c, u, g, b, D) { const N = cl(), U = [], j = [], ne = [[]]; b = function iC(o, c) { if (function cv(o) { return -1 === o }(c)) return h_(o); { const u = o.indexOf(`:${c}\ufffd`) + 2 + c.toString().length, g = o.search(new RegExp(`\ufffd\\/\\*\\d+:${c}\ufffd`)); return h_(o.substring(u, g)) } }(b, D); const pe = function zp(o) { return o.replace(u_, " ") }(b).split(lv); for (let He = 0; He < pe.length; He++) { let Dt = pe[He]; if (1 & He) { const Ut = 47 === Dt.charCodeAt(0), Rn = (Dt.charCodeAt(Ut ? 1 : 0), 22 + Number.parseInt(Dt.substring(Ut ? 2 : 1))); if (Ut) ne.shift(), po(cl(), !1); else { const Zn = rv(o, ne[0], Rn); ne.unshift([]), po(Zn, !0) } } else { const Ut = jp(Dt); for (let mn = 0; mn < Ut.length; mn++) { let Rn = Ut[mn]; if (1 & mn) { const Zn = Rn; if ("object" != typeof Zn) throw new Error(`Unable to parse ICU expression in "${b}" message.`); Bo(o, u, j, c, Zn, tC(o, N, ne[0], u, U, "", !0).index) } else "" !== Rn && nC(o, N, ne[0], U, j, u, Rn) } } } o.data[g] = { create: U, update: j } }(g, null === U ? 0 : U.index, b, D, N, u); const j = g.data[D], pe = bh(g, U === b[6] ? null : U, b); (function q1(o, c, u, g) { const b = o[11]; for (let D = 0; D < c.length; D++) { const N = c[D++], U = c[D], ne = (N & ta.APPEND_EAGERLY) === ta.APPEND_EAGERLY, pe = N >>> ta.SHIFT; let He = o[pe]; null === He && (He = o[pe] = (N & ta.COMMENT) === ta.COMMENT ? b.createComment(U) : rc(b, U)), ne && null !== u && rl(b, u, He, g, !1) } })(b, j.create, pe, U && 8 & U.type ? b[U.index] : null), Ea(!0) } function dv(o, c, u) { db(o, c, u), function hb() { Ea(!1) }() } function hv(o) { return function Z1(o) { o && (yf |= 1 << Math.min(ep, 31)), ep++ }(zc(Jt(), hl(), o)), hv } function pb(o) { !function sb(o, c, u) { if (ep > 0) { const g = o.data[u]; Yg(o, c, Array.isArray(g) ? g : g.update, hs() - ep - 1, yf) } yf = 0, ep = 0 }(zr(), Jt(), o + 22) } function mb(o, c, u, g, b) { if (o = xe(o), Array.isArray(o)) for (let D = 0; D < o.length; D++)mb(o[D], c, u, g, b); else { const D = zr(), N = Jt(); let U = Yi(o) ? o : xe(o.provide), j = Jh(o); const ne = vs(), pe = 1048575 & ne.providerIndexes, He = ne.directiveStart, Dt = ne.providerIndexes >> 20; if (Yi(o) || !o.multi) { const Ut = new Xt(j, b, qf), mn = $p(U, c, b ? pe : pe + Dt, He); -1 === mn ? (Sc(Bs(ne, N), D, U), _b(D, o, c.length), c.push(U), ne.directiveStart++, ne.directiveEnd++, b && (ne.providerIndexes += 1048576), u.push(Ut), N.push(Ut)) : (u[mn] = Ut, N[mn] = Ut) } else { const Ut = $p(U, c, pe + Dt, He), mn = $p(U, c, pe, pe + Dt), Zn = mn >= 0 && u[mn]; if (b && !Zn || !b && !(Ut >= 0 && u[Ut])) { Sc(Bs(ne, N), D, U); const fr = function m_(o, c, u, g, b) { const D = new Xt(o, u, qf); return D.multi = [], D.index = c, D.componentProviders = 0, g_(D, b, g && !u), D }(b ? yb : fv, u.length, b, g, j); !b && Zn && (u[mn].providerFactory = fr), _b(D, o, c.length, 0), c.push(U), ne.directiveStart++, ne.directiveEnd++, b && (ne.providerIndexes += 1048576), u.push(fr), N.push(fr) } else _b(D, o, Ut > -1 ? Ut : mn, g_(u[b ? mn : Ut], j, !b && g)); !b && g && Zn && u[mn].componentProviders++ } } } function _b(o, c, u, g) { const b = Yi(c), D = function ua(o) { return !!o.useClass }(c); if (b || D) { const j = (D ? xe(c.useClass) : c).prototype.ngOnDestroy; if (j) { const ne = o.destroyHooks || (o.destroyHooks = []); if (!b && c.multi) { const pe = ne.indexOf(u); -1 === pe ? ne.push(u, [g, j]) : ne[pe + 1].push(g, j) } else ne.push(u, j) } } } function g_(o, c, u) { return u && o.componentProviders++, o.multi.push(c) - 1 } function $p(o, c, u, g) { for (let b = u; b < g; b++)if (c[b] === o) return b; return -1 } function fv(o, c, u, g) { return pv(this.multi, []) } function yb(o, c, u, g) { const b = this.multi; let D; if (this.providerFactory) { const N = this.providerFactory.componentProviders, U = ia(u, u[1], this.providerFactory.index, g); D = U.slice(0, N), pv(b, D); for (let j = N; j < U.length; j++)D.push(U[j]) } else D = [], pv(b, D); return D } function pv(o, c) { for (let u = 0; u < o.length; u++)c.push((0, o[u])()); return c } function Jg(o, c = []) { return u => { u.providersResolver = (g, b) => function DT(o, c, u) { const g = zr(); if (g.firstCreatePass) { const b = us(o); mb(u, g.data, g.blueprint, b, !0), mb(c, g.data, g.blueprint, b, !1) } }(g, b ? b(o) : o, c) } } class Qg { } class da { } function uC(o, c) { return new dC(o, c ?? null) } class dC extends Qg { constructor(c, u) { super(), this._parent = u, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new du(this); const g = Qi(c); this._bootstrapComponents = xd(g.bootstrap), this._r3Injector = xm(c, u, [{ provide: Qg, useValue: this }, { provide: tf, useValue: this.componentFactoryResolver }], Ee(c), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(c) } get injector() { return this._r3Injector } destroy() { const c = this._r3Injector; !c.destroyed && c.destroy(), this.destroyCbs.forEach(u => u()), this.destroyCbs = null } onDestroy(c) { this.destroyCbs.push(c) } } class vb extends da { constructor(c) { super(), this.moduleType = c } create(c) { return new dC(this.moduleType, c) } } class hC extends Qg { constructor(c, u, g) { super(), this.componentFactoryResolver = new du(this), this.instance = null; const b = new Sl([...c, { provide: Qg, useValue: this }, { provide: tf, useValue: this.componentFactoryResolver }], u || Iu(), g, new Set(["environment"])); this.injector = b, b.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(c) { this.injector.onDestroy(c) } } function gv(o, c, u = null) { return new hC(o, c, u).injector } let fC = (() => { class o { constructor(u) { this._injector = u, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(u) { if (!u.standalone) return null; if (!this.cachedInjectors.has(u.id)) { const g = Cr(0, u.type), b = g.length > 0 ? gv([g], this._injector, `Standalone[${u.type.name}]`) : null; this.cachedInjectors.set(u.id, b) } return this.cachedInjectors.get(u.id) } ngOnDestroy() { try { for (const u of this.cachedInjectors.values()) null !== u && u.destroy() } finally { this.cachedInjectors.clear() } } } return o.\u0275prov = Ze({ token: o, providedIn: "environment", factory: () => new o(sn(Ul)) }), o })(); function __(o) { o.getStandaloneInjector = c => c.get(fC).getOrCreateStandaloneInjector(o) } function vv(o, c, u) { const g = Ms() + o, b = Jt(); return b[g] === hi ? Nh(b, g, u ? c.call(u) : c()) : Zm(b, g) } function Sb(o, c, u, g) { return Pu(Jt(), Ms(), o, c, u, g) } function b_(o, c, u, g, b) { return Nb(Jt(), Ms(), o, c, u, g, b) } function Ib(o, c, u, g, b, D) { return kb(Jt(), Ms(), o, c, u, g, b, D) } function Ab(o, c, u, g, b, D, N) { return Wp(Jt(), Ms(), o, c, u, g, b, D, N) } function tp(o, c, u, g, b, D, N, U) { const j = Ms() + o, ne = Jt(), pe = Rd(ne, j, u, g, b, D); return zc(ne, j + 4, N) || pe ? Nh(ne, j + 5, U ? c.call(U, u, g, b, D, N) : c(u, g, b, D, N)) : Zm(ne, j + 5) } function xb(o, c, u, g, b, D, N, U, j) { const ne = Ms() + o, pe = Jt(), He = Rd(pe, ne, u, g, b, D); return Rp(pe, ne + 4, N, U) || He ? Nh(pe, ne + 6, j ? c.call(j, u, g, b, D, N, U) : c(u, g, b, D, N, U)) : Zm(pe, ne + 6) } function Mb(o, c, u, g, b, D, N, U, j, ne) { const pe = Ms() + o, He = Jt(); let Dt = Rd(He, pe, u, g, b, D); return Fy(He, pe + 4, N, U, j) || Dt ? Nh(He, pe + 7, ne ? c.call(ne, u, g, b, D, N, U, j) : c(u, g, b, D, N, U, j)) : Zm(He, pe + 7) } function Ob(o, c, u, g) { return function vC(o, c, u, g, b, D) { let N = c + u, U = !1; for (let j = 0; j < b.length; j++)zc(o, N++, b[j]) && (U = !0); return U ? Nh(o, N, g.apply(D, b)) : np(o, N) }(Jt(), Ms(), o, c, u, g) } function np(o, c) { const u = o[c]; return u === hi ? void 0 : u } function Pu(o, c, u, g, b, D) { const N = c + u; return zc(o, N, b) ? Nh(o, N + 1, D ? g.call(D, b) : g(b)) : np(o, N + 1) } function Nb(o, c, u, g, b, D, N) { const U = c + u; return Rp(o, U, b, D) ? Nh(o, U + 2, N ? g.call(N, b, D) : g(b, D)) : np(o, U + 2) } function kb(o, c, u, g, b, D, N, U) { const j = c + u; return Fy(o, j, b, D, N) ? Nh(o, j + 3, U ? g.call(U, b, D, N) : g(b, D, N)) : np(o, j + 3) } function Wp(o, c, u, g, b, D, N, U, j) { const ne = c + u; return Rd(o, ne, b, D, N, U) ? Nh(o, ne + 4, j ? g.call(j, b, D, N, U) : g(b, D, N, U)) : np(o, ne + 4) } function bC(o, c) { const u = zr(); let g; const b = o + 22; u.firstCreatePass ? (g = function Pb(o, c) { if (c) for (let u = c.length - 1; u >= 0; u--) { const g = c[u]; if (o === g.name) return g } }(c, u.pipeRegistry), u.data[b] = g, g.onDestroy && (u.destroyHooks || (u.destroyHooks = [])).push(b, g.onDestroy)) : g = u.data[b]; const D = g.factory || (g.factory = Ao(g.type)), N = gn(qf); try { const U = qo(!1), j = D(); return qo(U), function KE(o, c, u, g) { u >= o.data.length && (o.data[u] = null, o.blueprint[u] = null), c[u] = g }(u, Jt(), b, j), j } finally { gn(N) } } function wC(o, c, u) { const g = o + 22, b = Jt(), D = Qs(b, g); return Xg(b, g) ? Pu(b, Ms(), c, D.transform, u, D) : D.transform(u) } function Rb(o, c, u, g) { const b = o + 22, D = Jt(), N = Qs(D, b); return Xg(D, b) ? Nb(D, Ms(), c, N.transform, u, g, N) : N.transform(u, g) } function CC(o, c, u, g, b) { const D = o + 22, N = Jt(), U = Qs(N, D); return Xg(N, D) ? kb(N, Ms(), c, U.transform, u, g, b, U) : U.transform(u, g, b) } function w_(o, c, u, g, b, D) { const N = o + 22, U = Jt(), j = Qs(U, N); return Xg(U, N) ? Wp(U, Ms(), c, j.transform, u, g, b, D, j) : j.transform(u, g, b, D) } function Xg(o, c) { return o[1].data[c].pure } function rp(o) { return c => { setTimeout(o, void 0, c) } } const gc = class $l extends i.x { constructor(c = !1) { super(), this.__isAsync = c } emit(c) { super.next(c) } subscribe(c, u, g) { let b = c, D = u || (() => null), N = g; if (c && "object" == typeof c) { const j = c; b = j.next?.bind(j), D = j.error?.bind(j), N = j.complete?.bind(j) } this.__isAsync && (D = rp(D), b && (b = rp(b)), N && (N = rp(N))); const U = super.subscribe({ next: b, error: D, complete: N }); return c instanceof m.w0 && c.add(U), U } }; function Fb() { return this._results[Kf()]() } class bv { get changes() { return this._changes || (this._changes = new gc) } constructor(c = !1) { this._emitDistinctChangesOnly = c, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const u = Kf(), g = bv.prototype; g[u] || (g[u] = Fb) } get(c) { return this._results[c] } map(c) { return this._results.map(c) } filter(c) { return this._results.filter(c) } find(c) { return this._results.find(c) } reduce(c, u) { return this._results.reduce(c, u) } forEach(c) { this._results.forEach(c) } some(c) { return this._results.some(c) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(c, u) { const g = this; g.dirty = !1; const b = function G(o) { return o.flat(Number.POSITIVE_INFINITY) }(c); (this._changesDetected = !function M(o, c, u) { if (o.length !== c.length) return !1; for (let g = 0; g < o.length; g++) { let b = o[g], D = c[g]; if (u && (b = u(b), D = u(D)), D !== b) return !1 } return !0 }(g._results, b, u)) && (g._results = b, g.length = b.length, g.last = b[this.length - 1], g.first = b[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } let Mn = (() => { class o { } return o.__NG_ELEMENT_ID__ = Lb, o })(); const Ga = Mn, Zp = class extends Ga { constructor(c, u, g) { super(), this._declarationLView = c, this._declarationTContainer = u, this.elementRef = g } createEmbeddedView(c, u) { const g = this._declarationTContainer.tViews, b = Ap(this._declarationLView, g, c, 16, null, g.declTNode, null, null, null, null, u || null); b[17] = this._declarationLView[this._declarationTContainer.index]; const N = this._declarationLView[19]; return null !== N && (b[19] = N.createEmbeddedView(g)), Rm(g, b, c), new Op(b) } }; function Lb() { return rr(vs(), Jt()) } function rr(o, c) { return 4 & o.type ? new Zp(c, o, Id(o, c)) : null } let mr = (() => { class o { } return o.__NG_ELEMENT_ID__ = AT, o })(); function AT() { return Bb(vs(), Jt()) } const Wn = mr, en = class extends Wn { constructor(c, u, g) { super(), this._lContainer = c, this._hostTNode = u, this._hostLView = g } get element() { return Id(this._hostTNode, this._hostLView) } get injector() { return new Ko(this._hostTNode, this._hostLView) } get parentInjector() { const c = Kc(this._hostTNode, this._hostLView); if (Va(c)) { const u = Yc(c, this._hostLView), g = xi(c); return new Ko(u[1].data[g + 8], u) } return new Ko(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(c) { const u = Cn(this._lContainer); return null !== u && u[c] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(c, u, g) { let b, D; "number" == typeof g ? b = g : null != g && (b = g.index, D = g.injector); const N = c.createEmbeddedView(u || {}, D); return this.insert(N, b), N } createComponent(c, u, g, b, D) { const N = c && !function V(o) { return "function" == typeof o }(c); let U; if (N) U = u; else { const He = u || {}; U = He.index, g = He.injector, b = He.projectableNodes, D = He.environmentInjector || He.ngModuleRef } const j = N ? c : new Hc(Hr(c)), ne = g || this.parentInjector; if (!D && null == j.ngModule) { const Dt = (N ? ne : this.parentInjector).get(Ul, null); Dt && (D = Dt) } const pe = j.create(ne, b, void 0, D); return this.insert(pe.hostView, U), pe } insert(c, u) { const g = c._lView, b = g[1]; if (function Oo(o) { return Ts(o[3]) }(g)) { const pe = this.indexOf(c); if (-1 !== pe) this.detach(pe); else { const He = g[3], Dt = new en(He, He[6], He[3]); Dt.detach(Dt.indexOf(c)) } } const D = this._adjustIndex(u), N = this._lContainer; !function ws(o, c, u, g) { const b = 10 + g, D = u.length; g > 0 && (u[b - 1][4] = c), g < D - 10 ? (c[4] = u[b], ce(u, 10 + g, c)) : (u.push(c), c[4] = null), c[3] = u; const N = c[17]; null !== N && u !== N && function vp(o, c) { const u = o[9]; c[16] !== c[3][3][16] && (o[2] = !0), null === u ? o[9] = [c] : u.push(c) }(N, c); const U = c[19]; null !== U && U.insertView(o), c[2] |= 64 }(b, g, N, D); const U = Ro(D, N), j = g[11], ne = Wu(j, N[7]); return null !== ne && function $u(o, c, u, g, b, D) { g[0] = b, g[6] = c, Ma(o, g, u, 1, b, D) }(b, N[6], j, g, ne, U), c.attachToViewContainerRef(), ce(ja(N), D, c), c } move(c, u) { return this.insert(c, u) } indexOf(c) { const u = Cn(this._lContainer); return null !== u ? u.indexOf(c) : -1 } remove(c) { const u = this._adjustIndex(c, -1), g = Ua(this._lContainer, u); g && (be(ja(this._lContainer), u), Zh(g[1], g)) } detach(c) { const u = this._adjustIndex(c, -1), g = Ua(this._lContainer, u); return g && null != be(ja(this._lContainer), u) ? new Op(g) : null } _adjustIndex(c, u = 0) { return c ?? this.length + u } }; function Cn(o) { return o[8] } function ja(o) { return o[8] || (o[8] = []) } function Bb(o, c) { let u; const g = c[o.index]; if (Ts(g)) u = g; else { let b; if (8 & o.type) b = ds(g); else { const D = c[11]; b = D.createComment(""); const N = gi(o, c); rl(D, Wu(D, N), b, function md(o, c) { return o.nextSibling(c) }(D, N), !1) } c[o.index] = u = hc(g, c, b, o), Um(c, u) } return new en(u, o, c) } class Vb { constructor(c) { this.queryList = c, this.matches = null } clone() { return new Vb(this.queryList) } setDirty() { this.queryList.setDirty() } } class Ub { constructor(c = []) { this.queries = c } createEmbeddedView(c) { const u = c.queries; if (null !== u) { const g = null !== c.contentQueries ? c.contentQueries[0] : u.length, b = []; for (let D = 0; D < g; D++) { const N = u.getByIndex(D); b.push(this.queries[N.indexInDeclarationView].clone()) } return new Ub(b) } return null } insertView(c) { this.dirtyQueriesWithMatches(c) } detachView(c) { this.dirtyQueriesWithMatches(c) } dirtyQueriesWithMatches(c) { for (let u = 0; u < this.queries.length; u++)null !== Gn(c, u).matches && this.queries[u].setDirty() } } class EC { constructor(c, u, g = null) { this.predicate = c, this.flags = u, this.read = g } } class Hb { constructor(c = []) { this.queries = c } elementStart(c, u) { for (let g = 0; g < this.queries.length; g++)this.queries[g].elementStart(c, u) } elementEnd(c) { for (let u = 0; u < this.queries.length; u++)this.queries[u].elementEnd(c) } embeddedTView(c) { let u = null; for (let g = 0; g < this.length; g++) { const b = null !== u ? u.length : 0, D = this.getByIndex(g).embeddedTView(c, b); D && (D.indexInDeclarationView = g, null !== u ? u.push(D) : u = [D]) } return null !== u ? new Hb(u) : null } template(c, u) { for (let g = 0; g < this.queries.length; g++)this.queries[g].template(c, u) } getByIndex(c) { return this.queries[c] } get length() { return this.queries.length } track(c) { this.queries.push(c) } } class zb { constructor(c, u = -1) { this.metadata = c, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = u } elementStart(c, u) { this.isApplyingToNode(u) && this.matchTNode(c, u) } elementEnd(c) { this._declarationNodeIndex === c.index && (this._appliesToNextNode = !1) } template(c, u) { this.elementStart(c, u) } embeddedTView(c, u) { return this.isApplyingToNode(c) ? (this.crossesNgTemplate = !0, this.addMatch(-c.index, u), new zb(this.metadata)) : null } isApplyingToNode(c) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const u = this._declarationNodeIndex; let g = c.parent; for (; null !== g && 8 & g.type && g.index !== u;)g = g.parent; return u === (null !== g ? g.index : -1) } return this._appliesToNextNode } matchTNode(c, u) { const g = this.metadata.predicate; if (Array.isArray(g)) for (let b = 0; b < g.length; b++) { const D = g[b]; this.matchTNodeWithReadOption(c, u, TC(u, D)), this.matchTNodeWithReadOption(c, u, ra(u, c, D, !1, !1)) } else g === Mn ? 4 & u.type && this.matchTNodeWithReadOption(c, u, -1) : this.matchTNodeWithReadOption(c, u, ra(u, c, g, !1, !1)) } matchTNodeWithReadOption(c, u, g) { if (null !== g) { const b = this.metadata.read; if (null !== b) if (b === nf || b === mr || b === Mn && 4 & u.type) this.addMatch(u.index, -2); else { const D = ra(u, c, b, !1, !1); null !== D && this.addMatch(u.index, D) } else this.addMatch(u.index, g) } } addMatch(c, u) { null === this.matches ? this.matches = [c, u] : this.matches.push(c, u) } } function TC(o, c) { const u = o.localNames; if (null !== u) for (let g = 0; g < u.length; g += 2)if (u[g] === c) return u[g + 1]; return null } function cI(o, c, u, g) { return -1 === u ? function xT(o, c) { return 11 & o.type ? Id(o, c) : 4 & o.type ? rr(o, c) : null }(c, o) : -2 === u ? function MT(o, c, u) { return u === nf ? Id(c, o) : u === Mn ? rr(c, o) : u === mr ? Bb(c, o) : void 0 }(o, c, g) : ia(o, o[1], u, c) } function Gb(o, c, u, g) { const b = c[19].queries[g]; if (null === b.matches) { const D = o.data, N = u.matches, U = []; for (let j = 0; j < N.length; j += 2) { const ne = N[j]; U.push(ne < 0 ? null : cI(c, D[ne], N[j + 1], u.metadata.read)) } b.matches = U } return b.matches } function ai(o, c, u, g) { const b = o.queries.getByIndex(u), D = b.matches; if (null !== D) { const N = Gb(o, c, b, u); for (let U = 0; U < D.length; U += 2) { const j = D[U]; if (j > 0) g.push(N[U / 2]); else { const ne = D[U + 1], pe = c[-j]; for (let He = 10; He < pe.length; He++) { const Dt = pe[He]; Dt[17] === Dt[3] && ai(Dt[1], Dt, ne, g) } if (null !== pe[9]) { const He = pe[9]; for (let Dt = 0; Dt < He.length; Dt++) { const Ut = He[Dt]; ai(Ut[1], Ut, ne, g) } } } } } return g } function qp(o) { const c = Jt(), u = zr(), g = Cc(); fl(g + 1); const b = Gn(u, g); if (o.dirty && function oo(o) { return 4 == (4 & o[2]) }(c) === (2 == (2 & b.metadata.flags))) { if (null === b.matches) o.reset([]); else { const D = b.crossesNgTemplate ? ai(u, c, g, []) : Gb(u, c, b, g); o.reset(D, Cg), o.notifyOnChanges() } return !0 } return !1 } function jb(o, c, u) { const g = zr(); g.firstCreatePass && (DC(g, new EC(o, c, u), -1), 2 == (2 & c) && (g.staticViewQueries = !0)), is(g, Jt(), c) } function Vo(o, c, u, g) { const b = zr(); if (b.firstCreatePass) { const D = vs(); DC(b, new EC(c, u, g), D.index), function Oa(o, c) { const u = o.contentQueries || (o.contentQueries = []); c !== (u.length ? u[u.length - 1] : -1) && u.push(o.queries.length - 1, c) }(b, o), 2 == (2 & u) && (b.staticContentQueries = !0) } is(b, Jt(), u) } function Ar() { return function C_(o, c) { return o[19].queries[c].queryList }(Jt(), Cc()) } function is(o, c, u) { const g = new bv(4 == (4 & u)); Lm(o, c, g, g.destroy), null === c[19] && (c[19] = new Ub), c[19].queries.push(new Vb(g)) } function DC(o, c, u) { null === o.queries && (o.queries = new Hb), o.queries.track(new zb(c, u)) } function Gn(o, c) { return o.queries.getByIndex(c) } function E_(o, c) { return rr(o, c) } const x_ = ci("Input", o => ({ bindingPropertyName: o })), PC = ci("Output", o => ({ bindingPropertyName: o })), Dv = ci("HostListener", (o, c) => ({ eventName: o, args: c })); function M_(...o) { } const RC = new Mi("Application Initializer"); let O_ = (() => { class o { constructor(u) { this.appInits = u, this.resolve = M_, this.reject = M_, this.initialized = !1, this.done = !1, this.donePromise = new Promise((g, b) => { this.resolve = g, this.reject = b }) } runInitializers() { if (this.initialized) return; const u = [], g = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let b = 0; b < this.appInits.length; b++) { const D = this.appInits[b](); if (I0(D)) u.push(D); else if (g1(D)) { const N = new Promise((U, j) => { D.subscribe({ complete: U, error: j }) }); u.push(N) } } Promise.all(u).then(() => { g() }).catch(b => { this.reject(b) }), 0 === u.length && g(), this.initialized = !0 } } return o.\u0275fac = function (u) { return new (u || o)(sn(RC, 8)) }, o.\u0275prov = Ze({ token: o, factory: o.\u0275fac, providedIn: "root" }), o })(); const ew = new Mi("AppId", { providedIn: "root", factory: function Tf() { return `${Iv()}${Iv()}${Iv()}` } }); function Iv() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const tw = new Mi("Platform Initializer"), ns = new Mi("Platform ID", { providedIn: "platform", factory: () => "unknown" }), qs = new Mi("appBootstrapListener"), nw = new Mi("AnimationModuleType"); let FC = (() => { class o { log(u) { console.log(u) } warn(u) { console.warn(u) } } return o.\u0275fac = function (u) { return new (u || o) }, o.\u0275prov = Ze({ token: o, factory: o.\u0275fac, providedIn: "platform" }), o })(); const k_ = new Mi("LocaleId", { providedIn: "root", factory: () => vt(k_, it.Optional | it.SkipSelf) || function LC() { return typeof $localize < "u" && $localize.locale || Vp }() }), BC = new Mi("DefaultCurrencyCode", { providedIn: "root", factory: () => "USD" }); class UT { constructor(c, u) { this.ngModuleFactory = c, this.componentFactories = u } } let HT = (() => { class o { compileModuleSync(u) { return new vb(u) } compileModuleAsync(u) { return Promise.resolve(this.compileModuleSync(u)) } compileModuleAndAllComponentsSync(u) { const g = this.compileModuleSync(u), D = xd(Qi(u).declarations).reduce((N, U) => { const j = Hr(U); return j && N.push(new Hc(j)), N }, []); return new UT(g, D) } compileModuleAndAllComponentsAsync(u) { return Promise.resolve(this.compileModuleAndAllComponentsSync(u)) } clearCache() { } clearCacheFor(u) { } getModuleId(u) { } } return o.\u0275fac = function (u) { return new (u || o) }, o.\u0275prov = Ze({ token: o, factory: o.\u0275fac, providedIn: "root" }), o })(); const Na = (() => Promise.resolve(0))(); function im(o) { typeof Zone > "u" ? Na.then(() => { o && o.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", o) } class sd { constructor({ enableLongStackTrace: c = !1, shouldCoalesceEventChangeDetection: u = !1, shouldCoalesceRunChangeDetection: g = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new gc(!1), this.onMicrotaskEmpty = new gc(!1), this.onStable = new gc(!1), this.onError = new gc(!1), typeof Zone > "u") throw new De(908, !1); Zone.assertZonePatched(); const b = this; b._nesting = 0, b._outer = b._inner = Zone.current, Zone.TaskTrackingZoneSpec && (b._inner = b._inner.fork(new Zone.TaskTrackingZoneSpec)), c && Zone.longStackTraceZoneSpec && (b._inner = b._inner.fork(Zone.longStackTraceZoneSpec)), b.shouldCoalesceEventChangeDetection = !g && u, b.shouldCoalesceRunChangeDetection = g, b.lastRequestAnimationFrameId = -1, b.nativeRequestAnimationFrame = function yc() { let o = pn.requestAnimationFrame, c = pn.cancelAnimationFrame; if (typeof Zone < "u" && o && c) { const u = o[Zone.__symbol__("OriginalDelegate")]; u && (o = u); const g = c[Zone.__symbol__("OriginalDelegate")]; g && (c = g) } return { nativeRequestAnimationFrame: o, nativeCancelAnimationFrame: c } }().nativeRequestAnimationFrame, function GC(o) { const c = () => { !function vc(o) { o.isCheckStableRunning || -1 !== o.lastRequestAnimationFrameId || (o.lastRequestAnimationFrameId = o.nativeRequestAnimationFrame.call(pn, () => { o.fakeTopEventTask || (o.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { o.lastRequestAnimationFrameId = -1, yo(o), o.isCheckStableRunning = !0, hu(o), o.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), o.fakeTopEventTask.invoke() }), yo(o)) }(o) }; o._inner = o._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (u, g, b, D, N, U) => { try { return jC(o), u.invokeTask(b, D, N, U) } finally { (o.shouldCoalesceEventChangeDetection && "eventTask" === D.type || o.shouldCoalesceRunChangeDetection) && c(), Av(o) } }, onInvoke: (u, g, b, D, N, U, j) => { try { return jC(o), u.invoke(b, D, N, U, j) } finally { o.shouldCoalesceRunChangeDetection && c(), Av(o) } }, onHasTask: (u, g, b, D) => { u.hasTask(b, D), g === b && ("microTask" == D.change ? (o._hasPendingMicrotasks = D.microTask, yo(o), hu(o)) : "macroTask" == D.change && (o.hasPendingMacrotasks = D.macroTask)) }, onHandleError: (u, g, b, D) => (u.handleError(b, D), o.runOutsideAngular(() => o.onError.emit(D)), !1) }) }(b) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!sd.isInAngularZone()) throw new De(909, !1) } static assertNotInAngularZone() { if (sd.isInAngularZone()) throw new De(909, !1) } run(c, u, g) { return this._inner.run(c, u, g) } runTask(c, u, g, b) { const D = this._inner, N = D.scheduleEventTask("NgZoneEvent: " + b, c, sm, M_, M_); try { return D.runTask(N, u, g) } finally { D.cancelTask(N) } } runGuarded(c, u, g) { return this._inner.runGuarded(c, u, g) } runOutsideAngular(c) { return this._outer.run(c) } } const sm = {}; function hu(o) { if (0 == o._nesting && !o.hasPendingMicrotasks && !o.isStable) try { o._nesting++, o.onMicrotaskEmpty.emit(null) } finally { if (o._nesting--, !o.hasPendingMicrotasks) try { o.runOutsideAngular(() => o.onStable.emit(null)) } finally { o.isStable = !0 } } } function yo(o) { o.hasPendingMicrotasks = !!(o._hasPendingMicrotasks || (o.shouldCoalesceEventChangeDetection || o.shouldCoalesceRunChangeDetection) && -1 !== o.lastRequestAnimationFrameId) } function jC(o) { o._nesting++, o.isStable && (o.isStable = !1, o.onUnstable.emit(null)) } function Av(o) { o._nesting--, hu(o) } class Qp { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new gc, this.onMicrotaskEmpty = new gc, this.onStable = new gc, this.onError = new gc } run(c, u, g) { return c.apply(u, g) } runGuarded(c, u, g) { return c.apply(u, g) } runOutsideAngular(c) { return c() } runTask(c, u, g, b) { return c.apply(u, g) } } const om = new Mi(""), R_ = new Mi(""); let lh, xv = (() => { class o { constructor(u, g, b) { this._ngZone = u, this.registry = g, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, lh || (function $C(o) { lh = o }(b), b.addToWindow(g)), this._watchAngularEvents(), u.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { sd.assertNotInAngularZone(), im(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) im(() => { for (; 0 !== this._callbacks.length;) { let u = this._callbacks.pop(); clearTimeout(u.timeoutId), u.doneCb(this._didWork) } this._didWork = !1 }); else { let u = this.getPendingTasks(); this._callbacks = this._callbacks.filter(g => !g.updateCb || !g.updateCb(u) || (clearTimeout(g.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(u => ({ source: u.source, creationLocation: u.creationLocation, data: u.data })) : [] } addCallback(u, g, b) { let D = -1; g && g > 0 && (D = setTimeout(() => { this._callbacks = this._callbacks.filter(N => N.timeoutId !== D), u(this._didWork, this.getPendingTasks()) }, g)), this._callbacks.push({ doneCb: u, timeoutId: D, updateCb: b }) } whenStable(u, g, b) { if (b && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(u, g, b), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(u) { this.registry.registerApplication(u, this) } unregisterApplication(u) { this.registry.unregisterApplication(u) } findProviders(u, g, b) { return [] } } return o.\u0275fac = function (u) { return new (u || o)(sn(sd), sn(rw), sn(R_)) }, o.\u0275prov = Ze({ token: o, factory: o.\u0275fac }), o })(), rw = (() => { class o { constructor() { this._applications = new Map } registerApplication(u, g) { this._applications.set(u, g) } unregisterApplication(u) { this._applications.delete(u) } unregisterAllApplications() { this._applications.clear() } getTestability(u) { return this._applications.get(u) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(u, g = !0) { return lh?.findTestabilityInTree(this, u, g) ?? null } } return o.\u0275fac = function (u) { return new (u || o) }, o.\u0275prov = Ze({ token: o, factory: o.\u0275fac, providedIn: "platform" }), o })(), Df = null; const Xp = new Mi("AllowMultipleToken"), Mv = new Mi("PlatformDestroyListeners"); class fu { constructor(c, u) { this.name = c, this.token = u } } function kv(o, c, u = []) { const g = `Platform: ${c}`, b = new Mi(g); return (D = []) => { let N = aw(); if (!N || N.injector.get(Xp, !1)) { const U = [...u, ...D, { provide: b, useValue: !0 }]; o ? o(U) : function iw(o) { if (Df && !Df.get(Xp, !1)) throw new De(400, !1); Df = o; const c = o.get(lw); (function am(o) { const c = o.get(tw, null); c && c.forEach(u => u()) })(o) }(function ow(o = [], c) { return Mh.create({ name: c, providers: [{ provide: Fo, useValue: "platform" }, { provide: Mv, useValue: new Set([() => Df = null]) }, ...o] }) }(U, g)) } return function sw(o) { const c = aw(); if (!c) throw new De(401, !1); return c }() } } function aw() { return Df?.get(lw) ?? null } let lw = (() => { class o { constructor(u) { this._injector = u, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(u, g) { const b = function uw(o, c) { let u; return u = "noop" === o ? new Qp : ("zone.js" === o ? void 0 : o) || new sd(c), u }(g?.ngZone, function cw(o) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!o || !o.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!o || !o.ngZoneRunCoalescing) || !1 } }(g)), D = [{ provide: sd, useValue: b }]; return b.run(() => { const N = Mh.create({ providers: D, parent: this.injector, name: u.moduleType.name }), U = u.create(N), j = U.injector.get(Ah, null); if (!j) throw new De(402, !1); return b.runOutsideAngular(() => { const ne = b.onError.subscribe({ next: pe => { j.handleError(pe) } }); U.onDestroy(() => { L_(this._modules, U), ne.unsubscribe() }) }), function F_(o, c, u) { try { const g = u(); return I0(g) ? g.catch(b => { throw c.runOutsideAngular(() => o.handleError(b)), b }) : g } catch (g) { throw c.runOutsideAngular(() => o.handleError(g)), g } }(j, b, () => { const ne = U.injector.get(O_); return ne.runInitializers(), ne.donePromise.then(() => (Wg(U.injector.get(k_, Vp) || Vp), this._moduleDoBootstrap(U), U)) }) }) } bootstrapModule(u, g = []) { const b = ZC({}, g); return function Ov(o, c, u) { const g = new vb(u); return Promise.resolve(g) }(0, 0, u).then(D => this.bootstrapModuleFactory(D, b)) } _moduleDoBootstrap(u) { const g = u.injector.get(Pv); if (u._bootstrapComponents.length > 0) u._bootstrapComponents.forEach(b => g.bootstrap(b)); else { if (!u.instance.ngDoBootstrap) throw new De(-403, !1); u.instance.ngDoBootstrap(g) } this._modules.push(u) } onDestroy(u) { this._destroyListeners.push(u) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new De(404, !1); this._modules.slice().forEach(g => g.destroy()), this._destroyListeners.forEach(g => g()); const u = this._injector.get(Mv, null); u && (u.forEach(g => g()), u.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return o.\u0275fac = function (u) { return new (u || o)(sn(Mh)) }, o.\u0275prov = Ze({ token: o, factory: o.\u0275fac, providedIn: "platform" }), o })(); function ZC(o, c) { return Array.isArray(c) ? c.reduce(ZC, o) : { ...o, ...c } } let Pv = (() => { class o { get destroyed() { return this._destroyed } get injector() { return this._injector } constructor(u, g, b) { this._zone = u, this._injector = g, this._exceptionHandler = b, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const D = new J.y(U => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { U.next(this._stable), U.complete() }) }), N = new J.y(U => { let j; this._zone.runOutsideAngular(() => { j = this._zone.onStable.subscribe(() => { sd.assertNotInAngularZone(), im(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, U.next(!0)) }) }) }); const ne = this._zone.onUnstable.subscribe(() => { sd.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { U.next(!1) })) }); return () => { j.unsubscribe(), ne.unsubscribe() } }); this.isStable = (0, ye.T)(D, N.pipe((0, Ce.B)())) } bootstrap(u, g) { const b = u instanceof Xh; if (!this._injector.get(O_).done) throw !b && Gi(u), new De(405, false); let N; N = b ? u : this._injector.get(tf).resolveComponentFactory(u), this.componentTypes.push(N.componentType); const U = function eg(o) { return o.isBoundToModule }(N) ? void 0 : this._injector.get(Qg), ne = N.create(Mh.NULL, [], g || N.selector, U), pe = ne.location.nativeElement, He = ne.injector.get(om, null); return He?.registerApplication(pe), ne.onDestroy(() => { this.detachView(ne.hostView), L_(this.components, ne), He?.unregisterApplication(pe) }), this._loadComponent(ne), ne } tick() { if (this._runningTick) throw new De(101, !1); try { this._runningTick = !0; for (let u of this._views) u.detectChanges() } catch (u) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(u)) } finally { this._runningTick = !1 } } attachView(u) { const g = u; this._views.push(g), g.attachToAppRef(this) } detachView(u) { const g = u; L_(this._views, g), g.detachFromAppRef() } _loadComponent(u) { this.attachView(u.hostView), this.tick(), this.components.push(u); const g = this._injector.get(qs, []); g.push(...this._bootstrapListeners), g.forEach(b => b(u)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(u => u()), this._views.slice().forEach(u => u.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(u) { return this._destroyListeners.push(u), () => L_(this._destroyListeners, u) } destroy() { if (this._destroyed) throw new De(406, !1); const u = this._injector; u.destroy && !u.destroyed && u.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return o.\u0275fac = function (u) { return new (u || o)(sn(sd), sn(Ul), sn(Ah)) }, o.\u0275prov = Ze({ token: o, factory: o.\u0275fac, providedIn: "root" }), o })(); function L_(o, c) { const u = o.indexOf(c); u > -1 && o.splice(u, 1) } function qC() { return !1 } function rg() { } let YC = (() => { class o { } return o.__NG_ELEMENT_ID__ = V_, o })(); function V_(o) { return function $T(o, c, u) { if (gr(o) && !u) { const g = Zr(o.index, c); return new Op(g, g) } return 47 & o.type ? new Op(c[16], c) : null }(vs(), Jt(), 16 == (16 & o)) } class JC { constructor() { } supports(c) { return Ry(c) } create(c) { return new QC(c) } } const Ru = (o, c) => c; class QC { constructor(c) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = c || Ru } forEachItem(c) { let u; for (u = this._itHead; null !== u; u = u._next)c(u) } forEachOperation(c) { let u = this._itHead, g = this._removalsHead, b = 0, D = null; for (; u || g;) { const N = !g || u && u.currentIndex < mw(g, b, D) ? u : g, U = mw(N, b, D), j = N.currentIndex; if (N === g) b--, g = g._nextRemoved; else if (u = u._next, null == N.previousIndex) b++; else { D || (D = []); const ne = U - b, pe = j - b; if (ne != pe) { for (let Dt = 0; Dt < ne; Dt++) { const Ut = Dt < D.length ? D[Dt] : D[Dt] = 0, mn = Ut + Dt; pe <= mn && mn < ne && (D[Dt] = Ut + 1) } D[N.previousIndex] = pe - ne } } U !== j && c(N, U, j) } } forEachPreviousItem(c) { let u; for (u = this._previousItHead; null !== u; u = u._nextPrevious)c(u) } forEachAddedItem(c) { let u; for (u = this._additionsHead; null !== u; u = u._nextAdded)c(u) } forEachMovedItem(c) { let u; for (u = this._movesHead; null !== u; u = u._nextMoved)c(u) } forEachRemovedItem(c) { let u; for (u = this._removalsHead; null !== u; u = u._nextRemoved)c(u) } forEachIdentityChange(c) { let u; for (u = this._identityChangesHead; null !== u; u = u._nextIdentityChange)c(u) } diff(c) { if (null == c && (c = []), !Ry(c)) throw new De(900, !1); return this.check(c) ? this : null } onDestroy() { } check(c) { this._reset(); let b, D, N, u = this._itHead, g = !1; if (Array.isArray(c)) { this.length = c.length; for (let U = 0; U < this.length; U++)D = c[U], N = this._trackByFn(U, D), null !== u && Object.is(u.trackById, N) ? (g && (u = this._verifyReinsertion(u, D, N, U)), Object.is(u.item, D) || this._addIdentityChange(u, D)) : (u = this._mismatch(u, D, N, U), g = !0), u = u._next } else b = 0, function WE(o, c) { if (Array.isArray(o)) for (let u = 0; u < o.length; u++)c(o[u]); else { const u = o[Kf()](); let g; for (; !(g = u.next()).done;)c(g.value) } }(c, U => { N = this._trackByFn(b, U), null !== u && Object.is(u.trackById, N) ? (g && (u = this._verifyReinsertion(u, U, N, b)), Object.is(u.item, U) || this._addIdentityChange(u, U)) : (u = this._mismatch(u, U, N, b), g = !0), u = u._next, b++ }), this.length = b; return this._truncate(u), this.collection = c, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let c; for (c = this._previousItHead = this._itHead; null !== c; c = c._next)c._nextPrevious = c._next; for (c = this._additionsHead; null !== c; c = c._nextAdded)c.previousIndex = c.currentIndex; for (this._additionsHead = this._additionsTail = null, c = this._movesHead; null !== c; c = c._nextMoved)c.previousIndex = c.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(c, u, g, b) { let D; return null === c ? D = this._itTail : (D = c._prev, this._remove(c)), null !== (c = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(g, null)) ? (Object.is(c.item, u) || this._addIdentityChange(c, u), this._reinsertAfter(c, D, b)) : null !== (c = null === this._linkedRecords ? null : this._linkedRecords.get(g, b)) ? (Object.is(c.item, u) || this._addIdentityChange(c, u), this._moveAfter(c, D, b)) : c = this._addAfter(new H_(u, g), D, b), c } _verifyReinsertion(c, u, g, b) { let D = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(g, null); return null !== D ? c = this._reinsertAfter(D, c._prev, b) : c.currentIndex != b && (c.currentIndex = b, this._addToMoves(c, b)), c } _truncate(c) { for (; null !== c;) { const u = c._next; this._addToRemovals(this._unlink(c)), c = u } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(c, u, g) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(c); const b = c._prevRemoved, D = c._nextRemoved; return null === b ? this._removalsHead = D : b._nextRemoved = D, null === D ? this._removalsTail = b : D._prevRemoved = b, this._insertAfter(c, u, g), this._addToMoves(c, g), c } _moveAfter(c, u, g) { return this._unlink(c), this._insertAfter(c, u, g), this._addToMoves(c, g), c } _addAfter(c, u, g) { return this._insertAfter(c, u, g), this._additionsTail = null === this._additionsTail ? this._additionsHead = c : this._additionsTail._nextAdded = c, c } _insertAfter(c, u, g) { const b = null === u ? this._itHead : u._next; return c._next = b, c._prev = u, null === b ? this._itTail = c : b._prev = c, null === u ? this._itHead = c : u._next = c, null === this._linkedRecords && (this._linkedRecords = new uh), this._linkedRecords.put(c), c.currentIndex = g, c } _remove(c) { return this._addToRemovals(this._unlink(c)) } _unlink(c) { null !== this._linkedRecords && this._linkedRecords.remove(c); const u = c._prev, g = c._next; return null === u ? this._itHead = g : u._next = g, null === g ? this._itTail = u : g._prev = u, c } _addToMoves(c, u) { return c.previousIndex === u || (this._movesTail = null === this._movesTail ? this._movesHead = c : this._movesTail._nextMoved = c), c } _addToRemovals(c) { return null === this._unlinkedRecords && (this._unlinkedRecords = new uh), this._unlinkedRecords.put(c), c.currentIndex = null, c._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = c, c._prevRemoved = null) : (c._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = c), c } _addIdentityChange(c, u) { return c.item = u, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = c : this._identityChangesTail._nextIdentityChange = c, c } } class H_ { constructor(c, u) { this.item = c, this.trackById = u, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class XC { constructor() { this._head = null, this._tail = null } add(c) { null === this._head ? (this._head = this._tail = c, c._nextDup = null, c._prevDup = null) : (this._tail._nextDup = c, c._prevDup = this._tail, c._nextDup = null, this._tail = c) } get(c, u) { let g; for (g = this._head; null !== g; g = g._nextDup)if ((null === u || u <= g.currentIndex) && Object.is(g.trackById, c)) return g; return null } remove(c) { const u = c._prevDup, g = c._nextDup; return null === u ? this._head = g : u._nextDup = g, null === g ? this._tail = u : g._prevDup = u, null === this._head } } class uh { constructor() { this.map = new Map } put(c) { const u = c.trackById; let g = this.map.get(u); g || (g = new XC, this.map.set(u, g)), g.add(c) } get(c, u) { const b = this.map.get(c); return b ? b.get(c, u) : null } remove(c) { const u = c.trackById; return this.map.get(u).remove(c) && this.map.delete(u), c } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function mw(o, c, u) { const g = o.previousIndex; if (null === g) return g; let b = 0; return u && g < u.length && (b = u[g]), g + c + b } class cm { constructor() { } supports(c) { return c instanceof Map || b0(c) } create() { return new JT } } class JT { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(c) { let u; for (u = this._mapHead; null !== u; u = u._next)c(u) } forEachPreviousItem(c) { let u; for (u = this._previousMapHead; null !== u; u = u._nextPrevious)c(u) } forEachChangedItem(c) { let u; for (u = this._changesHead; null !== u; u = u._nextChanged)c(u) } forEachAddedItem(c) { let u; for (u = this._additionsHead; null !== u; u = u._nextAdded)c(u) } forEachRemovedItem(c) { let u; for (u = this._removalsHead; null !== u; u = u._nextRemoved)c(u) } diff(c) { if (c) { if (!(c instanceof Map || b0(c))) throw new De(900, !1) } else c = new Map; return this.check(c) ? this : null } onDestroy() { } check(c) { this._reset(); let u = this._mapHead; if (this._appendAfter = null, this._forEach(c, (g, b) => { if (u && u.key === b) this._maybeAddToChanges(u, g), this._appendAfter = u, u = u._next; else { const D = this._getOrCreateRecordForKey(b, g); u = this._insertBeforeOrAppend(u, D) } }), u) { u._prev && (u._prev._next = null), this._removalsHead = u; for (let g = u; null !== g; g = g._nextRemoved)g === this._mapHead && (this._mapHead = null), this._records.delete(g.key), g._nextRemoved = g._next, g.previousValue = g.currentValue, g.currentValue = null, g._prev = null, g._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(c, u) { if (c) { const g = c._prev; return u._next = c, u._prev = g, c._prev = u, g && (g._next = u), c === this._mapHead && (this._mapHead = u), this._appendAfter = c, c } return this._appendAfter ? (this._appendAfter._next = u, u._prev = this._appendAfter) : this._mapHead = u, this._appendAfter = u, null } _getOrCreateRecordForKey(c, u) { if (this._records.has(c)) { const b = this._records.get(c); this._maybeAddToChanges(b, u); const D = b._prev, N = b._next; return D && (D._next = N), N && (N._prev = D), b._next = null, b._prev = null, b } const g = new QT(c); return this._records.set(c, g), g.currentValue = u, this._addToAdditions(g), g } _reset() { if (this.isDirty) { let c; for (this._previousMapHead = this._mapHead, c = this._previousMapHead; null !== c; c = c._next)c._nextPrevious = c._next; for (c = this._changesHead; null !== c; c = c._nextChanged)c.previousValue = c.currentValue; for (c = this._additionsHead; null != c; c = c._nextAdded)c.previousValue = c.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(c, u) { Object.is(u, c.currentValue) || (c.previousValue = c.currentValue, c.currentValue = u, this._addToChanges(c)) } _addToAdditions(c) { null === this._additionsHead ? this._additionsHead = this._additionsTail = c : (this._additionsTail._nextAdded = c, this._additionsTail = c) } _addToChanges(c) { null === this._changesHead ? this._changesHead = this._changesTail = c : (this._changesTail._nextChanged = c, this._changesTail = c) } _forEach(c, u) { c instanceof Map ? c.forEach(u) : Object.keys(c).forEach(g => u(c[g], g)) } } class QT { constructor(c) { this.key = c, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Ci() { return new _w([new JC]) } let _w = (() => { class o { constructor(u) { this.factories = u } static create(u, g) { if (null != g) { const b = g.factories.slice(); u = u.concat(b) } return new o(u) } static extend(u) { return { provide: o, useFactory: g => o.create(u, g || Ci()), deps: [[o, new ee, new vi]] } } find(u) { const g = this.factories.find(b => b.supports(u)); if (null != g) return g; throw new De(901, !1) } } return o.\u0275prov = Ze({ token: o, providedIn: "root", factory: Ci }), o })(); function um() { return new og([new cm]) } let og = (() => { class o { constructor(u) { this.factories = u } static create(u, g) { if (g) { const b = g.factories.slice(); u = u.concat(b) } return new o(u) } static extend(u) { return { provide: o, useFactory: g => o.create(u, g || um()), deps: [[o, new ee, new vi]] } } find(u) { const g = this.factories.find(b => b.supports(u)); if (g) return g; throw new De(901, !1) } } return o.\u0275prov = Ze({ token: o, providedIn: "root", factory: um }), o })(); const tD = kv(null, "core", []); let tE = (() => { class o { constructor(u) { } } return o.\u0275fac = function (u) { return new (u || o)(sn(Pv)) }, o.\u0275mod = Dr({ type: o }), o.\u0275inj = le({}), o })(); function nE(o) { return "boolean" == typeof o ? o : null != o && "false" !== o } function G_(o, c) { const u = Hr(o), g = c.elementInjector || Iu(); return new Hc(u).create(g, c.projectableNodes, c.hostElement, c.environmentInjector) } }, 4006: (un, Je, L) => { "use strict"; L.d(Je, { Cf: () => je, EJ: () => Ys, F: () => Ti, Fj: () => Se, JJ: () => dn, JL: () => ue, JU: () => Ee, Kr: () => Ss, NI: () => Rs, On: () => ro, Q7: () => As, UX: () => Xs, Wl: () => ae, YN: () => Go, Zs: () => Pa, _Y: () => ft, a5: () => wn, cw: () => mt, gN: () => jt, kI: () => ct, nD: () => Js, oH: () => gr, qu: () => Oo, sg: () => us, u: () => ka, u5: () => hr, wV: () => Mt }); var i = L(4650), m = L(6895), J = L(8996), ye = L(4128), Ce = L(4004); let we = (() => { class Q { constructor($, me) { this._renderer = $, this._elementRef = me, this.onChange = Rt => { }, this.onTouched = () => { } } setProperty($, me) { this._renderer.setProperty(this._elementRef.nativeElement, $, me) } registerOnTouched($) { this.onTouched = $ } registerOnChange($) { this.onChange = $ } setDisabledState($) { this.setProperty("disabled", $) } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(i.Qsj), i.Y36(i.SBq)) }, Q.\u0275dir = i.lG2({ type: Q }), Q })(), Te = (() => { class Q extends we { } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, features: [i.qOj] }), Q })(); const Ee = new i.OlP("NgValueAccessor"), _e = { provide: Ee, useExisting: (0, i.Gpc)(() => ae), multi: !0 }; let ae = (() => { class Q extends Te { writeValue($) { this.setProperty("checked", $) } } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]], hostBindings: function ($, me) { 1 & $ && i.NdJ("change", function (Bn) { return me.onChange(Bn.target.checked) })("blur", function () { return me.onTouched() }) }, features: [i._Bn([_e]), i.qOj] }), Q })(); const ve = { provide: Ee, useExisting: (0, i.Gpc)(() => Se), multi: !0 }, gt = new i.OlP("CompositionEventMode"); let Se = (() => { class Q extends we { constructor($, me, Rt) { super($, me), this._compositionMode = Rt, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function xe() { const Q = (0, m.q)() ? (0, m.q)().getUserAgent() : ""; return /android (\d+)/.test(Q.toLowerCase()) }()) } writeValue($) { this.setProperty("value", $ ?? "") } _handleInput($) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange($) } _compositionStart() { this._composing = !0 } _compositionEnd($) { this._composing = !1, this._compositionMode && this.onChange($) } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(i.Qsj), i.Y36(i.SBq), i.Y36(gt, 8)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function ($, me) { 1 & $ && i.NdJ("input", function (Bn) { return me._handleInput(Bn.target.value) })("blur", function () { return me.onTouched() })("compositionstart", function () { return me._compositionStart() })("compositionend", function (Bn) { return me._compositionEnd(Bn.target.value) }) }, features: [i._Bn([ve]), i.qOj] }), Q })(); function wt(Q) { return null == Q || ("string" == typeof Q || Array.isArray(Q)) && 0 === Q.length } function De(Q) { return null != Q && "number" == typeof Q.length } const je = new i.OlP("NgValidators"), _t = new i.OlP("NgAsyncValidators"), Qe = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class ct { static min(q) { return function Oe(Q) { return q => { if (wt(q.value) || wt(Q)) return null; const $ = parseFloat(q.value); return !isNaN($) && $ < Q ? { min: { min: Q, actual: q.value } } : null } }(q) } static max(q) { return function Ve(Q) { return q => { if (wt(q.value) || wt(Q)) return null; const $ = parseFloat(q.value); return !isNaN($) && $ > Q ? { max: { max: Q, actual: q.value } } : null } }(q) } static required(q) { return Be(q) } static requiredTrue(q) { return nt(q) } static email(q) { return function Ne(Q) { return wt(Q.value) || Qe.test(Q.value) ? null : { email: !0 } }(q) } static minLength(q) { return function tt(Q) { return q => wt(q.value) || !De(q.value) ? null : q.value.length < Q ? { minlength: { requiredLength: Q, actualLength: q.value.length } } : null }(q) } static maxLength(q) { return Fe(q) } static pattern(q) { return function Ue(Q) { if (!Q) return st; let q, $; return "string" == typeof Q ? ($ = "", "^" !== Q.charAt(0) && ($ += "^"), $ += Q, "$" !== Q.charAt(Q.length - 1) && ($ += "$"), q = new RegExp($)) : ($ = Q.toString(), q = Q), me => { if (wt(me.value)) return null; const Rt = me.value; return q.test(Rt) ? null : { pattern: { requiredPattern: $, actualValue: Rt } } } }(q) } static nullValidator(q) { return null } static compose(q) { return kn(q) } static composeAsync(q) { return It(q) } } function Be(Q) { return wt(Q.value) ? { required: !0 } : null } function nt(Q) { return !0 === Q.value ? null : { required: !0 } } function Fe(Q) { return q => De(q.value) && q.value.length > Q ? { maxlength: { requiredLength: Q, actualLength: q.value.length } } : null } function st(Q) { return null } function ht(Q) { return null != Q } function Kt(Q) { return (0, i.QGY)(Q) ? (0, J.D)(Q) : Q } function rn(Q) { let q = {}; return Q.forEach($ => { q = null != $ ? { ...q, ...$ } : q }), 0 === Object.keys(q).length ? null : q } function On(Q, q) { return q.map($ => $(Q)) } function nr(Q) { return Q.map(q => function qn(Q) { return !Q.validate }(q) ? q : $ => q.validate($)) } function kn(Q) { if (!Q) return null; const q = Q.filter(ht); return 0 == q.length ? null : function ($) { return rn(On($, q)) } } function fn(Q) { return null != Q ? kn(nr(Q)) : null } function It(Q) { if (!Q) return null; const q = Q.filter(ht); return 0 == q.length ? null : function ($) { const me = On($, q).map(Kt); return (0, ye.D)(me).pipe((0, Ce.U)(rn)) } } function Yt(Q) { return null != Q ? It(nr(Q)) : null } function pt(Q, q) { return null === Q ? [q] : Array.isArray(Q) ? [...Q, q] : [Q, q] } function Pt(Q) { return Q._rawValidators } function Ze(Q) { return Q._rawAsyncValidators } function Ot(Q) { return Q ? Array.isArray(Q) ? Q : [Q] : [] } function le(Q, q) { return Array.isArray(Q) ? Q.includes(q) : Q === q } function Xe(Q, q) { const $ = Ot(q); return Ot(Q).forEach(Rt => { le($, Rt) || $.push(Rt) }), $ } function kt(Q, q) { return Ot(q).filter($ => !le(Q, $)) } class an { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(q) { this._rawValidators = q || [], this._composedValidatorFn = fn(this._rawValidators) } _setAsyncValidators(q) { this._rawAsyncValidators = q || [], this._composedAsyncValidatorFn = Yt(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(q) { this._onDestroyCallbacks.push(q) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(q => q()), this._onDestroyCallbacks = [] } reset(q) { this.control && this.control.reset(q) } hasError(q, $) { return !!this.control && this.control.hasError(q, $) } getError(q, $) { return this.control ? this.control.getError(q, $) : null } } class jt extends an { get formDirective() { return null } get path() { return null } } class wn extends an { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Jn { constructor(q) { this._cd = q } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let dn = (() => { class Q extends Jn { constructor($) { super($) } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(wn, 2)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function ($, me) { 2 & $ && i.ekj("ng-untouched", me.isUntouched)("ng-touched", me.isTouched)("ng-pristine", me.isPristine)("ng-dirty", me.isDirty)("ng-valid", me.isValid)("ng-invalid", me.isInvalid)("ng-pending", me.isPending) }, features: [i.qOj] }), Q })(), ue = (() => { class Q extends Jn { constructor($) { super($) } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(jt, 10)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function ($, me) { 2 & $ && i.ekj("ng-untouched", me.isUntouched)("ng-touched", me.isTouched)("ng-pristine", me.isPristine)("ng-dirty", me.isDirty)("ng-valid", me.isValid)("ng-invalid", me.isInvalid)("ng-pending", me.isPending)("ng-submitted", me.isSubmitted) }, features: [i.qOj] }), Q })(); const Gt = "VALID", bn = "INVALID", sn = "PENDING", Bt = "DISABLED"; function vt(Q) { return (fe(Q) ? Q.validators : Q) || null } function qe(Q, q) { return (fe(q) ? q.asyncValidators : Q) || null } function fe(Q) { return null != Q && !Array.isArray(Q) && "object" == typeof Q } function ke(Q, q, $) { const me = Q.controls; if (!(q ? Object.keys(me) : me).length) throw new i.vHH(1e3, ""); if (!me[$]) throw new i.vHH(1001, "") } function et(Q, q, $) { Q._forEachChild((me, Rt) => { if (void 0 === $[Rt]) throw new i.vHH(1002, "") }) } class Lt { constructor(q, $) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(q), this._assignAsyncValidators($) } get validator() { return this._composedValidatorFn } set validator(q) { this._rawValidators = this._composedValidatorFn = q } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(q) { this._rawAsyncValidators = this._composedAsyncValidatorFn = q } get parent() { return this._parent } get valid() { return this.status === Gt } get invalid() { return this.status === bn } get pending() { return this.status == sn } get disabled() { return this.status === Bt } get enabled() { return this.status !== Bt } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(q) { this._assignValidators(q) } setAsyncValidators(q) { this._assignAsyncValidators(q) } addValidators(q) { this.setValidators(Xe(q, this._rawValidators)) } addAsyncValidators(q) { this.setAsyncValidators(Xe(q, this._rawAsyncValidators)) } removeValidators(q) { this.setValidators(kt(q, this._rawValidators)) } removeAsyncValidators(q) { this.setAsyncValidators(kt(q, this._rawAsyncValidators)) } hasValidator(q) { return le(this._rawValidators, q) } hasAsyncValidator(q) { return le(this._rawAsyncValidators, q) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(q = {}) { this.touched = !0, this._parent && !q.onlySelf && this._parent.markAsTouched(q) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(q => q.markAllAsTouched()) } markAsUntouched(q = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild($ => { $.markAsUntouched({ onlySelf: !0 }) }), this._parent && !q.onlySelf && this._parent._updateTouched(q) } markAsDirty(q = {}) { this.pristine = !1, this._parent && !q.onlySelf && this._parent.markAsDirty(q) } markAsPristine(q = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild($ => { $.markAsPristine({ onlySelf: !0 }) }), this._parent && !q.onlySelf && this._parent._updatePristine(q) } markAsPending(q = {}) { this.status = sn, !1 !== q.emitEvent && this.statusChanges.emit(this.status), this._parent && !q.onlySelf && this._parent.markAsPending(q) } disable(q = {}) { const $ = this._parentMarkedDirty(q.onlySelf); this.status = Bt, this.errors = null, this._forEachChild(me => { me.disable({ ...q, onlySelf: !0 }) }), this._updateValue(), !1 !== q.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...q, skipPristineCheck: $ }), this._onDisabledChange.forEach(me => me(!0)) } enable(q = {}) { const $ = this._parentMarkedDirty(q.onlySelf); this.status = Gt, this._forEachChild(me => { me.enable({ ...q, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: q.emitEvent }), this._updateAncestors({ ...q, skipPristineCheck: $ }), this._onDisabledChange.forEach(me => me(!1)) } _updateAncestors(q) { this._parent && !q.onlySelf && (this._parent.updateValueAndValidity(q), q.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(q) { this._parent = q } getRawValue() { return this.value } updateValueAndValidity(q = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Gt || this.status === sn) && this._runAsyncValidator(q.emitEvent)), !1 !== q.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !q.onlySelf && this._parent.updateValueAndValidity(q) } _updateTreeValidity(q = { emitEvent: !0 }) { this._forEachChild($ => $._updateTreeValidity(q)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: q.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Bt : Gt } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(q) { if (this.asyncValidator) { this.status = sn, this._hasOwnPendingAsyncValidator = !0; const $ = Kt(this.asyncValidator(this)); this._asyncValidationSubscription = $.subscribe(me => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(me, { emitEvent: q }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(q, $ = {}) { this.errors = q, this._updateControlsErrors(!1 !== $.emitEvent) } get(q) { let $ = q; return null == $ || (Array.isArray($) || ($ = $.split(".")), 0 === $.length) ? null : $.reduce((me, Rt) => me && me._find(Rt), this) } getError(q, $) { const me = $ ? this.get($) : this; return me && me.errors ? me.errors[q] : null } hasError(q, $) { return !!this.getError(q, $) } get root() { let q = this; for (; q._parent;)q = q._parent; return q } _updateControlsErrors(q) { this.status = this._calculateStatus(), q && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(q) } _initObservables() { this.valueChanges = new i.vpe, this.statusChanges = new i.vpe } _calculateStatus() { return this._allControlsDisabled() ? Bt : this.errors ? bn : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(sn) ? sn : this._anyControlsHaveStatus(bn) ? bn : Gt } _anyControlsHaveStatus(q) { return this._anyControls($ => $.status === q) } _anyControlsDirty() { return this._anyControls(q => q.dirty) } _anyControlsTouched() { return this._anyControls(q => q.touched) } _updatePristine(q = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !q.onlySelf && this._parent._updatePristine(q) } _updateTouched(q = {}) { this.touched = this._anyControlsTouched(), this._parent && !q.onlySelf && this._parent._updateTouched(q) } _registerOnCollectionChange(q) { this._onCollectionChange = q } _setUpdateStrategy(q) { fe(q) && null != q.updateOn && (this._updateOn = q.updateOn) } _parentMarkedDirty(q) { return !q && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(q) { return null } _assignValidators(q) { this._rawValidators = Array.isArray(q) ? q.slice() : q, this._composedValidatorFn = function Le(Q) { return Array.isArray(Q) ? fn(Q) : Q || null }(this._rawValidators) } _assignAsyncValidators(q) { this._rawAsyncValidators = Array.isArray(q) ? q.slice() : q, this._composedAsyncValidatorFn = function Zt(Q) { return Array.isArray(Q) ? Yt(Q) : Q || null }(this._rawAsyncValidators) } } class mt extends Lt { constructor(q, $, me) { super(vt($), qe(me, $)), this.controls = q, this._initObservables(), this._setUpdateStrategy($), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(q, $) { return this.controls[q] ? this.controls[q] : (this.controls[q] = $, $.setParent(this), $._registerOnCollectionChange(this._onCollectionChange), $) } addControl(q, $, me = {}) { this.registerControl(q, $), this.updateValueAndValidity({ emitEvent: me.emitEvent }), this._onCollectionChange() } removeControl(q, $ = {}) { this.controls[q] && this.controls[q]._registerOnCollectionChange(() => { }), delete this.controls[q], this.updateValueAndValidity({ emitEvent: $.emitEvent }), this._onCollectionChange() } setControl(q, $, me = {}) { this.controls[q] && this.controls[q]._registerOnCollectionChange(() => { }), delete this.controls[q], $ && this.registerControl(q, $), this.updateValueAndValidity({ emitEvent: me.emitEvent }), this._onCollectionChange() } contains(q) { return this.controls.hasOwnProperty(q) && this.controls[q].enabled } setValue(q, $ = {}) { et(this, 0, q), Object.keys(q).forEach(me => { ke(this, !0, me), this.controls[me].setValue(q[me], { onlySelf: !0, emitEvent: $.emitEvent }) }), this.updateValueAndValidity($) } patchValue(q, $ = {}) { null != q && (Object.keys(q).forEach(me => { const Rt = this.controls[me]; Rt && Rt.patchValue(q[me], { onlySelf: !0, emitEvent: $.emitEvent }) }), this.updateValueAndValidity($)) } reset(q = {}, $ = {}) { this._forEachChild((me, Rt) => { me.reset(q[Rt], { onlySelf: !0, emitEvent: $.emitEvent }) }), this._updatePristine($), this._updateTouched($), this.updateValueAndValidity($) } getRawValue() { return this._reduceChildren({}, (q, $, me) => (q[me] = $.getRawValue(), q)) } _syncPendingControls() { let q = this._reduceChildren(!1, ($, me) => !!me._syncPendingControls() || $); return q && this.updateValueAndValidity({ onlySelf: !0 }), q } _forEachChild(q) { Object.keys(this.controls).forEach($ => { const me = this.controls[$]; me && q(me, $) }) } _setUpControls() { this._forEachChild(q => { q.setParent(this), q._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(q) { for (const [$, me] of Object.entries(this.controls)) if (this.contains($) && q(me)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, ($, me, Rt) => ((me.enabled || this.disabled) && ($[Rt] = me.value), $)) } _reduceChildren(q, $) { let me = q; return this._forEachChild((Rt, Bn) => { me = $(me, Rt, Bn) }), me } _allControlsDisabled() { for (const q of Object.keys(this.controls)) if (this.controls[q].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(q) { return this.controls.hasOwnProperty(q) ? this.controls[q] : null } } class sr extends mt { } const ze = new i.OlP("CallSetDisabledState", { providedIn: "root", factory: () => Ye }), Ye = "always"; function Ie(Q, q) { return [...q.path, Q] } function Ct(Q, q, $ = Ye) { ti(Q, q), q.valueAccessor.writeValue(Q.value), (Q.disabled || "always" === $) && q.valueAccessor.setDisabledState?.(Q.disabled), function ss(Q, q) { q.valueAccessor.registerOnChange($ => { Q._pendingValue = $, Q._pendingChange = !0, Q._pendingDirty = !0, "change" === Q.updateOn && vo(Q, q) }) }(Q, q), function Dr(Q, q) { const $ = (me, Rt) => { q.valueAccessor.writeValue(me), Rt && q.viewToModelUpdate(me) }; Q.registerOnChange($), q._registerOnDestroy(() => { Q._unregisterOnChange($) }) }(Q, q), function Ps(Q, q) { q.valueAccessor.registerOnTouched(() => { Q._pendingTouched = !0, "blur" === Q.updateOn && Q._pendingChange && vo(Q, q), "submit" !== Q.updateOn && Q.markAsTouched() }) }(Q, q), function zn(Q, q) { if (q.valueAccessor.setDisabledState) { const $ = me => { q.valueAccessor.setDisabledState(me) }; Q.registerOnDisabledChange($), q._registerOnDestroy(() => { Q._unregisterOnDisabledChange($) }) } }(Q, q) } function nn(Q, q, $ = !0) { const me = () => { }; q.valueAccessor && (q.valueAccessor.registerOnChange(me), q.valueAccessor.registerOnTouched(me)), Br(Q, q), Q && (q._invokeOnDestroyCallbacks(), Q._registerOnCollectionChange(() => { })) } function xn(Q, q) { Q.forEach($ => { $.registerOnValidatorChange && $.registerOnValidatorChange(q) }) } function ti(Q, q) { const $ = Pt(Q); null !== q.validator ? Q.setValidators(pt($, q.validator)) : "function" == typeof $ && Q.setValidators([$]); const me = Ze(Q); null !== q.asyncValidator ? Q.setAsyncValidators(pt(me, q.asyncValidator)) : "function" == typeof me && Q.setAsyncValidators([me]); const Rt = () => Q.updateValueAndValidity(); xn(q._rawValidators, Rt), xn(q._rawAsyncValidators, Rt) } function Br(Q, q) { let $ = !1; if (null !== Q) { if (null !== q.validator) { const Rt = Pt(Q); if (Array.isArray(Rt) && Rt.length > 0) { const Bn = Rt.filter(wi => wi !== q.validator); Bn.length !== Rt.length && ($ = !0, Q.setValidators(Bn)) } } if (null !== q.asyncValidator) { const Rt = Ze(Q); if (Array.isArray(Rt) && Rt.length > 0) { const Bn = Rt.filter(wi => wi !== q.asyncValidator); Bn.length !== Rt.length && ($ = !0, Q.setAsyncValidators(Bn)) } } } const me = () => { }; return xn(q._rawValidators, me), xn(q._rawAsyncValidators, me), $ } function vo(Q, q) { Q._pendingDirty && Q.markAsDirty(), Q.setValue(Q._pendingValue, { emitModelToViewChange: !1 }), q.viewToModelUpdate(Q._pendingValue), Q._pendingChange = !1 } function Bi(Q, q) { ti(Q, q) } function Gi(Q, q) { if (!Q.hasOwnProperty("model")) return !1; const $ = Q.model; return !!$.isFirstChange() || !Object.is(q, $.currentValue) } function Gs(Q, q) { Q._syncPendingControls(), q.forEach($ => { const me = $.control; "submit" === me.updateOn && me._pendingChange && ($.viewToModelUpdate(me._pendingValue), me._pendingChange = !1) }) } function Ln(Q, q) { if (!q) return null; let $, me, Rt; return Array.isArray(q), q.forEach(Bn => { Bn.constructor === Se ? $ = Bn : function Qi(Q) { return Object.getPrototypeOf(Q.constructor) === Te }(Bn) ? me = Bn : Rt = Bn }), Rt || me || $ || null } const as = { provide: jt, useExisting: (0, i.Gpc)(() => Ti) }, Xi = (() => Promise.resolve())(); let Ti = (() => { class Q extends jt { constructor($, me, Rt) { super(), this.callSetDisabledState = Rt, this.submitted = !1, this._directives = new Set, this.ngSubmit = new i.vpe, this.form = new mt({}, fn($), Yt(me)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl($) { Xi.then(() => { const me = this._findContainer($.path); $.control = me.registerControl($.name, $.control), Ct($.control, $, this.callSetDisabledState), $.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add($) }) } getControl($) { return this.form.get($.path) } removeControl($) { Xi.then(() => { const me = this._findContainer($.path); me && me.removeControl($.name), this._directives.delete($) }) } addFormGroup($) { Xi.then(() => { const me = this._findContainer($.path), Rt = new mt({}); Bi(Rt, $), me.registerControl($.name, Rt), Rt.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup($) { Xi.then(() => { const me = this._findContainer($.path); me && me.removeControl($.name) }) } getFormGroup($) { return this.form.get($.path) } updateModel($, me) { Xi.then(() => { this.form.get($.path).setValue(me) }) } setValue($) { this.control.setValue($) } onSubmit($) { return this.submitted = !0, Gs(this.form, this._directives), this.ngSubmit.emit($), "dialog" === $?.target?.method } onReset() { this.resetForm() } resetForm($) { this.form.reset($), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer($) { return $.pop(), $.length ? this.form.get($) : this.form } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(je, 10), i.Y36(_t, 10), i.Y36(ze, 8)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function ($, me) { 1 & $ && i.NdJ("submit", function (Bn) { return me.onSubmit(Bn) })("reset", function () { return me.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [i._Bn([as]), i.qOj] }), Q })(); function _s(Q, q) { const $ = Q.indexOf(q); $ > -1 && Q.splice($, 1) } function Di(Q) { return "object" == typeof Q && null !== Q && 2 === Object.keys(Q).length && "value" in Q && "disabled" in Q } const Rs = class extends Lt { constructor(q = null, $, me) { super(vt($), qe(me, $)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(q), this._setUpdateStrategy($), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), fe($) && ($.nonNullable || $.initialValueIsDefault) && (this.defaultValue = Di(q) ? q.value : q) } setValue(q, $ = {}) { this.value = this._pendingValue = q, this._onChange.length && !1 !== $.emitModelToViewChange && this._onChange.forEach(me => me(this.value, !1 !== $.emitViewToModelChange)), this.updateValueAndValidity($) } patchValue(q, $ = {}) { this.setValue(q, $) } reset(q = this.defaultValue, $ = {}) { this._applyFormState(q), this.markAsPristine($), this.markAsUntouched($), this.setValue(this.value, $), this._pendingChange = !1 } _updateValue() { } _anyControls(q) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(q) { this._onChange.push(q) } _unregisterOnChange(q) { _s(this._onChange, q) } registerOnDisabledChange(q) { this._onDisabledChange.push(q) } _unregisterOnDisabledChange(q) { _s(this._onDisabledChange, q) } _forEachChild(q) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(q) { Di(q) ? (this.value = this._pendingValue = q.value, q.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = q } }, Fs = { provide: wn, useExisting: (0, i.Gpc)(() => ro) }, cs = (() => Promise.resolve())(); let ro = (() => { class Q extends wn { constructor($, me, Rt, Bn, wi, Jt) { super(), this._changeDetectorRef = wi, this.callSetDisabledState = Jt, this.control = new Rs, this._registered = !1, this.update = new i.vpe, this._parent = $, this._setValidators(me), this._setAsyncValidators(Rt), this.valueAccessor = Ln(0, Bn) } ngOnChanges($) { if (this._checkForErrors(), !this._registered || "name" in $) { if (this._registered && (this._checkName(), this.formDirective)) { const me = $.name.previousValue; this.formDirective.removeControl({ name: me, path: this._getPath(me) }) } this._setUpControl() } "isDisabled" in $ && this._updateDisabled($), Gi($, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate($) { this.viewModel = $, this.update.emit($) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { Ct(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue($) { cs.then(() => { this.control.setValue($, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled($) { const me = $.isDisabled.currentValue, Rt = 0 !== me && (0, i.D6c)(me); cs.then(() => { Rt && !this.control.disabled ? this.control.disable() : !Rt && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath($) { return this._parent ? Ie($, this._parent) : [$] } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(jt, 9), i.Y36(je, 10), i.Y36(_t, 10), i.Y36(Ee, 10), i.Y36(i.sBO, 8), i.Y36(ze, 8)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [i._Bn([Fs]), i.qOj, i.TTD] }), Q })(), ft = (() => { class Q { } return Q.\u0275fac = function ($) { return new ($ || Q) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), Q })(); const dt = { provide: Ee, useExisting: (0, i.Gpc)(() => Mt), multi: !0 }; let Mt = (() => { class Q extends Te { writeValue($) { this.setProperty("value", $ ?? "") } registerOnChange($) { this.onChange = me => { $("" == me ? null : parseFloat(me)) } } } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function ($, me) { 1 & $ && i.NdJ("input", function (Bn) { return me.onChange(Bn.target.value) })("blur", function () { return me.onTouched() }) }, features: [i._Bn([dt]), i.qOj] }), Q })(), Yn = (() => { class Q { } return Q.\u0275fac = function ($) { return new ($ || Q) }, Q.\u0275mod = i.oAB({ type: Q }), Q.\u0275inj = i.cJS({}), Q })(); const Ts = new i.OlP("NgModelWithFormControlWarning"), Ds = { provide: wn, useExisting: (0, i.Gpc)(() => gr) }; let gr = (() => { class Q extends wn { set isDisabled($) { } constructor($, me, Rt, Bn, wi) { super(), this._ngModelWarningConfig = Bn, this.callSetDisabledState = wi, this.update = new i.vpe, this._ngModelWarningSent = !1, this._setValidators($), this._setAsyncValidators(me), this.valueAccessor = Ln(0, Rt) } ngOnChanges($) { if (this._isControlChanged($)) { const me = $.form.previousValue; me && nn(me, this, !1), Ct(this.form, this, this.callSetDisabledState), this.form.updateValueAndValidity({ emitEvent: !1 }) } Gi($, this.viewModel) && (this.form.setValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.form && nn(this.form, this, !1) } get path() { return [] } get control() { return this.form } viewToModelUpdate($) { this.viewModel = $, this.update.emit($) } _isControlChanged($) { return $.hasOwnProperty("form") } } return Q._ngModelWarningSentOnce = !1, Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(je, 10), i.Y36(_t, 10), i.Y36(Ee, 10), i.Y36(Ts, 8), i.Y36(ze, 8)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "formControl", ""]], inputs: { form: ["formControl", "form"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngForm"], features: [i._Bn([Ds]), i.qOj, i.TTD] }), Q })(); const xl = { provide: jt, useExisting: (0, i.Gpc)(() => us) }; let us = (() => { class Q extends jt { constructor($, me, Rt) { super(), this.callSetDisabledState = Rt, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new i.vpe, this._setValidators($), this._setAsyncValidators(me) } ngOnChanges($) { this._checkFormPresent(), $.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Br(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl($) { const me = this.form.get($.path); return Ct(me, $, this.callSetDisabledState), me.updateValueAndValidity({ emitEvent: !1 }), this.directives.push($), me } getControl($) { return this.form.get($.path) } removeControl($) { nn($.control || null, $, !1), function pr(Q, q) { const $ = Q.indexOf(q); $ > -1 && Q.splice($, 1) }(this.directives, $) } addFormGroup($) { this._setUpFormContainer($) } removeFormGroup($) { this._cleanUpFormContainer($) } getFormGroup($) { return this.form.get($.path) } addFormArray($) { this._setUpFormContainer($) } removeFormArray($) { this._cleanUpFormContainer($) } getFormArray($) { return this.form.get($.path) } updateModel($, me) { this.form.get($.path).setValue(me) } onSubmit($) { return this.submitted = !0, Gs(this.form, this.directives), this.ngSubmit.emit($), "dialog" === $?.target?.method } onReset() { this.resetForm() } resetForm($) { this.form.reset($), this.submitted = !1 } _updateDomValue() { this.directives.forEach($ => { const me = $.control, Rt = this.form.get($.path); me !== Rt && (nn(me || null, $), (Q => Q instanceof Rs)(Rt) && (Ct(Rt, $, this.callSetDisabledState), $.control = Rt)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer($) { const me = this.form.get($.path); Bi(me, $), me.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer($) { if (this.form) { const me = this.form.get($.path); me && function _a(Q, q) { return Br(Q, q) }(me, $) && me.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { ti(this.form, this), this._oldForm && Br(this._oldForm, this) } _checkFormPresent() { } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(je, 10), i.Y36(_t, 10), i.Y36(ze, 8)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "formGroup", ""]], hostBindings: function ($, me) { 1 & $ && i.NdJ("submit", function (Bn) { return me.onSubmit(Bn) })("reset", function () { return me.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [i._Bn([xl]), i.qOj, i.TTD] }), Q })(); const Si = { provide: wn, useExisting: (0, i.Gpc)(() => ka) }; let ka = (() => { class Q extends wn { set isDisabled($) { } constructor($, me, Rt, Bn, wi) { super(), this._ngModelWarningConfig = wi, this._added = !1, this.update = new i.vpe, this._ngModelWarningSent = !1, this._parent = $, this._setValidators(me), this._setAsyncValidators(Rt), this.valueAccessor = Ln(0, Bn) } ngOnChanges($) { this._added || this._setUpControl(), Gi($, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate($) { this.viewModel = $, this.update.emit($) } get path() { return Ie(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } } return Q._ngModelWarningSentOnce = !1, Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(jt, 13), i.Y36(je, 10), i.Y36(_t, 10), i.Y36(Ee, 10), i.Y36(Ts, 8)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [i._Bn([Si]), i.qOj, i.TTD] }), Q })(); const io = { provide: Ee, useExisting: (0, i.Gpc)(() => Ys), multi: !0 }; function Wl(Q, q) { return null == Q ? `${q}` : (q && "object" == typeof q && (q = "Object"), `${Q}: ${q}`.slice(0, 50)) } let Ys = (() => { class Q extends Te { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith($) { this._compareWith = $ } writeValue($) { this.value = $; const Rt = Wl(this._getOptionId($), $); this.setProperty("value", Rt) } registerOnChange($) { this.onChange = me => { this.value = this._getOptionValue(me), $(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId($) { for (const me of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(me), $)) return me; return null } _getOptionValue($) { const me = function zo(Q) { return Q.split(":")[0] }($); return this._optionMap.has(me) ? this._optionMap.get(me) : $ } } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function ($, me) { 1 & $ && i.NdJ("change", function (Bn) { return me.onChange(Bn.target.value) })("blur", function () { return me.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [i._Bn([io]), i.qOj] }), Q })(), Go = (() => { class Q { constructor($, me, Rt) { this._element = $, this._renderer = me, this._select = Rt, this._select && (this.id = this._select._registerOption()) } set ngValue($) { null != this._select && (this._select._optionMap.set(this.id, $), this._setElementValue(Wl(this.id, $)), this._select.writeValue(this._select.value)) } set value($) { this._setElementValue($), this._select && this._select.writeValue(this._select.value) } _setElementValue($) { this._renderer.setProperty(this._element.nativeElement, "value", $) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(i.SBq), i.Y36(i.Qsj), i.Y36(Ys, 9)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), Q })(); const so = { provide: Ee, useExisting: (0, i.Gpc)(() => pi), multi: !0 }; function jo(Q, q) { return null == Q ? `${q}` : ("string" == typeof q && (q = `'${q}'`), q && "object" == typeof q && (q = "Object"), `${Q}: ${q}`.slice(0, 50)) } let pi = (() => { class Q extends Te { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith($) { this._compareWith = $ } writeValue($) { let me; if (this.value = $, Array.isArray($)) { const Rt = $.map(Bn => this._getOptionId(Bn)); me = (Bn, wi) => { Bn._setSelected(Rt.indexOf(wi.toString()) > -1) } } else me = (Rt, Bn) => { Rt._setSelected(!1) }; this._optionMap.forEach(me) } registerOnChange($) { this.onChange = me => { const Rt = [], Bn = me.selectedOptions; if (void 0 !== Bn) { const wi = Bn; for (let Jt = 0; Jt < wi.length; Jt++) { const ll = this._getOptionValue(wi[Jt].value); Rt.push(ll) } } else { const wi = me.options; for (let Jt = 0; Jt < wi.length; Jt++) { const zr = wi[Jt]; if (zr.selected) { const ll = this._getOptionValue(zr.value); Rt.push(ll) } } } this.value = Rt, $(Rt) } } _registerOption($) { const me = (this._idCounter++).toString(); return this._optionMap.set(me, $), me } _getOptionId($) { for (const me of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(me)._value, $)) return me; return null } _getOptionValue($) { const me = function na(Q) { return Q.split(":")[0] }($); return this._optionMap.has(me) ? this._optionMap.get(me)._value : $ } } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function ($, me) { 1 & $ && i.NdJ("change", function (Bn) { return me.onChange(Bn.target) })("blur", function () { return me.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [i._Bn([so]), i.qOj] }), Q })(), Ss = (() => { class Q { constructor($, me, Rt) { this._element = $, this._renderer = me, this._select = Rt, this._select && (this.id = this._select._registerOption(this)) } set ngValue($) { null != this._select && (this._value = $, this._setElementValue(jo(this.id, $)), this._select.writeValue(this._select.value)) } set value($) { this._select ? (this._value = $, this._setElementValue(jo(this.id, $)), this._select.writeValue(this._select.value)) : this._setElementValue($) } _setElementValue($) { this._renderer.setProperty(this._element.nativeElement, "value", $) } _setSelected($) { this._renderer.setProperty(this._element.nativeElement, "selected", $) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return Q.\u0275fac = function ($) { return new ($ || Q)(i.Y36(i.SBq), i.Y36(i.Qsj), i.Y36(pi, 9)) }, Q.\u0275dir = i.lG2({ type: Q, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), Q })(); let ho = (() => { class Q { constructor() { this._validator = st } ngOnChanges($) { if (this.inputName in $) { const me = this.normalizeInput($[this.inputName].currentValue); this._enabled = this.enabled(me), this._validator = this._enabled ? this.createValidator(me) : st, this._onChange && this._onChange() } } validate($) { return this._validator($) } registerOnValidatorChange($) { this._onChange = $ } enabled($) { return null != $ } } return Q.\u0275fac = function ($) { return new ($ || Q) }, Q.\u0275dir = i.lG2({ type: Q, features: [i.TTD] }), Q })(); const Za = { provide: je, useExisting: (0, i.Gpc)(() => As), multi: !0 }, fo = { provide: je, useExisting: (0, i.Gpc)(() => Pa), multi: !0 }; let As = (() => { class Q extends ho { constructor() { super(...arguments), this.inputName = "required", this.normalizeInput = i.D6c, this.createValidator = $ => Be } enabled($) { return $ } } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function ($, me) { 2 & $ && i.uIk("required", me._enabled ? "" : null) }, inputs: { required: "required" }, features: [i._Bn([Za]), i.qOj] }), Q })(), Pa = (() => { class Q extends As { constructor() { super(...arguments), this.createValidator = $ => nt } } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]], hostVars: 1, hostBindings: function ($, me) { 2 & $ && i.uIk("required", me._enabled ? "" : null) }, features: [i._Bn([fo]), i.qOj] }), Q })(); const Ui = { provide: je, useExisting: (0, i.Gpc)(() => Js), multi: !0 }; let Js = (() => { class Q extends ho { constructor() { super(...arguments), this.inputName = "maxlength", this.normalizeInput = $ => function $o(Q) { return "number" == typeof Q ? Q : parseInt(Q, 10) }($), this.createValidator = $ => Fe($) } } return Q.\u0275fac = function () { let q; return function (me) { return (q || (q = i.n5z(Q)))(me || Q) } }(), Q.\u0275dir = i.lG2({ type: Q, selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]], hostVars: 1, hostBindings: function ($, me) { 2 & $ && i.uIk("maxlength", me._enabled ? me.maxlength : null) }, inputs: { maxlength: "maxlength" }, features: [i._Bn([Ui]), i.qOj] }), Q })(), wa = (() => { class Q { } return Q.\u0275fac = function ($) { return new ($ || Q) }, Q.\u0275mod = i.oAB({ type: Q }), Q.\u0275inj = i.cJS({ imports: [Yn] }), Q })(); class Qs extends Lt { constructor(q, $, me) { super(vt($), qe(me, $)), this.controls = q, this._initObservables(), this._setUpdateStrategy($), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(q) { return this.controls[this._adjustIndex(q)] } push(q, $ = {}) { this.controls.push(q), this._registerControl(q), this.updateValueAndValidity({ emitEvent: $.emitEvent }), this._onCollectionChange() } insert(q, $, me = {}) { this.controls.splice(q, 0, $), this._registerControl($), this.updateValueAndValidity({ emitEvent: me.emitEvent }) } removeAt(q, $ = {}) { let me = this._adjustIndex(q); me < 0 && (me = 0), this.controls[me] && this.controls[me]._registerOnCollectionChange(() => { }), this.controls.splice(me, 1), this.updateValueAndValidity({ emitEvent: $.emitEvent }) } setControl(q, $, me = {}) { let Rt = this._adjustIndex(q); Rt < 0 && (Rt = 0), this.controls[Rt] && this.controls[Rt]._registerOnCollectionChange(() => { }), this.controls.splice(Rt, 1), $ && (this.controls.splice(Rt, 0, $), this._registerControl($)), this.updateValueAndValidity({ emitEvent: me.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(q, $ = {}) { et(this, 0, q), q.forEach((me, Rt) => { ke(this, !1, Rt), this.at(Rt).setValue(me, { onlySelf: !0, emitEvent: $.emitEvent }) }), this.updateValueAndValidity($) } patchValue(q, $ = {}) { null != q && (q.forEach((me, Rt) => { this.at(Rt) && this.at(Rt).patchValue(me, { onlySelf: !0, emitEvent: $.emitEvent }) }), this.updateValueAndValidity($)) } reset(q = [], $ = {}) { this._forEachChild((me, Rt) => { me.reset(q[Rt], { onlySelf: !0, emitEvent: $.emitEvent }) }), this._updatePristine($), this._updateTouched($), this.updateValueAndValidity($) } getRawValue() { return this.controls.map(q => q.getRawValue()) } clear(q = {}) { this.controls.length < 1 || (this._forEachChild($ => $._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: q.emitEvent })) } _adjustIndex(q) { return q < 0 ? q + this.length : q } _syncPendingControls() { let q = this.controls.reduce(($, me) => !!me._syncPendingControls() || $, !1); return q && this.updateValueAndValidity({ onlySelf: !0 }), q } _forEachChild(q) { this.controls.forEach(($, me) => { q($, me) }) } _updateValue() { this.value = this.controls.filter(q => q.enabled || this.disabled).map(q => q.value) } _anyControls(q) { return this.controls.some($ => $.enabled && q($)) } _setUpControls() { this._forEachChild(q => this._registerControl(q)) } _allControlsDisabled() { for (const q of this.controls) if (q.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(q) { q.setParent(this), q._registerOnCollectionChange(this._onCollectionChange) } _find(q) { return this.at(q) ?? null } } function xs(Q) { return !!Q && (void 0 !== Q.asyncValidators || void 0 !== Q.validators || void 0 !== Q.updateOn) } let Oo = (() => { class Q { constructor() { this.useNonNullable = !1 } get nonNullable() { const $ = new Q; return $.useNonNullable = !0, $ } group($, me = null) { const Rt = this._reduceControls($); let Bn = {}; return xs(me) ? Bn = me : null !== me && (Bn.validators = me.validator, Bn.asyncValidators = me.asyncValidator), new mt(Rt, Bn) } record($, me = null) { const Rt = this._reduceControls($); return new sr(Rt, me) } control($, me, Rt) { let Bn = {}; return this.useNonNullable ? (xs(me) ? Bn = me : (Bn.validators = me, Bn.asyncValidators = Rt), new Rs($, { ...Bn, nonNullable: !0 })) : new Rs($, me, Rt) } array($, me, Rt) { const Bn = $.map(wi => this._createControl(wi)); return new Qs(Bn, me, Rt) } _reduceControls($) { const me = {}; return Object.keys($).forEach(Rt => { me[Rt] = this._createControl($[Rt]) }), me } _createControl($) { return $ instanceof Rs || $ instanceof Lt ? $ : Array.isArray($) ? this.control($[0], $.length > 1 ? $[1] : null, $.length > 2 ? $[2] : null) : this.control($) } } return Q.\u0275fac = function ($) { return new ($ || Q) }, Q.\u0275prov = i.Yz7({ token: Q, factory: Q.\u0275fac, providedIn: "root" }), Q })(), hr = (() => { class Q { static withConfig($) { return { ngModule: Q, providers: [{ provide: ze, useValue: $.callSetDisabledState ?? Ye }] } } } return Q.\u0275fac = function ($) { return new ($ || Q) }, Q.\u0275mod = i.oAB({ type: Q }), Q.\u0275inj = i.cJS({ imports: [wa] }), Q })(), Xs = (() => { class Q { static withConfig($) { return { ngModule: Q, providers: [{ provide: Ts, useValue: $.warnOnNgModelWithFormControl ?? "always" }, { provide: ze, useValue: $.callSetDisabledState ?? Ye }] } } } return Q.\u0275fac = function ($) { return new ($ || Q) }, Q.\u0275mod = i.oAB({ type: Q }), Q.\u0275inj = i.cJS({ imports: [wa] }), Q })() }, 1481: (un, Je, L) => { "use strict"; L.d(Je, { Dx: () => Hn, H7: () => An, Qz: () => rt, b2: () => ue, hm: () => et, ok: () => fe, q6: () => Jn, se: () => st }); var i = L(6895), m = L(4650); class J extends i.w_ { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class ye extends J { static makeCurrent() { (0, i.HT)(new ye) } onAndCancel(Ye, Ie, Ct) { return Ye.addEventListener(Ie, Ct, !1), () => { Ye.removeEventListener(Ie, Ct, !1) } } dispatchEvent(Ye, Ie) { Ye.dispatchEvent(Ie) } remove(Ye) { Ye.parentNode && Ye.parentNode.removeChild(Ye) } createElement(Ye, Ie) { return (Ie = Ie || this.getDefaultDocument()).createElement(Ye) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(Ye) { return Ye.nodeType === Node.ELEMENT_NODE } isShadowRoot(Ye) { return Ye instanceof DocumentFragment } getGlobalEventTarget(Ye, Ie) { return "window" === Ie ? window : "document" === Ie ? Ye : "body" === Ie ? Ye.body : null } getBaseHref(Ye) { const Ie = function we() { return Ce = Ce || document.querySelector("base"), Ce ? Ce.getAttribute("href") : null }(); return null == Ie ? null : function Ee(ze) { Te = Te || document.createElement("a"), Te.setAttribute("href", ze); const Ye = Te.pathname; return "/" === Ye.charAt(0) ? Ye : `/${Ye}` }(Ie) } resetBaseElement() { Ce = null } getUserAgent() { return window.navigator.userAgent } getCookie(Ye) { return (0, i.Mx)(document.cookie, Ye) } } let Te, Ce = null; const _e = new m.OlP("TRANSITION_ID"), ve = [{ provide: m.ip1, useFactory: function ae(ze, Ye, Ie) { return () => { Ie.get(m.CZH).donePromise.then(() => { const Ct = (0, i.q)(), nn = Ye.querySelectorAll(`style[ng-transition="${ze}"]`); for (let xn = 0; xn < nn.length; xn++)Ct.remove(nn[xn]) }) } }, deps: [_e, i.K0, m.zs3], multi: !0 }]; let gt = (() => { class ze { build() { return new XMLHttpRequest } } return ze.\u0275fac = function (Ie) { return new (Ie || ze) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(); const Se = new m.OlP("EventManagerPlugins"); let rt = (() => { class ze { constructor(Ie, Ct) { this._zone = Ct, this._eventNameToPlugin = new Map, Ie.forEach(nn => nn.manager = this), this._plugins = Ie.slice().reverse() } addEventListener(Ie, Ct, nn) { return this._findPluginFor(Ct).addEventListener(Ie, Ct, nn) } addGlobalEventListener(Ie, Ct, nn) { return this._findPluginFor(Ct).addGlobalEventListener(Ie, Ct, nn) } getZone() { return this._zone } _findPluginFor(Ie) { const Ct = this._eventNameToPlugin.get(Ie); if (Ct) return Ct; const nn = this._plugins; for (let xn = 0; xn < nn.length; xn++) { const zn = nn[xn]; if (zn.supports(Ie)) return this._eventNameToPlugin.set(Ie, zn), zn } throw new Error(`No event manager plugin found for event ${Ie}`) } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(Se), m.LFG(m.R0b)) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(); class wt { constructor(Ye) { this._doc = Ye } addGlobalEventListener(Ye, Ie, Ct) { const nn = (0, i.q)().getGlobalEventTarget(this._doc, Ye); if (!nn) throw new Error(`Unsupported event target ${nn} for event ${Ie}`); return this.addEventListener(nn, Ie, Ct) } } let De = (() => { class ze { constructor() { this._stylesSet = new Set } addStyles(Ie) { const Ct = new Set; Ie.forEach(nn => { this._stylesSet.has(nn) || (this._stylesSet.add(nn), Ct.add(nn)) }), this.onStylesAdded(Ct) } onStylesAdded(Ie) { } getAllStyles() { return Array.from(this._stylesSet) } } return ze.\u0275fac = function (Ie) { return new (Ie || ze) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(), je = (() => { class ze extends De { constructor(Ie) { super(), this._doc = Ie, this._hostNodes = new Map, this._hostNodes.set(Ie.head, []) } _addStylesToHost(Ie, Ct, nn) { Ie.forEach(xn => { const zn = this._doc.createElement("style"); zn.textContent = xn, nn.push(Ct.appendChild(zn)) }) } addHost(Ie) { const Ct = []; this._addStylesToHost(this._stylesSet, Ie, Ct), this._hostNodes.set(Ie, Ct) } removeHost(Ie) { const Ct = this._hostNodes.get(Ie); Ct && Ct.forEach(_t), this._hostNodes.delete(Ie) } onStylesAdded(Ie) { this._hostNodes.forEach((Ct, nn) => { this._addStylesToHost(Ie, nn, Ct) }) } ngOnDestroy() { this._hostNodes.forEach(Ie => Ie.forEach(_t)) } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(i.K0)) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(); function _t(ze) { (0, i.q)().remove(ze) } const Qe = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, ct = /%COMP%/g; function Fe(ze, Ye) { return Ye.flat(100).map(Ie => Ie.replace(ct, ze)) } function Ue(ze) { return Ye => { if ("__ngUnwrap__" === Ye) return ze; !1 === ze(Ye) && (Ye.preventDefault(), Ye.returnValue = !1) } } let st = (() => { class ze { constructor(Ie, Ct, nn) { this.eventManager = Ie, this.sharedStylesHost = Ct, this.appId = nn, this.rendererByCompId = new Map, this.defaultRenderer = new ht(Ie) } createRenderer(Ie, Ct) { if (!Ie || !Ct) return this.defaultRenderer; switch (Ct.encapsulation) { case m.ifc.Emulated: { let nn = this.rendererByCompId.get(Ct.id); return nn || (nn = new qn(this.eventManager, this.sharedStylesHost, Ct, this.appId), this.rendererByCompId.set(Ct.id, nn)), nn.applyToHost(Ie), nn } case m.ifc.ShadowDom: return new nr(this.eventManager, this.sharedStylesHost, Ie, Ct); default: if (!this.rendererByCompId.has(Ct.id)) { const nn = Fe(Ct.id, Ct.styles); this.sharedStylesHost.addStyles(nn), this.rendererByCompId.set(Ct.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(rt), m.LFG(je), m.LFG(m.AFp)) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(); class ht { constructor(Ye) { this.eventManager = Ye, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(Ye, Ie) { return Ie ? document.createElementNS(Qe[Ie] || Ie, Ye) : document.createElement(Ye) } createComment(Ye) { return document.createComment(Ye) } createText(Ye) { return document.createTextNode(Ye) } appendChild(Ye, Ie) { (On(Ye) ? Ye.content : Ye).appendChild(Ie) } insertBefore(Ye, Ie, Ct) { Ye && (On(Ye) ? Ye.content : Ye).insertBefore(Ie, Ct) } removeChild(Ye, Ie) { Ye && Ye.removeChild(Ie) } selectRootElement(Ye, Ie) { let Ct = "string" == typeof Ye ? document.querySelector(Ye) : Ye; if (!Ct) throw new Error(`The selector "${Ye}" did not match any elements`); return Ie || (Ct.textContent = ""), Ct } parentNode(Ye) { return Ye.parentNode } nextSibling(Ye) { return Ye.nextSibling } setAttribute(Ye, Ie, Ct, nn) { if (nn) { Ie = nn + ":" + Ie; const xn = Qe[nn]; xn ? Ye.setAttributeNS(xn, Ie, Ct) : Ye.setAttribute(Ie, Ct) } else Ye.setAttribute(Ie, Ct) } removeAttribute(Ye, Ie, Ct) { if (Ct) { const nn = Qe[Ct]; nn ? Ye.removeAttributeNS(nn, Ie) : Ye.removeAttribute(`${Ct}:${Ie}`) } else Ye.removeAttribute(Ie) } addClass(Ye, Ie) { Ye.classList.add(Ie) } removeClass(Ye, Ie) { Ye.classList.remove(Ie) } setStyle(Ye, Ie, Ct, nn) { nn & (m.JOm.DashCase | m.JOm.Important) ? Ye.style.setProperty(Ie, Ct, nn & m.JOm.Important ? "important" : "") : Ye.style[Ie] = Ct } removeStyle(Ye, Ie, Ct) { Ct & m.JOm.DashCase ? Ye.style.removeProperty(Ie) : Ye.style[Ie] = "" } setProperty(Ye, Ie, Ct) { Ye[Ie] = Ct } setValue(Ye, Ie) { Ye.nodeValue = Ie } listen(Ye, Ie, Ct) { return "string" == typeof Ye ? this.eventManager.addGlobalEventListener(Ye, Ie, Ue(Ct)) : this.eventManager.addEventListener(Ye, Ie, Ue(Ct)) } } function On(ze) { return "TEMPLATE" === ze.tagName && void 0 !== ze.content } class qn extends ht { constructor(Ye, Ie, Ct, nn) { super(Ye), this.component = Ct; const xn = Fe(nn + "-" + Ct.id, Ct.styles); Ie.addStyles(xn), this.contentAttr = function Ne(ze) { return "_ngcontent-%COMP%".replace(ct, ze) }(nn + "-" + Ct.id), this.hostAttr = function tt(ze) { return "_nghost-%COMP%".replace(ct, ze) }(nn + "-" + Ct.id) } applyToHost(Ye) { super.setAttribute(Ye, this.hostAttr, "") } createElement(Ye, Ie) { const Ct = super.createElement(Ye, Ie); return super.setAttribute(Ct, this.contentAttr, ""), Ct } } class nr extends ht { constructor(Ye, Ie, Ct, nn) { super(Ye), this.sharedStylesHost = Ie, this.hostEl = Ct, this.shadowRoot = Ct.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const xn = Fe(nn.id, nn.styles); for (let zn = 0; zn < xn.length; zn++) { const ti = document.createElement("style"); ti.textContent = xn[zn], this.shadowRoot.appendChild(ti) } } nodeOrShadowRoot(Ye) { return Ye === this.hostEl ? this.shadowRoot : Ye } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(Ye, Ie) { return super.appendChild(this.nodeOrShadowRoot(Ye), Ie) } insertBefore(Ye, Ie, Ct) { return super.insertBefore(this.nodeOrShadowRoot(Ye), Ie, Ct) } removeChild(Ye, Ie) { return super.removeChild(this.nodeOrShadowRoot(Ye), Ie) } parentNode(Ye) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(Ye))) } } let kn = (() => { class ze extends wt { constructor(Ie) { super(Ie) } supports(Ie) { return !0 } addEventListener(Ie, Ct, nn) { return Ie.addEventListener(Ct, nn, !1), () => this.removeEventListener(Ie, Ct, nn) } removeEventListener(Ie, Ct, nn) { return Ie.removeEventListener(Ct, nn) } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(i.K0)) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(); const fn = ["alt", "control", "meta", "shift"], It = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Yt = { alt: ze => ze.altKey, control: ze => ze.ctrlKey, meta: ze => ze.metaKey, shift: ze => ze.shiftKey }; let pt = (() => { class ze extends wt { constructor(Ie) { super(Ie) } supports(Ie) { return null != ze.parseEventName(Ie) } addEventListener(Ie, Ct, nn) { const xn = ze.parseEventName(Ct), zn = ze.eventCallback(xn.fullKey, nn, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => (0, i.q)().onAndCancel(Ie, xn.domEventName, zn)) } static parseEventName(Ie) { const Ct = Ie.toLowerCase().split("."), nn = Ct.shift(); if (0 === Ct.length || "keydown" !== nn && "keyup" !== nn) return null; const xn = ze._normalizeKey(Ct.pop()); let zn = "", ti = Ct.indexOf("code"); if (ti > -1 && (Ct.splice(ti, 1), zn = "code."), fn.forEach(ss => { const Ps = Ct.indexOf(ss); Ps > -1 && (Ct.splice(Ps, 1), zn += ss + ".") }), zn += xn, 0 != Ct.length || 0 === xn.length) return null; const Br = {}; return Br.domEventName = nn, Br.fullKey = zn, Br } static matchEventFullKeyCode(Ie, Ct) { let nn = It[Ie.key] || Ie.key, xn = ""; return Ct.indexOf("code.") > -1 && (nn = Ie.code, xn = "code."), !(null == nn || !nn) && (nn = nn.toLowerCase(), " " === nn ? nn = "space" : "." === nn && (nn = "dot"), fn.forEach(zn => { zn !== nn && (0, Yt[zn])(Ie) && (xn += zn + ".") }), xn += nn, xn === Ct) } static eventCallback(Ie, Ct, nn) { return xn => { ze.matchEventFullKeyCode(xn, Ie) && nn.runGuarded(() => Ct(xn)) } } static _normalizeKey(Ie) { return "esc" === Ie ? "escape" : Ie } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(i.K0)) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(); const Jn = (0, m.eFA)(m._c5, "browser", [{ provide: m.Lbi, useValue: i.bD }, { provide: m.g9A, useValue: function kt() { ye.makeCurrent() }, multi: !0 }, { provide: i.K0, useFactory: function jt() { return (0, m.RDi)(document), document }, deps: [] }]), or = new m.OlP(""), Ht = [{ provide: m.rWj, useClass: class xe { addToWindow(Ye) { m.dqk.getAngularTestability = (Ct, nn = !0) => { const xn = Ye.findTestabilityInTree(Ct, nn); if (null == xn) throw new Error("Could not find testability for element."); return xn }, m.dqk.getAllAngularTestabilities = () => Ye.getAllTestabilities(), m.dqk.getAllAngularRootElements = () => Ye.getAllRootElements(), m.dqk.frameworkStabilizers || (m.dqk.frameworkStabilizers = []), m.dqk.frameworkStabilizers.push(Ct => { const nn = m.dqk.getAllAngularTestabilities(); let xn = nn.length, zn = !1; const ti = function (Br) { zn = zn || Br, xn--, 0 == xn && Ct(zn) }; nn.forEach(function (Br) { Br.whenStable(ti) }) }) } findTestabilityInTree(Ye, Ie, Ct) { return null == Ie ? null : Ye.getTestability(Ie) ?? (Ct ? (0, i.q)().isShadowRoot(Ie) ? this.findTestabilityInTree(Ye, Ie.host, !0) : this.findTestabilityInTree(Ye, Ie.parentElement, !0) : null) } }, deps: [] }, { provide: m.lri, useClass: m.dDg, deps: [m.R0b, m.eoX, m.rWj] }, { provide: m.dDg, useClass: m.dDg, deps: [m.R0b, m.eoX, m.rWj] }], dn = [{ provide: m.zSh, useValue: "root" }, { provide: m.qLn, useFactory: function an() { return new m.qLn }, deps: [] }, { provide: Se, useClass: kn, multi: !0, deps: [i.K0, m.R0b, m.Lbi] }, { provide: Se, useClass: pt, multi: !0, deps: [i.K0] }, { provide: st, useClass: st, deps: [rt, je, m.AFp] }, { provide: m.FYo, useExisting: st }, { provide: De, useExisting: je }, { provide: je, useClass: je, deps: [i.K0] }, { provide: rt, useClass: rt, deps: [Se, m.R0b] }, { provide: i.JF, useClass: gt, deps: [] }, []]; let ue = (() => { class ze { constructor(Ie) { } static withServerTransition(Ie) { return { ngModule: ze, providers: [{ provide: m.AFp, useValue: Ie.appId }, { provide: _e, useExisting: m.AFp }, ve] } } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(or, 12)) }, ze.\u0275mod = m.oAB({ type: ze }), ze.\u0275inj = m.cJS({ providers: [...dn, ...Ht], imports: [i.ez, m.hGG] }), ze })(), Hn = (() => { class ze { constructor(Ie) { this._doc = Ie } getTitle() { return this._doc.title } setTitle(Ie) { this._doc.title = Ie || "" } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(i.K0)) }, ze.\u0275prov = m.Yz7({ token: ze, factory: function (Ie) { let Ct = null; return Ct = Ie ? new Ie : function gn() { return new Hn((0, m.LFG)(i.K0)) }(), Ct }, providedIn: "root" }), ze })(); typeof window < "u" && window; const fe = new m.OlP("HammerGestureConfig"); let et = (() => { class ze { constructor() { this.events = [], this.overrides = {} } buildHammer(Ie) { const Ct = new Hammer(Ie, this.options); Ct.get("pinch").set({ enable: !0 }), Ct.get("rotate").set({ enable: !0 }); for (const nn in this.overrides) Ct.get(nn).set(this.overrides[nn]); return Ct } } return ze.\u0275fac = function (Ie) { return new (Ie || ze) }, ze.\u0275prov = m.Yz7({ token: ze, factory: ze.\u0275fac }), ze })(), An = (() => { class ze { } return ze.\u0275fac = function (Ie) { return new (Ie || ze) }, ze.\u0275prov = m.Yz7({ token: ze, factory: function (Ie) { let Ct = null; return Ct = Ie ? new (Ie || ze) : m.LFG(sr), Ct }, providedIn: "root" }), ze })(), sr = (() => { class ze extends An { constructor(Ie) { super(), this._doc = Ie } sanitize(Ie, Ct) { if (null == Ct) return null; switch (Ie) { case m.q3G.NONE: return Ct; case m.q3G.HTML: return (0, m.qzn)(Ct, "HTML") ? (0, m.z3N)(Ct) : (0, m.EiD)(this._doc, String(Ct)).toString(); case m.q3G.STYLE: return (0, m.qzn)(Ct, "Style") ? (0, m.z3N)(Ct) : Ct; case m.q3G.SCRIPT: if ((0, m.qzn)(Ct, "Script")) return (0, m.z3N)(Ct); throw new Error("unsafe value used in a script context"); case m.q3G.URL: return (0, m.qzn)(Ct, "URL") ? (0, m.z3N)(Ct) : (0, m.mCW)(String(Ct)); case m.q3G.RESOURCE_URL: if ((0, m.qzn)(Ct, "ResourceURL")) return (0, m.z3N)(Ct); throw new Error(`unsafe value used in a resource URL context (see ${m.JZr})`); default: throw new Error(`Unexpected SecurityContext ${Ie} (see ${m.JZr})`) } } bypassSecurityTrustHtml(Ie) { return (0, m.JVY)(Ie) } bypassSecurityTrustStyle(Ie) { return (0, m.L6k)(Ie) } bypassSecurityTrustScript(Ie) { return (0, m.eBb)(Ie) } bypassSecurityTrustUrl(Ie) { return (0, m.LAX)(Ie) } bypassSecurityTrustResourceUrl(Ie) { return (0, m.pB0)(Ie) } } return ze.\u0275fac = function (Ie) { return new (Ie || ze)(m.LFG(i.K0)) }, ze.\u0275prov = m.Yz7({ token: ze, factory: function (Ie) { let Ct = null; return Ct = Ie ? new Ie : function ar(ze) { return new sr(ze.get(i.K0)) }(m.LFG(m.zs3)), Ct }, providedIn: "root" }), ze })() }, 8988: (un, Je, L) => { "use strict"; L.d(Je, { gz: () => gr, m2: () => Xi, OD: () => as, F0: () => Bs, rH: () => Xa, Od: () => Kc, Bz: () => cn, lC: () => $o }); var i = L(4650), m = L(8996), J = L(9646), ye = L(1135), Ce = L(6805), we = L(9841), Te = L(7272), Ee = L(9770), _e = L(9635), ae = L(2843), ve = L(9751), xe = L(515), gt = L(4033), Se = L(7579), rt = L(6895), wt = L(4004), De = L(3900), je = L(5698), _t = L(8675), Qe = L(9300), ct = L(6099), Oe = L(590), Ve = L(4351), Be = L(8505), nt = L(262), Ne = L(2940), tt = L(2035), Fe = L(8068), Ue = L(6590), st = L(4671); function ht(R, V) { const M = arguments.length >= 2; return G => G.pipe(R ? (0, Qe.h)((X, ce) => R(X, ce, G)) : st.y, (0, tt.h)(1), M ? (0, Ue.d)(V) : (0, Fe.T)(() => new Ce.K)) } var Kt = L(2529), rn = L(9718), On = L(8746), qn = L(8343), nr = L(8189), kn = L(1481); const fn = "primary", It = Symbol("RouteTitle"); class Yt { constructor(V) { this.params = V || {} } has(V) { return Object.prototype.hasOwnProperty.call(this.params, V) } get(V) { if (this.has(V)) { const M = this.params[V]; return Array.isArray(M) ? M[0] : M } return null } getAll(V) { if (this.has(V)) { const M = this.params[V]; return Array.isArray(M) ? M : [M] } return [] } get keys() { return Object.keys(this.params) } } function pt(R) { return new Yt(R) } function Pt(R, V, M) { const G = M.path.split("/"); if (G.length > R.length || "full" === M.pathMatch && (V.hasChildren() || G.length < R.length)) return null; const X = {}; for (let ce = 0; ce < G.length; ce++) { const be = G[ce], St = R[ce]; if (be.startsWith(":")) X[be.substring(1)] = St; else if (be !== St.path) return null } return { consumed: R.slice(0, G.length), posParams: X } } function Ot(R, V) { const M = R ? Object.keys(R) : void 0, G = V ? Object.keys(V) : void 0; if (!M || !G || M.length != G.length) return !1; let X; for (let ce = 0; ce < M.length; ce++)if (X = M[ce], !le(R[X], V[X])) return !1; return !0 } function le(R, V) { if (Array.isArray(R) && Array.isArray(V)) { if (R.length !== V.length) return !1; const M = [...R].sort(), G = [...V].sort(); return M.every((X, ce) => G[ce] === X) } return R === V } function Xe(R) { return Array.prototype.concat.apply([], R) } function kt(R) { return R.length > 0 ? R[R.length - 1] : null } function jt(R, V) { for (const M in R) R.hasOwnProperty(M) && V(R[M], M) } function wn(R) { return (0, i.CqO)(R) ? R : (0, i.QGY)(R) ? (0, m.D)(Promise.resolve(R)) : (0, J.of)(R) } const Jn = !1, or = { exact: function it(R, V, M) { if (!Qn(R.segments, V.segments) || !Hn(R.segments, V.segments, M) || R.numberOfChildren !== V.numberOfChildren) return !1; for (const G in V.children) if (!R.children[G] || !it(R.children[G], V.children[G], M)) return !1; return !0 }, subset: Nt }, Ht = { exact: function ue(R, V) { return Ot(R, V) }, subset: function lt(R, V) { return Object.keys(V).length <= Object.keys(R).length && Object.keys(V).every(M => le(R[M], V[M])) }, ignored: () => !0 }; function dn(R, V, M) { return or[M.paths](R.root, V.root, M.matrixParams) && Ht[M.queryParams](R.queryParams, V.queryParams) && !("exact" === M.fragment && R.fragment !== V.fragment) } function Nt(R, V, M) { return gn(R, V, V.segments, M) } function gn(R, V, M, G) { if (R.segments.length > M.length) { const X = R.segments.slice(0, M.length); return !(!Qn(X, M) || V.hasChildren() || !Hn(X, M, G)) } if (R.segments.length === M.length) { if (!Qn(R.segments, M) || !Hn(R.segments, M, G)) return !1; for (const X in V.children) if (!R.children[X] || !Nt(R.children[X], V.children[X], G)) return !1; return !0 } { const X = M.slice(0, R.segments.length), ce = M.slice(R.segments.length); return !!(Qn(R.segments, X) && Hn(R.segments, X, G) && R.children[fn]) && gn(R.children[fn], V, ce, G) } } function Hn(R, V, M) { return V.every((G, X) => Ht[M](R[X].parameters, G.parameters)) } class _r { constructor(V = new pn([], {}), M = {}, G = null) { this.root = V, this.queryParams = M, this.fragment = G } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = pt(this.queryParams)), this._queryParamMap } toString() { return vr.serialize(this) } } class pn { constructor(V, M) { this.segments = V, this.children = M, this.parent = null, jt(M, (G, X) => G.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return At(this) } } class Fn { constructor(V, M) { this.path = V, this.parameters = M } get parameterMap() { return this._parameterMap || (this._parameterMap = pt(this.parameters)), this._parameterMap } toString() { return vt(this) } } function Qn(R, V) { return R.length === V.length && R.every((M, G) => M.path === V[G].path) } let dr = (() => { class R { } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: function () { return new Kr }, providedIn: "root" }), R })(); class Kr { parse(V) { const M = new An(V); return new _r(M.parseRootSegment(), M.parseQueryParams(), M.parseFragment()) } serialize(V) { const M = `/${ln(V.root, !0)}`, G = function qe(R) { const V = Object.keys(R).map(M => { const G = R[M]; return Array.isArray(G) ? G.map(X => `${Et(M)}=${Et(X)}`).join("&") : `${Et(M)}=${Et(G)}` }).filter(M => !!M); return V.length ? `?${V.join("&")}` : "" }(V.queryParams); return `${M}${G}${"string" == typeof V.fragment ? `#${function Gt(R) { return encodeURI(R) }(V.fragment)}` : ""}` } } const vr = new Kr; function At(R) { return R.segments.map(V => vt(V)).join("/") } function ln(R, V) { if (!R.hasChildren()) return At(R); if (V) { const M = R.children[fn] ? ln(R.children[fn], !1) : "", G = []; return jt(R.children, (X, ce) => { ce !== fn && G.push(`${ce}:${ln(X, !1)}`) }), G.length > 0 ? `${M}(${G.join("//")})` : M } { const M = function ur(R, V) { let M = []; return jt(R.children, (G, X) => { X === fn && (M = M.concat(V(G, X))) }), jt(R.children, (G, X) => { X !== fn && (M = M.concat(V(G, X))) }), M }(R, (G, X) => X === fn ? [ln(R.children[fn], !1)] : [`${X}:${ln(G, !1)}`]); return 1 === Object.keys(R.children).length && null != R.children[fn] ? `${At(R)}/${M[0]}` : `${At(R)}/(${M.join("//")})` } } function Ae(R) { return encodeURIComponent(R).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Et(R) { return Ae(R).replace(/%3B/gi, ";") } function bn(R) { return Ae(R).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function sn(R) { return decodeURIComponent(R) } function Bt(R) { return sn(R.replace(/\+/g, "%20")) } function vt(R) { return `${bn(R.path)}${function Le(R) { return Object.keys(R).map(V => `;${bn(V)}=${bn(R[V])}`).join("") }(R.parameters)}` } const Zt = /^[^\/()?;=#]+/; function fe(R) { const V = R.match(Zt); return V ? V[0] : "" } const ke = /^[^=?&#]+/, Lt = /^[^&#]+/; class An { constructor(V) { this.url = V, this.remaining = V } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new pn([], {}) : new pn([], this.parseChildren()) } parseQueryParams() { const V = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(V) } while (this.consumeOptional("&")); return V } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const V = []; for (this.peekStartsWith("(") || V.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), V.push(this.parseSegment()); let M = {}; this.peekStartsWith("/(") && (this.capture("/"), M = this.parseParens(!0)); let G = {}; return this.peekStartsWith("(") && (G = this.parseParens(!1)), (V.length > 0 || Object.keys(M).length > 0) && (G[fn] = new pn(V, M)), G } parseSegment() { const V = fe(this.remaining); if ("" === V && this.peekStartsWith(";")) throw new i.vHH(4009, Jn); return this.capture(V), new Fn(sn(V), this.parseMatrixParams()) } parseMatrixParams() { const V = {}; for (; this.consumeOptional(";");)this.parseParam(V); return V } parseParam(V) { const M = fe(this.remaining); if (!M) return; this.capture(M); let G = ""; if (this.consumeOptional("=")) { const X = fe(this.remaining); X && (G = X, this.capture(G)) } V[sn(M)] = sn(G) } parseQueryParam(V) { const M = function et(R) { const V = R.match(ke); return V ? V[0] : "" }(this.remaining); if (!M) return; this.capture(M); let G = ""; if (this.consumeOptional("=")) { const be = function mt(R) { const V = R.match(Lt); return V ? V[0] : "" }(this.remaining); be && (G = be, this.capture(G)) } const X = Bt(M), ce = Bt(G); if (V.hasOwnProperty(X)) { let be = V[X]; Array.isArray(be) || (be = [be], V[X] = be), be.push(ce) } else V[X] = ce } parseParens(V) { const M = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const G = fe(this.remaining), X = this.remaining[G.length]; if ("/" !== X && ")" !== X && ";" !== X) throw new i.vHH(4010, Jn); let ce; G.indexOf(":") > -1 ? (ce = G.slice(0, G.indexOf(":")), this.capture(ce), this.capture(":")) : V && (ce = fn); const be = this.parseChildren(); M[ce] = 1 === Object.keys(be).length ? be[fn] : new pn([], be), this.consumeOptional("//") } return M } peekStartsWith(V) { return this.remaining.startsWith(V) } consumeOptional(V) { return !!this.peekStartsWith(V) && (this.remaining = this.remaining.substring(V.length), !0) } capture(V) { if (!this.consumeOptional(V)) throw new i.vHH(4011, Jn) } } function ar(R) { return R.segments.length > 0 ? new pn([], { [fn]: R }) : R } function sr(R) { const V = {}; for (const G of Object.keys(R.children)) { const ce = sr(R.children[G]); (ce.segments.length > 0 || ce.hasChildren()) && (V[G] = ce) } return function Fr(R) { if (1 === R.numberOfChildren && R.children[fn]) { const V = R.children[fn]; return new pn(R.segments.concat(V.segments), V.children) } return R }(new pn(R.segments, V)) } function ze(R) { return R instanceof _r } function xn(R, V, M, G, X) { if (0 === M.length) return Br(V.root, V.root, V.root, G, X); const ce = function vo(R) { if ("string" == typeof R[0] && 1 === R.length && "/" === R[0]) return new Ps(!0, 0, R); let V = 0, M = !1; const G = R.reduce((X, ce, be) => { if ("object" == typeof ce && null != ce) { if (ce.outlets) { const St = {}; return jt(ce.outlets, (on, Kn) => { St[Kn] = "string" == typeof on ? on.split("/") : on }), [...X, { outlets: St }] } if (ce.segmentPath) return [...X, ce.segmentPath] } return "string" != typeof ce ? [...X, ce] : 0 === be ? (ce.split("/").forEach((St, on) => { 0 == on && "." === St || (0 == on && "" === St ? M = !0 : ".." === St ? V++ : "" != St && X.push(St)) }), X) : [...X, ce] }, []); return new Ps(M, V, G) }(M); return ce.toRoot() ? Br(V.root, V.root, new pn([], {}), G, X) : function be(on) { const Kn = function _a(R, V, M, G) { if (R.isAbsolute) return new Dr(V.root, !0, 0); if (-1 === G) return new Dr(M, M === V.root, 0); return function ya(R, V, M) { let G = R, X = V, ce = M; for (; ce > X;) { if (ce -= X, G = G.parent, !G) throw new i.vHH(4005, !1); X = G.segments.length } return new Dr(G, !1, X - ce) }(M, G + (zn(R.commands[0]) ? 0 : 1), R.numberOfDoubleDots) }(ce, V, R.snapshot?._urlSegment, on), Vn = Kn.processChildren ? Ji(Kn.segmentGroup, Kn.index, ce.commands) : Hr(Kn.segmentGroup, Kn.index, ce.commands); return Br(V.root, Kn.segmentGroup, Vn, G, X) }(R.snapshot?._lastPathIndex) } function zn(R) { return "object" == typeof R && null != R && !R.outlets && !R.segmentPath } function ti(R) { return "object" == typeof R && null != R && R.outlets } function Br(R, V, M, G, X) { let be, ce = {}; G && jt(G, (on, Kn) => { ce[Kn] = Array.isArray(on) ? on.map(Vn => `${Vn}`) : `${on}` }), be = R === V ? M : ss(R, V, M); const St = ar(sr(be)); return new _r(St, ce, X) } function ss(R, V, M) { const G = {}; return jt(R.children, (X, ce) => { G[ce] = X === V ? M : ss(X, V, M) }), new pn(R.segments, G) } class Ps { constructor(V, M, G) { if (this.isAbsolute = V, this.numberOfDoubleDots = M, this.commands = G, V && G.length > 0 && zn(G[0])) throw new i.vHH(4003, !1); const X = G.find(ti); if (X && X !== kt(G)) throw new i.vHH(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Dr { constructor(V, M, G) { this.segmentGroup = V, this.processChildren = M, this.index = G } } function Hr(R, V, M) { if (R || (R = new pn([], {})), 0 === R.segments.length && R.hasChildren()) return Ji(R, V, M); const G = function Ei(R, V, M) { let G = 0, X = V; const ce = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; X < R.segments.length;) { if (G >= M.length) return ce; const be = R.segments[X], St = M[G]; if (ti(St)) break; const on = `${St}`, Kn = G < M.length - 1 ? M[G + 1] : null; if (X > 0 && void 0 === on) break; if (on && Kn && "object" == typeof Kn && void 0 === Kn.outlets) { if (!Ln(on, Kn, be)) return ce; G += 2 } else { if (!Ln(on, {}, be)) return ce; G++ } X++ } return { match: !0, pathIndex: X, commandIndex: G } }(R, V, M), X = M.slice(G.commandIndex); if (G.match && G.pathIndex < R.segments.length) { const ce = new pn(R.segments.slice(0, G.pathIndex), {}); return ce.children[fn] = new pn(R.segments.slice(G.pathIndex), R.children), Ji(ce, 0, X) } return G.match && 0 === X.length ? new pn(R.segments, {}) : G.match && !R.hasChildren() ? Gi(R, V, M) : G.match ? Ji(R, 0, X) : Gi(R, V, M) } function Ji(R, V, M) { if (0 === M.length) return new pn(R.segments, {}); { const G = function va(R) { return ti(R[0]) ? R[0].outlets : { [fn]: R } }(M), X = {}; return jt(G, (ce, be) => { "string" == typeof ce && (ce = [ce]), null !== ce && (X[be] = Hr(R.children[be], V, ce)) }), jt(R.children, (ce, be) => { void 0 === G[be] && (X[be] = ce) }), new pn(R.segments, X) } } function Gi(R, V, M) { const G = R.segments.slice(0, V); let X = 0; for (; X < M.length;) { const ce = M[X]; if (ti(ce)) { const on = Qi(ce.outlets); return new pn(G, on) } if (0 === X && zn(M[0])) { G.push(new Fn(R.segments[V].path, Gs(M[0]))), X++; continue } const be = ti(ce) ? ce.outlets[fn] : `${ce}`, St = X < M.length - 1 ? M[X + 1] : null; be && St && zn(St) ? (G.push(new Fn(be, Gs(St))), X += 2) : (G.push(new Fn(be, {})), X++) } return new pn(G, {}) } function Qi(R) { const V = {}; return jt(R, (M, G) => { "string" == typeof M && (M = [M]), null !== M && (V[G] = Gi(new pn([], {}), 0, M)) }), V } function Gs(R) { const V = {}; return jt(R, (M, G) => V[G] = `${M}`), V } function Ln(R, V, M) { return R == M.path && Ot(V, M.parameters) } const pr = "imperative"; class ni { constructor(V, M) { this.id = V, this.url = M } } class as extends ni { constructor(V, M, G = "imperative", X = null) { super(V, M), this.type = 0, this.navigationTrigger = G, this.restoredState = X } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Xi extends ni { constructor(V, M, G) { super(V, M), this.urlAfterRedirects = G, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Ti extends ni { constructor(V, M, G, X) { super(V, M), this.reason = G, this.code = X, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class _s extends ni { constructor(V, M, G, X) { super(V, M), this.reason = G, this.code = X, this.type = 16 } } class Di extends ni { constructor(V, M, G, X) { super(V, M), this.error = G, this.target = X, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class Rs extends ni { constructor(V, M, G, X) { super(V, M), this.urlAfterRedirects = G, this.state = X, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class js extends ni { constructor(V, M, G, X) { super(V, M), this.urlAfterRedirects = G, this.state = X, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Mr extends ni { constructor(V, M, G, X, ce) { super(V, M), this.urlAfterRedirects = G, this.state = X, this.shouldActivate = ce, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class ba extends ni { constructor(V, M, G, X) { super(V, M), this.urlAfterRedirects = G, this.state = X, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class So extends ni { constructor(V, M, G, X) { super(V, M), this.urlAfterRedirects = G, this.state = X, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class al { constructor(V) { this.route = V, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Vi { constructor(V) { this.route = V, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class ls { constructor(V) { this.snapshot = V, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Ho { constructor(V) { this.snapshot = V, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class no { constructor(V) { this.snapshot = V, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Fs { constructor(V) { this.snapshot = V, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class cs { constructor(V, M, G) { this.routerEvent = V, this.position = M, this.anchor = G, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } let dt = (() => { class R { createUrlTree(M, G, X, ce, be, St) { return xn(M || G.root, X, ce, be, St) } } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac }), R })(), hn = (() => { class R { } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: function (V) { return dt.\u0275fac(V) }, providedIn: "root" }), R })(); class Sn { constructor(V) { this._root = V } get root() { return this._root.value } parent(V) { const M = this.pathFromRoot(V); return M.length > 1 ? M[M.length - 2] : null } children(V) { const M = Yn(V, this._root); return M ? M.children.map(G => G.value) : [] } firstChild(V) { const M = Yn(V, this._root); return M && M.children.length > 0 ? M.children[0].value : null } siblings(V) { const M = lr(V, this._root); return M.length < 2 ? [] : M[M.length - 2].children.map(X => X.value).filter(X => X !== V) } pathFromRoot(V) { return lr(V, this._root).map(M => M.value) } } function Yn(R, V) { if (R === V.value) return V; for (const M of V.children) { const G = Yn(R, M); if (G) return G } return null } function lr(R, V) { if (R === V.value) return [V]; for (const M of V.children) { const G = lr(R, M); if (G.length) return G.unshift(V), G } return [] } class wr { constructor(V, M) { this.value = V, this.children = M } toString() { return `TreeNode(${this.value})` } } function Vr(R) { const V = {}; return R && R.children.forEach(M => V[M.value.outlet] = M), V } class Ai extends Sn { constructor(V, M) { super(V), this.snapshot = M, Io(this, V) } toString() { return this.snapshot.toString() } } function Ts(R, V) { const M = function Ds(R, V) { const be = new bo([], {}, {}, "", {}, fn, V, null, R.root, -1, {}); return new Jr("", new wr(be, [])) }(R, V), G = new ye.X([new Fn("", {})]), X = new ye.X({}), ce = new ye.X({}), be = new ye.X({}), St = new ye.X(""), on = new gr(G, X, be, St, ce, fn, V, M.root); return on.snapshot = M.root, new Ai(new wr(on, []), M) } class gr { constructor(V, M, G, X, ce, be, St, on) { this.url = V, this.params = M, this.queryParams = G, this.fragment = X, this.data = ce, this.outlet = be, this.component = St, this.title = this.data?.pipe((0, wt.U)(Kn => Kn[It])) ?? (0, J.of)(void 0), this._futureSnapshot = on } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe((0, wt.U)(V => pt(V)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe((0, wt.U)(V => pt(V)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function xl(R, V = "emptyOnly") { const M = R.pathFromRoot; let G = 0; if ("always" !== V) for (G = M.length - 1; G >= 1;) { const X = M[G], ce = M[G - 1]; if (X.routeConfig && "" === X.routeConfig.path) G--; else { if (ce.component) break; G-- } } return function us(R) { return R.reduce((V, M) => ({ params: { ...V.params, ...M.params }, data: { ...V.data, ...M.data }, resolve: { ...M.data, ...V.resolve, ...M.routeConfig?.data, ...M._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(M.slice(G)) } class bo { get title() { return this.data?.[It] } constructor(V, M, G, X, ce, be, St, on, Kn, Vn, Lr) { this.url = V, this.params = M, this.queryParams = G, this.fragment = X, this.data = ce, this.outlet = be, this.component = St, this.routeConfig = on, this._urlSegment = Kn, this._lastPathIndex = Vn, this._resolve = Lr } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = pt(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = pt(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(G => G.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Jr extends Sn { constructor(V, M) { super(M), this.url = V, Io(this, M) } toString() { return Xn(this._root) } } function Io(R, V) { V.value._routerState = R, V.children.forEach(M => Io(R, M)) } function Xn(R) { const V = R.children.length > 0 ? ` { ${R.children.map(Xn).join(", ")} } ` : ""; return `${R.value}${V}` } function uo(R) { if (R.snapshot) { const V = R.snapshot, M = R._futureSnapshot; R.snapshot = M, Ot(V.queryParams, M.queryParams) || R.queryParams.next(M.queryParams), V.fragment !== M.fragment && R.fragment.next(M.fragment), Ot(V.params, M.params) || R.params.next(M.params), function Ze(R, V) { if (R.length !== V.length) return !1; for (let M = 0; M < R.length; ++M)if (!Ot(R[M], V[M])) return !1; return !0 }(V.url, M.url) || R.url.next(M.url), Ot(V.data, M.data) || R.data.next(M.data) } else R.snapshot = R._futureSnapshot, R.data.next(R._futureSnapshot.data) } function Si(R, V) { const M = Ot(R.params, V.params) && function yn(R, V) { return Qn(R, V) && R.every((M, G) => Ot(M.parameters, V[G].parameters)) }(R.url, V.url); return M && !(!R.parent != !V.parent) && (!R.parent || Si(R.parent, V.parent)) } function io(R, V, M) { if (M && R.shouldReuseRoute(V.value, M.value.snapshot)) { const G = M.value; G._futureSnapshot = V.value; const X = function Wl(R, V, M) { return V.children.map(G => { for (const X of M.children) if (R.shouldReuseRoute(G.value, X.value.snapshot)) return io(R, G, X); return io(R, G) }) }(R, V, M); return new wr(G, X) } { if (R.shouldAttach(V.value)) { const ce = R.retrieve(V.value); if (null !== ce) { const be = ce.route; return be.value._futureSnapshot = V.value, be.children = V.children.map(St => io(R, St)), be } } const G = function zo(R) { return new gr(new ye.X(R.url), new ye.X(R.params), new ye.X(R.queryParams), new ye.X(R.fragment), new ye.X(R.data), R.outlet, R.component, R) }(V.value), X = V.children.map(ce => io(R, ce)); return new wr(G, X) } } const Ys = "ngNavigationCancelingError"; function Go(R, V) { const { redirectTo: M, navigationBehaviorOptions: G } = ze(V) ? { redirectTo: V, navigationBehaviorOptions: void 0 } : V, X = so(!1, 0, V); return X.url = M, X.navigationBehaviorOptions = G, X } function so(R, V, M) { const G = new Error("NavigationCancelingError: " + (R || "")); return G[Ys] = !0, G.cancellationCode = V, M && (G.url = M), G } function jo(R) { return na(R) && ze(R.url) } function na(R) { return R && R[Ys] } class Zl { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.injector = null, this.children = new pi, this.attachRef = null } } let pi = (() => { class R { constructor() { this.contexts = new Map } onChildOutletCreated(M, G) { const X = this.getOrCreateContext(M); X.outlet = G, this.contexts.set(M, X) } onChildOutletDestroyed(M) { const G = this.getContext(M); G && (G.outlet = null, G.attachRef = null) } onOutletDeactivated() { const M = this.contexts; return this.contexts = new Map, M } onOutletReAttached(M) { this.contexts = M } getOrCreateContext(M) { let G = this.getContext(M); return G || (G = new Zl, this.contexts.set(M, G)), G } getContext(M) { return this.contexts.get(M) || null } } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(); const Ss = !1; let $o = (() => { class R { constructor() { this.activated = null, this._activatedRoute = null, this.name = fn, this.activateEvents = new i.vpe, this.deactivateEvents = new i.vpe, this.attachEvents = new i.vpe, this.detachEvents = new i.vpe, this.parentContexts = (0, i.f3M)(pi), this.location = (0, i.f3M)(i.s_b), this.changeDetector = (0, i.f3M)(i.sBO), this.environmentInjector = (0, i.f3M)(i.lqb) } ngOnChanges(M) { if (M.name) { const { firstChange: G, previousValue: X } = M.name; if (G) return; this.isTrackedInParentContexts(X) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(X)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name) } isTrackedInParentContexts(M) { return this.parentContexts.getContext(M)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const M = this.parentContexts.getContext(this.name); M?.route && (M.attachRef ? this.attach(M.attachRef, M.route) : this.activateWith(M.route, M.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new i.vHH(4012, Ss); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new i.vHH(4012, Ss); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new i.vHH(4012, Ss); this.location.detach(); const M = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(M.instance), M } attach(M, G) { this.activated = M, this._activatedRoute = G, this.location.insert(M.hostView), this.attachEvents.emit(M.instance) } deactivate() { if (this.activated) { const M = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(M) } } activateWith(M, G) { if (this.isActivated) throw new i.vHH(4013, Ss); this._activatedRoute = M; const X = this.location, be = M.snapshot.component, St = this.parentContexts.getOrCreateContext(this.name).children, on = new wo(M, St, X.injector); if (G && function ho(R) { return !!R.resolveComponentFactory }(G)) { const Kn = G.resolveComponentFactory(be); this.activated = X.createComponent(Kn, X.length, on) } else this.activated = X.createComponent(be, { index: X.length, injector: on, environmentInjector: G ?? this.environmentInjector }); this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275dir = i.lG2({ type: R, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [i.TTD] }), R })(); class wo { constructor(V, M, G) { this.route = V, this.childContexts = M, this.parent = G } get(V, M) { return V === gr ? this.route : V === pi ? this.childContexts : this.parent.get(V, M) } } let Ao = (() => { class R { } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275cmp = i.Xpm({ type: R, selectors: [["ng-component"]], standalone: !0, features: [i.jDz], decls: 1, vars: 0, template: function (M, G) { 1 & M && i._UZ(0, "router-outlet") }, dependencies: [$o], encapsulation: 2 }), R })(); function rs(R, V) { return R.providers && !R._injector && (R._injector = (0, i.MMx)(R.providers, V, `Route: ${R.path}`)), R._injector ?? V } function xo(R) { const V = R.children && R.children.map(xo), M = V ? { ...R, children: V } : { ...R }; return !M.component && !M.loadComponent && (V || M.loadChildren) && M.outlet && M.outlet !== fn && (M.component = Ao), M } function Ii(R) { return R.outlet || fn } function Ui(R, V) { const M = R.filter(G => Ii(G) === V); return M.push(...R.filter(G => Ii(G) !== V)), M } function Js(R) { if (!R) return null; if (R.routeConfig?._injector) return R.routeConfig._injector; for (let V = R.parent; V; V = V.parent) { const M = V.routeConfig; if (M?._loadedInjector) return M._loadedInjector; if (M?._injector) return M._injector } return null } class Mo { constructor(V, M, G, X) { this.routeReuseStrategy = V, this.futureState = M, this.currState = G, this.forwardEvent = X } activate(V) { const M = this.futureState._root, G = this.currState ? this.currState._root : null; this.deactivateChildRoutes(M, G, V), uo(this.futureState.root), this.activateChildRoutes(M, G, V) } deactivateChildRoutes(V, M, G) { const X = Vr(M); V.children.forEach(ce => { const be = ce.value.outlet; this.deactivateRoutes(ce, X[be], G), delete X[be] }), jt(X, (ce, be) => { this.deactivateRouteAndItsChildren(ce, G) }) } deactivateRoutes(V, M, G) { const X = V.value, ce = M ? M.value : null; if (X === ce) if (X.component) { const be = G.getContext(X.outlet); be && this.deactivateChildRoutes(V, M, be.children) } else this.deactivateChildRoutes(V, M, G); else ce && this.deactivateRouteAndItsChildren(M, G) } deactivateRouteAndItsChildren(V, M) { V.value.component && this.routeReuseStrategy.shouldDetach(V.value.snapshot) ? this.detachAndStoreRouteSubtree(V, M) : this.deactivateRouteAndOutlet(V, M) } detachAndStoreRouteSubtree(V, M) { const G = M.getContext(V.value.outlet), X = G && V.value.component ? G.children : M, ce = Vr(V); for (const be of Object.keys(ce)) this.deactivateRouteAndItsChildren(ce[be], X); if (G && G.outlet) { const be = G.outlet.detach(), St = G.children.onOutletDeactivated(); this.routeReuseStrategy.store(V.value.snapshot, { componentRef: be, route: V, contexts: St }) } } deactivateRouteAndOutlet(V, M) { const G = M.getContext(V.value.outlet), X = G && V.value.component ? G.children : M, ce = Vr(V); for (const be of Object.keys(ce)) this.deactivateRouteAndItsChildren(ce[be], X); G && G.outlet && (G.outlet.deactivate(), G.children.onOutletDeactivated(), G.attachRef = null, G.resolver = null, G.route = null) } activateChildRoutes(V, M, G) { const X = Vr(M); V.children.forEach(ce => { this.activateRoutes(ce, X[ce.value.outlet], G), this.forwardEvent(new Fs(ce.value.snapshot)) }), V.children.length && this.forwardEvent(new Ho(V.value.snapshot)) } activateRoutes(V, M, G) { const X = V.value, ce = M ? M.value : null; if (uo(X), X === ce) if (X.component) { const be = G.getOrCreateContext(X.outlet); this.activateChildRoutes(V, M, be.children) } else this.activateChildRoutes(V, M, G); else if (X.component) { const be = G.getOrCreateContext(X.outlet); if (this.routeReuseStrategy.shouldAttach(X.snapshot)) { const St = this.routeReuseStrategy.retrieve(X.snapshot); this.routeReuseStrategy.store(X.snapshot, null), be.children.onOutletReAttached(St.contexts), be.attachRef = St.componentRef, be.route = St.route.value, be.outlet && be.outlet.attach(St.componentRef, St.route.value), uo(St.route.value), this.activateChildRoutes(V, null, be.children) } else { const St = Js(X.snapshot), on = St?.get(i._Vd) ?? null; be.attachRef = null, be.route = X, be.resolver = on, be.injector = St, be.outlet && be.outlet.activateWith(X, be.injector), this.activateChildRoutes(V, null, be.children) } } else this.activateChildRoutes(V, null, G) } } class Ra { constructor(V) { this.path = V, this.route = this.path[this.path.length - 1] } } class gi { constructor(V, M) { this.component = V, this.route = M } } function Ml(R, V, M) { const G = R._root; return Zr(G, V ? V._root : null, M, [G.value]) } function Qs(R, V) { const M = Symbol(), G = V.get(R, M); return G === M ? "function" != typeof R || (0, i.Z0I)(R) ? V.get(R) : R : G } function Zr(R, V, M, G, X = { canDeactivateChecks: [], canActivateChecks: [] }) { const ce = Vr(V); return R.children.forEach(be => { (function oo(R, V, M, G, X = { canDeactivateChecks: [], canActivateChecks: [] }) { const ce = R.value, be = V ? V.value : null, St = M ? M.getContext(R.value.outlet) : null; if (be && ce.routeConfig === be.routeConfig) { const on = function xs(R, V, M) { if ("function" == typeof M) return M(R, V); switch (M) { case "pathParamsChange": return !Qn(R.url, V.url); case "pathParamsOrQueryParamsChange": return !Qn(R.url, V.url) || !Ot(R.queryParams, V.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Si(R, V) || !Ot(R.queryParams, V.queryParams); default: return !Si(R, V) } }(be, ce, ce.routeConfig.runGuardsAndResolvers); on ? X.canActivateChecks.push(new Ra(G)) : (ce.data = be.data, ce._resolvedData = be._resolvedData), Zr(R, V, ce.component ? St ? St.children : null : M, G, X), on && St && St.outlet && St.outlet.isActivated && X.canDeactivateChecks.push(new gi(St.outlet.component, be)) } else be && Oo(V, St, X), X.canActivateChecks.push(new Ra(G)), Zr(R, null, ce.component ? St ? St.children : null : M, G, X) })(be, ce[be.value.outlet], M, G.concat([be.value]), X), delete ce[be.value.outlet] }), jt(ce, (be, St) => Oo(be, M.getContext(St), X)), X } function Oo(R, V, M) { const G = Vr(R), X = R.value; jt(G, (ce, be) => { Oo(ce, X.component ? V ? V.children.getContext(be) : null : V, M) }), M.canDeactivateChecks.push(new gi(X.component && V && V.outlet && V.outlet.isActivated ? V.outlet.component : null, X)) } function Hi(R) { return "function" == typeof R } function Rt(R) { return R instanceof Ce.K || "EmptyError" === R?.name } const Bn = Symbol("INITIAL_VALUE"); function wi() { return (0, De.w)(R => (0, we.a)(R.map(V => V.pipe((0, je.q)(1), (0, _t.O)(Bn)))).pipe((0, wt.U)(V => { for (const M of V) if (!0 !== M) { if (M === Bn) return Bn; if (!1 === M || M instanceof _r) return M } return !0 }), (0, Qe.h)(V => V !== Bn), (0, je.q)(1))) } function ul(R) { return (0, _e.z)((0, Be.b)(V => { if (ze(V)) throw Go(0, V) }), (0, wt.U)(V => !0 === V)) } const Kl = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function dl(R, V, M, G, X) { const ce = Ms(R, V, M); return ce.matched ? function Yl(R, V, M, G) { const X = V.canMatch; if (!X || 0 === X.length) return (0, J.of)(!0); const ce = X.map(be => { const St = Qs(be, R); return wn(function q(R) { return R && Hi(R.canMatch) }(St) ? St.canMatch(V, M) : R.runInContext(() => St(V, M))) }); return (0, J.of)(ce).pipe(wi(), ul()) }(G = rs(V, G), V, M).pipe((0, wt.U)(be => !0 === be ? ce : { ...Kl })) : (0, J.of)(ce) } function Ms(R, V, M) { if ("" === V.path) return "full" === V.pathMatch && (R.hasChildren() || M.length > 0) ? { ...Kl } : { matched: !0, consumedSegments: [], remainingSegments: M, parameters: {}, positionalParamSegments: {} }; const X = (V.matcher || Pt)(M, R, V); if (!X) return { ...Kl }; const ce = {}; jt(X.posParams, (St, on) => { ce[on] = St.path }); const be = X.consumed.length > 0 ? { ...ce, ...X.consumed[X.consumed.length - 1].parameters } : ce; return { matched: !0, consumedSegments: X.consumed, remainingSegments: M.slice(X.consumed.length), parameters: be, positionalParamSegments: X.posParams ?? {} } } function hs(R, V, M, G) { if (M.length > 0 && function Co(R, V, M) { return M.some(G => Ea(R, V, G) && Ii(G) !== fn) }(R, M, G)) { const ce = new pn(V, function hl(R, V, M, G) { const X = {}; X[fn] = G, G._sourceSegment = R, G._segmentIndexShift = V.length; for (const ce of M) if ("" === ce.path && Ii(ce) !== fn) { const be = new pn([], {}); be._sourceSegment = R, be._segmentIndexShift = V.length, X[Ii(ce)] = be } return X }(R, V, G, new pn(M, R.children))); return ce._sourceSegment = R, ce._segmentIndexShift = V.length, { segmentGroup: ce, slicedSegments: [] } } if (0 === M.length && function bc(R, V, M) { return M.some(G => Ea(R, V, G)) }(R, M, G)) { const ce = new pn(R.segments, function Ca(R, V, M, G, X) { const ce = {}; for (const be of G) if (Ea(R, M, be) && !X[Ii(be)]) { const St = new pn([], {}); St._sourceSegment = R, St._segmentIndexShift = V.length, ce[Ii(be)] = St } return { ...X, ...ce } }(R, V, M, G, R.children)); return ce._sourceSegment = R, ce._segmentIndexShift = V.length, { segmentGroup: ce, slicedSegments: M } } const X = new pn(R.segments, R.children); return X._sourceSegment = R, X._segmentIndexShift = V.length, { segmentGroup: X, slicedSegments: M } } function Ea(R, V, M) { return (!(R.hasChildren() || V.length > 0) || "full" !== M.pathMatch) && "" === M.path } function Jl(R, V, M, G) { return !!(Ii(R) === G || G !== fn && Ea(V, M, R)) && ("**" === R.path || Ms(V, R, M).matched) } function wc(R, V, M) { return 0 === V.length && !R.children[M] } const Ql = !1; class No { constructor(V) { this.segmentGroup = V || null } } class Cc { constructor(V) { this.urlTree = V } } function fl(R) { return (0, ae._)(new No(R)) } function mu(R) { return (0, ae._)(new Cc(R)) } class Ya { constructor(V, M, G, X, ce) { this.injector = V, this.configLoader = M, this.urlSerializer = G, this.urlTree = X, this.config = ce, this.allowRedirects = !0 } apply() { const V = hs(this.urlTree.root, [], [], this.config).segmentGroup, M = new pn(V.segments, V.children); return this.expandSegmentGroup(this.injector, this.config, M, fn).pipe((0, wt.U)(ce => this.createUrlTree(sr(ce), this.urlTree.queryParams, this.urlTree.fragment))).pipe((0, nt.K)(ce => { if (ce instanceof Cc) return this.allowRedirects = !1, this.match(ce.urlTree); throw ce instanceof No ? this.noMatchError(ce) : ce })) } match(V) { return this.expandSegmentGroup(this.injector, this.config, V.root, fn).pipe((0, wt.U)(X => this.createUrlTree(sr(X), V.queryParams, V.fragment))).pipe((0, nt.K)(X => { throw X instanceof No ? this.noMatchError(X) : X })) } noMatchError(V) { return new i.vHH(4002, Ql) } createUrlTree(V, M, G) { const X = ar(V); return new _r(X, M, G) } expandSegmentGroup(V, M, G, X) { return 0 === G.segments.length && G.hasChildren() ? this.expandChildren(V, M, G).pipe((0, wt.U)(ce => new pn([], ce))) : this.expandSegment(V, G, M, G.segments, X, !0) } expandChildren(V, M, G) { const X = []; for (const ce of Object.keys(G.children)) "primary" === ce ? X.unshift(ce) : X.push(ce); return (0, m.D)(X).pipe((0, Ve.b)(ce => { const be = G.children[ce], St = Ui(M, ce); return this.expandSegmentGroup(V, St, be, ce).pipe((0, wt.U)(on => ({ segment: on, outlet: ce }))) }), (0, Ne.R)((ce, be) => (ce[be.outlet] = be.segment, ce), {}), ht()) } expandSegment(V, M, G, X, ce, be) { return (0, m.D)(G).pipe((0, Ve.b)(St => this.expandSegmentAgainstRoute(V, M, G, St, X, ce, be).pipe((0, nt.K)(Kn => { if (Kn instanceof No) return (0, J.of)(null); throw Kn }))), (0, Oe.P)(St => !!St), (0, nt.K)((St, on) => { if (Rt(St)) return wc(M, X, ce) ? (0, J.of)(new pn([], {})) : fl(M); throw St })) } expandSegmentAgainstRoute(V, M, G, X, ce, be, St) { return Jl(X, M, ce, be) ? void 0 === X.redirectTo ? this.matchSegmentAgainstRoute(V, M, X, ce, be) : St && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(V, M, G, X, ce, be) : fl(M) : fl(M) } expandSegmentAgainstRouteUsingRedirect(V, M, G, X, ce, be) { return "**" === X.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(V, G, X, be) : this.expandRegularSegmentAgainstRouteUsingRedirect(V, M, G, X, ce, be) } expandWildCardWithParamsAgainstRouteUsingRedirect(V, M, G, X) { const ce = this.applyRedirectCommands([], G.redirectTo, {}); return G.redirectTo.startsWith("/") ? mu(ce) : this.lineralizeSegments(G, ce).pipe((0, ct.z)(be => { const St = new pn(be, {}); return this.expandSegment(V, St, M, be, X, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(V, M, G, X, ce, be) { const { matched: St, consumedSegments: on, remainingSegments: Kn, positionalParamSegments: Vn } = Ms(M, X, ce); if (!St) return fl(M); const Lr = this.applyRedirectCommands(on, X.redirectTo, Vn); return X.redirectTo.startsWith("/") ? mu(Lr) : this.lineralizeSegments(X, Lr).pipe((0, ct.z)(Gr => this.expandSegment(V, M, G, Gr.concat(Kn), be, !1))) } matchSegmentAgainstRoute(V, M, G, X, ce) { return "**" === G.path ? (V = rs(G, V), G.loadChildren ? (G._loadedRoutes ? (0, J.of)({ routes: G._loadedRoutes, injector: G._loadedInjector }) : this.configLoader.loadChildren(V, G)).pipe((0, wt.U)(St => (G._loadedRoutes = St.routes, G._loadedInjector = St.injector, new pn(X, {})))) : (0, J.of)(new pn(X, {}))) : dl(M, G, X, V).pipe((0, De.w)(({ matched: be, consumedSegments: St, remainingSegments: on }) => be ? this.getChildConfig(V = G._injector ?? V, G, X).pipe((0, ct.z)(Vn => { const Lr = Vn.injector ?? V, Gr = Vn.routes, { segmentGroup: Sr, slicedSegments: $i } = hs(M, St, on, Gr), Wi = new pn(Sr.segments, Sr.children); if (0 === $i.length && Wi.hasChildren()) return this.expandChildren(Lr, Gr, Wi).pipe((0, wt.U)(oa => new pn(St, oa))); if (0 === Gr.length && 0 === $i.length) return (0, J.of)(new pn(St, {})); const sa = Ii(G) === ce; return this.expandSegment(Lr, Wi, Gr, $i, sa ? fn : ce, !0).pipe((0, wt.U)(lo => new pn(St.concat(lo.segments), lo.children))) })) : fl(M))) } getChildConfig(V, M, G) { return M.children ? (0, J.of)({ routes: M.children, injector: V }) : M.loadChildren ? void 0 !== M._loadedRoutes ? (0, J.of)({ routes: M._loadedRoutes, injector: M._loadedInjector }) : function Fa(R, V, M, G) { const X = V.canLoad; if (void 0 === X || 0 === X.length) return (0, J.of)(!0); const ce = X.map(be => { const St = Qs(be, R); return wn(function ys(R) { return R && Hi(R.canLoad) }(St) ? St.canLoad(V, M) : R.runInContext(() => St(V, M))) }); return (0, J.of)(ce).pipe(wi(), ul()) }(V, M, G).pipe((0, ct.z)(X => X ? this.configLoader.loadChildren(V, M).pipe((0, Be.b)(ce => { M._loadedRoutes = ce.routes, M._loadedInjector = ce.injector })) : function Ec(R) { return (0, ae._)(so(Ql, 3)) }())) : (0, J.of)({ routes: [], injector: V }) } lineralizeSegments(V, M) { let G = [], X = M.root; for (; ;) { if (G = G.concat(X.segments), 0 === X.numberOfChildren) return (0, J.of)(G); if (X.numberOfChildren > 1 || !X.children[fn]) return (0, ae._)(new i.vHH(4e3, Ql)); X = X.children[fn] } } applyRedirectCommands(V, M, G) { return this.applyRedirectCreateUrlTree(M, this.urlSerializer.parse(M), V, G) } applyRedirectCreateUrlTree(V, M, G, X) { const ce = this.createSegmentGroup(V, M.root, G, X); return new _r(ce, this.createQueryParams(M.queryParams, this.urlTree.queryParams), M.fragment) } createQueryParams(V, M) { const G = {}; return jt(V, (X, ce) => { if ("string" == typeof X && X.startsWith(":")) { const St = X.substring(1); G[ce] = M[St] } else G[ce] = X }), G } createSegmentGroup(V, M, G, X) { const ce = this.createSegments(V, M.segments, G, X); let be = {}; return jt(M.children, (St, on) => { be[on] = this.createSegmentGroup(V, St, G, X) }), new pn(ce, be) } createSegments(V, M, G, X) { return M.map(ce => ce.path.startsWith(":") ? this.findPosParam(V, ce, X) : this.findOrReturn(ce, G)) } findPosParam(V, M, G) { const X = G[M.path.substring(1)]; if (!X) throw new i.vHH(4001, Ql); return X } findOrReturn(V, M) { let G = 0; for (const X of M) { if (X.path === V.path) return M.splice(G), X; G++ } return V } } class Bd { } class Eo { constructor(V, M, G, X, ce, be, St) { this.injector = V, this.rootComponentType = M, this.config = G, this.urlTree = X, this.url = ce, this.paramsInheritanceStrategy = be, this.urlSerializer = St } recognize() { const V = hs(this.urlTree.root, [], [], this.config.filter(M => void 0 === M.redirectTo)).segmentGroup; return this.processSegmentGroup(this.injector, this.config, V, fn).pipe((0, wt.U)(M => { if (null === M) return null; const G = new bo([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, fn, this.rootComponentType, null, this.urlTree.root, -1, {}), X = new wr(G, M), ce = new Jr(this.url, X); return this.inheritParamsAndData(ce._root), ce })) } inheritParamsAndData(V) { const M = V.value, G = xl(M, this.paramsInheritanceStrategy); M.params = Object.freeze(G.params), M.data = Object.freeze(G.data), V.children.forEach(X => this.inheritParamsAndData(X)) } processSegmentGroup(V, M, G, X) { return 0 === G.segments.length && G.hasChildren() ? this.processChildren(V, M, G) : this.processSegment(V, M, G, G.segments, X) } processChildren(V, M, G) { return (0, m.D)(Object.keys(G.children)).pipe((0, Ve.b)(X => { const ce = G.children[X], be = Ui(M, X); return this.processSegmentGroup(V, be, ce, X) }), (0, Ne.R)((X, ce) => X && ce ? (X.push(...ce), X) : null), (0, Kt.o)(X => null !== X), (0, Ue.d)(null), ht(), (0, wt.U)(X => { if (null === X) return null; const ce = ec(X); return function La(R) { R.sort((V, M) => V.value.outlet === fn ? -1 : M.value.outlet === fn ? 1 : V.value.outlet.localeCompare(M.value.outlet)) }(ce), ce })) } processSegment(V, M, G, X, ce) { return (0, m.D)(M).pipe((0, Ve.b)(be => this.processSegmentAgainstRoute(be._injector ?? V, be, G, X, ce)), (0, Oe.P)(be => !!be), (0, nt.K)(be => { if (Rt(be)) return wc(G, X, ce) ? (0, J.of)([]) : (0, J.of)(null); throw be })) } processSegmentAgainstRoute(V, M, G, X, ce) { if (M.redirectTo || !Jl(M, G, X, ce)) return (0, J.of)(null); let be; if ("**" === M.path) { const St = X.length > 0 ? kt(X).parameters : {}, on = Nl(G) + X.length, Kn = new bo(X, St, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, kl(M), Ii(M), M.component ?? M._loadedComponent ?? null, M, Da(G), on, z(M)); be = (0, J.of)({ snapshot: Kn, consumedSegments: [], remainingSegments: [] }) } else be = dl(G, M, X, V).pipe((0, wt.U)(({ matched: St, consumedSegments: on, remainingSegments: Kn, parameters: Vn }) => { if (!St) return null; const Lr = Nl(G) + on.length; return { snapshot: new bo(on, Vn, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, kl(M), Ii(M), M.component ?? M._loadedComponent ?? null, M, Da(G), Lr, z(M)), consumedSegments: on, remainingSegments: Kn } })); return be.pipe((0, De.w)(St => { if (null === St) return (0, J.of)(null); const { snapshot: on, consumedSegments: Kn, remainingSegments: Vn } = St; V = M._injector ?? V; const Lr = M._loadedInjector ?? V, Gr = function es(R) { return R.children ? R.children : R.loadChildren ? R._loadedRoutes : [] }(M), { segmentGroup: Sr, slicedSegments: $i } = hs(G, Kn, Vn, Gr.filter(sa => void 0 === sa.redirectTo)); if (0 === $i.length && Sr.hasChildren()) return this.processChildren(Lr, Gr, Sr).pipe((0, wt.U)(sa => null === sa ? null : [new wr(on, sa)])); if (0 === Gr.length && 0 === $i.length) return (0, J.of)([new wr(on, [])]); const Wi = Ii(M) === ce; return this.processSegment(Lr, Gr, Sr, $i, Wi ? fn : ce).pipe((0, wt.U)(sa => null === sa ? null : [new wr(on, sa)])) })) } } function Ja(R) { const V = R.value.routeConfig; return V && "" === V.path && void 0 === V.redirectTo } function ec(R) { const V = [], M = new Set; for (const G of R) { if (!Ja(G)) { V.push(G); continue } const X = V.find(ce => G.value.routeConfig === ce.value.routeConfig); void 0 !== X ? (X.children.push(...G.children), M.add(X)) : V.push(G) } for (const G of M) { const X = ec(G.children); V.push(new wr(G.value, X)) } return V.filter(G => !M.has(G)) } function Da(R) { let V = R; for (; V._sourceSegment;)V = V._sourceSegment; return V } function Nl(R) { let V = R, M = V._segmentIndexShift ?? 0; for (; V._sourceSegment;)V = V._sourceSegment, M += V._segmentIndexShift ?? 0; return M - 1 } function kl(R) { return R.data || {} } function z(R) { return R.resolve || {} } function Nn(R) { return "string" == typeof R.title || null === R.title } function ri(R) { return (0, De.w)(V => { const M = R(V); return M ? (0, m.D)(M).pipe((0, wt.U)(() => V)) : (0, J.of)(V) }) } const Or = new i.OlP("ROUTES"); let fs = (() => { class R { constructor(M, G) { this.injector = M, this.compiler = G, this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap } loadComponent(M) { if (this.componentLoaders.get(M)) return this.componentLoaders.get(M); if (M._loadedComponent) return (0, J.of)(M._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(M); const G = wn(M.loadComponent()).pipe((0, wt.U)(Os), (0, Be.b)(ce => { this.onLoadEndListener && this.onLoadEndListener(M), M._loadedComponent = ce }), (0, On.x)(() => { this.componentLoaders.delete(M) })), X = new gt.c(G, () => new Se.x).pipe((0, qn.x)()); return this.componentLoaders.set(M, X), X } loadChildren(M, G) { if (this.childrenLoaders.get(G)) return this.childrenLoaders.get(G); if (G._loadedRoutes) return (0, J.of)({ routes: G._loadedRoutes, injector: G._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(G); const ce = this.loadModuleFactoryOrRoutes(G.loadChildren).pipe((0, wt.U)(St => { this.onLoadEndListener && this.onLoadEndListener(G); let on, Kn, Vn = !1; Array.isArray(St) ? Kn = St : (on = St.create(M).injector, Kn = Xe(on.get(Or, [], i.XFs.Self | i.XFs.Optional))); return { routes: Kn.map(xo), injector: on } }), (0, On.x)(() => { this.childrenLoaders.delete(G) })), be = new gt.c(ce, () => new Se.x).pipe((0, qn.x)()); return this.childrenLoaders.set(G, be), be } loadModuleFactoryOrRoutes(M) { return wn(M()).pipe((0, wt.U)(Os), (0, ct.z)(X => X instanceof i.YKP || Array.isArray(X) ? (0, J.of)(X) : (0, m.D)(this.compiler.compileModuleAsync(X)))) } } return R.\u0275fac = function (M) { return new (M || R)(i.LFG(i.zs3), i.LFG(i.Sil)) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(); function Os(R) { return function xr(R) { return R && "object" == typeof R && "default" in R }(R) ? R.default : R } let bs = (() => { class R { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.lastSuccessfulNavigation = null, this.events = new Se.x, this.configLoader = (0, i.f3M)(fs), this.environmentInjector = (0, i.f3M)(i.lqb), this.urlSerializer = (0, i.f3M)(dr), this.rootContexts = (0, i.f3M)(pi), this.navigationId = 0, this.afterPreactivation = () => (0, J.of)(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = X => this.events.next(new Vi(X)), this.configLoader.onLoadStartListener = X => this.events.next(new al(X)) } complete() { this.transitions?.complete() } handleNavigationRequest(M) { const G = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...M, id: G }) } setupNavigations(M) { return this.transitions = new ye.X({ id: 0, targetPageId: 0, currentUrlTree: M.currentUrlTree, currentRawUrl: M.currentUrlTree, extractedUrl: M.urlHandlingStrategy.extract(M.currentUrlTree), urlAfterRedirects: M.urlHandlingStrategy.extract(M.currentUrlTree), rawUrl: M.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: pr, restoredState: null, currentSnapshot: M.routerState.snapshot, targetSnapshot: null, currentRouterState: M.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe((0, Qe.h)(G => 0 !== G.id), (0, wt.U)(G => ({ ...G, extractedUrl: M.urlHandlingStrategy.extract(G.rawUrl) })), (0, De.w)(G => { let X = !1, ce = !1; return (0, J.of)(G).pipe((0, Be.b)(be => { this.currentNavigation = { id: be.id, initialUrl: be.rawUrl, extractedUrl: be.extractedUrl, trigger: be.source, extras: be.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), (0, De.w)(be => { const St = M.browserUrlTree.toString(), on = !M.navigated || be.extractedUrl.toString() !== St || St !== M.currentUrlTree.toString(); if (!on && "reload" !== (be.extras.onSameUrlNavigation ?? M.onSameUrlNavigation)) { const Vn = ""; return this.events.next(new _s(be.id, M.serializeUrl(G.rawUrl), Vn, 0)), M.rawUrlTree = be.rawUrl, be.resolve(null), xe.E } if (M.urlHandlingStrategy.shouldProcessUrl(be.rawUrl)) return To(be.source) && (M.browserUrlTree = be.extractedUrl), (0, J.of)(be).pipe((0, De.w)(Vn => { const Lr = this.transitions?.getValue(); return this.events.next(new as(Vn.id, this.urlSerializer.serialize(Vn.extractedUrl), Vn.source, Vn.restoredState)), Lr !== this.transitions?.getValue() ? xe.E : Promise.resolve(Vn) }), function Tc(R, V, M, G) { return (0, De.w)(X => function Ol(R, V, M, G, X) { return new Ya(R, V, M, G, X).apply() }(R, V, M, X.extractedUrl, G).pipe((0, wt.U)(ce => ({ ...X, urlAfterRedirects: ce })))) }(this.environmentInjector, this.configLoader, this.urlSerializer, M.config), (0, Be.b)(Vn => { this.currentNavigation = { ...this.currentNavigation, finalUrl: Vn.urlAfterRedirects }, G.urlAfterRedirects = Vn.urlAfterRedirects }), function re(R, V, M, G, X) { return (0, ct.z)(ce => function Ka(R, V, M, G, X, ce, be = "emptyOnly") { return new Eo(R, V, M, G, X, be, ce).recognize().pipe((0, De.w)(St => null === St ? function pl(R) { return new ve.y(V => V.error(R)) }(new Bd) : (0, J.of)(St))) }(R, V, M, ce.urlAfterRedirects, G.serialize(ce.urlAfterRedirects), G, X).pipe((0, wt.U)(be => ({ ...ce, targetSnapshot: be })))) }(this.environmentInjector, this.rootComponentType, M.config, this.urlSerializer, M.paramsInheritanceStrategy), (0, Be.b)(Vn => { if (G.targetSnapshot = Vn.targetSnapshot, "eager" === M.urlUpdateStrategy) { if (!Vn.extras.skipLocationChange) { const Gr = M.urlHandlingStrategy.merge(Vn.urlAfterRedirects, Vn.rawUrl); M.setBrowserUrl(Gr, Vn) } M.browserUrlTree = Vn.urlAfterRedirects } const Lr = new Rs(Vn.id, this.urlSerializer.serialize(Vn.extractedUrl), this.urlSerializer.serialize(Vn.urlAfterRedirects), Vn.targetSnapshot); this.events.next(Lr) })); if (on && M.urlHandlingStrategy.shouldProcessUrl(M.rawUrlTree)) { const { id: Vn, extractedUrl: Lr, source: Gr, restoredState: Sr, extras: $i } = be, Wi = new as(Vn, this.urlSerializer.serialize(Lr), Gr, Sr); this.events.next(Wi); const sa = Ts(Lr, this.rootComponentType).snapshot; return G = { ...be, targetSnapshot: sa, urlAfterRedirects: Lr, extras: { ...$i, skipLocationChange: !1, replaceUrl: !1 } }, (0, J.of)(G) } { const Vn = ""; return this.events.next(new _s(be.id, M.serializeUrl(G.extractedUrl), Vn, 1)), M.rawUrlTree = be.rawUrl, be.resolve(null), xe.E } }), (0, Be.b)(be => { const St = new js(be.id, this.urlSerializer.serialize(be.extractedUrl), this.urlSerializer.serialize(be.urlAfterRedirects), be.targetSnapshot); this.events.next(St) }), (0, wt.U)(be => G = { ...be, guards: Ml(be.targetSnapshot, be.currentSnapshot, this.rootContexts) }), function Jt(R, V) { return (0, ct.z)(M => { const { targetSnapshot: G, currentSnapshot: X, guards: { canActivateChecks: ce, canDeactivateChecks: be } } = M; return 0 === be.length && 0 === ce.length ? (0, J.of)({ ...M, guardsResult: !0 }) : function zr(R, V, M, G) { return (0, m.D)(R).pipe((0, ct.z)(X => function po(R, V, M, G, X) { const ce = V && V.routeConfig ? V.routeConfig.canDeactivate : null; if (!ce || 0 === ce.length) return (0, J.of)(!0); const be = ce.map(St => { const on = Js(V) ?? X, Kn = Qs(St, on); return wn(function Q(R) { return R && Hi(R.canDeactivate) }(Kn) ? Kn.canDeactivate(R, V, M, G) : on.runInContext(() => Kn(R, V, M, G))).pipe((0, Oe.P)()) }); return (0, J.of)(be).pipe(wi()) }(X.component, X.route, M, V, G)), (0, Oe.P)(X => !0 !== X, !0)) }(be, G, X, R).pipe((0, ct.z)(St => St && function qa(R) { return "boolean" == typeof R }(St) ? function ll(R, V, M, G) { return (0, m.D)(V).pipe((0, Ve.b)(X => (0, Te.z)(function vs(R, V) { return null !== R && V && V(new ls(R)), (0, J.of)(!0) }(X.route.parent, G), function qc(R, V) { return null !== R && V && V(new no(R)), (0, J.of)(!0) }(X.route, G), function cl(R, V, M) { const G = V[V.length - 1], ce = V.slice(0, V.length - 1).reverse().map(be => function wa(R) { const V = R.routeConfig ? R.routeConfig.canActivateChild : null; return V && 0 !== V.length ? { node: R, guards: V } : null }(be)).filter(be => null !== be).map(be => (0, Ee.P)(() => { const St = be.guards.map(on => { const Kn = Js(be.node) ?? M, Vn = Qs(on, Kn); return wn(function Xs(R) { return R && Hi(R.canActivateChild) }(Vn) ? Vn.canActivateChild(G, R) : Kn.runInContext(() => Vn(G, R))).pipe((0, Oe.P)()) }); return (0, J.of)(St).pipe(wi()) })); return (0, J.of)(ce).pipe(wi()) }(R, X.path, M), function ql(R, V, M) { const G = V.routeConfig ? V.routeConfig.canActivate : null; if (!G || 0 === G.length) return (0, J.of)(!0); const X = G.map(ce => (0, Ee.P)(() => { const be = Js(V) ?? M, St = Qs(ce, be); return wn(function hr(R) { return R && Hi(R.canActivate) }(St) ? St.canActivate(V, R) : be.runInContext(() => St(V, R))).pipe((0, Oe.P)()) })); return (0, J.of)(X).pipe(wi()) }(R, X.route, M))), (0, Oe.P)(X => !0 !== X, !0)) }(G, ce, R, V) : (0, J.of)(St)), (0, wt.U)(St => ({ ...M, guardsResult: St }))) }) }(this.environmentInjector, be => this.events.next(be)), (0, Be.b)(be => { if (G.guardsResult = be.guardsResult, ze(be.guardsResult)) throw Go(0, be.guardsResult); const St = new Mr(be.id, this.urlSerializer.serialize(be.extractedUrl), this.urlSerializer.serialize(be.urlAfterRedirects), be.targetSnapshot, !!be.guardsResult); this.events.next(St) }), (0, Qe.h)(be => !!be.guardsResult || (M.restoreHistory(be), this.cancelNavigationTransition(be, "", 3), !1)), ri(be => { if (be.guards.canActivateChecks.length) return (0, J.of)(be).pipe((0, Be.b)(St => { const on = new ba(St.id, this.urlSerializer.serialize(St.extractedUrl), this.urlSerializer.serialize(St.urlAfterRedirects), St.targetSnapshot); this.events.next(on) }), (0, De.w)(St => { let on = !1; return (0, J.of)(St).pipe(function Z(R, V) { return (0, ct.z)(M => { const { targetSnapshot: G, guards: { canActivateChecks: X } } = M; if (!X.length) return (0, J.of)(M); let ce = 0; return (0, m.D)(X).pipe((0, Ve.b)(be => function he(R, V, M, G) { const X = R.routeConfig, ce = R._resolve; return void 0 !== X?.title && !Nn(X) && (ce[It] = X.title), function $e(R, V, M, G) { const X = function Ft(R) { return [...Object.keys(R), ...Object.getOwnPropertySymbols(R)] }(R); if (0 === X.length) return (0, J.of)({}); const ce = {}; return (0, m.D)(X).pipe((0, ct.z)(be => function Xt(R, V, M, G) { const X = Js(V) ?? G, ce = Qs(R, X); return wn(ce.resolve ? ce.resolve(V, M) : X.runInContext(() => ce(V, M))) }(R[be], V, M, G).pipe((0, Oe.P)(), (0, Be.b)(St => { ce[be] = St }))), (0, tt.h)(1), (0, rn.h)(ce), (0, nt.K)(be => Rt(be) ? xe.E : (0, ae._)(be))) }(ce, R, V, G).pipe((0, wt.U)(be => (R._resolvedData = be, R.data = xl(R, M).resolve, X && Nn(X) && (R.data[It] = X.title), null))) }(be.route, G, R, V)), (0, Be.b)(() => ce++), (0, tt.h)(1), (0, ct.z)(be => ce === X.length ? (0, J.of)(M) : xe.E)) }) }(M.paramsInheritanceStrategy, this.environmentInjector), (0, Be.b)({ next: () => on = !0, complete: () => { on || (M.restoreHistory(St), this.cancelNavigationTransition(St, "", 2)) } })) }), (0, Be.b)(St => { const on = new So(St.id, this.urlSerializer.serialize(St.extractedUrl), this.urlSerializer.serialize(St.urlAfterRedirects), St.targetSnapshot); this.events.next(on) })) }), ri(be => { const St = on => { const Kn = []; on.routeConfig?.loadComponent && !on.routeConfig._loadedComponent && Kn.push(this.configLoader.loadComponent(on.routeConfig).pipe((0, Be.b)(Vn => { on.component = Vn }), (0, wt.U)(() => { }))); for (const Vn of on.children) Kn.push(...St(Vn)); return Kn }; return (0, we.a)(St(be.targetSnapshot.root)).pipe((0, Ue.d)(), (0, je.q)(1)) }), ri(() => this.afterPreactivation()), (0, wt.U)(be => { const St = function ka(R, V, M) { const G = io(R, V._root, M ? M._root : void 0); return new Ai(G, V) }(M.routeReuseStrategy, be.targetSnapshot, be.currentRouterState); return G = { ...be, targetRouterState: St } }), (0, Be.b)(be => { M.currentUrlTree = be.urlAfterRedirects, M.rawUrlTree = M.urlHandlingStrategy.merge(be.urlAfterRedirects, be.rawUrl), M.routerState = be.targetRouterState, "deferred" === M.urlUpdateStrategy && (be.extras.skipLocationChange || M.setBrowserUrl(M.rawUrlTree, be), M.browserUrlTree = be.urlAfterRedirects) }), ((R, V, M) => (0, wt.U)(G => (new Mo(V, G.targetRouterState, G.currentRouterState, M).activate(R), G)))(this.rootContexts, M.routeReuseStrategy, be => this.events.next(be)), (0, Be.b)({ next: be => { X = !0, this.lastSuccessfulNavigation = this.currentNavigation, M.navigated = !0, this.events.next(new Xi(be.id, this.urlSerializer.serialize(be.extractedUrl), this.urlSerializer.serialize(M.currentUrlTree))), M.titleStrategy?.updateTitle(be.targetRouterState.snapshot), be.resolve(!0) }, complete: () => { X = !0 } }), (0, On.x)(() => { X || ce || this.cancelNavigationTransition(G, "", 1), this.currentNavigation?.id === G.id && (this.currentNavigation = null) }), (0, nt.K)(be => { if (ce = !0, na(be)) { jo(be) || (M.navigated = !0, M.restoreHistory(G, !0)); const St = new Ti(G.id, this.urlSerializer.serialize(G.extractedUrl), be.message, be.cancellationCode); if (this.events.next(St), jo(be)) { const on = M.urlHandlingStrategy.merge(be.url, M.rawUrlTree), Kn = { skipLocationChange: G.extras.skipLocationChange, replaceUrl: "eager" === M.urlUpdateStrategy || To(G.source) }; M.scheduleNavigation(on, pr, null, Kn, { resolve: G.resolve, reject: G.reject, promise: G.promise }) } else G.resolve(!1) } else { M.restoreHistory(G, !0); const St = new Di(G.id, this.urlSerializer.serialize(G.extractedUrl), be, G.targetSnapshot ?? void 0); this.events.next(St); try { G.resolve(M.errorHandler(be)) } catch (on) { G.reject(on) } } return xe.E })) })) } cancelNavigationTransition(M, G, X) { const ce = new Ti(M.id, this.urlSerializer.serialize(M.extractedUrl), G, X); this.events.next(ce), M.resolve(!1) } } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(); function To(R) { return R !== pr } let go = (() => { class R { buildTitle(M) { let G, X = M.root; for (; void 0 !== X;)G = this.getResolvedTitleForRoute(X) ?? G, X = X.children.find(ce => ce.outlet === fn); return G } getResolvedTitleForRoute(M) { return M.data[It] } } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: function () { return (0, i.f3M)(Ba) }, providedIn: "root" }), R })(), Ba = (() => { class R extends go { constructor(M) { super(), this.title = M } updateTitle(M) { const G = this.buildTitle(M); void 0 !== G && this.title.setTitle(G) } } return R.\u0275fac = function (M) { return new (M || R)(i.LFG(kn.Dx)) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(), Va = (() => { class R { } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: function () { return (0, i.f3M)(Dc) }, providedIn: "root" }), R })(); class xi { shouldDetach(V) { return !1 } store(V, M) { } shouldAttach(V) { return !1 } retrieve(V) { return null } shouldReuseRoute(V, M) { return V.routeConfig === M.routeConfig } } let Dc = (() => { class R extends xi { } return R.\u0275fac = function () { let V; return function (G) { return (V || (V = i.n5z(R)))(G || R) } }(), R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(); const Zo = new i.OlP("", { providedIn: "root", factory: () => ({}) }); let qo = (() => { class R { } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: function () { return (0, i.f3M)(gl) }, providedIn: "root" }), R })(), gl = (() => { class R { shouldProcessUrl(M) { return !0 } extract(M) { return M } merge(M, G) { return M } } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(); function Pl(R) { throw R } function Rl(R, V, M) { return V.parse("/") } const $s = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, Fl = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Bs = (() => { class R { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { return this.location.getState()?.\u0275routerPageId } get events() { return this.navigationTransitions.events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = (0, i.f3M)(i.c2e), this.isNgZoneEnabled = !1, this.options = (0, i.f3M)(Zo, { optional: !0 }) || {}, this.errorHandler = this.options.errorHandler || Pl, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || Rl, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = (0, i.f3M)(qo), this.routeReuseStrategy = (0, i.f3M)(Va), this.urlCreationStrategy = (0, i.f3M)(hn), this.titleStrategy = (0, i.f3M)(go), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = Xe((0, i.f3M)(Or, { optional: !0 }) ?? []), this.navigationTransitions = (0, i.f3M)(bs), this.urlSerializer = (0, i.f3M)(dr), this.location = (0, i.f3M)(rt.Ye), this.isNgZoneEnabled = (0, i.f3M)(i.R0b) instanceof i.R0b && i.R0b.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new _r, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = Ts(this.currentUrlTree, null), this.navigationTransitions.setupNavigations(this).subscribe(M => { this.lastSuccessfulId = M.id, this.currentPageId = M.targetPageId }, M => { this.console.warn(`Unhandled Navigation Error: ${M}`) }) } resetRootComponentType(M) { this.routerState.root.component = M, this.navigationTransitions.rootComponentType = M } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const M = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), pr, M) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(M => { const G = "popstate" === M.type ? "popstate" : "hashchange"; "popstate" === G && setTimeout(() => { this.navigateToSyncWithBrowser(M.url, G, M.state) }, 0) })) } navigateToSyncWithBrowser(M, G, X) { const ce = { replaceUrl: !0 }, be = X?.navigationId ? X : null; if (X) { const on = { ...X }; delete on.navigationId, delete on.\u0275routerPageId, 0 !== Object.keys(on).length && (ce.state = on) } const St = this.parseUrl(M); this.scheduleNavigation(St, G, be, ce) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } resetConfig(M) { this.config = M.map(xo), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(M, G = {}) { const { relativeTo: X, queryParams: ce, fragment: be, queryParamsHandling: St, preserveFragment: on } = G, Kn = on ? this.currentUrlTree.fragment : be; let Vn = null; switch (St) { case "merge": Vn = { ...this.currentUrlTree.queryParams, ...ce }; break; case "preserve": Vn = this.currentUrlTree.queryParams; break; default: Vn = ce || null }return null !== Vn && (Vn = this.removeEmptyProps(Vn)), this.urlCreationStrategy.createUrlTree(X, this.routerState, this.currentUrlTree, M, Vn, Kn ?? null) } navigateByUrl(M, G = { skipLocationChange: !1 }) { const X = ze(M) ? M : this.parseUrl(M), ce = this.urlHandlingStrategy.merge(X, this.rawUrlTree); return this.scheduleNavigation(ce, pr, null, G) } navigate(M, G = { skipLocationChange: !1 }) { return function Qa(R) { for (let V = 0; V < R.length; V++) { if (null == R[V]) throw new i.vHH(4008, !1) } }(M), this.navigateByUrl(this.createUrlTree(M, G), G) } serializeUrl(M) { return this.urlSerializer.serialize(M) } parseUrl(M) { let G; try { G = this.urlSerializer.parse(M) } catch (X) { G = this.malformedUriErrorHandler(X, this.urlSerializer, M) } return G } isActive(M, G) { let X; if (X = !0 === G ? { ...$s } : !1 === G ? { ...Fl } : G, ze(M)) return dn(this.currentUrlTree, M, X); const ce = this.parseUrl(M); return dn(this.currentUrlTree, ce, X) } removeEmptyProps(M) { return Object.keys(M).reduce((G, X) => { const ce = M[X]; return null != ce && (G[X] = ce), G }, {}) } scheduleNavigation(M, G, X, ce, be) { if (this.disposed) return Promise.resolve(!1); let St, on, Kn, Vn; return be ? (St = be.resolve, on = be.reject, Kn = be.promise) : Kn = new Promise((Lr, Gr) => { St = Lr, on = Gr }), Vn = "computed" === this.canceledNavigationResolution ? X && X.\u0275routerPageId ? X.\u0275routerPageId : ce.replaceUrl || ce.skipLocationChange ? this.browserPageId ?? 0 : (this.browserPageId ?? 0) + 1 : 0, this.navigationTransitions.handleNavigationRequest({ targetPageId: Vn, source: G, restoredState: X, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: M, extras: ce, resolve: St, reject: on, promise: Kn, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), Kn.catch(Lr => Promise.reject(Lr)) } setBrowserUrl(M, G) { const X = this.urlSerializer.serialize(M), ce = { ...G.extras.state, ...this.generateNgRouterState(G.id, G.targetPageId) }; this.location.isCurrentPathEqualTo(X) || G.extras.replaceUrl ? this.location.replaceState(X, "", ce) : this.location.go(X, "", ce) } restoreHistory(M, G = !1) { if ("computed" === this.canceledNavigationResolution) { const X = this.currentPageId - M.targetPageId; "popstate" !== M.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== this.getCurrentNavigation()?.finalUrl || 0 === X ? this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === X && (this.resetState(M), this.browserUrlTree = M.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(X) } else "replace" === this.canceledNavigationResolution && (G && this.resetState(M), this.resetUrlToCurrentUrlTree()) } resetState(M) { this.routerState = M.currentRouterState, this.currentUrlTree = M.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, M.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(M, G) { return "computed" === this.canceledNavigationResolution ? { navigationId: M, \u0275routerPageId: G } : { navigationId: M } } } return R.\u0275fac = function (M) { return new (M || R) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(), Xa = (() => { class R { constructor(M, G, X, ce, be, St) { this.router = M, this.route = G, this.tabIndexAttribute = X, this.renderer = ce, this.el = be, this.locationStrategy = St, this._preserveFragment = !1, this._skipLocationChange = !1, this._replaceUrl = !1, this.href = null, this.commands = null, this.onChanges = new Se.x; const on = be.nativeElement.tagName; this.isAnchorElement = "A" === on || "AREA" === on, this.isAnchorElement ? this.subscription = M.events.subscribe(Kn => { Kn instanceof Xi && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } set preserveFragment(M) { this._preserveFragment = (0, i.D6c)(M) } get preserveFragment() { return this._preserveFragment } set skipLocationChange(M) { this._skipLocationChange = (0, i.D6c)(M) } get skipLocationChange() { return this._skipLocationChange } set replaceUrl(M) { this._replaceUrl = (0, i.D6c)(M) } get replaceUrl() { return this._replaceUrl } setTabIndexIfNotOnNativeEl(M) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", M) } ngOnChanges(M) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(M) { null != M ? (this.commands = Array.isArray(M) ? M : [M], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick(M, G, X, ce, be) { return !!(null === this.urlTree || this.isAnchorElement && (0 !== M || G || X || ce || be || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null; const M = null === this.href ? null : (0, i.P3R)(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", M) } applyAttributeValue(M, G) { const X = this.renderer, ce = this.el.nativeElement; null !== G ? X.setAttribute(ce, M, G) : X.removeAttribute(ce, M) } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } } return R.\u0275fac = function (M) { return new (M || R)(i.Y36(Bs), i.Y36(gr), i.$8M("tabindex"), i.Y36(i.Qsj), i.Y36(i.SBq), i.Y36(rt.S$)) }, R.\u0275dir = i.lG2({ type: R, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (M, G) { 1 & M && i.NdJ("click", function (ce) { return G.onClick(ce.button, ce.ctrlKey, ce.shiftKey, ce.altKey, ce.metaKey) }), 2 & M && i.uIk("target", G.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", routerLink: "routerLink" }, standalone: !0, features: [i.TTD] }), R })(), Kc = (() => { class R { get isActive() { return this._isActive } constructor(M, G, X, ce, be) { this.router = M, this.element = G, this.renderer = X, this.cdr = ce, this.link = be, this.classes = [], this._isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.isActiveChange = new i.vpe, this.routerEventsSubscription = M.events.subscribe(St => { St instanceof Xi && this.update() }) } ngAfterContentInit() { (0, J.of)(this.links.changes, (0, J.of)(null)).pipe((0, nr.J)()).subscribe(M => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { this.linkInputChangesSubscription?.unsubscribe(); const M = [...this.links.toArray(), this.link].filter(G => !!G).map(G => G.onChanges); this.linkInputChangesSubscription = (0, m.D)(M).pipe((0, nr.J)()).subscribe(G => { this._isActive !== this.isLinkActive(this.router)(G) && this.update() }) } set routerLinkActive(M) { const G = Array.isArray(M) ? M : M.split(" "); this.classes = G.filter(X => !!X) } ngOnChanges(M) { this.update() } ngOnDestroy() { this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe() } update() { !this.links || !this.router.navigated || Promise.resolve().then(() => { const M = this.hasActiveLinks(); this._isActive !== M && (this._isActive = M, this.cdr.markForCheck(), this.classes.forEach(G => { M ? this.renderer.addClass(this.element.nativeElement, G) : this.renderer.removeClass(this.element.nativeElement, G) }), M && void 0 !== this.ariaCurrentWhenActive ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this.isActiveChange.emit(M)) }) } isLinkActive(M) { const G = function Sc(R) { return !!R.paths }(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return X => !!X.urlTree && M.isActive(X.urlTree, G) } hasActiveLinks() { const M = this.isLinkActive(this.router); return this.link && M(this.link) || this.links.some(M) } } return R.\u0275fac = function (M) { return new (M || R)(i.Y36(Bs), i.Y36(i.SBq), i.Y36(i.Qsj), i.Y36(i.sBO), i.Y36(Xa, 8)) }, R.\u0275dir = i.lG2({ type: R, selectors: [["", "routerLinkActive", ""]], contentQueries: function (M, G, X) { if (1 & M && i.Suo(X, Xa, 5), 2 & M) { let ce; i.iGM(ce = i.CRH()) && (G.links = ce) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, exportAs: ["routerLinkActive"], standalone: !0, features: [i.TTD] }), R })(); class Jc { } let Lu = (() => { class R { constructor(M, G, X, ce, be) { this.router = M, this.injector = X, this.preloadingStrategy = ce, this.loader = be } setUpPreloading() { this.subscription = this.router.events.pipe((0, Qe.h)(M => M instanceof Xi), (0, Ve.b)(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(M, G) { const X = []; for (const ce of G) { ce.providers && !ce._injector && (ce._injector = (0, i.MMx)(ce.providers, M, `Route: ${ce.path}`)); const be = ce._injector ?? M, St = ce._loadedInjector ?? be; ce.loadChildren && !ce._loadedRoutes && void 0 === ce.canLoad || ce.loadComponent && !ce._loadedComponent ? X.push(this.preloadConfig(be, ce)) : (ce.children || ce._loadedRoutes) && X.push(this.processRoutes(St, ce.children ?? ce._loadedRoutes)) } return (0, m.D)(X).pipe((0, nr.J)()) } preloadConfig(M, G) { return this.preloadingStrategy.preload(G, () => { let X; X = G.loadChildren && void 0 === G.canLoad ? this.loader.loadChildren(M, G) : (0, J.of)(null); const ce = X.pipe((0, ct.z)(be => null === be ? (0, J.of)(void 0) : (G._loadedRoutes = be.routes, G._loadedInjector = be.injector, this.processRoutes(be.injector ?? M, be.routes)))); if (G.loadComponent && !G._loadedComponent) { const be = this.loader.loadComponent(G); return (0, m.D)([ce, be]).pipe((0, nr.J)()) } return ce }) } } return R.\u0275fac = function (M) { return new (M || R)(i.LFG(Bs), i.LFG(i.Sil), i.LFG(i.lqb), i.LFG(Jc), i.LFG(fs)) }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac, providedIn: "root" }), R })(); const eo = new i.OlP(""); let Ic = (() => { class R { constructor(M, G, X, ce, be = {}) { this.urlSerializer = M, this.transitions = G, this.viewportScroller = X, this.zone = ce, this.options = be, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, be.scrollPositionRestoration = be.scrollPositionRestoration || "disabled", be.anchorScrolling = be.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(M => { M instanceof as ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = M.navigationTrigger, this.restoredId = M.restoredState ? M.restoredState.navigationId : 0) : M instanceof Xi && (this.lastId = M.id, this.scheduleScrollEvent(M, this.urlSerializer.parse(M.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(M => { M instanceof cs && (M.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(M.position) : M.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(M.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(M, G) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new cs(M, "popstate" === this.lastSource ? this.store[this.restoredId] : null, G)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } } return R.\u0275fac = function (M) { i.$Z() }, R.\u0275prov = i.Yz7({ token: R, factory: R.\u0275fac }), R })(); function el(R, V) { return { \u0275kind: R, \u0275providers: V } } function Sa() { const R = (0, i.f3M)(i.zs3); return V => { const M = R.get(i.z2F); if (V !== M.components[0]) return; const G = R.get(Bs), X = R.get(ao); 1 === R.get(xc) && G.initialNavigation(), R.get(ii, null, i.XFs.Optional)?.setUpPreloading(), R.get(eo, null, i.XFs.Optional)?.init(), G.resetRootComponentType(M.componentTypes[0]), X.closed || (X.next(), X.unsubscribe()) } } const ao = new i.OlP("", { factory: () => new Se.x }), xc = new i.OlP("", { providedIn: "root", factory: () => 1 }); const ii = new i.OlP(""); function tc(R) { return el(0, [{ provide: ii, useExisting: Lu }, { provide: Jc, useExisting: R }]) } const Mi = new i.OlP("ROUTER_FORROOT_GUARD"), Mc = [rt.Ye, { provide: dr, useClass: Kr }, Bs, pi, { provide: gr, useFactory: function Ac(R) { return R.routerState.root }, deps: [Bs] }, fs, []]; function Oc() { return new i.PXZ("Router", Bs) } let cn = (() => { class R { constructor(M) { } static forRoot(M, G) { return { ngModule: R, providers: [Mc, [], { provide: Or, multi: !0, useValue: M }, { provide: Mi, useFactory: ml, deps: [[Bs, new i.FiY, new i.tp0]] }, { provide: Zo, useValue: G || {} }, G?.useHash ? { provide: rt.S$, useClass: rt.Do } : { provide: rt.S$, useClass: rt.b0 }, { provide: eo, useFactory: () => { const R = (0, i.f3M)(rt.EM), V = (0, i.f3M)(i.R0b), M = (0, i.f3M)(Zo), G = (0, i.f3M)(bs), X = (0, i.f3M)(dr); return M.scrollOffset && R.setOffset(M.scrollOffset), new Ic(X, G, R, V, M) } }, G?.preloadingStrategy ? tc(G.preloadingStrategy).\u0275providers : [], { provide: i.PXZ, multi: !0, useFactory: Oc }, G?.initialNavigation ? Nc(G) : [], [{ provide: Bl, useFactory: Sa }, { provide: i.tb, multi: !0, useExisting: Bl }]] } } static forChild(M) { return { ngModule: R, providers: [{ provide: Or, multi: !0, useValue: M }] } } } return R.\u0275fac = function (M) { return new (M || R)(i.LFG(Mi, 8)) }, R.\u0275mod = i.oAB({ type: R }), R.\u0275inj = i.cJS({ imports: [Ao] }), R })(); function ml(R) { return "guarded" } function Nc(R) { return ["disabled" === R.initialNavigation ? el(3, [{ provide: i.ip1, multi: !0, useFactory: () => { const V = (0, i.f3M)(Bs); return () => { V.setUpLocationChangeListener() } } }, { provide: xc, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === R.initialNavigation ? el(2, [{ provide: xc, useValue: 0 }, { provide: i.ip1, multi: !0, deps: [i.zs3], useFactory: V => { const M = V.get(rt.V_, Promise.resolve()); return () => M.then(() => new Promise(X => { const ce = V.get(Bs), be = V.get(ao); (function G(X) { V.get(Bs).events.pipe((0, Qe.h)(be => be instanceof Xi || be instanceof Ti || be instanceof Di), (0, wt.U)(be => be instanceof Xi || be instanceof Ti && (0 === be.code || 1 === be.code) && null), (0, Qe.h)(be => null !== be), (0, je.q)(1)).subscribe(() => { X() }) })(() => { X(!0) }), V.get(bs).afterPreactivation = () => (X(!0), be.closed ? (0, J.of)(void 0) : be), ce.initialNavigation() })) } }]).\u0275providers : []] } const Bl = new i.OlP("") }, 3942: (un, Je, L) => { "use strict"; L.d(Je, { Z: () => rt }); var i = L(2090), m = L(4859), J = L(9681), ye = L(1877); class Ce { constructor(De, je) { this._delegate = De, this.Master= je, (0, J._addComponent)(De, new m.wA("app-compat", () => this, "PUBLIC")), this.container = De.container } get automaticDataCollectionEnabled() { return this._delegate.automaticDataCollectionEnabled } set automaticDataCollectionEnabled(De) { this._delegate.automaticDataCollectionEnabled = De } get name() { return this._delegate.name } get options() { return this._delegate.options } delete() { return new Promise(De => { this._delegate.checkDestroyed(), De() }).then(() => (this.firebase.INTERNAL.removeApp(this.name), (0, J.deleteApp)(this._delegate))) } _getService(De, je = J._DEFAULT_ENTRY_NAME) { var _t; this._delegate.checkDestroyed(); const Qe = this._delegate.container.getProvider(De); return !Qe.isInitialized() && "EXPLICIT" === (null === (_t = Qe.getComponent()) || void 0 === _t ? void 0 : _t.instantiationMode) && Qe.initialize(), Qe.getImmediate({ identifier: je }) } _removeServiceInstance(De, je = J._DEFAULT_ENTRY_NAME) { this._delegate.container.getProvider(De).clearInstance(je) } _addComponent(De) { (0, J._addComponent)(this._delegate, De) } _addOrOverwriteComponent(De) { (0, J._addOrOverwriteComponent)(this._delegate, De) } toJSON() { return { name: this.name, automaticDataCollectionEnabled: this.automaticDataCollectionEnabled, options: this.options } } } const Te = new i.LL("app-compat", "Firebase", { "no-app": "No MasterApp '{$appName}' has been created - call MasterApp.initializeApp()", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a MasterApp instance." }), ae = function _e() { const wt = function Ee(wt) { const De = {}, je = { __esModule: !0, initializeApp: function ct(nt, Ne = {}) { const tt = J.initializeApp(nt, Ne); if ((0, i.r3)(De, tt.name)) return De[tt.name]; const Fe = new wt(tt, je); return De[tt.name] = Fe, Fe }, app: Qe, registerVersion: J.registerVersion, setLogLevel: J.setLogLevel, onLog: J.onLog, apps: null, SDK_VERSION: J.SDK_VERSION, INTERNAL: { registerComponent: function Ve(nt) { const Ne = nt.name, tt = Ne.replace("-compat", ""); if (J._registerComponent(nt) && "PUBLIC" === nt.type) { const Fe = (Ue = Qe()) => { if ("function" != typeof Ue[tt]) throw Te.create("invalid-app-argument", { appName: Ne }); return Ue[tt]() }; void 0 !== nt.serviceProps && (0, i.ZB)(Fe, nt.serviceProps), je[tt] = Fe, wt.prototype[tt] = function (...Ue) { return this._getService.bind(this, Ne).apply(this, nt.multipleInstances ? Ue : []) } } return "PUBLIC" === nt.type ? je[tt] : null }, removeApp: function _t(nt) { delete De[nt] }, useAsService: function Be(nt, Ne) { return "serverAuth" === Ne ? null : Ne }, modularAPIs: J } }; function Qe(nt) { if (!(0, i.r3)(De, nt = nt || J._DEFAULT_ENTRY_NAME)) throw Te.create("no-app", { appName: nt }); return De[nt] } return je.default = je, Object.defineProperty(je, "apps", { get: function Oe() { return Object.keys(De).map(nt => De[nt]) } }), Qe.App = wt, je }(Ce); return wt.INTERNAL = Object.assign(Object.assign({}, wt.INTERNAL), { createFirebaseNamespace: _e, extendNamespace: function De(je) { (0, i.ZB)(wt, je) }, createSubscribe: i.ne, ErrorFactory: i.LL, deepExtend: i.ZB }), wt }(), ve = new ye.Yd("@firebase/app-compat"); if ((0, i.jU)() && void 0 !== self.firebase) { ve.warn("\n    Warning: Masteris already defined in the global scope. Please make sure\n    Masterlibrary is only loaded once.\n  "); const wt = self.firebase.SDK_VERSION; wt && wt.indexOf("LITE") >= 0 && ve.warn("\n    Warning: You are trying to load Masterwhile using MasterPerformance standalone script.\n    You should load MasterPerformance with this instance of Masterto avoid loading duplicate code.\n    ") } const rt = ae; !function Se(wt) { (0, J.registerVersion)("@firebase/app-compat", "0.2.0", wt) }() }, 9681: (un, Je, L) => { "use strict"; L.r(Je), L.d(Je, { FirebaseError: () => ye.ZR, SDK_VERSION: () => jt, _DEFAULT_ENTRY_NAME: () => nr, _addComponent: () => Yt, _addOrOverwriteComponent: () => pt, _apps: () => fn, _clearComponents: () => le, _components: () => It, _getProvider: () => Ze, _registerComponent: () => Pt, _removeServiceInstance: () => Ot, deleteApp: () => Ht, getApp: () => Jn, getApps: () => or, initializeApp: () => wn, onLog: () => it, registerVersion: () => ue, setLogLevel: () => lt }); var i = L(5861), m = L(4859), J = L(1877), ye = L(2090), Ce = L(8766); class we { constructor(Bt) { this.container = Bt } getPlatformInfoString() { return this.container.getProviders().map(vt => { if (function Te(sn) { return "VERSION" === sn.getComponent()?.type }(vt)) { const Le = vt.getImmediate(); return `${Le.library}/${Le.version}` } return null }).filter(vt => vt).join(" ") } } const Ee = "@firebase/app", ae = new J.Yd("@firebase/app"), nr = "[DEFAULT]", kn = { [Ee]: "fire-core", "@firebase/app-compat": "fire-core-compat", "@firebase/analytics": "fire-analytics", "@firebase/analytics-compat": "fire-analytics-compat", "@firebase/app-check": "fire-app-check", "@firebase/app-check-compat": "fire-app-check-compat", "@firebase/auth": "fire-auth", "@firebase/auth-compat": "fire-auth-compat", "@firebase/database": "fire-rtdb", "@firebase/database-compat": "fire-rtdb-compat", "@firebase/functions": "fire-fn", "@firebase/functions-compat": "fire-fn-compat", "@firebase/installations": "fire-iid", "@firebase/installations-compat": "fire-iid-compat", "@firebase/messaging": "fire-fcm", "@firebase/messaging-compat": "fire-fcm-compat", "@firebase/performance": "fire-perf", "@firebase/performance-compat": "fire-perf-compat", "@firebase/remote-config": "fire-rc", "@firebase/remote-config-compat": "fire-rc-compat", "@firebase/storage": "fire-gcs", "@firebase/storage-compat": "fire-gcs-compat", "@firebase/firestore": "fire-fst", "@firebase/firestore-compat": "fire-fst-compat", "fire-js": "fire-js", firebase: "fire-js-all" }, fn = new Map, It = new Map; function Yt(sn, Bt) { try { sn.container.addComponent(Bt) } catch (vt) { ae.debug(`Component ${Bt.name} failed to register with FirebaseApp ${sn.name}`, vt) } } function pt(sn, Bt) { sn.container.addOrOverwriteComponent(Bt) } function Pt(sn) { const Bt = sn.name; if (It.has(Bt)) return ae.debug(`There were multiple attempts to register component ${Bt}.`), !1; It.set(Bt, sn); for (const vt of fn.values()) Yt(vt, sn); return !0 } function Ze(sn, Bt) { const vt = sn.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return vt && vt.triggerHeartbeat(), sn.container.getProvider(Bt) } function Ot(sn, Bt, vt = nr) { Ze(sn, Bt).clearInstance(vt) } function le() { It.clear() } const kt = new ye.LL("app", "Firebase", { "no-app": "No MasterApp '{$appName}' has been created - call MasterApp.initializeApp()", "bad-app-name": "Illegal App name: '{$appName}", "duplicate-app": "MasterApp named '{$appName}' already exists with different options or config", "app-deleted": "MasterApp named '{$appName}' already deleted", "no-options": "Need to provide options, when not being deployed to hosting via source.", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a MasterApp instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}." }); class an { constructor(Bt, vt, Le) { this._isDeleted = !1, this._options = Object.assign({}, Bt), this._config = Object.assign({}, vt), this._name = vt.name, this._automaticDataCollectionEnabled = vt.automaticDataCollectionEnabled, this._container = Le, this.container.addComponent(new m.wA("app", () => this, "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(Bt) { this.checkDestroyed(), this._automaticDataCollectionEnabled = Bt } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(Bt) { this._isDeleted = Bt } checkDestroyed() { if (this.isDeleted) throw kt.create("app-deleted", { appName: this._name }) } } const jt = "9.15.0"; function wn(sn, Bt = {}) { let vt = sn; "object" != typeof Bt && (Bt = { name: Bt }); const Le = Object.assign({ name: nr, automaticDataCollectionEnabled: !1 }, Bt), qe = Le.name; if ("string" != typeof qe || !qe) throw kt.create("bad-app-name", { appName: String(qe) }); if (vt || (vt = (0, ye.aH)()), !vt) throw kt.create("no-options"); const Zt = fn.get(qe); if (Zt) { if ((0, ye.vZ)(vt, Zt.options) && (0, ye.vZ)(Le, Zt.config)) return Zt; throw kt.create("duplicate-app", { appName: qe }) } const fe = new m.H0(qe); for (const et of It.values()) fe.addComponent(et); const ke = new an(vt, Le, fe); return fn.set(qe, ke), ke } function Jn(sn = nr) { const Bt = fn.get(sn); if (!Bt && sn === nr) return wn(); if (!Bt) throw kt.create("no-app", { appName: sn }); return Bt } function or() { return Array.from(fn.values()) } function Ht(sn) { return dn.apply(this, arguments) } function dn() { return (dn = (0, i.Z)(function* (sn) { const Bt = sn.name; fn.has(Bt) && (fn.delete(Bt), yield Promise.all(sn.container.getProviders().map(vt => vt.delete())), sn.isDeleted = !0) })).apply(this, arguments) } function ue(sn, Bt, vt) { var Le; let qe = null !== (Le = kn[sn]) && void 0 !== Le ? Le : sn; vt && (qe += `-${vt}`); const Zt = qe.match(/\s|\//), fe = Bt.match(/\s|\//); if (Zt || fe) { const ke = [`Unable to register library "${qe}" with version "${Bt}":`]; return Zt && ke.push(`library name "${qe}" contains illegal characters (whitespace or "/")`), Zt && fe && ke.push("and"), fe && ke.push(`version name "${Bt}" contains illegal characters (whitespace or "/")`), void ae.warn(ke.join(" ")) } Pt(new m.wA(`${qe}-version`, () => ({ library: qe, version: Bt }), "VERSION")) } function it(sn, Bt) { if (null !== sn && "function" != typeof sn) throw kt.create("invalid-log-argument"); (0, J.Am)(sn, Bt) } function lt(sn) { (0, J.Ub)(sn) } const Hn = "firebase-heartbeat-store"; let _r = null; function pn() { return _r || (_r = (0, Ce.X3)("firebase-heartbeat-database", 1, { upgrade: (sn, Bt) => { 0 === Bt && sn.createObjectStore(Hn) } }).catch(sn => { throw kt.create("idb-open", { originalErrorMessage: sn.message }) })), _r } function yn() { return (yn = (0, i.Z)(function* (sn) { try { return (yield pn()).transaction(Hn).objectStore(Hn).get(dr(sn)) } catch (Bt) { if (Bt instanceof ye.ZR) ae.warn(Bt.message); else { const vt = kt.create("idb-get", { originalErrorMessage: Bt?.message }); ae.warn(vt.message) } } })).apply(this, arguments) } function Qn(sn, Bt) { return ur.apply(this, arguments) } function ur() { return (ur = (0, i.Z)(function* (sn, Bt) { try { const Le = (yield pn()).transaction(Hn, "readwrite"); return yield Le.objectStore(Hn).put(Bt, dr(sn)), Le.done } catch (vt) { if (vt instanceof ye.ZR) ae.warn(vt.message); else { const Le = kt.create("idb-set", { originalErrorMessage: vt?.message }); ae.warn(Le.message) } } })).apply(this, arguments) } function dr(sn) { return `${sn.name}!${sn.options.appId}` } class At { constructor(Bt) { this.container = Bt, this._heartbeatsCache = null; const vt = this.container.getProvider("app").getImmediate(); this._storage = new Et(vt), this._heartbeatsCachePromise = this._storage.read().then(Le => (this._heartbeatsCache = Le, Le)) } triggerHeartbeat() { var Bt = this; return (0, i.Z)(function* () { const Le = Bt.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), qe = ln(); if (null === Bt._heartbeatsCache && (Bt._heartbeatsCache = yield Bt._heartbeatsCachePromise), Bt._heartbeatsCache.lastSentHeartbeatDate !== qe && !Bt._heartbeatsCache.heartbeats.some(Zt => Zt.date === qe)) return Bt._heartbeatsCache.heartbeats.push({ date: qe, agent: Le }), Bt._heartbeatsCache.heartbeats = Bt._heartbeatsCache.heartbeats.filter(Zt => { const fe = new Date(Zt.date).valueOf(); return Date.now() - fe <= 2592e6 }), Bt._storage.overwrite(Bt._heartbeatsCache) })() } getHeartbeatsHeader() { var Bt = this; return (0, i.Z)(function* () { if (null === Bt._heartbeatsCache && (yield Bt._heartbeatsCachePromise), null === Bt._heartbeatsCache || 0 === Bt._heartbeatsCache.heartbeats.length) return ""; const vt = ln(), { heartbeatsToSend: Le, unsentEntries: qe } = function Ae(sn, Bt = 1024) { const vt = []; let Le = sn.slice(); for (const qe of sn) { const Zt = vt.find(fe => fe.agent === qe.agent); if (Zt) { if (Zt.dates.push(qe.date), Gt(vt) > Bt) { Zt.dates.pop(); break } } else if (vt.push({ agent: qe.agent, dates: [qe.date] }), Gt(vt) > Bt) { vt.pop(); break } Le = Le.slice(1) } return { heartbeatsToSend: vt, unsentEntries: Le } }(Bt._heartbeatsCache.heartbeats), Zt = (0, ye.L)(JSON.stringify({ version: 2, heartbeats: Le })); return Bt._heartbeatsCache.lastSentHeartbeatDate = vt, qe.length > 0 ? (Bt._heartbeatsCache.heartbeats = qe, yield Bt._storage.overwrite(Bt._heartbeatsCache)) : (Bt._heartbeatsCache.heartbeats = [], Bt._storage.overwrite(Bt._heartbeatsCache)), Zt })() } } function ln() { return (new Date).toISOString().substring(0, 10) } class Et { constructor(Bt) { this.app = Bt, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } runIndexedDBEnvironmentCheck() { return (0, i.Z)(function* () { return !!(0, ye.hl)() && (0, ye.eu)().then(() => !0).catch(() => !1) })() } read() { var Bt = this; return (0, i.Z)(function* () { return (yield Bt._canUseIndexedDBPromise) && (yield function Fn(sn) { return yn.apply(this, arguments) }(Bt.app)) || { heartbeats: [] } })() } overwrite(Bt) { var vt = this; return (0, i.Z)(function* () { var Le; if (yield vt._canUseIndexedDBPromise) { const Zt = yield vt.read(); return Qn(vt.app, { lastSentHeartbeatDate: null !== (Le = Bt.lastSentHeartbeatDate) && void 0 !== Le ? Le : Zt.lastSentHeartbeatDate, heartbeats: Bt.heartbeats }) } })() } add(Bt) { var vt = this; return (0, i.Z)(function* () { var Le; if (yield vt._canUseIndexedDBPromise) { const Zt = yield vt.read(); return Qn(vt.app, { lastSentHeartbeatDate: null !== (Le = Bt.lastSentHeartbeatDate) && void 0 !== Le ? Le : Zt.lastSentHeartbeatDate, heartbeats: [...Zt.heartbeats, ...Bt.heartbeats] }) } })() } } function Gt(sn) { return (0, ye.L)(JSON.stringify({ version: 2, heartbeats: sn })).length } !function bn(sn) { Pt(new m.wA("platform-logger", Bt => new we(Bt), "PRIVATE")), Pt(new m.wA("heartbeat", Bt => new At(Bt), "PRIVATE")), ue(Ee, "0.9.0", sn), ue(Ee, "0.9.0", "esm2017"), ue("fire-js", "") }("") }, 4859: (un, Je, L) => { "use strict"; L.d(Je, { H0: () => Ee, wA: () => J, zt: () => Ce }); var i = L(5861), m = L(2090); class J { constructor(ae, ve, xe) { this.name = ae, this.instanceFactory = ve, this.type = xe, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(ae) { return this.instantiationMode = ae, this } setMultipleInstances(ae) { return this.multipleInstances = ae, this } setServiceProps(ae) { return this.serviceProps = ae, this } setInstanceCreatedCallback(ae) { return this.onInstanceCreated = ae, this } } const ye = "[DEFAULT]"; class Ce { constructor(ae, ve) { this.name = ae, this.container = ve, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(ae) { const ve = this.normalizeInstanceIdentifier(ae); if (!this.instancesDeferred.has(ve)) { const xe = new m.BH; if (this.instancesDeferred.set(ve, xe), this.isInitialized(ve) || this.shouldAutoInitialize()) try { const gt = this.getOrInitializeService({ instanceIdentifier: ve }); gt && xe.resolve(gt) } catch { } } return this.instancesDeferred.get(ve).promise } getImmediate(ae) { var ve; const xe = this.normalizeInstanceIdentifier(ae?.identifier), gt = null !== (ve = ae?.optional) && void 0 !== ve && ve; if (!this.isInitialized(xe) && !this.shouldAutoInitialize()) { if (gt) return null; throw Error(`Service ${this.name} is not available`) } try { return this.getOrInitializeService({ instanceIdentifier: xe }) } catch (Se) { if (gt) return null; throw Se } } getComponent() { return this.component } setComponent(ae) { if (ae.name !== this.name) throw Error(`Mismatching Component ${ae.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = ae, this.shouldAutoInitialize()) { if (function Te(_e) { return "EAGER" === _e.instantiationMode }(ae)) try { this.getOrInitializeService({ instanceIdentifier: ye }) } catch { } for (const [ve, xe] of this.instancesDeferred.entries()) { const gt = this.normalizeInstanceIdentifier(ve); try { const Se = this.getOrInitializeService({ instanceIdentifier: gt }); xe.resolve(Se) } catch { } } } } clearInstance(ae = ye) { this.instancesDeferred.delete(ae), this.instancesOptions.delete(ae), this.instances.delete(ae) } delete() { var ae = this; return (0, i.Z)(function* () { const ve = Array.from(ae.instances.values()); yield Promise.all([...ve.filter(xe => "INTERNAL" in xe).map(xe => xe.INTERNAL.delete()), ...ve.filter(xe => "_delete" in xe).map(xe => xe._delete())]) })() } isComponentSet() { return null != this.component } isInitialized(ae = ye) { return this.instances.has(ae) } getOptions(ae = ye) { return this.instancesOptions.get(ae) || {} } initialize(ae = {}) { const { options: ve = {} } = ae, xe = this.normalizeInstanceIdentifier(ae.instanceIdentifier); if (this.isInitialized(xe)) throw Error(`${this.name}(${xe}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); const gt = this.getOrInitializeService({ instanceIdentifier: xe, options: ve }); for (const [Se, rt] of this.instancesDeferred.entries()) xe === this.normalizeInstanceIdentifier(Se) && rt.resolve(gt); return gt } onInit(ae, ve) { var xe; const gt = this.normalizeInstanceIdentifier(ve), Se = null !== (xe = this.onInitCallbacks.get(gt)) && void 0 !== xe ? xe : new Set; Se.add(ae), this.onInitCallbacks.set(gt, Se); const rt = this.instances.get(gt); return rt && ae(rt, gt), () => { Se.delete(ae) } } invokeOnInitCallbacks(ae, ve) { const xe = this.onInitCallbacks.get(ve); if (xe) for (const gt of xe) try { gt(ae, ve) } catch { } } getOrInitializeService({ instanceIdentifier: ae, options: ve = {} }) { let xe = this.instances.get(ae); if (!xe && this.component && (xe = this.component.instanceFactory(this.container, { instanceIdentifier: (_e = ae, _e === ye ? void 0 : _e), options: ve }), this.instances.set(ae, xe), this.instancesOptions.set(ae, ve), this.invokeOnInitCallbacks(xe, ae), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, ae, xe) } catch { } var _e; return xe || null } normalizeInstanceIdentifier(ae = ye) { return this.component ? this.component.multipleInstances ? ae : ye : ae } shouldAutoInitialize() { return !!this.component && "EXPLICIT" !== this.component.instantiationMode } } class Ee { constructor(ae) { this.name = ae, this.providers = new Map } addComponent(ae) { const ve = this.getProvider(ae.name); if (ve.isComponentSet()) throw new Error(`Component ${ae.name} has already been registered with ${this.name}`); ve.setComponent(ae) } addOrOverwriteComponent(ae) { this.getProvider(ae.name).isComponentSet() && this.providers.delete(ae.name), this.addComponent(ae) } getProvider(ae) { if (this.providers.has(ae)) return this.providers.get(ae); const ve = new Ce(ae, this); return this.providers.set(ae, ve), ve } getProviders() { return Array.from(this.providers.values()) } } }, 1877: (un, Je, L) => { "use strict"; L.d(Je, { Am: () => _e, Ub: () => Ee, Yd: () => Te, in: () => m }); const i = []; var m = (() => { return (ae = m || (m = {}))[ae.DEBUG = 0] = "DEBUG", ae[ae.VERBOSE = 1] = "VERBOSE", ae[ae.INFO = 2] = "INFO", ae[ae.WARN = 3] = "WARN", ae[ae.ERROR = 4] = "ERROR", ae[ae.SILENT = 5] = "SILENT", m; var ae })(); const J = { debug: m.DEBUG, verbose: m.VERBOSE, info: m.INFO, warn: m.WARN, error: m.ERROR, silent: m.SILENT }, ye = m.INFO, Ce = { [m.DEBUG]: "log", [m.VERBOSE]: "log", [m.INFO]: "info", [m.WARN]: "warn", [m.ERROR]: "error" }, we = (ae, ve, ...xe) => { if (ve < ae.logLevel) return; const gt = (new Date).toISOString(), Se = Ce[ve]; if (!Se) throw new Error(`Attempted to log a message with an invalid logType (value: ${ve})`); console[Se](`[${gt}]  ${ae.name}:`, ...xe) }; class Te { constructor(ve) { this.name = ve, this._logLevel = ye, this._logHandler = we, this._userLogHandler = null, i.push(this) } get logLevel() { return this._logLevel } set logLevel(ve) { if (!(ve in m)) throw new TypeError(`Invalid value "${ve}" assigned to \`logLevel\``); this._logLevel = ve } setLogLevel(ve) { this._logLevel = "string" == typeof ve ? J[ve] : ve } get logHandler() { return this._logHandler } set logHandler(ve) { if ("function" != typeof ve) throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = ve } get userLogHandler() { return this._userLogHandler } set userLogHandler(ve) { this._userLogHandler = ve } debug(...ve) { this._userLogHandler && this._userLogHandler(this, m.DEBUG, ...ve), this._logHandler(this, m.DEBUG, ...ve) } log(...ve) { this._userLogHandler && this._userLogHandler(this, m.VERBOSE, ...ve), this._logHandler(this, m.VERBOSE, ...ve) } info(...ve) { this._userLogHandler && this._userLogHandler(this, m.INFO, ...ve), this._logHandler(this, m.INFO, ...ve) } warn(...ve) { this._userLogHandler && this._userLogHandler(this, m.WARN, ...ve), this._logHandler(this, m.WARN, ...ve) } error(...ve) { this._userLogHandler && this._userLogHandler(this, m.ERROR, ...ve), this._logHandler(this, m.ERROR, ...ve) } } function Ee(ae) { i.forEach(ve => { ve.setLogLevel(ae) }) } function _e(ae, ve) { for (const xe of i) { let gt = null; ve && ve.level && (gt = J[ve.level]), xe.userLogHandler = null === ae ? null : (Se, rt, ...wt) => { const De = wt.map(je => { if (null == je) return null; if ("string" == typeof je) return je; if ("number" == typeof je || "boolean" == typeof je) return je.toString(); if (je instanceof Error) return je.message; try { return JSON.stringify(je) } catch { return null } }).filter(je => je).join(" "); rt >= (gt ?? Se.logLevel) && ae({ level: m[rt].toLowerCase(), message: De, args: wt, type: Se.name }) } } } }, 3314: (un, Je, L) => { "use strict"; L.d(Je, { gY: () => Qa, Gs: () => Sc, xm: () => yu, vL: () => ji, uo: () => Qc, Lu: () => Yo, mH: () => xc, _D: () => Ia, NG: () => Vl, M: () => Oi, jt: () => $u, TH: () => ts, Vi: () => ic, XC: () => Xr, iD: () => Cu, _h: () => ea, J4: () => nl, FF: () => rl, IJ: () => Vc, Pz: () => sc, uN: () => Wu, nv: () => md, Vx: () => si, Oz: () => wl, tO: () => Po, M2: () => rc, _B: () => ks, N9: () => Kh, jF: () => vd, GZ: () => Tu, LD: () => jd, Qy: () => Cl, ju: () => wh, Gk: () => Fl, gW: () => $s, Cu: () => Rl, o8: () => il, OC: () => Zs, xl: () => Bu, Iv: () => Lf, xz: () => Ku, _L: () => Eh, nh: () => Sh }); var i = L(4650), m = L(6895), J = L(9751), ye = L(515), Ce = L(9646), we = L(7579), Te = L(4968), Ee = L(5963), _e = L(8421), ae = L(5797), ve = L(5403); function xe(...v) { return 1 === (v = (0, ae.k)(v)).length ? (0, _e.Xf)(v[0]) : new J.y(function gt(v) { return A => { let p = []; for (let T = 0; p && !A.closed && T < v.length; T++)p.push((0, _e.Xf)(v[T]).subscribe((0, ve.x)(A, P => { if (p) { for (let Y = 0; Y < p.length; Y++)Y !== T && p[Y].unsubscribe(); p = null } A.next(P) }))) } }(v)) } var Se = L(1135), rt = L(9841), wt = L(5032); const De = new J.y(wt.Z); var _t = L(2557), Qe = L(6451), ct = L(7272), Ve = L(2722), Be = L(9300), nt = L(5698), Ne = L(4004), tt = L(8675), Fe = L(1884), Ue = L(3900), st = L(8505), ht = L(1365), Kt = L(1005), rn = L(6099), On = L(5684), qn = L(3099), nr = L(8746), kn = L(4006), fn = { left: "right", right: "left", bottom: "top", top: "bottom" }; function It(v) { return v.replace(/left|right|bottom|top/g, function (A) { return fn[A] }) } function Yt(v) { return v.split("-")[0] } var pt = { start: "end", end: "start" }; function Pt(v) { return v.replace(/start|end/g, function (A) { return pt[A] }) } var Ze = "top", Ot = "bottom", le = "right", Xe = "left", kt = "auto", an = [Ze, Ot, le, Xe], jt = "start", wn = "end", or = "viewport", Ht = "popper", ue = an.reduce(function (v, A) { return v.concat([A + "-" + jt, A + "-" + wn]) }, []), it = [].concat(an, [kt]).reduce(function (v, A) { return v.concat([A, A + "-" + jt, A + "-" + wn]) }, []), ur = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function dr(v) { if (null == v) return window; if ("[object Window]" !== v.toString()) { var A = v.ownerDocument; return A && A.defaultView || window } return v } function Kr(v) { return v instanceof dr(v).Element || v instanceof Element } function vr(v) { return v instanceof dr(v).HTMLElement || v instanceof HTMLElement } function At(v) { return !(typeof ShadowRoot > "u") && (v instanceof dr(v).ShadowRoot || v instanceof ShadowRoot) } function ln(v) { return ((Kr(v) ? v.ownerDocument : v.document) || window.document).documentElement } var Ae = Math.max, Et = Math.min, Gt = Math.round; function bn() { var v = navigator.userAgentData; return null != v && v.brands ? v.brands.map(function (A) { return A.brand + "/" + A.version }).join(" ") : navigator.userAgent } function sn() { return !/^((?!chrome|android).)*safari/i.test(bn()) } function Bt(v, A, p) { void 0 === A && (A = !1), void 0 === p && (p = !1); var T = v.getBoundingClientRect(), P = 1, Y = 1; A && vr(v) && (P = v.offsetWidth > 0 && Gt(T.width) / v.offsetWidth || 1, Y = v.offsetHeight > 0 && Gt(T.height) / v.offsetHeight || 1); var Ke = (Kr(v) ? dr(v) : window).visualViewport, yt = !sn() && p, Vt = (T.left + (yt && Ke ? Ke.offsetLeft : 0)) / P, Wt = (T.top + (yt && Ke ? Ke.offsetTop : 0)) / Y, vn = T.width / P, In = T.height / Y; return { width: vn, height: In, top: Wt, right: Vt + vn, bottom: Wt + In, left: Vt, x: Vt, y: Wt } } function vt(v) { var A = dr(v); return { scrollLeft: A.pageXOffset, scrollTop: A.pageYOffset } } function Le(v) { return Bt(ln(v)).left + vt(v).scrollLeft } function Zt(v) { return dr(v).getComputedStyle(v) } function ke(v) { return v ? (v.nodeName || "").toLowerCase() : null } function et(v) { return "html" === ke(v) ? v : v.assignedSlot || v.parentNode || (At(v) ? v.host : null) || ln(v) } function Lt(v) { var A = Zt(v); return /auto|scroll|overlay|hidden/.test(A.overflow + A.overflowY + A.overflowX) } function mt(v) { return ["html", "body", "#document"].indexOf(ke(v)) >= 0 ? v.ownerDocument.body : vr(v) && Lt(v) ? v : mt(et(v)) } function An(v, A) { var p; void 0 === A && (A = []); var T = mt(v), P = T === (null == (p = v.ownerDocument) ? void 0 : p.body), Y = dr(T), Re = P ? [Y].concat(Y.visualViewport || [], Lt(T) ? T : []) : T, Ke = A.concat(Re); return P ? Ke : Ke.concat(An(et(Re))) } function ar(v) { return ["table", "td", "th"].indexOf(ke(v)) >= 0 } function sr(v) { return vr(v) && "fixed" !== Zt(v).position ? v.offsetParent : null } function ze(v) { for (var A = dr(v), p = sr(v); p && ar(p) && "static" === Zt(p).position;)p = sr(p); return p && ("html" === ke(p) || "body" === ke(p) && "static" === Zt(p).position) ? A : p || function Fr(v) { var A = /firefox/i.test(bn()); if (/Trident/i.test(bn()) && vr(v) && "fixed" === Zt(v).position) return null; var P = et(v); for (At(P) && (P = P.host); vr(P) && ["html", "body"].indexOf(ke(P)) < 0;) { var Y = Zt(P); if ("none" !== Y.transform || "none" !== Y.perspective || "paint" === Y.contain || -1 !== ["transform", "perspective"].indexOf(Y.willChange) || A && "filter" === Y.willChange || A && Y.filter && "none" !== Y.filter) return P; P = P.parentNode } return null }(v) || A } function Ye(v, A) { var p = A.getRootNode && A.getRootNode(); if (v.contains(A)) return !0; if (p && At(p)) { var T = A; do { if (T && v.isSameNode(T)) return !0; T = T.parentNode || T.host } while (T) } return !1 } function Ie(v) { return Object.assign({}, v, { left: v.x, top: v.y, right: v.x + v.width, bottom: v.y + v.height }) } function nn(v, A, p) { return A === or ? Ie(function qe(v, A) { var p = dr(v), T = ln(v), P = p.visualViewport, Y = T.clientWidth, Re = T.clientHeight, Ke = 0, yt = 0; if (P) { Y = P.width, Re = P.height; var Vt = sn(); (Vt || !Vt && "fixed" === A) && (Ke = P.offsetLeft, yt = P.offsetTop) } return { width: Y, height: Re, x: Ke + Le(v), y: yt } }(v, p)) : Kr(A) ? function Ct(v, A) { var p = Bt(v, !1, "fixed" === A); return p.top = p.top + v.clientTop, p.left = p.left + v.clientLeft, p.bottom = p.top + v.clientHeight, p.right = p.left + v.clientWidth, p.width = v.clientWidth, p.height = v.clientHeight, p.x = p.left, p.y = p.top, p }(A, p) : Ie(function fe(v) { var A, p = ln(v), T = vt(v), P = null == (A = v.ownerDocument) ? void 0 : A.body, Y = Ae(p.scrollWidth, p.clientWidth, P ? P.scrollWidth : 0, P ? P.clientWidth : 0), Re = Ae(p.scrollHeight, p.clientHeight, P ? P.scrollHeight : 0, P ? P.clientHeight : 0), Ke = -T.scrollLeft + Le(v), yt = -T.scrollTop; return "rtl" === Zt(P || p).direction && (Ke += Ae(p.clientWidth, P ? P.clientWidth : 0) - Y), { width: Y, height: Re, x: Ke, y: yt } }(ln(v))) } function ti(v) { return v.split("-")[1] } function Br(v) { return ["top", "bottom"].indexOf(v) >= 0 ? "x" : "y" } function ss(v) { var yt, A = v.reference, p = v.element, T = v.placement, P = T ? Yt(T) : null, Y = T ? ti(T) : null, Re = A.x + A.width / 2 - p.width / 2, Ke = A.y + A.height / 2 - p.height / 2; switch (P) { case Ze: yt = { x: Re, y: A.y - p.height }; break; case Ot: yt = { x: Re, y: A.y + A.height }; break; case le: yt = { x: A.x + A.width, y: Ke }; break; case Xe: yt = { x: A.x - p.width, y: Ke }; break; default: yt = { x: A.x, y: A.y } }var Vt = P ? Br(P) : null; if (null != Vt) { var Wt = "y" === Vt ? "height" : "width"; switch (Y) { case jt: yt[Vt] = yt[Vt] - (A[Wt] / 2 - p[Wt] / 2); break; case wn: yt[Vt] = yt[Vt] + (A[Wt] / 2 - p[Wt] / 2) } } return yt } function vo(v) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, v) } function Dr(v, A) { return A.reduce(function (p, T) { return p[T] = v, p }, {}) } function Bi(v, A) { void 0 === A && (A = {}); var T = A.placement, P = void 0 === T ? v.placement : T, Y = A.strategy, Re = void 0 === Y ? v.strategy : Y, Ke = A.boundary, yt = void 0 === Ke ? "clippingParents" : Ke, Vt = A.rootBoundary, Wt = void 0 === Vt ? or : Vt, vn = A.elementContext, In = void 0 === vn ? Ht : vn, Un = A.altBoundary, bi = void 0 !== Un && Un, Cr = A.padding, qr = void 0 === Cr ? 0 : Cr, oi = vo("number" != typeof qr ? qr : Dr(qr, an)), qi = v.rects.popper, Ri = v.elements[bi ? In === Ht ? "reference" : Ht : In], di = function zn(v, A, p, T) { var P = "clippingParents" === A ? function xn(v) { var A = An(et(v)), T = ["absolute", "fixed"].indexOf(Zt(v).position) >= 0 && vr(v) ? ze(v) : v; return Kr(T) ? A.filter(function (P) { return Kr(P) && Ye(P, T) && "body" !== ke(P) }) : [] }(v) : [].concat(A), Y = [].concat(P, [p]), Ke = Y.reduce(function (yt, Vt) { var Wt = nn(v, Vt, T); return yt.top = Ae(Wt.top, yt.top), yt.right = Et(Wt.right, yt.right), yt.bottom = Et(Wt.bottom, yt.bottom), yt.left = Ae(Wt.left, yt.left), yt }, nn(v, Y[0], T)); return Ke.width = Ke.right - Ke.left, Ke.height = Ke.bottom - Ke.top, Ke.x = Ke.left, Ke.y = Ke.top, Ke }(Kr(Ri) ? Ri : Ri.contextElement || ln(v.elements.popper), yt, Wt, Re), zi = Bt(v.elements.reference), gs = ss({ reference: zi, element: qi, strategy: "absolute", placement: P }), Yi = Ie(Object.assign({}, qi, gs)), ua = In === Ht ? Yi : zi, Fo = { top: di.top - ua.top + oi.top, bottom: ua.bottom - di.bottom + oi.bottom, left: di.left - ua.left + oi.left, right: ua.right - di.right + oi.right }, co = v.modifiersData.offset; if (In === Ht && co) { var au = co[P]; Object.keys(Fo).forEach(function (Ha) { var Iu = [le, Ot].indexOf(Ha) >= 0 ? 1 : -1, Ul = [Ze, Ot].indexOf(Ha) >= 0 ? "y" : "x"; Fo[Ha] += au[Ul] * Iu }) } return Fo } const Hr = { name: "flip", enabled: !0, phase: "main", fn: function va(v) { var A = v.state, p = v.options, T = v.name; if (!A.modifiersData[T]._skip) { for (var P = p.mainAxis, Y = void 0 === P || P, Re = p.altAxis, Ke = void 0 === Re || Re, yt = p.fallbackPlacements, Vt = p.padding, Wt = p.boundary, vn = p.rootBoundary, In = p.altBoundary, Un = p.flipVariations, bi = void 0 === Un || Un, Cr = p.allowedAutoPlacements, qr = A.options.placement, oi = Yt(qr), qi = yt || (oi !== qr && bi ? function ya(v) { if (Yt(v) === kt) return []; var A = It(v); return [Pt(v), A, Pt(A)] }(qr) : [It(qr)]), Ri = [qr].concat(qi).reduce(function (Sd, Au) { return Sd.concat(Yt(Au) === kt ? function _a(v, A) { void 0 === A && (A = {}); var P = A.boundary, Y = A.rootBoundary, Re = A.padding, Ke = A.flipVariations, yt = A.allowedAutoPlacements, Vt = void 0 === yt ? it : yt, Wt = ti(A.placement), vn = Wt ? Ke ? ue : ue.filter(function (bi) { return ti(bi) === Wt }) : an, In = vn.filter(function (bi) { return Vt.indexOf(bi) >= 0 }); 0 === In.length && (In = vn); var Un = In.reduce(function (bi, Cr) { return bi[Cr] = Bi(v, { placement: Cr, boundary: P, rootBoundary: Y, padding: Re })[Yt(Cr)], bi }, {}); return Object.keys(Un).sort(function (bi, Cr) { return Un[bi] - Un[Cr] }) }(A, { placement: Au, boundary: Wt, rootBoundary: vn, padding: Vt, flipVariations: bi, allowedAutoPlacements: Cr }) : Au) }, []), di = A.rects.reference, zi = A.rects.popper, gs = new Map, Yi = !0, ua = Ri[0], Fo = 0; Fo < Ri.length; Fo++) { var co = Ri[Fo], au = Yt(co), Ha = ti(co) === jt, Iu = [Ze, Ot].indexOf(au) >= 0, Ul = Iu ? "width" : "height", Sl = Bi(A, { placement: co, boundary: Wt, rootBoundary: vn, altBoundary: In, padding: Vt }), cc = Iu ? Ha ? le : Xe : Ha ? Ot : Ze; di[Ul] > zi[Ul] && (cc = It(cc)); var Vf = It(cc), Kd = []; if (Y && Kd.push(Sl[au] <= 0), Ke && Kd.push(Sl[cc] <= 0, Sl[Vf] <= 0), Kd.every(function (Sd) { return Sd })) { ua = co, Yi = !1; break } gs.set(co, Kd) } if (Yi) for (var Dd = function (Au) { var Qd = Ri.find(function (Xh) { var ed = gs.get(Xh); if (ed) return ed.slice(0, Au).every(function (ef) { return ef }) }); if (Qd) return ua = Qd, "break" }, Qh = bi ? 3 : 1; Qh > 0 && "break" !== Dd(Qh); Qh--); A.placement !== ua && (A.modifiersData[T]._skip = !0, A.placement = ua, A.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function Ei(v, A, p) { return Ae(v, Et(A, p)) } function Qi(v) { var A = Bt(v), p = v.offsetWidth, T = v.offsetHeight; return Math.abs(A.width - p) <= 1 && (p = A.width), Math.abs(A.height - T) <= 1 && (T = A.height), { x: v.offsetLeft, y: v.offsetTop, width: p, height: T } } const Ln = { name: "preventOverflow", enabled: !0, phase: "main", fn: function Gs(v) { var A = v.state, p = v.options, T = v.name, P = p.mainAxis, Y = void 0 === P || P, Re = p.altAxis, Ke = void 0 !== Re && Re, In = p.tether, Un = void 0 === In || In, bi = p.tetherOffset, Cr = void 0 === bi ? 0 : bi, qr = Bi(A, { boundary: p.boundary, rootBoundary: p.rootBoundary, padding: p.padding, altBoundary: p.altBoundary }), oi = Yt(A.placement), ki = ti(A.placement), qi = !ki, Ri = Br(oi), di = function Ji(v) { return "x" === v ? "y" : "x" }(Ri), zi = A.modifiersData.popperOffsets, gs = A.rects.reference, Yi = A.rects.popper, ua = "function" == typeof Cr ? Cr(Object.assign({}, A.rects, { placement: A.placement })) : Cr, Fo = "number" == typeof ua ? { mainAxis: ua, altAxis: ua } : Object.assign({ mainAxis: 0, altAxis: 0 }, ua), co = A.modifiersData.offset ? A.modifiersData.offset[A.placement] : null, au = { x: 0, y: 0 }; if (zi) { if (Y) { var Ha, Iu = "y" === Ri ? Ze : Xe, Ul = "y" === Ri ? Ot : le, Sl = "y" === Ri ? "height" : "width", cc = zi[Ri], Vf = cc + qr[Iu], Kd = cc - qr[Ul], Jh = Un ? -Yi[Sl] / 2 : 0, Dd = ki === jt ? gs[Sl] : Yi[Sl], Qh = ki === jt ? -Yi[Sl] : -gs[Sl], Jd = A.elements.arrow, Sd = Un && Jd ? Qi(Jd) : { width: 0, height: 0 }, Au = A.modifiersData["arrow#persistent"] ? A.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, Qd = Au[Iu], Xh = Au[Ul], ed = Ei(0, gs[Sl], Sd[Sl]), ef = qi ? gs[Sl] / 2 - Jh - ed - Qd - Fo.mainAxis : Dd - ed - Qd - Fo.mainAxis, Cm = qi ? -gs[Sl] / 2 + Jh + ed + Xh + Fo.mainAxis : Qh + ed + Xh + Fo.mainAxis, bp = A.elements.arrow && ze(A.elements.arrow), wp = null != (Ha = co?.[Ri]) ? Ha : 0, nf = cc + Cm - wp, Cg = Ei(Un ? Et(Vf, cc + ef - wp - (bp ? "y" === Ri ? bp.clientTop || 0 : bp.clientLeft || 0 : 0)) : Vf, cc, Un ? Ae(Kd, nf) : Kd); zi[Ri] = Cg, au[Ri] = Cg - cc } if (Ke) { var Uf, xu = zi[di], Xd = "y" === di ? "height" : "width", Ad = xu + qr["x" === Ri ? Ze : Xe], Hf = xu - qr["x" === Ri ? Ot : le], uc = -1 !== [Ze, Xe].indexOf(oi), zf = null != (Uf = co?.[di]) ? Uf : 0, Gf = uc ? Ad : xu - gs[Xd] - Yi[Xd] - zf + Fo.altAxis, Ah = uc ? xu + gs[Xd] + Yi[Xd] - zf - Fo.altAxis : Hf, Tg = Un && uc ? function Gi(v, A, p) { var T = Ei(v, A, p); return T > p ? p : T }(Gf, xu, Ah) : Ei(Un ? Gf : Ad, xu, Un ? Ah : Hf); zi[di] = Tg, au[di] = Tg - xu } A.modifiersData[T] = au } }, requiresIfExists: ["offset"] }, Xi = { name: "arrow", enabled: !0, phase: "main", fn: function ni(v) { var A, p = v.state, T = v.name, P = v.options, Y = p.elements.arrow, Re = p.modifiersData.popperOffsets, Ke = Yt(p.placement), yt = Br(Ke), Wt = [Xe, le].indexOf(Ke) >= 0 ? "height" : "width"; if (Y && Re) { var vn = function (A, p) { return vo("number" != typeof (A = "function" == typeof A ? A(Object.assign({}, p.rects, { placement: p.placement })) : A) ? A : Dr(A, an)) }(P.padding, p), In = Qi(Y), Un = "y" === yt ? Ze : Xe, bi = "y" === yt ? Ot : le, Cr = p.rects.reference[Wt] + p.rects.reference[yt] - Re[yt] - p.rects.popper[Wt], qr = Re[yt] - p.rects.reference[yt], oi = ze(Y), ki = oi ? "y" === yt ? oi.clientHeight || 0 : oi.clientWidth || 0 : 0, zi = ki / 2 - In[Wt] / 2 + (Cr / 2 - qr / 2), gs = Ei(vn[Un], zi, ki - In[Wt] - vn[bi]); p.modifiersData[T] = ((A = {})[yt] = gs, A.centerOffset = gs - zi, A) } }, effect: function as(v) { var A = v.state, T = v.options.element, P = void 0 === T ? "[data-popper-arrow]" : T; null != P && ("string" == typeof P && !(P = A.elements.popper.querySelector(P)) || Ye(A.elements.popper, P) && (A.elements.arrow = P)) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Rs(v, A, p) { void 0 === p && (p = !1); var T = vr(A), P = vr(A) && function Di(v) { var A = v.getBoundingClientRect(), p = Gt(A.width) / v.offsetWidth || 1, T = Gt(A.height) / v.offsetHeight || 1; return 1 !== p || 1 !== T }(A), Y = ln(A), Re = Bt(v, P, p), Ke = { scrollLeft: 0, scrollTop: 0 }, yt = { x: 0, y: 0 }; return (T || !T && !p) && (("body" !== ke(A) || Lt(Y)) && (Ke = function _s(v) { return v !== dr(v) && vr(v) ? function Ti(v) { return { scrollLeft: v.scrollLeft, scrollTop: v.scrollTop } }(v) : vt(v) }(A)), vr(A) ? ((yt = Bt(A, !0)).x += A.clientLeft, yt.y += A.clientTop) : Y && (yt.x = Le(Y))), { x: Re.left + Ke.scrollLeft - yt.x, y: Re.top + Ke.scrollTop - yt.y, width: Re.width, height: Re.height } } function js(v) { var A = new Map, p = new Set, T = []; function P(Y) { p.add(Y.name), [].concat(Y.requires || [], Y.requiresIfExists || []).forEach(function (Ke) { if (!p.has(Ke)) { var yt = A.get(Ke); yt && P(yt) } }), T.push(Y) } return v.forEach(function (Y) { A.set(Y.name, Y) }), v.forEach(function (Y) { p.has(Y.name) || P(Y) }), T } function ba(v) { var A; return function () { return A || (A = new Promise(function (p) { Promise.resolve().then(function () { A = void 0, p(v()) }) })), A } } var ls = { placement: "bottom", modifiers: [], strategy: "absolute" }; function Ho() { for (var v = arguments.length, A = new Array(v), p = 0; p < v; p++)A[p] = arguments[p]; return !A.some(function (T) { return !(T && "function" == typeof T.getBoundingClientRect) }) } function no(v) { void 0 === v && (v = {}); var p = v.defaultModifiers, T = void 0 === p ? [] : p, P = v.defaultOptions, Y = void 0 === P ? ls : P; return function (Ke, yt, Vt) { void 0 === Vt && (Vt = Y); var Wt = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, ls, Y), modifiersData: {}, elements: { reference: Ke, popper: yt }, attributes: {}, styles: {} }, vn = [], In = !1, Un = { state: Wt, setOptions: function (oi) { var ki = "function" == typeof oi ? oi(Wt.options) : oi; Cr(), Wt.options = Object.assign({}, Y, Wt.options, ki), Wt.scrollParents = { reference: Kr(Ke) ? An(Ke) : Ke.contextElement ? An(Ke.contextElement) : [], popper: An(yt) }; var qi = function Mr(v) { var A = js(v); return ur.reduce(function (p, T) { return p.concat(A.filter(function (P) { return P.phase === T })) }, []) }(function So(v) { var A = v.reduce(function (p, T) { var P = p[T.name]; return p[T.name] = P ? Object.assign({}, P, T, { options: Object.assign({}, P.options, T.options), data: Object.assign({}, P.data, T.data) }) : T, p }, {}); return Object.keys(A).map(function (p) { return A[p] }) }([].concat(T, Wt.options.modifiers))); return Wt.orderedModifiers = qi.filter(function (co) { return co.enabled }), function bi() { Wt.orderedModifiers.forEach(function (qr) { var ki = qr.options, Ri = qr.effect; if ("function" == typeof Ri) { var di = Ri({ state: Wt, name: qr.name, instance: Un, options: void 0 === ki ? {} : ki }); vn.push(di || function () { }) } }) }(), Un.update() }, forceUpdate: function () { if (!In) { var oi = Wt.elements, ki = oi.reference, qi = oi.popper; if (Ho(ki, qi)) { Wt.rects = { reference: Rs(ki, ze(qi), "fixed" === Wt.options.strategy), popper: Qi(qi) }, Wt.reset = !1, Wt.placement = Wt.options.placement, Wt.orderedModifiers.forEach(function (co) { return Wt.modifiersData[co.name] = Object.assign({}, co.data) }); for (var di = 0; di < Wt.orderedModifiers.length; di++)if (!0 !== Wt.reset) { var zi = Wt.orderedModifiers[di], gs = zi.fn, Yi = zi.options; "function" == typeof gs && (Wt = gs({ state: Wt, options: void 0 === Yi ? {} : Yi, name: zi.name, instance: Un }) || Wt) } else Wt.reset = !1, di = -1 } } }, update: ba(function () { return new Promise(function (qr) { Un.forceUpdate(), qr(Wt) }) }), destroy: function () { Cr(), In = !0 } }; if (!Ho(Ke, yt)) return Un; function Cr() { vn.forEach(function (qr) { return qr() }), vn = [] } return Un.setOptions(Vt).then(function (qr) { !In && Vt.onFirstUpdate && Vt.onFirstUpdate(qr) }), Un } } var cs = { passive: !0 }, hn = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function Yn(v) { var A, p = v.popper, T = v.popperRect, P = v.placement, Y = v.variation, Re = v.offsets, Ke = v.position, yt = v.gpuAcceleration, Vt = v.adaptive, Wt = v.roundOffsets, vn = v.isFixed, In = Re.x, Un = void 0 === In ? 0 : In, bi = Re.y, Cr = void 0 === bi ? 0 : bi, qr = "function" == typeof Wt ? Wt({ x: Un, y: Cr }) : { x: Un, y: Cr }; Un = qr.x, Cr = qr.y; var oi = Re.hasOwnProperty("x"), ki = Re.hasOwnProperty("y"), qi = Xe, Ri = Ze, di = window; if (Vt) { var zi = ze(p), gs = "clientHeight", Yi = "clientWidth"; zi === dr(p) && "static" !== Zt(zi = ln(p)).position && "absolute" === Ke && (gs = "scrollHeight", Yi = "scrollWidth"), (P === Ze || (P === Xe || P === le) && Y === wn) && (Ri = Ot, Cr -= (vn && zi === di && di.visualViewport ? di.visualViewport.height : zi[gs]) - T.height, Cr *= yt ? 1 : -1), P !== Xe && (P !== Ze && P !== Ot || Y !== wn) || (qi = le, Un -= (vn && zi === di && di.visualViewport ? di.visualViewport.width : zi[Yi]) - T.width, Un *= yt ? 1 : -1) } var Ha, co = Object.assign({ position: Ke }, Vt && hn), au = !0 === Wt ? function Sn(v) { var p = v.y, P = window.devicePixelRatio || 1; return { x: Gt(v.x * P) / P || 0, y: Gt(p * P) / P || 0 } }({ x: Un, y: Cr }) : { x: Un, y: Cr }; return Un = au.x, Cr = au.y, Object.assign({}, co, yt ? ((Ha = {})[Ri] = ki ? "0" : "", Ha[qi] = oi ? "0" : "", Ha.transform = (di.devicePixelRatio || 1) <= 1 ? "translate(" + Un + "px, " + Cr + "px)" : "translate3d(" + Un + "px, " + Cr + "px, 0)", Ha) : ((A = {})[Ri] = ki ? Cr + "px" : "", A[qi] = oi ? Un + "px" : "", A.transform = "", A)) } var gr = no({ defaultModifiers: [{ name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function ro(v) { var A = v.state, p = v.instance, T = v.options, P = T.scroll, Y = void 0 === P || P, Re = T.resize, Ke = void 0 === Re || Re, yt = dr(A.elements.popper), Vt = [].concat(A.scrollParents.reference, A.scrollParents.popper); return Y && Vt.forEach(function (Wt) { Wt.addEventListener("scroll", p.update, cs) }), Ke && yt.addEventListener("resize", p.update, cs), function () { Y && Vt.forEach(function (Wt) { Wt.removeEventListener("scroll", p.update, cs) }), Ke && yt.removeEventListener("resize", p.update, cs) } }, data: {} }, { name: "popperOffsets", enabled: !0, phase: "read", fn: function dt(v) { var A = v.state; A.modifiersData[v.name] = ss({ reference: A.rects.reference, element: A.rects.popper, strategy: "absolute", placement: A.placement }) }, data: {} }, { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function lr(v) { var A = v.state, p = v.options, T = p.gpuAcceleration, P = void 0 === T || T, Y = p.adaptive, Re = void 0 === Y || Y, Ke = p.roundOffsets, yt = void 0 === Ke || Ke, Wt = { placement: Yt(A.placement), variation: ti(A.placement), popper: A.elements.popper, popperRect: A.rects.popper, gpuAcceleration: P, isFixed: "fixed" === A.options.strategy }; null != A.modifiersData.popperOffsets && (A.styles.popper = Object.assign({}, A.styles.popper, Yn(Object.assign({}, Wt, { offsets: A.modifiersData.popperOffsets, position: A.options.strategy, adaptive: Re, roundOffsets: yt })))), null != A.modifiersData.arrow && (A.styles.arrow = Object.assign({}, A.styles.arrow, Yn(Object.assign({}, Wt, { offsets: A.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: yt })))), A.attributes.popper = Object.assign({}, A.attributes.popper, { "data-popper-placement": A.placement }) }, data: {} }, { name: "applyStyles", enabled: !0, phase: "write", fn: function Vr(v) { var A = v.state; Object.keys(A.elements).forEach(function (p) { var T = A.styles[p] || {}, P = A.attributes[p] || {}, Y = A.elements[p]; !vr(Y) || !ke(Y) || (Object.assign(Y.style, T), Object.keys(P).forEach(function (Re) { var Ke = P[Re]; !1 === Ke ? Y.removeAttribute(Re) : Y.setAttribute(Re, !0 === Ke ? "" : Ke) })) }) }, effect: function Ai(v) { var A = v.state, p = { popper: { position: A.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(A.elements.popper.style, p.popper), A.styles = p, A.elements.arrow && Object.assign(A.elements.arrow.style, p.arrow), function () { Object.keys(A.elements).forEach(function (T) { var P = A.elements[T], Y = A.attributes[T] || {}, Ke = Object.keys(A.styles.hasOwnProperty(T) ? A.styles[T] : p[T]).reduce(function (yt, Vt) { return yt[Vt] = "", yt }, {}); !vr(P) || !ke(P) || (Object.assign(P.style, Ke), Object.keys(Y).forEach(function (yt) { P.removeAttribute(yt) })) }) } }, requires: ["computeStyles"] }] }); const bo = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function us(v) { var A = v.state, T = v.name, P = v.options.offset, Y = void 0 === P ? [0, 0] : P, Re = it.reduce(function (Wt, vn) { return Wt[vn] = function xl(v, A, p) { var T = Yt(v), P = [Xe, Ze].indexOf(T) >= 0 ? -1 : 1, Y = "function" == typeof p ? p(Object.assign({}, A, { placement: v })) : p, Re = Y[0], Ke = Y[1]; return Re = Re || 0, Ke = (Ke || 0) * P, [Xe, le].indexOf(T) >= 0 ? { x: Ke, y: Re } : { x: Re, y: Ke } }(vn, A.rects, Y), Wt }, {}), Ke = Re[A.placement], Vt = Ke.y; null != A.modifiersData.popperOffsets && (A.modifiersData.popperOffsets.x += Ke.x, A.modifiersData.popperOffsets.y += Vt), A.modifiersData[T] = Re } }; function Jr(v, A) { } function Io(v, A) { if (1 & v && (i.TgZ(0, "button", 3), i._uU(1), i.YNc(2, Jr, 0, 0, "ng-template", 4), i.qZA()), 2 & v) { const p = A.$implicit; i.Q6J("ngbPanelToggle", p), i.xp6(1), i.hij(" ", p.title, ""), i.xp6(1), i.Q6J("ngTemplateOutlet", null == p.titleTpl ? null : p.titleTpl.templateRef) } } function Xn(v, A) { } function uo(v, A) { } function Si(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "div", 8), i.NdJ("ngbRef", function (P) { i.CHM(p); const Y = i.oxw().$implicit; return i.KtG(Y.panelDiv = P) }), i.TgZ(1, "div", 9), i.YNc(2, uo, 0, 0, "ng-template", 4), i.qZA()() } if (2 & v) { const p = i.oxw().$implicit; i.s9C("id", p.id), i.uIk("aria-labelledby", p.id + "-header"), i.xp6(2), i.Q6J("ngTemplateOutlet", (null == p.contentTpl ? null : p.contentTpl.templateRef) || null) } } const ka = function (v, A) { return { $implicit: v, opened: A } }; function io(v, A) { if (1 & v && (i.TgZ(0, "div")(1, "div", 5), i.YNc(2, Xn, 0, 0, "ng-template", 6), i.qZA(), i.YNc(3, Si, 3, 3, "div", 7), i.qZA()), 2 & v) { const p = A.$implicit, T = i.oxw(), P = i.MAs(1); i.Tol("accordion-item " + (p.cardClass || "")), i.xp6(1), i.Tol("accordion-header " + (p.type ? "bg-" + p.type : T.type ? "bg-" + T.type : "")), i.MGl("id", "", p.id, "-header"), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == p.headerTpl ? null : p.headerTpl.templateRef) || P)("ngTemplateOutletContext", i.WLB(8, ka, p, p.isOpen)), i.xp6(1), i.Q6J("ngIf", !T.destroyOnHide || p.isOpen || p.transitionRunning) } } function Wl(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "button", 1), i.NdJ("click", function () { i.CHM(p); const P = i.oxw(); return i.KtG(P.close()) }), i.qZA() } } const zo = ["*"]; function Ys(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "button", 6), i.NdJ("click", function () { const Y = i.CHM(p).$implicit, Re = i.oxw(); return Re.focus(), i.KtG(Re.select(Y.id, Re.NgbSlideEventSource.INDICATOR)) }), i.qZA() } if (2 & v) { const p = A.$implicit, T = i.oxw(); i.ekj("active", p.id === T.activeId), i.uIk("aria-labelledby", "slide-" + p.id)("aria-controls", "slide-" + p.id)("aria-selected", p.id === T.activeId) } } function Go(v, A) { } function so(v, A) { if (1 & v && (i.TgZ(0, "div", 7)(1, "span", 8), i.SDv(2, 9), i.qZA(), i.YNc(3, Go, 0, 0, "ng-template", 10), i.qZA()), 2 & v) { const p = A.$implicit, T = A.index, P = A.count; i.Q6J("id", "slide-" + p.id), i.xp6(2), i.pQV(T + 1)(P), i.QtT(2), i.xp6(1), i.Q6J("ngTemplateOutlet", p.tplRef) } } function jo(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "button", 11), i.NdJ("click", function () { i.CHM(p); const P = i.oxw(); return i.KtG(P.arrowLeft()) }), i._UZ(1, "span", 12), i.TgZ(2, "span", 8), i.SDv(3, 13), i.qZA()() } } function na(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "button", 14), i.NdJ("click", function () { i.CHM(p); const P = i.oxw(); return i.KtG(P.arrowRight()) }), i._UZ(1, "span", 15), i.TgZ(2, "span", 8), i.SDv(3, 16), i.qZA()() } } const Zl = ["month"], pi = ["year"]; function Ss(v, A) { if (1 & v && (i.TgZ(0, "option", 5), i._uU(1), i.qZA()), 2 & v) { const p = A.$implicit, T = i.oxw(); i.Q6J("value", p), i.uIk("aria-label", T.i18n.getMonthFullName(p, T.date.year)), i.xp6(1), i.Oqu(T.i18n.getMonthShortName(p, T.date.year)) } } function $o(v, A) { if (1 & v && (i.TgZ(0, "option", 5), i._uU(1), i.qZA()), 2 & v) { const p = A.$implicit, T = i.oxw(); i.Q6J("value", p), i.xp6(1), i.Oqu(T.i18n.getYearNumerals(p)) } } function wo(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "ngb-datepicker-navigation-select", 7), i.NdJ("select", function (P) { i.CHM(p); const Y = i.oxw(); return i.KtG(Y.select.emit(P)) }), i.qZA() } if (2 & v) { const p = i.oxw(); i.Q6J("date", p.date)("disabled", p.disabled)("months", p.selectBoxes.months)("years", p.selectBoxes.years) } } function ho(v, A) { 1 & v && i._UZ(0, "div", 0) } function Ao(v, A) { 1 & v && i._UZ(0, "div", 0) } function rs(v, A) { if (1 & v && (i.YNc(0, ho, 1, 0, "div", 9), i.TgZ(1, "div", 10), i._uU(2), i.qZA(), i.YNc(3, Ao, 1, 0, "div", 9)), 2 & v) { const p = A.$implicit, T = A.index, P = i.oxw(2); i.Q6J("ngIf", T > 0), i.xp6(2), i.hij(" ", P.i18n.getMonthLabel(p.firstDate), " "), i.xp6(1), i.Q6J("ngIf", T !== P.months.length - 1) } } function Is(v, A) { if (1 & v && i.YNc(0, rs, 4, 3, "ng-template", 8), 2 & v) { const p = i.oxw(); i.Q6J("ngForOf", p.months) } } const Wo = ["ngbDatepickerDayView", ""], Za = ["defaultDayTemplate"], fo = ["content"]; function As(v, A) { if (1 & v && i._UZ(0, "div", 7), 2 & v) { const T = A.currentMonth, P = A.selected, Y = A.disabled, Re = A.focused; i.Q6J("date", A.date)("currentMonth", T)("selected", P)("disabled", Y)("focused", Re) } } function Pa(v, A) { if (1 & v && (i.TgZ(0, "div", 12), i._uU(1), i.qZA()), 2 & v) { const p = i.oxw().$implicit, T = i.oxw(2); i.xp6(1), i.hij(" ", T.i18n.getMonthLabel(p.firstDate), " ") } } function Ks(v, A) { if (1 & v && (i.TgZ(0, "div", 9), i.YNc(1, Pa, 2, 1, "div", 10), i._UZ(2, "ngb-datepicker-month", 11), i.qZA()), 2 & v) { const p = A.$implicit, T = i.oxw(2); i.xp6(1), i.Q6J("ngIf", "none" === T.navigation || T.displayMonths > 1 && "select" === T.navigation), i.xp6(1), i.Q6J("month", p.firstDate) } } function Ls(v, A) { if (1 & v && i.YNc(0, Ks, 3, 2, "div", 8), 2 & v) { const p = i.oxw(); i.Q6J("ngForOf", p.model.months) } } function xo(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "ngb-datepicker-navigation", 13), i.NdJ("navigate", function (P) { i.CHM(p); const Y = i.oxw(); return i.KtG(Y.onNavigateEvent(P)) })("select", function (P) { i.CHM(p); const Y = i.oxw(); return i.KtG(Y.onNavigateDateSelect(P)) }), i.qZA() } if (2 & v) { const p = i.oxw(); i.Q6J("date", p.model.firstDate)("months", p.model.months)("disabled", p.model.disabled)("showSelect", "select" === p.model.navigation)("prevDisabled", p.model.prevDisabled)("nextDisabled", p.model.nextDisabled)("selectBoxes", p.model.selectBoxes) } } function Ii(v, A) { } function Ui(v, A) { } function Js(v, A) { if (1 & v && (i.TgZ(0, "div", 5), i._uU(1), i.qZA()), 2 & v) { const p = i.oxw(2); i.xp6(1), i.Oqu(p.i18n.getWeekLabel()) } } function ds(v, A) { if (1 & v && (i.TgZ(0, "div", 6), i._uU(1), i.qZA()), 2 & v) { const p = A.$implicit; i.xp6(1), i.Oqu(p) } } function Mo(v, A) { if (1 & v && (i.TgZ(0, "div", 2), i.YNc(1, Js, 2, 1, "div", 3), i.YNc(2, ds, 2, 1, "div", 4), i.qZA()), 2 & v) { const p = i.oxw(); i.xp6(1), i.Q6J("ngIf", p.datepicker.showWeekNumbers), i.xp6(1), i.Q6J("ngForOf", p.viewModel.weekdays) } } function Ra(v, A) { if (1 & v && (i.TgZ(0, "div", 11), i._uU(1), i.qZA()), 2 & v) { const p = i.oxw(2).$implicit, T = i.oxw(); i.xp6(1), i.Oqu(T.i18n.getWeekNumerals(p.number)) } } function gi(v, A) { } function Ml(v, A) { if (1 & v && i.YNc(0, gi, 0, 0, "ng-template", 14), 2 & v) { const p = i.oxw().$implicit, T = i.oxw(3); i.Q6J("ngTemplateOutlet", T.datepicker.dayTemplate)("ngTemplateOutletContext", p.context) } } function wa(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "div", 12), i.NdJ("click", function (P) { const Re = i.CHM(p).$implicit; return i.oxw(3).doSelect(Re), i.KtG(P.preventDefault()) }), i.YNc(1, Ml, 1, 2, "ng-template", 13), i.qZA() } if (2 & v) { const p = A.$implicit; i.ekj("disabled", p.context.disabled)("hidden", p.hidden)("ngb-dp-today", p.context.today), i.Q6J("tabindex", p.tabindex), i.uIk("aria-label", p.ariaLabel), i.xp6(1), i.Q6J("ngIf", !p.hidden) } } function Qs(v, A) { if (1 & v && (i.TgZ(0, "div", 8), i.YNc(1, Ra, 2, 1, "div", 9), i.YNc(2, wa, 2, 9, "div", 10), i.qZA()), 2 & v) { const p = i.oxw().$implicit, T = i.oxw(); i.xp6(1), i.Q6J("ngIf", T.datepicker.showWeekNumbers), i.xp6(1), i.Q6J("ngForOf", p.days) } } function Zr(v, A) { 1 & v && i.YNc(0, Qs, 3, 2, "div", 7), 2 & v && i.Q6J("ngIf", !A.$implicit.collapsed) } const oo = ["dialog"], xs = ["ngbNavOutlet", ""]; function Oo(v, A) { } const Hi = function (v) { return { $implicit: v } }; function qa(v, A) { if (1 & v && (i.TgZ(0, "div", 2), i.YNc(1, Oo, 0, 0, "ng-template", 3), i.qZA()), 2 & v) { const p = i.oxw().$implicit, T = i.oxw(); i.Q6J("item", p)("nav", T.nav)("role", T.paneRole), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == p.contentTpl ? null : p.contentTpl.templateRef) || null)("ngTemplateOutletContext", i.VKq(5, Hi, p.active || T.isPanelTransitioning(p))) } } function ys(v, A) { if (1 & v && i.YNc(0, qa, 2, 7, "div", 1), 2 & v) { const p = A.$implicit, T = i.oxw(); i.Q6J("ngIf", p.isPanelInDom() || T.isPanelTransitioning(p)) } } function hr(v, A) { 1 & v && (i.TgZ(0, "span", 9), i.SDv(1, 10), i.qZA()) } function Xs(v, A) { 1 & v && (i.TgZ(0, "span", 9), i.SDv(1, 11), i.qZA()) } function Q(v, A) { 1 & v && (i.TgZ(0, "span", 9), i.SDv(1, 12), i.qZA()) } function q(v, A) { 1 & v && (i.TgZ(0, "span", 9), i.SDv(1, 13), i.qZA()) } function $(v, A) { 1 & v && i._uU(0, "...") } function me(v, A) { 1 & v && (i.TgZ(0, "span", 15), i._uU(1, "(current)"), i.qZA()) } function Rt(v, A) { if (1 & v && (i._uU(0), i.YNc(1, me, 2, 0, "span", 14)), 2 & v) { const p = A.$implicit, T = A.currentPage; i.hij(" ", p, " "), i.xp6(1), i.Q6J("ngIf", p === T) } } function Bn(v, A) { } const wi = function (v) { return { disabled: !0, currentPage: v } }; function Jt(v, A) { if (1 & v && (i.TgZ(0, "a", 20), i.YNc(1, Bn, 0, 0, "ng-template", 8), i.qZA()), 2 & v) { const p = i.oxw(2).$implicit, T = i.oxw(), P = i.MAs(9); i.xp6(1), i.Q6J("ngTemplateOutlet", (null == T.tplEllipsis ? null : T.tplEllipsis.templateRef) || P)("ngTemplateOutletContext", i.VKq(2, wi, p)) } } function zr(v, A) { } const ll = function (v, A, p) { return { disabled: v, $implicit: A, currentPage: p } }; function qc(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "a", 21), i.NdJ("click", function (P) { i.CHM(p); const Y = i.oxw().$implicit; return i.oxw(2).selectPage(Y), i.KtG(P.preventDefault()) }), i.YNc(1, zr, 0, 0, "ng-template", 8), i.qZA() } if (2 & v) { const p = i.oxw().$implicit, T = i.oxw(), P = T.disabled, Y = T.$implicit, Re = i.oxw(), Ke = i.MAs(11); i.uIk("tabindex", P ? "-1" : null)("aria-disabled", P ? "true" : null), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == Re.tplNumber ? null : Re.tplNumber.templateRef) || Ke)("ngTemplateOutletContext", i.kEZ(4, ll, P, p, Y)) } } function vs(v, A) { if (1 & v && (i.TgZ(0, "li", 17), i.YNc(1, Jt, 2, 4, "a", 18), i.YNc(2, qc, 2, 8, "a", 19), i.qZA()), 2 & v) { const p = A.$implicit, T = i.oxw(), P = T.$implicit, Y = T.disabled, Re = i.oxw(); i.ekj("active", p === P)("disabled", Re.isEllipsis(p) || Y), i.uIk("aria-current", p === P ? "page" : null), i.xp6(1), i.Q6J("ngIf", Re.isEllipsis(p)), i.xp6(1), i.Q6J("ngIf", !Re.isEllipsis(p)) } } function ql(v, A) { 1 & v && i.YNc(0, vs, 3, 7, "li", 16), 2 & v && i.Q6J("ngForOf", A.pages) } function cl(v, A) { } const po = function (v, A) { return { disabled: v, currentPage: A } }; function Fa(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "li", 17)(1, "a", 22), i.NdJ("click", function (P) { return i.CHM(p), i.oxw().selectPage(1), i.KtG(P.preventDefault()) }), i.YNc(2, cl, 0, 0, "ng-template", 8), i.qZA()() } if (2 & v) { const p = i.oxw(), T = i.MAs(1); i.ekj("disabled", p.previousDisabled()), i.xp6(1), i.uIk("tabindex", p.previousDisabled() ? "-1" : null)("aria-disabled", p.previousDisabled() ? "true" : null), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == p.tplFirst ? null : p.tplFirst.templateRef) || T)("ngTemplateOutletContext", i.WLB(6, po, p.previousDisabled(), p.page)) } } function ul(v, A) { } const Yl = function (v) { return { disabled: v } }; function Kl(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "li", 17)(1, "a", 23), i.NdJ("click", function (P) { i.CHM(p); const Y = i.oxw(); return Y.selectPage(Y.page - 1), i.KtG(P.preventDefault()) }), i.YNc(2, ul, 0, 0, "ng-template", 8), i.qZA()() } if (2 & v) { const p = i.oxw(), T = i.MAs(3); i.ekj("disabled", p.previousDisabled()), i.xp6(1), i.uIk("tabindex", p.previousDisabled() ? "-1" : null)("aria-disabled", p.previousDisabled() ? "true" : null), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == p.tplPrevious ? null : p.tplPrevious.templateRef) || T)("ngTemplateOutletContext", i.VKq(6, Yl, p.previousDisabled())) } } function dl(v, A) { } function Ms(v, A) { } function hs(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "li", 17)(1, "a", 24), i.NdJ("click", function (P) { i.CHM(p); const Y = i.oxw(); return Y.selectPage(Y.page + 1), i.KtG(P.preventDefault()) }), i.YNc(2, Ms, 0, 0, "ng-template", 8), i.qZA()() } if (2 & v) { const p = i.oxw(), T = i.MAs(5); i.ekj("disabled", p.nextDisabled()), i.xp6(1), i.uIk("tabindex", p.nextDisabled() ? "-1" : null)("aria-disabled", p.nextDisabled() ? "true" : null), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == p.tplNext ? null : p.tplNext.templateRef) || T)("ngTemplateOutletContext", i.WLB(6, po, p.nextDisabled(), p.page)) } } function Ca(v, A) { } function hl(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "li", 17)(1, "a", 25), i.NdJ("click", function (P) { i.CHM(p); const Y = i.oxw(); return Y.selectPage(Y.pageCount), i.KtG(P.preventDefault()) }), i.YNc(2, Ca, 0, 0, "ng-template", 8), i.qZA()() } if (2 & v) { const p = i.oxw(), T = i.MAs(7); i.ekj("disabled", p.nextDisabled()), i.xp6(1), i.uIk("tabindex", p.nextDisabled() ? "-1" : null)("aria-disabled", p.nextDisabled() ? "true" : null), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == p.tplLast ? null : p.tplLast.templateRef) || T)("ngTemplateOutletContext", i.WLB(6, po, p.nextDisabled(), p.page)) } } const Co = function (v, A, p) { return { $implicit: v, pages: A, disabled: p } }; function bc(v, A) { if (1 & v && i._uU(0), 2 & v) { const p = i.oxw(2); i.Oqu(p.title) } } function Ea(v, A) { } function Jl(v, A) { if (1 & v && (i.TgZ(0, "h3", 3), i.YNc(1, bc, 1, 1, "ng-template", null, 4, i.W1O), i.YNc(3, Ea, 0, 0, "ng-template", 5), i.qZA()), 2 & v) { const p = i.MAs(2), T = i.oxw(); i.xp6(3), i.Q6J("ngTemplateOutlet", T.isTitleTemplate() ? T.title : p)("ngTemplateOutletContext", T.context) } } function Ql(v, A) { 1 & v && i._uU(0), 2 & v && i.Oqu(100 === A.fill ? "\u2605" : "\u2606") } function No(v, A) { } function Cc(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "span", 2), i._uU(1), i.qZA(), i.TgZ(2, "span", 3), i.NdJ("mouseenter", function () { const Y = i.CHM(p).index, Re = i.oxw(); return i.KtG(Re.enter(Y + 1)) })("click", function () { const Y = i.CHM(p).index, Re = i.oxw(); return i.KtG(Re.handleClick(Y + 1)) }), i.YNc(3, No, 0, 0, "ng-template", 4), i.qZA() } if (2 & v) { const p = A.index, T = i.oxw(), P = i.MAs(1); i.xp6(1), i.hij("(", p < T.nextRate ? "*" : " ", ")"), i.xp6(1), i.Udp("cursor", T.isInteractive() ? "pointer" : "default"), i.xp6(1), i.Q6J("ngTemplateOutlet", T.starTemplate || T.starTemplateFromContent || P)("ngTemplateOutletContext", T.contexts[p]) } } function La(v, A) { if (1 & v && (i.TgZ(0, "strong", 3), i._uU(1), i.qZA()), 2 & v) { const p = i.oxw(); i.xp6(1), i.Oqu(p.header) } } function es(v, A) { } function Ja(v, A) { if (1 & v) { const p = i.EpF(); i.TgZ(0, "div", 4), i.YNc(1, es, 0, 0, "ng-template", 5), i.TgZ(2, "button", 6), i.NdJ("click", function () { i.CHM(p); const P = i.oxw(); return i.KtG(P.hide()) }), i.qZA()() } if (2 & v) { const p = i.oxw(), T = i.MAs(1); i.xp6(1), i.Q6J("ngTemplateOutlet", p.contentHeaderTpl || T) } } function ec(v, A) { if (1 & v && (i.TgZ(0, "span"), i._uU(1), i.qZA()), 2 & v) { const p = i.oxw().$implicit, T = i.oxw(); i.Tol(T.highlightClass), i.xp6(1), i.Oqu(p) } } function yi(v, A) { if (1 & v && i._uU(0), 2 & v) { const p = i.oxw().$implicit; i.Oqu(p) } } function Da(v, A) { if (1 & v && (i.YNc(0, ec, 2, 3, "span", 1), i.YNc(1, yi, 1, 1, "ng-template", null, 2, i.W1O)), 2 & v) { const p = A.odd, T = i.MAs(2); i.Q6J("ngIf", p)("ngIfElse", T) } } function re(v) { return parseInt(`${v}`, 10) } function Z(v) { return null != v ? `${v}` : "" } function he(v, A, p = 0) { return Math.max(Math.min(v, A), p) } function $e(v) { return "string" == typeof v } function Ft(v) { return !isNaN(re(v)) } function Xt(v) { return "number" == typeof v && isFinite(v) && Math.floor(v) === v } function Nn(v) { return null != v } function ri(v) { return v && v.then } function Nr(v) { return Ft(v) ? `0${v}`.slice(-2) : "" } function Or(v, A) { return v && v.className && v.className.split && v.className.split(/\s+/).indexOf(A) >= 0 } function xr(v) { return (v || document.body).getBoundingClientRect() } function mi(v) { return v.normalize("NFD").replace(/[\u0300-\u036f]/g, "") } const To = { animation: !0, transitionTimerDelayMs: 5 }, go = () => { }, { transitionTimerDelayMs: Ba } = To, Va = new Map, xi = (v, A, p, T) => { let P = T.context || {}; const Y = Va.get(A); if (Y) switch (T.runningTransition) { case "continue": return ye.E; case "stop": v.run(() => Y.transition$.complete()), P = Object.assign(Y.context, P), Va.delete(A) }const Re = p(A, T.animation, P) || go; if (!T.animation || "none" === window.getComputedStyle(A).transitionProperty) return v.run(() => Re()), (0, Ce.of)(void 0).pipe(function Os(v) { return A => new J.y(p => A.subscribe({ next: Re => v.run(() => p.next(Re)), error: Re => v.run(() => p.error(Re)), complete: () => v.run(() => p.complete()) })) }(v)); const Ke = new we.x, yt = new we.x, Vt = Ke.pipe(function Oe(...v) { return A => (0, ct.z)(A, (0, Ce.of)(...v)) }(!0)); Va.set(A, { transition$: Ke, complete: () => { yt.next(), yt.complete() }, context: P }); const Wt = function bs(v) { const { transitionDelay: A, transitionDuration: p } = window.getComputedStyle(v); return 1e3 * (parseFloat(A) + parseFloat(p)) }(A); return v.runOutsideAngular(() => { const vn = (0, Te.R)(A, "transitionend").pipe((0, Ve.R)(Vt), (0, Be.h)(({ target: Un }) => Un === A)); xe((0, Ee.H)(Wt + Ba).pipe((0, Ve.R)(Vt)), vn, yt).pipe((0, Ve.R)(Vt)).subscribe(() => { Va.delete(A), v.run(() => { Re(), Ke.next(), Ke.complete() }) }) }), Ke.asObservable() }, Zo = (v, A, p) => { let { direction: T, maxSize: P, dimension: Y } = p; const { classList: Re } = v; function Ke() { Re.add("collapse"), "show" === T ? Re.add("show") : Re.remove("show") } if (A) return P || (P = function Yc(v, A) { if (typeof navigator > "u") return "0px"; const { classList: p } = v, T = p.contains("show"); T || p.add("show"), v.style[A] = ""; const P = v.getBoundingClientRect()[A] + "px"; return T || p.remove("show"), P }(v, Y), p.maxSize = P, v.style[Y] = "show" !== T ? P : "0px", Re.remove("collapse"), Re.remove("collapsing"), Re.remove("show"), xr(v), Re.add("collapsing")), v.style[Y] = "show" === T ? P : "0px", () => { Ke(), Re.remove("collapsing"), v.style[Y] = "" }; Ke() }; let qo = (() => { class v { constructor() { this.animation = To.animation } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), gl = (() => { class v { constructor(p) { this._ngbConfig = p, this.closeOthers = !1 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), ko = 0, Pl = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPanelHeader", ""]] }), v })(), Rl = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPanelTitle", ""]] }), v })(), $s = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPanelContent", ""]] }), v })(), Fl = (() => { class v { constructor() { this.disabled = !1, this.id = "ngb-panel-" + ko++, this.isOpen = !1, this.initClassDone = !1, this.transitionRunning = !1, this.shown = new i.vpe, this.hidden = new i.vpe } ngAfterContentChecked() { this.titleTpl = this.titleTpls.first, this.headerTpl = this.headerTpls.first, this.contentTpl = this.contentTpls.first } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ngb-panel"]], contentQueries: function (p, T, P) { if (1 & p && (i.Suo(P, Rl, 4), i.Suo(P, Pl, 4), i.Suo(P, $s, 4)), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.titleTpls = Y), i.iGM(Y = i.CRH()) && (T.headerTpls = Y), i.iGM(Y = i.CRH()) && (T.contentTpls = Y) } }, inputs: { disabled: "disabled", id: "id", title: "title", type: "type", cardClass: "cardClass" }, outputs: { shown: "shown", hidden: "hidden" } }), v })(), Bs = (() => { class v { constructor(p) { this._El = p, this.ngbRef = new i.vpe } ngOnInit() { this.ngbRef.emit(this._El.nativeElement) } ngOnDestroy() { this.ngbRef.emit(null) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbRef", ""]], outputs: { ngbRef: "ngbRef" } }), v })(), Qa = (() => { class v { constructor(p, T, P) { this._ngZone = T, this._changeDetector = P, this.activeIds = [], this.destroyOnHide = !0, this.panelChange = new i.vpe, this.shown = new i.vpe, this.hidden = new i.vpe, this.animation = p.animation, this.type = p.type, this.closeOtherPanels = p.closeOthers } isExpanded(p) { return this.activeIds.indexOf(p) > -1 } expand(p) { this._changeOpenState(this._findPanelById(p), !0) } expandAll() { this.closeOtherPanels ? 0 === this.activeIds.length && this.panels.length && this._changeOpenState(this.panels.first, !0) : this.panels.forEach(p => this._changeOpenState(p, !0)) } collapse(p) { this._changeOpenState(this._findPanelById(p), !1) } collapseAll() { this.panels.forEach(p => { this._changeOpenState(p, !1) }) } toggle(p) { const T = this._findPanelById(p); T && this._changeOpenState(T, !T.isOpen) } ngAfterContentChecked() { $e(this.activeIds) && (this.activeIds = this.activeIds.split(/\s*,\s*/)), this.panels.forEach(p => { p.isOpen = !p.disabled && this.activeIds.indexOf(p.id) > -1 }), this.activeIds.length > 1 && this.closeOtherPanels && (this._closeOthers(this.activeIds[0], !1), this._updateActiveIds()), this._ngZone.onStable.pipe((0, nt.q)(1)).subscribe(() => { this.panels.forEach(p => { const T = p.panelDiv; T ? p.initClassDone || (p.initClassDone = !0, xi(this._ngZone, T, Zo, { animation: !1, runningTransition: "continue", context: { direction: p.isOpen ? "show" : "hide", dimension: "height" } })) : p.initClassDone = !1 }) }) } _changeOpenState(p, T) { if (null != p && !p.disabled && p.isOpen !== T) { let P = !1; this.panelChange.emit({ panelId: p.id, nextState: T, preventDefault: () => { P = !0 } }), P || (p.isOpen = T, p.transitionRunning = !0, T && this.closeOtherPanels && this._closeOthers(p.id), this._updateActiveIds(), this._runTransitions(this.animation)) } } _closeOthers(p, T = !0) { this.panels.forEach(P => { P.id !== p && P.isOpen && (P.isOpen = !1, P.transitionRunning = T) }) } _findPanelById(p) { return this.panels.find(T => T.id === p) || null } _updateActiveIds() { this.activeIds = this.panels.filter(p => p.isOpen && !p.disabled).map(p => p.id) } _runTransitions(p) { this._changeDetector.detectChanges(), this.panels.forEach(T => { T.transitionRunning && xi(this._ngZone, T.panelDiv, Zo, { animation: p, runningTransition: "stop", context: { direction: T.isOpen ? "show" : "hide", dimension: "height" } }).subscribe(() => { T.transitionRunning = !1; const { id: Y } = T; T.isOpen ? (T.shown.emit(), this.shown.emit(Y)) : (T.hidden.emit(), this.hidden.emit(Y)) }) }) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(gl), i.Y36(i.R0b), i.Y36(i.sBO)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-accordion"]], contentQueries: function (p, T, P) { if (1 & p && i.Suo(P, Fl, 4), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.panels = Y) } }, hostAttrs: ["role", "tablist", 1, "accordion"], hostVars: 1, hostBindings: function (p, T) { 2 & p && i.uIk("aria-multiselectable", !T.closeOtherPanels) }, inputs: { animation: "animation", activeIds: "activeIds", closeOtherPanels: ["closeOthers", "closeOtherPanels"], destroyOnHide: "destroyOnHide", type: "type" }, outputs: { panelChange: "panelChange", shown: "shown", hidden: "hidden" }, exportAs: ["ngbAccordion"], decls: 3, vars: 1, consts: [["ngbPanelHeader", ""], ["t", ""], ["ngFor", "", 3, "ngForOf"], [1, "accordion-button", 3, "ngbPanelToggle"], [3, "ngTemplateOutlet"], ["role", "tab", 3, "id"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "tabpanel", 3, "id", "ngbRef", 4, "ngIf"], ["role", "tabpanel", 3, "id", "ngbRef"], [1, "accordion-body"]], template: function (p, T) { 1 & p && (i.YNc(0, Io, 3, 3, "ng-template", 0, 1, i.W1O), i.YNc(2, io, 4, 11, "ng-template", 2)), 2 & p && (i.xp6(2), i.Q6J("ngForOf", T.panels)) }, dependencies: function () { return [m.sg, m.O5, m.tP, Bs, Pl, Xa] }, encapsulation: 2 }), v })(), Xa = (() => { class v { constructor(p, T) { this.accordion = p, this.panel = T } set ngbPanelToggle(p) { p && (this.panel = p) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(Qa), i.Y36(Fl, 9)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["button", "ngbPanelToggle", ""]], hostAttrs: ["type", "button"], hostVars: 5, hostBindings: function (p, T) { 1 & p && i.NdJ("click", function () { return T.accordion.toggle(T.panel.id) }), 2 & p && (i.Ikx("disabled", T.panel.disabled), i.uIk("aria-expanded", T.panel.isOpen)("aria-controls", T.panel.id), i.ekj("collapsed", !T.panel.isOpen)) }, inputs: { ngbPanelToggle: "ngbPanelToggle" } }), v })(), Sc = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(); const Jc = ({ classList: v }) => { v.remove("show") }; let Ll = (() => { class v { constructor(p) { this._ngbConfig = p, this.dismissible = !0, this.type = "warning" } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), yu = (() => { class v { constructor(p, T, P, Y) { this._renderer = T, this._element = P, this._zone = Y, this.closed = new i.vpe, this.dismissible = p.dismissible, this.type = p.type, this.animation = p.animation } close() { const p = xi(this._zone, this._element.nativeElement, Jc, { animation: this.animation, runningTransition: "continue" }); return p.subscribe(() => this.closed.emit()), p } ngOnChanges(p) { const T = p.type; T && !T.firstChange && (this._renderer.removeClass(this._element.nativeElement, `alert-${T.previousValue}`), this._renderer.addClass(this._element.nativeElement, `alert-${T.currentValue}`)) } ngOnInit() { this._renderer.addClass(this._element.nativeElement, `alert-${this.type}`) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(Ll), i.Y36(i.Qsj), i.Y36(i.SBq), i.Y36(i.R0b)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-alert"]], hostAttrs: ["role", "alert", 1, "alert", "show"], hostVars: 4, hostBindings: function (p, T) { 2 & p && i.ekj("fade", T.animation)("alert-dismissible", T.dismissible) }, inputs: { animation: "animation", dismissible: "dismissible", type: "type" }, outputs: { closed: "closed" }, exportAs: ["ngbAlert"], features: [i.TTD], ngContentSelectors: zo, decls: 2, vars: 1, consts: function () { let A; return A = $localize`:@@ngb.alert.close:Close`, [["type", "button", "class", "btn-close", "aria-label", A, 3, "click", 4, "ngIf"], ["type", "button", "aria-label", A, 1, "btn-close", 3, "click"]] }, template: function (p, T) { 1 & p && (i.F$t(), i.Hsn(0), i.YNc(1, Wl, 1, 0, "button", 0)), 2 & p && (i.xp6(1), i.Q6J("ngIf", T.dismissible)) }, dependencies: [m.O5], styles: ["ngb-alert{display:block}\n"], encapsulation: 2, changeDetection: 0 }), v })(), Lu = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(); var eo = (() => { return (v = eo || (eo = {})).START = "start", v.END = "end", eo; var v })(); const Ic = ({ classList: v }) => v.contains("carousel-item-start") || v.contains("carousel-item-end"), ra = v => { v.remove("carousel-item-start"), v.remove("carousel-item-end") }, ia = v => { ra(v), v.remove("carousel-item-prev"), v.remove("carousel-item-next") }, Ac = (v, A, { direction: p }) => { const { classList: T } = v; return A ? (Ic(v) ? ra(T) : (T.add("carousel-item-" + (p === eo.START ? "next" : "prev")), xr(v), T.add("carousel-item-" + p)), () => { ia(T), T.add("active") }) : (ra(T), ia(T), void T.add("active")) }, el = (v, A, { direction: p }) => { const { classList: T } = v; return A ? (Ic(v) ? ra(T) : T.add("carousel-item-" + p), () => { ia(T), T.remove("active") }) : (ra(T), ia(T), void T.remove("active")) }; let Yo = (() => { class v { constructor(p) { this._ngbConfig = p, this.interval = 5e3, this.wrap = !0, this.keyboard = !0, this.pauseOnHover = !0, this.pauseOnFocus = !0, this.showNavigationArrows = !0, this.showNavigationIndicators = !0 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), Ko = 0, Bu = (() => { class v { constructor(p) { this.tplRef = p, this.id = "ngb-slide-" + Ko++, this.slid = new i.vpe } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbSlide", ""]], inputs: { id: "id" }, outputs: { slid: "slid" } }), v })(), Qc = (() => { class v { constructor(p, T, P, Y, Re) { this._platformId = T, this._ngZone = P, this._cd = Y, this._container = Re, this.NgbSlideEventSource = Sa, this._destroy$ = new we.x, this._interval$ = new Se.X(0), this._mouseHover$ = new Se.X(!1), this._focused$ = new Se.X(!1), this._pauseOnHover$ = new Se.X(!1), this._pauseOnFocus$ = new Se.X(!1), this._pause$ = new Se.X(!1), this._wrap$ = new Se.X(!1), this.slide = new i.vpe, this.slid = new i.vpe, this._transitionIds = null, this.animation = p.animation, this.interval = p.interval, this.wrap = p.wrap, this.keyboard = p.keyboard, this.pauseOnHover = p.pauseOnHover, this.pauseOnFocus = p.pauseOnFocus, this.showNavigationArrows = p.showNavigationArrows, this.showNavigationIndicators = p.showNavigationIndicators } set interval(p) { this._interval$.next(p) } get interval() { return this._interval$.value } set wrap(p) { this._wrap$.next(p) } get wrap() { return this._wrap$.value } set pauseOnHover(p) { this._pauseOnHover$.next(p) } get pauseOnHover() { return this._pauseOnHover$.value } set pauseOnFocus(p) { this._pauseOnFocus$.next(p) } get pauseOnFocus() { return this._pauseOnFocus$.value } set mouseHover(p) { this._mouseHover$.next(p) } get mouseHover() { return this._mouseHover$.value } set focused(p) { this._focused$.next(p) } get focused() { return this._focused$.value } arrowLeft() { this.focus(), this.prev(Sa.ARROW_LEFT) } arrowRight() { this.focus(), this.next(Sa.ARROW_RIGHT) } ngAfterContentInit() { (0, m.NF)(this._platformId) && this._ngZone.runOutsideAngular(() => { const p = (0, rt.a)([this.slide.pipe((0, Ne.U)(T => T.current), (0, tt.O)(this.activeId)), this._wrap$, this.slides.changes.pipe((0, tt.O)(null))]).pipe((0, Ne.U)(([T, P]) => { const Y = this.slides.toArray(), Re = this._getSlideIdxById(T); return P ? Y.length > 1 : Re < Y.length - 1 }), (0, Fe.x)()); (0, rt.a)([this._pause$, this._pauseOnHover$, this._mouseHover$, this._pauseOnFocus$, this._focused$, this._interval$, p]).pipe((0, Ne.U)(([T, P, Y, Re, Ke, yt, Vt]) => T || P && Y || Re && Ke || !Vt ? 0 : yt), (0, Fe.x)(), (0, Ue.w)(T => T > 0 ? (0, Ee.H)(T, T) : De), (0, Ve.R)(this._destroy$)).subscribe(() => this._ngZone.run(() => this.next(Sa.TIMER))) }), this.slides.changes.pipe((0, Ve.R)(this._destroy$)).subscribe(() => { this._transitionIds?.forEach(p => (v => { Va.get(v)?.complete() })(this._getSlideElement(p))), this._transitionIds = null, this._cd.markForCheck(), this._ngZone.onStable.pipe((0, nt.q)(1)).subscribe(() => { for (const { id: p } of this.slides) { const T = this._getSlideElement(p); p === this.activeId ? T.classList.add("active") : T.classList.remove("active") } }) }) } ngAfterContentChecked() { let p = this._getSlideById(this.activeId); this.activeId = p ? p.id : this.slides.length ? this.slides.first.id : "" } ngAfterViewInit() { if (this.activeId) { const p = this._getSlideElement(this.activeId); p && p.classList.add("active") } } ngOnDestroy() { this._destroy$.next() } select(p, T) { this._cycleToSelected(p, this._getSlideEventDirection(this.activeId, p), T) } prev(p) { this._cycleToSelected(this._getPrevSlide(this.activeId), eo.END, p) } next(p) { this._cycleToSelected(this._getNextSlide(this.activeId), eo.START, p) } pause() { this._pause$.next(!0) } cycle() { this._pause$.next(!1) } focus() { this._container.nativeElement.focus() } _cycleToSelected(p, T, P) { const Y = this._transitionIds; if (Y && (Y[0] !== p || Y[1] !== this.activeId)) return; let Re = this._getSlideById(p); if (Re && Re.id !== this.activeId) { this._transitionIds = [this.activeId, p], this.slide.emit({ prev: this.activeId, current: Re.id, direction: T, paused: this._pause$.value, source: P }); const Ke = { animation: this.animation, runningTransition: "stop", context: { direction: T } }, yt = [], Vt = this._getSlideById(this.activeId); if (Vt) { const Un = xi(this._ngZone, this._getSlideElement(Vt.id), el, Ke); Un.subscribe(() => { Vt.slid.emit({ isShown: !1, direction: T, source: P }) }), yt.push(Un) } const Wt = this.activeId; this.activeId = Re.id; const vn = this._getSlideById(this.activeId), In = xi(this._ngZone, this._getSlideElement(Re.id), Ac, Ke); In.subscribe(() => { vn?.slid.emit({ isShown: !0, direction: T, source: P }) }), yt.push(In), (0, _t.$)(...yt).pipe((0, nt.q)(1)).subscribe(() => { this._transitionIds = null, this.slid.emit({ prev: Wt, current: Re.id, direction: T, paused: this._pause$.value, source: P }) }) } this._cd.markForCheck() } _getSlideEventDirection(p, T) { return this._getSlideIdxById(p) > this._getSlideIdxById(T) ? eo.END : eo.START } _getSlideById(p) { return this.slides.find(T => T.id === p) || null } _getSlideIdxById(p) { const T = this._getSlideById(p); return null != T ? this.slides.toArray().indexOf(T) : -1 } _getNextSlide(p) { const T = this.slides.toArray(), P = this._getSlideIdxById(p); return P === T.length - 1 ? this.wrap ? T[0].id : T[T.length - 1].id : T[P + 1].id } _getPrevSlide(p) { const T = this.slides.toArray(), P = this._getSlideIdxById(p); return 0 === P ? this.wrap ? T[T.length - 1].id : T[0].id : T[P - 1].id } _getSlideElement(p) { return this._container.nativeElement.querySelector(`#slide-${p}`) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(Yo), i.Y36(i.Lbi), i.Y36(i.R0b), i.Y36(i.sBO), i.Y36(i.SBq)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-carousel"]], contentQueries: function (p, T, P) { if (1 & p && i.Suo(P, Bu, 4), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.slides = Y) } }, hostAttrs: ["tabIndex", "0", 1, "carousel", "slide"], hostVars: 3, hostBindings: function (p, T) { 1 & p && i.NdJ("keydown.arrowLeft", function () { return T.keyboard && T.arrowLeft() })("keydown.arrowRight", function () { return T.keyboard && T.arrowRight() })("mouseenter", function () { return T.mouseHover = !0 })("mouseleave", function () { return T.mouseHover = !1 })("focusin", function () { return T.focused = !0 })("focusout", function () { return T.focused = !1 }), 2 & p && (i.uIk("aria-activedescendant", "slide-" + T.activeId), i.Udp("display", "block")) }, inputs: { animation: "animation", activeId: "activeId", interval: "interval", wrap: "wrap", keyboard: "keyboard", pauseOnHover: "pauseOnHover", pauseOnFocus: "pauseOnFocus", showNavigationArrows: "showNavigationArrows", showNavigationIndicators: "showNavigationIndicators" }, outputs: { slide: "slide", slid: "slid" }, exportAs: ["ngbCarousel"], decls: 6, vars: 6, consts: function () { let A, p, T; return A = $localize`:Currently selected slide number read by screen reader@@ngb.carousel.slide-number: Slide ${"\ufffd0\ufffd"}:INTERPOLATION: of ${"\ufffd1\ufffd"}:INTERPOLATION_1: `, p = $localize`:@@ngb.carousel.previous:Previous`, T = $localize`:@@ngb.carousel.next:Next`, [["role", "tablist", 1, "carousel-indicators"], ["type", "button", "data-bs-target", "", "role", "tab", 3, "active", "click", 4, "ngFor", "ngForOf"], [1, "carousel-inner"], ["class", "carousel-item", "role", "tabpanel", 3, "id", 4, "ngFor", "ngForOf"], ["class", "carousel-control-prev", "type", "button", 3, "click", 4, "ngIf"], ["class", "carousel-control-next", "type", "button", 3, "click", 4, "ngIf"], ["type", "button", "data-bs-target", "", "role", "tab", 3, "click"], ["role", "tabpanel", 1, "carousel-item", 3, "id"], [1, "visually-hidden"], A, [3, "ngTemplateOutlet"], ["type", "button", 1, "carousel-control-prev", 3, "click"], ["aria-hidden", "true", 1, "carousel-control-prev-icon"], p, ["type", "button", 1, "carousel-control-next", 3, "click"], ["aria-hidden", "true", 1, "carousel-control-next-icon"], T] }, template: function (p, T) { 1 & p && (i.TgZ(0, "div", 0), i.YNc(1, Ys, 1, 5, "button", 1), i.qZA(), i.TgZ(2, "div", 2), i.YNc(3, so, 4, 4, "div", 3), i.qZA(), i.YNc(4, jo, 4, 0, "button", 4), i.YNc(5, na, 4, 0, "button", 5)), 2 & p && (i.ekj("visually-hidden", !T.showNavigationIndicators), i.xp6(1), i.Q6J("ngForOf", T.slides), i.xp6(2), i.Q6J("ngForOf", T.slides), i.xp6(1), i.Q6J("ngIf", T.showNavigationArrows), i.xp6(1), i.Q6J("ngIf", T.showNavigationArrows)) }, dependencies: [m.sg, m.O5, m.tP], encapsulation: 2, changeDetection: 0 }), v })(); var Sa = (() => { return (v = Sa || (Sa = {})).TIMER = "timer", v.ARROW_LEFT = "arrowLeft", v.ARROW_RIGHT = "arrowRight", v.INDICATOR = "indicator", Sa; var v })(); let xc = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(), Vu = (() => { class v { constructor(p) { this._ngbConfig = p, this.horizontal = !1 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), Ia = (() => { class v { constructor(p, T, P) { this._element = p, this._zone = P, this._afterInit = !1, this._isCollapsed = !1, this.ngbCollapseChange = new i.vpe, this.shown = new i.vpe, this.hidden = new i.vpe, this.animation = T.animation, this.horizontal = T.horizontal } set collapsed(p) { this._isCollapsed !== p && (this._isCollapsed = p, this._afterInit && this._runTransitionWithEvents(p, this.animation)) } ngOnInit() { this._runTransition(this._isCollapsed, !1), this._afterInit = !0 } toggle(p = this._isCollapsed) { this.collapsed = !p, this.ngbCollapseChange.next(this._isCollapsed) } _runTransition(p, T) { return xi(this._zone, this._element.nativeElement, Zo, { animation: T, runningTransition: "stop", context: { direction: p ? "hide" : "show", dimension: this.horizontal ? "width" : "height" } }) } _runTransitionWithEvents(p, T) { this._runTransition(p, T).subscribe(() => { p ? this.hidden.emit() : this.shown.emit() }) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq), i.Y36(Vu), i.Y36(i.R0b)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbCollapse", ""]], hostVars: 2, hostBindings: function (p, T) { 2 & p && i.ekj("collapse-horizontal", T.horizontal) }, inputs: { animation: "animation", collapsed: ["ngbCollapse", "collapsed"], horizontal: "horizontal" }, outputs: { ngbCollapseChange: "ngbCollapseChange", shown: "shown", hidden: "hidden" }, exportAs: ["ngbCollapse"] }), v })(), Vs = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({}), v })(); class ii { constructor(A, p, T) { this.year = Xt(A) ? A : null, this.month = Xt(p) ? p : null, this.day = Xt(T) ? T : null } static from(A) { return A instanceof ii ? A : A ? new ii(A.year, A.month, A.day) : null } equals(A) { return null != A && this.year === A.year && this.month === A.month && this.day === A.day } before(A) { return !!A && (this.year === A.year ? this.month === A.month ? this.day !== A.day && this.day < A.day : this.month < A.month : this.year < A.year) } after(A) { return !!A && (this.year === A.year ? this.month === A.month ? this.day !== A.day && this.day > A.day : this.month > A.month : this.year > A.year) } } function tc(v, A) { return !function vu(v, A) { return !v && !A || !!v && !!A && v.equals(A) }(v, A) } function ud(v, A) { return !(!v && !A || v && A && v.year === A.year && v.month === A.month) } function Aa(v, A, p) { return v && A && v.before(A) ? A : v && p && v.after(p) ? p : v || null } function Mi(v, A) { const { minDate: p, maxDate: T, disabled: P, markDisabled: Y } = A; return !(null == v || P || Y && Y(v, { year: v.year, month: v.month }) || p && v.before(p) || T && v.after(T)) } function Nc(v) { return new ii(v.getFullYear(), v.getMonth() + 1, v.getDate()) } function Bl(v) { const A = new Date(v.year, v.month - 1, v.day, 12); return isNaN(A.getTime()) || A.setFullYear(v.year), A } let ji = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: function () { return function Xc() { return new R }() }, providedIn: "root" }), v })(), R = (() => { class v extends ji { getDaysPerWeek() { return 7 } getMonths() { return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] } getWeeksPerMonth() { return 6 } getNext(p, T = "d", P = 1) { let Y = Bl(p), Re = !0, Ke = Y.getMonth(); switch (T) { case "y": Y.setFullYear(Y.getFullYear() + P); break; case "m": Ke += P, Y.setMonth(Ke), Ke %= 12, Ke < 0 && (Ke += 12); break; case "d": Y.setDate(Y.getDate() + P), Re = !1; break; default: return p }return Re && Y.getMonth() !== Ke && Y.setDate(0), Nc(Y) } getPrev(p, T = "d", P = 1) { return this.getNext(p, T, -P) } getWeekday(p) { let P = Bl(p).getDay(); return 0 === P ? 7 : P } getWeekNumber(p, T) { 7 === T && (T = 0); const Re = Bl(p[(11 - T) % 7]); Re.setDate(Re.getDate() + 4 - (Re.getDay() || 7)); const Ke = Re.getTime(); return Re.setMonth(0), Re.setDate(1), Math.floor(Math.round((Ke - Re.getTime()) / 864e5) / 7) + 1 } getToday() { return Nc(new Date) } isValid(p) { if (!(p && Xt(p.year) && Xt(p.month) && Xt(p.day) && 0 !== p.year)) return !1; const T = Bl(p); return !isNaN(T.getTime()) && T.getFullYear() === p.year && T.getMonth() + 1 === p.month && T.getDate() === p.day } } return v.\u0275fac = function () { let A; return function (T) { return (A || (A = i.n5z(v)))(T || v) } }(), v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac }), v })(), M = (() => { class v { getMonthLabel(p) { return `${this.getMonthFullName(p.month, p.year)} ${this.getYearNumerals(p.year)}` } getDayNumerals(p) { return `${p.day}` } getWeekNumerals(p) { return `${p}` } getYearNumerals(p) { return `${p}` } getWeekLabel() { return "" } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: function (p) { let T = null; return T = p ? new p : function V(v) { return new G(v) }(i.LFG(i.soG)), T }, providedIn: "root" }), v })(), G = (() => { class v extends M { constructor(p) { super(), this._locale = p, this._monthsShort = (0, m.UT)(p, m.x.Standalone, m.Tn.Abbreviated), this._monthsFull = (0, m.UT)(p, m.x.Standalone, m.Tn.Wide) } getWeekdayLabel(p, T) { const P = (0, m.Mn)(this._locale, m.x.Standalone, void 0 === T ? m.Tn.Short : T); return P.map((Re, Ke) => P[(Ke + 1) % 7])[p - 1] || "" } getMonthShortName(p) { return this._monthsShort[p - 1] || "" } getMonthFullName(p) { return this._monthsFull[p - 1] || "" } getDayAriaLabel(p) { const T = new Date(p.year, p.month - 1, p.day); return (0, m.p6)(T, "fullDate", this._locale) } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(i.soG)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac }), v })(), X = (() => { class v { constructor(p, T) { this._calendar = p, this._i18n = T, this._VALIDATORS = { dayTemplateData: P => { if (this._state.dayTemplateData !== P) return { dayTemplateData: P } }, displayMonths: P => { if (Xt(P = re(P)) && P > 0 && this._state.displayMonths !== P) return { displayMonths: P } }, disabled: P => { if (this._state.disabled !== P) return { disabled: P } }, firstDayOfWeek: P => { if (Xt(P = re(P)) && P >= 0 && this._state.firstDayOfWeek !== P) return { firstDayOfWeek: P } }, focusVisible: P => { if (this._state.focusVisible !== P && !this._state.disabled) return { focusVisible: P } }, markDisabled: P => { if (this._state.markDisabled !== P) return { markDisabled: P } }, maxDate: P => { const Y = this.toValidDate(P, null); if (tc(this._state.maxDate, Y)) return { maxDate: Y } }, minDate: P => { const Y = this.toValidDate(P, null); if (tc(this._state.minDate, Y)) return { minDate: Y } }, navigation: P => { if (this._state.navigation !== P) return { navigation: P } }, outsideDays: P => { if (this._state.outsideDays !== P) return { outsideDays: P } }, weekdays: P => { const Y = !0 === P || !1 === P ? m.Tn.Short : P, Re = !0 !== P && !1 !== P || P; if (this._state.weekdayWidth !== Y || this._state.weekdaysVisible !== Re) return { weekdayWidth: Y, weekdaysVisible: Re } } }, this._model$ = new we.x, this._dateSelect$ = new we.x, this._state = { dayTemplateData: null, markDisabled: null, maxDate: null, minDate: null, disabled: !1, displayMonths: 1, firstDate: null, firstDayOfWeek: 1, lastDate: null, focusDate: null, focusVisible: !1, months: [], navigation: "select", outsideDays: "visible", prevDisabled: !1, nextDisabled: !1, selectedDate: null, selectBoxes: { years: [], months: [] }, weekdayWidth: m.Tn.Short, weekdaysVisible: !0 } } get model$() { return this._model$.pipe((0, Be.h)(p => p.months.length > 0)) } get dateSelect$() { return this._dateSelect$.pipe((0, Be.h)(p => null !== p)) } set(p) { let T = Object.keys(p).map(P => this._VALIDATORS[P](p[P])).reduce((P, Y) => ({ ...P, ...Y }), {}); Object.keys(T).length > 0 && this._nextState(T) } focus(p) { const T = this.toValidDate(p, null); null != T && !this._state.disabled && tc(this._state.focusDate, T) && this._nextState({ focusDate: p }) } focusSelect() { Mi(this._state.focusDate, this._state) && this.select(this._state.focusDate, { emitEvent: !0 }) } open(p) { const T = this.toValidDate(p, this._calendar.getToday()); null != T && !this._state.disabled && (!this._state.firstDate || ud(this._state.firstDate, T)) && this._nextState({ firstDate: T }) } select(p, T = {}) { const P = this.toValidDate(p, null); null != P && !this._state.disabled && (tc(this._state.selectedDate, P) && this._nextState({ selectedDate: P }), T.emitEvent && Mi(P, this._state) && this._dateSelect$.next(P)) } toValidDate(p, T) { const P = ii.from(p); return void 0 === T && (T = this._calendar.getToday()), this._calendar.isValid(P) ? P : T } getMonth(p) { for (let T of this._state.months) if (p.month === T.number && p.year === T.year) return T; throw new Error(`month ${p.month} of year ${p.year} not found`) } _nextState(p) { const T = this._updateState(p); this._patchContexts(T), this._state = T, this._model$.next(this._state) } _patchContexts(p) { const { months: T, displayMonths: P, selectedDate: Y, focusDate: Re, focusVisible: Ke, disabled: yt, outsideDays: Vt } = p; p.months.forEach(Wt => { Wt.weeks.forEach(vn => { vn.days.forEach(In => { Re && (In.context.focused = Re.equals(In.date) && Ke), In.tabindex = !yt && Re && In.date.equals(Re) && Re.month === Wt.number ? 0 : -1, !0 === yt && (In.context.disabled = !0), void 0 !== Y && (In.context.selected = null !== Y && Y.equals(In.date)), Wt.number !== In.date.month && (In.hidden = "hidden" === Vt || "collapsed" === Vt || P > 1 && In.date.after(T[0].firstDate) && In.date.before(T[P - 1].lastDate)) }) }) }) } _updateState(p) { const T = Object.assign({}, this._state, p); let P = T.firstDate; if (("minDate" in p || "maxDate" in p) && (function ci(v, A) { if (A && v && A.before(v)) throw new Error(`'maxDate' ${A} should be greater than 'minDate' ${v}`) }(T.minDate, T.maxDate), T.focusDate = Aa(T.focusDate, T.minDate, T.maxDate), T.firstDate = Aa(T.firstDate, T.minDate, T.maxDate), P = T.focusDate), "disabled" in p && (T.focusVisible = !1), "selectedDate" in p && 0 === this._state.months.length && (P = T.selectedDate), "focusVisible" in p || "focusDate" in p && (T.focusDate = Aa(T.focusDate, T.minDate, T.maxDate), P = T.focusDate, 0 !== T.months.length && T.focusDate && !T.focusDate.before(T.firstDate) && !T.focusDate.after(T.lastDate))) return T; if ("firstDate" in p && (T.firstDate = Aa(T.firstDate, T.minDate, T.maxDate), P = T.firstDate), P) { const Re = function Pe(v, A, p, T, P) { const { displayMonths: Y, months: Re } = p, Ke = Re.splice(0, Re.length); return Array.from({ length: Y }, (Vt, Wt) => { const vn = Object.assign(v.getNext(A, "m", Wt), { day: 1 }); if (Re[Wt] = null, !P) { const In = Ke.findIndex(Un => Un.firstDate.equals(vn)); -1 !== In && (Re[Wt] = Ke.splice(In, 1)[0]) } return vn }).forEach((Vt, Wt) => { null === Re[Wt] && (Re[Wt] = function Jo(v, A, p, T, P = {}) { const { dayTemplateData: Y, minDate: Re, maxDate: Ke, firstDayOfWeek: yt, markDisabled: Vt, outsideDays: Wt, weekdayWidth: vn, weekdaysVisible: In } = p, Un = v.getToday(); P.firstDate = null, P.lastDate = null, P.number = A.month, P.year = A.year, P.weeks = P.weeks || [], P.weekdays = P.weekdays || [], A = function ml(v, A, p) { const T = v.getDaysPerWeek(), P = new ii(A.year, A.month, 1), Y = v.getWeekday(P) % T; return v.getPrev(P, "d", (T + Y - p) % T) }(v, A, yt), In || (P.weekdays.length = 0); for (let bi = 0; bi < v.getWeeksPerMonth(); bi++) { let Cr = P.weeks[bi]; Cr || (Cr = P.weeks[bi] = { number: 0, days: [], collapsed: !0 }); const qr = Cr.days; for (let oi = 0; oi < v.getDaysPerWeek(); oi++) { 0 === bi && In && (P.weekdays[oi] = T.getWeekdayLabel(v.getWeekday(A), vn)); const ki = new ii(A.year, A.month, A.day), qi = v.getNext(ki), Ri = T.getDayAriaLabel(ki); let di = !!(Re && ki.before(Re) || Ke && ki.after(Ke)); !di && Vt && (di = Vt(ki, { month: P.number, year: P.year })); let zi = ki.equals(Un), gs = Y ? Y(ki, { month: P.number, year: P.year }) : void 0; null === P.firstDate && ki.month === P.number && (P.firstDate = ki), ki.month === P.number && qi.month !== P.number && (P.lastDate = ki); let Yi = qr[oi]; Yi || (Yi = qr[oi] = {}), Yi.date = ki, Yi.context = Object.assign(Yi.context || {}, { $implicit: ki, date: ki, data: gs, currentMonth: P.number, currentYear: P.year, disabled: di, focused: !1, selected: !1, today: zi }), Yi.tabindex = -1, Yi.ariaLabel = Ri, Yi.hidden = !1, A = qi } Cr.number = v.getWeekNumber(qr.map(oi => oi.date), yt), Cr.collapsed = "collapsed" === Wt && qr[0].date.month !== P.number && qr[qr.length - 1].date.month !== P.number } return P }(v, Vt, p, T, Ke.shift() || {})) }), Re }(this._calendar, P, T, this._i18n, "dayTemplateData" in p || "firstDayOfWeek" in p || "markDisabled" in p || "minDate" in p || "maxDate" in p || "disabled" in p || "outsideDays" in p || "weekdaysVisible" in p); T.months = Re, T.firstDate = Re[0].firstDate, T.lastDate = Re[Re.length - 1].lastDate, "selectedDate" in p && !Mi(T.selectedDate, T) && (T.selectedDate = null), "firstDate" in p && (!T.focusDate || T.focusDate.before(T.firstDate) || T.focusDate.after(T.lastDate)) && (T.focusDate = P); const Ke = !this._state.firstDate || this._state.firstDate.year !== T.firstDate.year, yt = !this._state.firstDate || this._state.firstDate.month !== T.firstDate.month; "select" === T.navigation ? (("minDate" in p || "maxDate" in p || 0 === T.selectBoxes.years.length || Ke) && (T.selectBoxes.years = function Oc(v, A, p) { if (!v) return []; const T = A ? Math.max(A.year, v.year - 500) : v.year - 10, Y = (p ? Math.min(p.year, v.year + 500) : v.year + 10) - T + 1, Re = Array(Y); for (let Ke = 0; Ke < Y; Ke++)Re[Ke] = T + Ke; return Re }(T.firstDate, T.minDate, T.maxDate)), ("minDate" in p || "maxDate" in p || 0 === T.selectBoxes.months.length || Ke) && (T.selectBoxes.months = function Mc(v, A, p, T) { if (!A) return []; let P = v.getMonths(A.year); if (p && A.year === p.year) { const Y = P.findIndex(Re => Re === p.month); P = P.slice(Y) } if (T && A.year === T.year) { const Y = P.findIndex(Re => Re === T.month); P = P.slice(0, Y + 1) } return P }(this._calendar, T.firstDate, T.minDate, T.maxDate))) : T.selectBoxes = { years: [], months: [] }, ("arrows" === T.navigation || "select" === T.navigation) && (yt || Ke || "minDate" in p || "maxDate" in p || "disabled" in p) && (T.prevDisabled = T.disabled || function tl(v, A, p) { const T = Object.assign(v.getPrev(A, "m"), { day: 1 }); return null != p && (T.year === p.year && T.month < p.month || T.year < p.year && 1 === p.month) }(this._calendar, T.firstDate, T.minDate), T.nextDisabled = T.disabled || function cn(v, A, p) { const T = Object.assign(v.getNext(A, "m"), { day: 1 }); return null != p && T.after(p) }(this._calendar, T.lastDate, T.maxDate)) } return T } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(ji), i.LFG(M)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac }), v })(); var ce = (() => { return (v = ce || (ce = {}))[v.PREV = 0] = "PREV", v[v.NEXT = 1] = "NEXT", ce; var v })(); let be = (() => { class v { constructor() { this.displayMonths = 1, this.firstDayOfWeek = 1, this.navigation = "select", this.outsideDays = "visible", this.showWeekNumbers = !1, this.weekdays = m.Tn.Short } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), on = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: function () { return function St() { return new Kn }() }, providedIn: "root" }), v })(), Kn = (() => { class v extends on { fromModel(p) { return p && Xt(p.year) && Xt(p.month) && Xt(p.day) ? { year: p.year, month: p.month, day: p.day } : null } toModel(p) { return p && Xt(p.year) && Xt(p.month) && Xt(p.day) ? { year: p.year, month: p.month, day: p.day } : null } } return v.\u0275fac = function () { let A; return function (T) { return (A || (A = i.n5z(v)))(T || v) } }(), v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac }), v })(), Vn = (() => { class v { constructor(p, T) { this.i18n = p, this._renderer = T, this.select = new i.vpe, this._month = -1, this._year = -1 } changeMonth(p) { this.select.emit(new ii(this.date.year, re(p), 1)) } changeYear(p) { this.select.emit(new ii(re(p), this.date.month, 1)) } ngAfterViewChecked() { this.date && (this.date.month !== this._month && (this._month = this.date.month, this._renderer.setProperty(this.monthSelect.nativeElement, "value", this._month)), this.date.year !== this._year && (this._year = this.date.year, this._renderer.setProperty(this.yearSelect.nativeElement, "value", this._year))) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(M), i.Y36(i.Qsj)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-datepicker-navigation-select"]], viewQuery: function (p, T) { if (1 & p && (i.Gf(Zl, 7, i.SBq), i.Gf(pi, 7, i.SBq)), 2 & p) { let P; i.iGM(P = i.CRH()) && (T.monthSelect = P.first), i.iGM(P = i.CRH()) && (T.yearSelect = P.first) } }, inputs: { date: "date", disabled: "disabled", months: "months", years: "years" }, outputs: { select: "select" }, decls: 6, vars: 4, consts: function () { let A, p, T, P; return A = $localize`:@@ngb.datepicker.select-month:Select month`, p = $localize`:@@ngb.datepicker.select-month:Select month`, T = $localize`:@@ngb.datepicker.select-year:Select year`, P = $localize`:@@ngb.datepicker.select-year:Select year`, [["aria-label", A, "title", p, 1, "form-select", 3, "disabled", "change"], ["month", ""], [3, "value", 4, "ngFor", "ngForOf"], ["aria-label", T, "title", P, 1, "form-select", 3, "disabled", "change"], ["year", ""], [3, "value"]] }, template: function (p, T) { 1 & p && (i.TgZ(0, "select", 0, 1), i.NdJ("change", function (Y) { return T.changeMonth(Y.target.value) }), i.YNc(2, Ss, 2, 3, "option", 2), i.qZA(), i.TgZ(3, "select", 3, 4), i.NdJ("change", function (Y) { return T.changeYear(Y.target.value) }), i.YNc(5, $o, 2, 2, "option", 2), i.qZA()), 2 & p && (i.Q6J("disabled", T.disabled), i.xp6(2), i.Q6J("ngForOf", T.months), i.xp6(1), i.Q6J("disabled", T.disabled), i.xp6(2), i.Q6J("ngForOf", T.years)) }, dependencies: [m.sg, kn.YN, kn.Kr], styles: ["ngb-datepicker-navigation-select>.form-select{flex:1 1 auto;padding:0 .5rem;font-size:.875rem;height:1.85rem}ngb-datepicker-navigation-select>.form-select:focus{z-index:1}ngb-datepicker-navigation-select>.form-select::-ms-value{background-color:transparent!important}\n"], encapsulation: 2, changeDetection: 0 }), v })(), Lr = (() => { class v { constructor(p) { this.i18n = p, this.navigation = ce, this.months = [], this.navigate = new i.vpe, this.select = new i.vpe } onClickPrev(p) { p.currentTarget.focus(), this.navigate.emit(this.navigation.PREV) } onClickNext(p) { p.currentTarget.focus(), this.navigate.emit(this.navigation.NEXT) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(M)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-datepicker-navigation"]], inputs: { date: "date", disabled: "disabled", months: "months", showSelect: "showSelect", prevDisabled: "prevDisabled", nextDisabled: "nextDisabled", selectBoxes: "selectBoxes" }, outputs: { navigate: "navigate", select: "select" }, decls: 8, vars: 4, consts: function () { let A, p, T, P; return A = $localize`:@@ngb.datepicker.previous-month:Previous month`, p = $localize`:@@ngb.datepicker.previous-month:Previous month`, T = $localize`:@@ngb.datepicker.next-month:Next month`, P = $localize`:@@ngb.datepicker.next-month:Next month`, [[1, "ngb-dp-arrow"], ["type", "button", "aria-label", A, "title", p, 1, "btn", "btn-link", "ngb-dp-arrow-btn", 3, "disabled", "click"], [1, "ngb-dp-navigation-chevron"], ["class", "ngb-dp-navigation-select", 3, "date", "disabled", "months", "years", "select", 4, "ngIf"], [4, "ngIf"], [1, "ngb-dp-arrow", "right"], ["type", "button", "aria-label", T, "title", P, 1, "btn", "btn-link", "ngb-dp-arrow-btn", 3, "disabled", "click"], [1, "ngb-dp-navigation-select", 3, "date", "disabled", "months", "years", "select"], ["ngFor", "", 3, "ngForOf"], ["class", "ngb-dp-arrow", 4, "ngIf"], [1, "ngb-dp-month-name"]] }, template: function (p, T) { 1 & p && (i.TgZ(0, "div", 0)(1, "button", 1), i.NdJ("click", function (Y) { return T.onClickPrev(Y) }), i._UZ(2, "span", 2), i.qZA()(), i.YNc(3, wo, 1, 4, "ngb-datepicker-navigation-select", 3), i.YNc(4, Is, 1, 1, null, 4), i.TgZ(5, "div", 5)(6, "button", 6), i.NdJ("click", function (Y) { return T.onClickNext(Y) }), i._UZ(7, "span", 2), i.qZA()()), 2 & p && (i.xp6(1), i.Q6J("disabled", T.prevDisabled), i.xp6(2), i.Q6J("ngIf", T.showSelect), i.xp6(1), i.Q6J("ngIf", !T.showSelect), i.xp6(2), i.Q6J("disabled", T.nextDisabled)) }, dependencies: [m.sg, m.O5, Vn], styles: ["ngb-datepicker-navigation{display:flex;align-items:center}.ngb-dp-navigation-chevron{border-style:solid;border-width:.2em .2em 0 0;display:inline-block;width:.75em;height:.75em;margin-left:.25em;margin-right:.15em;transform:rotate(-135deg)}.ngb-dp-arrow{display:flex;flex:1 1 auto;padding-right:0;padding-left:0;margin:0;width:2rem;height:2rem}.ngb-dp-arrow.right{justify-content:flex-end}.ngb-dp-arrow.right .ngb-dp-navigation-chevron{transform:rotate(45deg);margin-left:.15em;margin-right:.25em}.ngb-dp-arrow-btn{padding:0 .25rem;margin:0 .5rem;border:none;background-color:transparent;z-index:1}.ngb-dp-arrow-btn:focus{outline-width:1px;outline-style:auto}@media all and (-ms-high-contrast: none),(-ms-high-contrast: active){.ngb-dp-arrow-btn:focus{outline-style:solid}}.ngb-dp-month-name{font-size:larger;height:2rem;line-height:2rem;text-align:center}.ngb-dp-navigation-select{display:flex;flex:1 1 9rem}\n"], encapsulation: 2, changeDetection: 0 }), v })(), Gr = (() => { class v { constructor(p) { this.i18n = p } isMuted() { return !this.selected && (this.date.month !== this.currentMonth || this.disabled) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(M)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["", "ngbDatepickerDayView", ""]], hostAttrs: [1, "btn-light"], hostVars: 10, hostBindings: function (p, T) { 2 & p && i.ekj("bg-primary", T.selected)("text-white", T.selected)("text-muted", T.isMuted())("outside", T.isMuted())("active", T.focused) }, inputs: { currentMonth: "currentMonth", date: "date", disabled: "disabled", focused: "focused", selected: "selected" }, attrs: Wo, decls: 1, vars: 1, template: function (p, T) { 1 & p && i._uU(0), 2 & p && i.Oqu(T.i18n.getDayNumerals(T.date)) }, styles: ["[ngbDatepickerDayView]{text-align:center;width:2rem;height:2rem;line-height:2rem;border-radius:.25rem;background:transparent}[ngbDatepickerDayView]:hover:not(.bg-primary),[ngbDatepickerDayView].active:not(.bg-primary){background-color:var(--bs-btn-bg);outline:1px solid var(--bs-border-color)}[ngbDatepickerDayView].outside{opacity:.5}\n"], encapsulation: 2, changeDetection: 0 }), v })(); var Sr = (() => { return (v = Sr || (Sr = {}))[v.Tab = 9] = "Tab", v[v.Enter = 13] = "Enter", v[v.Escape = 27] = "Escape", v[v.Space = 32] = "Space", v[v.PageUp = 33] = "PageUp", v[v.PageDown = 34] = "PageDown", v[v.End = 35] = "End", v[v.Home = 36] = "Home", v[v.ArrowLeft = 37] = "ArrowLeft", v[v.ArrowUp = 38] = "ArrowUp", v[v.ArrowRight = 39] = "ArrowRight", v[v.ArrowDown = 40] = "ArrowDown", Sr; var v })(); let $i = (() => { class v { processKey(p, T) { const { state: P, calendar: Y } = T; switch (p.which) { case Sr.PageUp: T.focusDate(Y.getPrev(P.focusedDate, p.shiftKey ? "y" : "m", 1)); break; case Sr.PageDown: T.focusDate(Y.getNext(P.focusedDate, p.shiftKey ? "y" : "m", 1)); break; case Sr.End: T.focusDate(p.shiftKey ? P.maxDate : P.lastDate); break; case Sr.Home: T.focusDate(p.shiftKey ? P.minDate : P.firstDate); break; case Sr.ArrowLeft: T.focusDate(Y.getPrev(P.focusedDate, "d", 1)); break; case Sr.ArrowUp: T.focusDate(Y.getPrev(P.focusedDate, "d", Y.getDaysPerWeek())); break; case Sr.ArrowRight: T.focusDate(Y.getNext(P.focusedDate, "d", 1)); break; case Sr.ArrowDown: T.focusDate(Y.getNext(P.focusedDate, "d", Y.getDaysPerWeek())); break; case Sr.Enter: case Sr.Space: T.focusSelect(); break; default: return }p.preventDefault(), p.stopPropagation() } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), Wi = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbDatepickerContent", ""]] }), v })(), sa = (() => { class v { constructor(p, T, P, Y, Re, Ke, yt, Vt) { this._service = p, this._calendar = T, this.i18n = P, this._elementRef = Ke, this._ngbDateAdapter = yt, this._ngZone = Vt, this._controlValue = null, this._destroyed$ = new we.x, this._publicState = {}, this.navigate = new i.vpe, this.dateSelect = new i.vpe, this.onChange = Wt => { }, this.onTouched = () => { }, ["dayTemplate", "dayTemplateData", "displayMonths", "firstDayOfWeek", "footerTemplate", "markDisabled", "minDate", "maxDate", "navigation", "outsideDays", "showWeekNumbers", "startDate", "weekdays"].forEach(Wt => this[Wt] = Y[Wt]), p.dateSelect$.pipe((0, Ve.R)(this._destroyed$)).subscribe(Wt => { this.dateSelect.emit(Wt) }), p.model$.pipe((0, Ve.R)(this._destroyed$)).subscribe(Wt => { const vn = Wt.firstDate, In = this.model ? this.model.firstDate : null; this._publicState = { maxDate: Wt.maxDate, minDate: Wt.minDate, firstDate: Wt.firstDate, lastDate: Wt.lastDate, focusedDate: Wt.focusDate, months: Wt.months.map(oi => oi.firstDate) }; let Un = !1; if (!vn.equals(In) && (this.navigate.emit({ current: In ? { year: In.year, month: In.month } : null, next: { year: vn.year, month: vn.month }, preventDefault: () => Un = !0 }), Un && null !== In)) return void this._service.open(In); const bi = Wt.selectedDate, Cr = Wt.focusDate, qr = this.model ? this.model.focusDate : null; this.model = Wt, tc(bi, this._controlValue) && (this._controlValue = bi, this.onTouched(), this.onChange(this._ngbDateAdapter.toModel(bi))), tc(Cr, qr) && qr && Wt.focusVisible && this.focus(), Re.markForCheck() }) } get state() { return this._publicState } get calendar() { return this._calendar } focusDate(p) { this._service.focus(ii.from(p)) } focusSelect() { this._service.focusSelect() } focus() { this._ngZone.onStable.asObservable().pipe((0, nt.q)(1)).subscribe(() => { const p = this._elementRef.nativeElement.querySelector('div.ngb-dp-day[tabindex="0"]'); p && p.focus() }) } navigateTo(p) { this._service.open(ii.from(p ? p.day ? p : { ...p, day: 1 } : null)) } ngAfterViewInit() { this._ngZone.runOutsideAngular(() => { const p = (0, Te.R)(this._contentEl.nativeElement, "focusin"), T = (0, Te.R)(this._contentEl.nativeElement, "focusout"), { nativeElement: P } = this._elementRef; (0, Qe.T)(p, T).pipe((0, Be.h)(({ target: Y, relatedTarget: Re }) => !(Or(Y, "ngb-dp-day") && Or(Re, "ngb-dp-day") && P.contains(Y) && P.contains(Re))), (0, Ve.R)(this._destroyed$)).subscribe(({ type: Y }) => this._ngZone.run(() => this._service.set({ focusVisible: "focusin" === Y }))) }) } ngOnDestroy() { this._destroyed$.next() } ngOnInit() { if (void 0 === this.model) { const p = {};["dayTemplateData", "displayMonths", "markDisabled", "firstDayOfWeek", "navigation", "minDate", "maxDate", "outsideDays", "weekdays"].forEach(T => p[T] = this[T]), this._service.set(p), this.navigateTo(this.startDate) } this.dayTemplate || (this.dayTemplate = this._defaultDayTemplate) } ngOnChanges(p) { const T = {}; if (["dayTemplateData", "displayMonths", "markDisabled", "firstDayOfWeek", "navigation", "minDate", "maxDate", "outsideDays", "weekdays"].filter(P => P in p).forEach(P => T[P] = this[P]), this._service.set(T), "startDate" in p) { const { currentValue: P, previousValue: Y } = p.startDate; ud(Y, P) && this.navigateTo(this.startDate) } } onDateSelect(p) { this._service.focus(p), this._service.select(p, { emitEvent: !0 }) } onNavigateDateSelect(p) { this._service.open(p) } onNavigateEvent(p) { switch (p) { case ce.PREV: this._service.open(this._calendar.getPrev(this.model.firstDate, "m", 1)); break; case ce.NEXT: this._service.open(this._calendar.getNext(this.model.firstDate, "m", 1)) } } registerOnChange(p) { this.onChange = p } registerOnTouched(p) { this.onTouched = p } setDisabledState(p) { this._service.set({ disabled: p }) } writeValue(p) { this._controlValue = ii.from(this._ngbDateAdapter.fromModel(p)), this._service.select(this._controlValue) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(X), i.Y36(ji), i.Y36(M), i.Y36(be), i.Y36(i.sBO), i.Y36(i.SBq), i.Y36(on), i.Y36(i.R0b)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-datepicker"]], contentQueries: function (p, T, P) { if (1 & p && i.Suo(P, Wi, 7), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.contentTemplate = Y.first) } }, viewQuery: function (p, T) { if (1 & p && (i.Gf(Za, 7), i.Gf(fo, 7)), 2 & p) { let P; i.iGM(P = i.CRH()) && (T._defaultDayTemplate = P.first), i.iGM(P = i.CRH()) && (T._contentEl = P.first) } }, hostVars: 2, hostBindings: function (p, T) { 2 & p && i.ekj("disabled", T.model.disabled) }, inputs: { dayTemplate: "dayTemplate", dayTemplateData: "dayTemplateData", displayMonths: "displayMonths", firstDayOfWeek: "firstDayOfWeek", footerTemplate: "footerTemplate", markDisabled: "markDisabled", maxDate: "maxDate", minDate: "minDate", navigation: "navigation", outsideDays: "outsideDays", showWeekNumbers: "showWeekNumbers", startDate: "startDate", weekdays: "weekdays" }, outputs: { navigate: "navigate", dateSelect: "dateSelect" }, exportAs: ["ngbDatepicker"], features: [i._Bn([{ provide: kn.JU, useExisting: (0, i.Gpc)(() => v), multi: !0 }, X]), i.TTD], decls: 10, vars: 5, consts: [["defaultDayTemplate", ""], ["defaultContentTemplate", ""], [1, "ngb-dp-header"], [3, "date", "months", "disabled", "showSelect", "prevDisabled", "nextDisabled", "selectBoxes", "navigate", "select", 4, "ngIf"], [1, "ngb-dp-content"], ["content", ""], [3, "ngTemplateOutlet"], ["ngbDatepickerDayView", "", 3, "date", "currentMonth", "selected", "disabled", "focused"], ["class", "ngb-dp-month", 4, "ngFor", "ngForOf"], [1, "ngb-dp-month"], ["class", "ngb-dp-month-name", 4, "ngIf"], [3, "month"], [1, "ngb-dp-month-name"], [3, "date", "months", "disabled", "showSelect", "prevDisabled", "nextDisabled", "selectBoxes", "navigate", "select"]], template: function (p, T) { if (1 & p && (i.YNc(0, As, 1, 5, "ng-template", null, 0, i.W1O), i.YNc(2, Ls, 1, 1, "ng-template", null, 1, i.W1O), i.TgZ(4, "div", 2), i.YNc(5, xo, 1, 7, "ngb-datepicker-navigation", 3), i.qZA(), i.TgZ(6, "div", 4, 5), i.YNc(8, Ii, 0, 0, "ng-template", 6), i.qZA(), i.YNc(9, Ui, 0, 0, "ng-template", 6)), 2 & p) { const P = i.MAs(3); i.xp6(5), i.Q6J("ngIf", "none" !== T.navigation), i.xp6(1), i.ekj("ngb-dp-months", !T.contentTemplate), i.xp6(2), i.Q6J("ngTemplateOutlet", (null == T.contentTemplate ? null : T.contentTemplate.templateRef) || P), i.xp6(1), i.Q6J("ngTemplateOutlet", T.footerTemplate) } }, dependencies: function () { return [m.sg, m.O5, m.tP, bu, Lr, Gr] }, styles: ["ngb-datepicker{border:1px solid var(--bs-border-color);border-radius:.25rem;display:inline-block}ngb-datepicker-month{pointer-events:auto}ngb-datepicker.dropdown-menu{padding:0}ngb-datepicker.disabled .ngb-dp-weekday,ngb-datepicker.disabled .ngb-dp-week-number,ngb-datepicker.disabled .ngb-dp-month-name{color:var(--bs-text-muted)}.ngb-dp-body{z-index:1055}.ngb-dp-header{border-bottom:0;border-radius:.25rem .25rem 0 0;padding-top:.25rem;background-color:var(--bs-light)}.ngb-dp-months{display:flex}.ngb-dp-month{pointer-events:none}.ngb-dp-month-name{font-size:larger;height:2rem;line-height:2rem;text-align:center;background-color:var(--bs-light)}.ngb-dp-month+.ngb-dp-month .ngb-dp-month-name,.ngb-dp-month+.ngb-dp-month .ngb-dp-week{padding-left:1rem}.ngb-dp-month:last-child .ngb-dp-week{padding-right:.25rem}.ngb-dp-month:first-child .ngb-dp-week{padding-left:.25rem}.ngb-dp-month .ngb-dp-week:last-child{padding-bottom:.25rem}\n"], encapsulation: 2, changeDetection: 0 }), v })(), bu = (() => { class v { constructor(p, T, P, Y) { this.i18n = p, this.datepicker = T, this._keyboardService = P, this._service = Y } set month(p) { this.viewModel = this._service.getMonth(p) } onKeyDown(p) { this._keyboardService.processKey(p, this.datepicker) } doSelect(p) { !p.context.disabled && !p.hidden && this.datepicker.onDateSelect(p.date) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(M), i.Y36(sa), i.Y36($i), i.Y36(X)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-datepicker-month"]], hostAttrs: ["role", "grid"], hostBindings: function (p, T) { 1 & p && i.NdJ("keydown", function (Y) { return T.onKeyDown(Y) }) }, inputs: { month: "month" }, decls: 2, vars: 2, consts: [["class", "ngb-dp-week ngb-dp-weekdays", "role", "row", 4, "ngIf"], ["ngFor", "", 3, "ngForOf"], ["role", "row", 1, "ngb-dp-week", "ngb-dp-weekdays"], ["class", "ngb-dp-weekday ngb-dp-showweek small", 4, "ngIf"], ["class", "ngb-dp-weekday small", "role", "columnheader", 4, "ngFor", "ngForOf"], [1, "ngb-dp-weekday", "ngb-dp-showweek", "small"], ["role", "columnheader", 1, "ngb-dp-weekday", "small"], ["class", "ngb-dp-week", "role", "row", 4, "ngIf"], ["role", "row", 1, "ngb-dp-week"], ["class", "ngb-dp-week-number small text-muted", 4, "ngIf"], ["class", "ngb-dp-day", "role", "gridcell", 3, "disabled", "tabindex", "hidden", "ngb-dp-today", "click", 4, "ngFor", "ngForOf"], [1, "ngb-dp-week-number", "small", "text-muted"], ["role", "gridcell", 1, "ngb-dp-day", 3, "tabindex", "click"], [3, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function (p, T) { 1 & p && (i.YNc(0, Mo, 3, 2, "div", 0), i.YNc(1, Zr, 1, 1, "ng-template", 1)), 2 & p && (i.Q6J("ngIf", T.viewModel.weekdays.length > 0), i.xp6(1), i.Q6J("ngForOf", T.viewModel.weeks)) }, dependencies: [m.sg, m.O5, m.tP], styles: ['ngb-datepicker-month{display:block}.ngb-dp-weekday,.ngb-dp-week-number{line-height:2rem;text-align:center;font-style:italic}.ngb-dp-weekday{color:var(--bs-info)}.ngb-dp-week{border-radius:.25rem;display:flex}.ngb-dp-weekdays{border-bottom:1px solid var(--bs-border-color);border-radius:0;background-color:var(--bs-light)}.ngb-dp-day,.ngb-dp-weekday,.ngb-dp-week-number{width:2rem;height:2rem}.ngb-dp-day{cursor:pointer}.ngb-dp-day.disabled,.ngb-dp-day.hidden{cursor:default;pointer-events:none}.ngb-dp-day[tabindex="0"]{z-index:1}\n'], encapsulation: 2 }), v })(); const lo = (v, A) => !!A && A.some(p => p.contains(v)), oa = (v, A) => !A || null != function fs(v, A) { return !A || typeof v.closest > "u" ? null : v.closest(A) }(v, A), Ns = typeof navigator < "u" && !!navigator.userAgent && (/iPad|iPhone|iPod/.test(navigator.userAgent) || /Macintosh/.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2 || /Android/.test(navigator.userAgent)); function Qo(v, A, p, T, P, Y, Re, Ke) { p && v.runOutsideAngular((v => Ns ? () => setTimeout(() => v(), 100) : v)(() => { const Vt = (0, Te.R)(A, "keydown").pipe((0, Ve.R)(P), (0, Be.h)(In => In.which === Sr.Escape), (0, st.b)(In => In.preventDefault())), Wt = (0, Te.R)(A, "mousedown").pipe((0, Ne.U)(In => { const Un = In.target; return 2 !== In.button && !lo(Un, Re) && ("inside" === p ? lo(Un, Y) && oa(Un, Ke) : "outside" === p ? !lo(Un, Y) : oa(Un, Ke) || !lo(Un, Y)) }), (0, Ve.R)(P)), vn = (0, Te.R)(A, "mouseup").pipe((0, ht.M)(Wt), (0, Be.h)(([In, Un]) => Un), (0, Kt.g)(0), (0, Ve.R)(P)); xe([Vt.pipe((0, Ne.U)(In => 0)), vn.pipe((0, Ne.U)(In => 1))]).subscribe(In => v.run(() => T(In))) })) } const aa = ["a[href]", "button:not([disabled])", 'input:not([disabled]):not([type="hidden"])', "select:not([disabled])", "textarea:not([disabled])", "[contenteditable]", '[tabindex]:not([tabindex="-1"])'].join(", "); function la(v) { const A = Array.from(v.querySelectorAll(aa)).filter(p => -1 !== p.tabIndex); return [A[0], A[A.length - 1]] } const ps = (v, A, p, T = !1) => { v.runOutsideAngular(() => { const P = (0, Te.R)(A, "focusin").pipe((0, Ve.R)(p), (0, Ne.U)(Y => Y.target)); (0, Te.R)(A, "keydown").pipe((0, Ve.R)(p), (0, Be.h)(Y => Y.which === Sr.Tab), (0, ht.M)(P)).subscribe(([Y, Re]) => { const [Ke, yt] = la(A); (Re === Ke || Re === A) && Y.shiftKey && (yt.focus(), Y.preventDefault()), Re === yt && !Y.shiftKey && (Ke.focus(), Y.preventDefault()) }), T && (0, Te.R)(A, "click").pipe((0, Ve.R)(p), (0, ht.M)(P), (0, Ne.U)(Y => Y[1])).subscribe(Y => Y.focus()) }) }, vi = /\s+/, W = /  +/gi, ee = { top: ["top"], bottom: ["bottom"], start: ["left", "right"], left: ["left"], end: ["right", "left"], right: ["right"], "top-start": ["top-start", "top-end"], "top-left": ["top-start"], "top-end": ["top-end", "top-start"], "top-right": ["top-end"], "bottom-start": ["bottom-start", "bottom-end"], "bottom-left": ["bottom-start"], "bottom-end": ["bottom-end", "bottom-start"], "bottom-right": ["bottom-end"], "start-top": ["left-start", "right-start"], "left-top": ["left-start"], "start-bottom": ["left-end", "right-end"], "left-bottom": ["left-end"], "end-top": ["right-start", "left-start"], "right-top": ["right-start"], "end-bottom": ["right-end", "left-end"], "right-bottom": ["right-end"] }, We = /^left/, xt = /^right/, zt = /^start/, _n = /^end/; function er({ placement: v, baseClass: A }, p) { let T = Array.isArray(v) ? v : v.split(vi), Y = T.findIndex(Vt => "auto" === Vt); Y >= 0 && ["top", "bottom", "start", "end", "top-start", "top-end", "bottom-start", "bottom-end", "start-top", "start-bottom", "end-top", "end-bottom"].forEach(function (Vt) { null == T.find(Wt => -1 !== Wt.search("^" + Vt)) && T.splice(Y++, 1, Vt) }); const Re = T.map(Vt => function de(v, A) { const [p, T] = ee[v]; return A && T || p }(Vt, p.isRTL())); return { placement: Re.shift(), modifiers: [{ name: "bootstrapClasses", enabled: !!A, phase: "write", fn({ state: Vt }) { const Wt = new RegExp(A + "(-[a-z]+)*", "gi"), vn = Vt.elements.popper, In = Vt.placement; let Un = vn.className; Un = Un.replace(Wt, ""), Un += ` ${function jn(v, A) { let [p, T] = A.split("-"); const P = p.replace(We, "start").replace(xt, "end"); let Y = [P]; if (T) { let Re = T; ("left" === p || "right" === p) && (Re = Re.replace(zt, "top").replace(_n, "bottom")), Y.push(`${P}-${Re}`) } return v && (Y = Y.map(Re => `${v}-${Re}`)), Y.join(" ") }(A, In)}`, Un = Un.trim().replace(W, " "), vn.className = Un } }, Hr, Ln, Xi, { enabled: !0, name: "flip", options: { fallbackPlacements: Re } }, { enabled: !0, name: "preventOverflow", phase: "main", fn: function () { } }] } } function ir(v) { return v } function Ir(v) { let A = null; return { createPopper(p) { if (!A) { let P = (p.updatePopperOptions || ir)(er(p, v)); A = gr(p.hostElement, p.targetElement, P) } }, update() { A && A.update() }, setOptions(p) { if (A) { let P = (p.updatePopperOptions || ir)(er(p, v)); A.setOptions(P) } }, destroy() { A && (A.destroy(), A = null) } } } let Pr = (() => { class v extends be { constructor() { super(...arguments), this.autoClose = !0, this.placement = ["bottom-start", "bottom-end", "top-start", "top-end"], this.popperOptions = p => p, this.restoreFocus = !0 } } return v.\u0275fac = function () { let A; return function (T) { return (A || (A = i.n5z(v)))(T || v) } }(), v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(); function ca(v) { return A => (A.modifiers.push(bo, { name: "offset", options: { offset: () => v } }), A) } let Vl = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: function () { return function Ws() { return new Uu }() }, providedIn: "root" }), v })(), Uu = (() => { class v extends Vl { parse(p) { if (null != p) { const T = p.trim().split("-"); if (1 === T.length && Ft(T[0])) return { year: re(T[0]), month: null, day: null }; if (2 === T.length && Ft(T[0]) && Ft(T[1])) return { year: re(T[0]), month: re(T[1]), day: null }; if (3 === T.length && Ft(T[0]) && Ft(T[1]) && Ft(T[2])) return { year: re(T[0]), month: re(T[1]), day: re(T[2]) } } return null } format(p) { return p ? `${p.year}-${Ft(p.month) ? Nr(p.month) : ""}-${Ft(p.day) ? Nr(p.day) : ""}` : "" } } return v.\u0275fac = function () { let A; return function (T) { return (A || (A = i.n5z(v)))(T || v) } }(), v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac }), v })(), _l = (() => { class v { constructor(p) { this._element = p.documentElement } isRTL() { return "rtl" === (this._element.getAttribute("dir") || "").toLowerCase() } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(m.K0)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), nl = (() => { class v { constructor(p, T, P, Y, Re, Ke, yt, Vt, Wt, vn, In) { this._parserFormatter = p, this._elRef = T, this._vcRef = P, this._renderer = Y, this._ngZone = Re, this._calendar = Ke, this._dateAdapter = yt, this._document = Wt, this._changeDetector = vn, this._cRef = null, this._disabled = !1, this._elWithFocus = null, this._model = null, this._destroyCloseHandlers$ = new we.x, this.dateSelect = new i.vpe, this.navigate = new i.vpe, this.closed = new i.vpe, this._onChange = Un => { }, this._onTouched = () => { }, this._validatorChange = () => { }, ["autoClose", "container", "positionTarget", "placement", "popperOptions"].forEach(Un => this[Un] = In[Un]), this._positioning = Ir(Vt) } get disabled() { return this._disabled } set disabled(p) { this._disabled = "" === p || p && "false" !== p, this.isOpen() && this._cRef.instance.setDisabledState(this._disabled) } registerOnChange(p) { this._onChange = p } registerOnTouched(p) { this._onTouched = p } registerOnValidatorChange(p) { this._validatorChange = p } setDisabledState(p) { this.disabled = p } validate(p) { const { value: T } = p; if (null != T) { const P = this._fromDateStruct(this._dateAdapter.fromModel(T)); if (!P) return { ngbDate: { invalid: T } }; if (this.minDate && P.before(ii.from(this.minDate))) return { ngbDate: { minDate: { minDate: this.minDate, actual: T } } }; if (this.maxDate && P.after(ii.from(this.maxDate))) return { ngbDate: { maxDate: { maxDate: this.maxDate, actual: T } } } } return null } writeValue(p) { this._model = this._fromDateStruct(this._dateAdapter.fromModel(p)), this._writeModelValue(this._model) } manualDateChange(p, T = !1) { const P = p !== this._inputValue; P && (this._inputValue = p, this._model = this._fromDateStruct(this._parserFormatter.parse(p))), (P || !T) && this._onChange(this._model ? this._dateAdapter.toModel(this._model) : "" === p ? null : p), T && this._model && this._writeModelValue(this._model) } isOpen() { return !!this._cRef } open() { if (!this.isOpen()) { let p; if (this._cRef = this._vcRef.createComponent(sa), this._applyPopupStyling(this._cRef.location.nativeElement), this._applyDatepickerInputs(this._cRef), this._subscribeForDatepickerOutputs(this._cRef.instance), this._cRef.instance.ngOnInit(), this._cRef.instance.writeValue(this._dateAdapter.toModel(this._model)), this._cRef.instance.registerOnChange(T => { this.writeValue(T), this._onChange(T), this._onTouched() }), this._cRef.changeDetectorRef.detectChanges(), this._cRef.instance.setDisabledState(this.disabled), "body" === this.container && this._document.querySelector(this.container).appendChild(this._cRef.location.nativeElement), this._elWithFocus = this._document.activeElement, ps(this._ngZone, this._cRef.location.nativeElement, this.closed, !0), setTimeout(() => this._cRef?.instance.focus()), p = $e(this.positionTarget) ? this._document.querySelector(this.positionTarget) : this.positionTarget instanceof HTMLElement ? this.positionTarget : this._elRef.nativeElement, this._ngZone.runOutsideAngular(() => { this._cRef && (this._positioning.createPopper({ hostElement: p, targetElement: this._cRef.location.nativeElement, placement: this.placement, appendToBody: "body" === this.container, updatePopperOptions: T => this.popperOptions(ca([0, 2])(T)) }), this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positioning.update())) }), this.positionTarget && !p) throw new Error("ngbDatepicker could not find element declared in [positionTarget] to position against."); this._setCloseHandlers() } } close() { if (this.isOpen()) { this._vcRef.remove(this._vcRef.indexOf(this._cRef.hostView)), this._cRef = null, this._positioning.destroy(), this._zoneSubscription?.unsubscribe(), this._destroyCloseHandlers$.next(), this.closed.emit(), this._changeDetector.markForCheck(); let p = this._elWithFocus; $e(this.restoreFocus) ? p = this._document.querySelector(this.restoreFocus) : void 0 !== this.restoreFocus && (p = this.restoreFocus), p && p.focus ? p.focus() : this._document.body.focus() } } toggle() { this.isOpen() ? this.close() : this.open() } navigateTo(p) { this.isOpen() && this._cRef.instance.navigateTo(p) } onBlur() { this._onTouched() } onFocus() { this._elWithFocus = this._elRef.nativeElement } ngOnChanges(p) { if ((p.minDate || p.maxDate) && (this._validatorChange(), this.isOpen() && (p.minDate && (this._cRef.instance.minDate = this.minDate), p.maxDate && (this._cRef.instance.maxDate = this.maxDate), this._cRef.instance.ngOnChanges(p))), p.datepickerClass) { const { currentValue: T, previousValue: P } = p.datepickerClass; this._applyPopupClass(T, P) } p.autoClose && this.isOpen() && this._setCloseHandlers() } ngOnDestroy() { this.close() } _applyDatepickerInputs(p) { ["dayTemplate", "dayTemplateData", "displayMonths", "firstDayOfWeek", "footerTemplate", "markDisabled", "minDate", "maxDate", "navigation", "outsideDays", "showNavigation", "showWeekNumbers", "weekdays"].forEach(T => { void 0 !== this[T] && p.setInput(T, this[T]) }), p.setInput("startDate", this.startDate || this._model) } _applyPopupClass(p, T) { const P = this._cRef?.location.nativeElement; P && (p && this._renderer.addClass(P, p), T && this._renderer.removeClass(P, T)) } _applyPopupStyling(p) { this._renderer.addClass(p, "dropdown-menu"), this._renderer.addClass(p, "show"), "body" === this.container && this._renderer.addClass(p, "ngb-dp-body"), this._applyPopupClass(this.datepickerClass) } _subscribeForDatepickerOutputs(p) { p.navigate.subscribe(T => this.navigate.emit(T)), p.dateSelect.subscribe(T => { this.dateSelect.emit(T), (!0 === this.autoClose || "inside" === this.autoClose) && this.close() }) } _writeModelValue(p) { const T = this._parserFormatter.format(p); this._inputValue = T, this._renderer.setProperty(this._elRef.nativeElement, "value", T), this.isOpen() && (this._cRef.instance.writeValue(this._dateAdapter.toModel(p)), this._onTouched()) } _fromDateStruct(p) { const T = p ? new ii(p.year, p.month, p.day) : null; return this._calendar.isValid(T) ? T : null } _setCloseHandlers() { this._destroyCloseHandlers$.next(), Qo(this._ngZone, this._document, this.autoClose, () => this.close(), this._destroyCloseHandlers$, [], [this._elRef.nativeElement, this._cRef.location.nativeElement]) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(Vl), i.Y36(i.SBq), i.Y36(i.s_b), i.Y36(i.Qsj), i.Y36(i.R0b), i.Y36(ji), i.Y36(on), i.Y36(_l), i.Y36(m.K0), i.Y36(i.sBO), i.Y36(Pr)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["input", "ngbDatepicker", ""]], hostVars: 1, hostBindings: function (p, T) { 1 & p && i.NdJ("input", function (Y) { return T.manualDateChange(Y.target.value) })("change", function (Y) { return T.manualDateChange(Y.target.value, !0) })("focus", function () { return T.onFocus() })("blur", function () { return T.onBlur() }), 2 & p && i.Ikx("disabled", T.disabled) }, inputs: { autoClose: "autoClose", datepickerClass: "datepickerClass", dayTemplate: "dayTemplate", dayTemplateData: "dayTemplateData", displayMonths: "displayMonths", firstDayOfWeek: "firstDayOfWeek", footerTemplate: "footerTemplate", markDisabled: "markDisabled", minDate: "minDate", maxDate: "maxDate", navigation: "navigation", outsideDays: "outsideDays", placement: "placement", popperOptions: "popperOptions", restoreFocus: "restoreFocus", showWeekNumbers: "showWeekNumbers", startDate: "startDate", container: "container", positionTarget: "positionTarget", weekdays: "weekdays", disabled: "disabled" }, outputs: { dateSelect: "dateSelect", navigate: "navigate", closed: "closed" }, exportAs: ["ngbDatepicker"], features: [i._Bn([{ provide: kn.JU, useExisting: (0, i.Gpc)(() => v), multi: !0 }, { provide: kn.Cf, useExisting: (0, i.Gpc)(() => v), multi: !0 }, { provide: be, useExisting: Pr }]), i.TTD] }), v })(); new Date(1882, 10, 12), new Date(2174, 10, 25); let Oi = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez, kn.u5] }), v })(), Qr = (() => { class v { constructor() { this.autoClose = !0, this.placement = ["bottom-start", "bottom-end", "top-start", "top-end"], this.popperOptions = p => p } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), rc = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", 8, "navbar"]] }), v })(), ts = (() => { class v { constructor(p, T) { this.elementRef = p, this._renderer = T, this._disabled = !1 } set disabled(p) { this._disabled = "" === p || !0 === p, this._renderer.setProperty(this.elementRef.nativeElement, "disabled", this._disabled) } get disabled() { return this._disabled } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq), i.Y36(i.Qsj)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbDropdownItem", ""]], hostAttrs: [1, "dropdown-item"], hostVars: 3, hostBindings: function (p, T) { 2 & p && (i.Ikx("tabIndex", T.disabled ? -1 : 0), i.ekj("disabled", T.disabled)) }, inputs: { disabled: "disabled" } }), v })(), ic = (() => { class v { constructor(p, T) { this.dropdown = p, this.placement = "bottom", this.isOpen = !1, this.nativeElement = T.nativeElement } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36((0, i.Gpc)(() => $u)), i.Y36(i.SBq)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbDropdownMenu", ""]], contentQueries: function (p, T, P) { if (1 & p && i.Suo(P, ts, 4), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.menuItems = Y) } }, hostVars: 4, hostBindings: function (p, T) { 1 & p && i.NdJ("keydown.ArrowUp", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.ArrowDown", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Home", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.End", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Enter", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Space", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Tab", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Shift.Tab", function (Y) { return T.dropdown.onKeyDown(Y) }), 2 & p && i.ekj("dropdown-menu", !0)("show", T.dropdown.isOpen()) } }), v })(), wu = (() => { class v { constructor(p, T) { this.dropdown = p, this.nativeElement = T.nativeElement } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36((0, i.Gpc)(() => $u)), i.Y36(i.SBq)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbDropdownAnchor", ""]], hostAttrs: [1, "dropdown-toggle"], hostVars: 1, hostBindings: function (p, T) { 2 & p && i.uIk("aria-expanded", T.dropdown.isOpen()) } }), v })(), Cu = (() => { class v extends wu { constructor(p, T) { super(p, T) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36((0, i.Gpc)(() => $u)), i.Y36(i.SBq)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbDropdownToggle", ""]], hostAttrs: [1, "dropdown-toggle"], hostVars: 1, hostBindings: function (p, T) { 1 & p && i.NdJ("click", function () { return T.dropdown.toggle() })("keydown.ArrowUp", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.ArrowDown", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Home", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.End", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Tab", function (Y) { return T.dropdown.onKeyDown(Y) })("keydown.Shift.Tab", function (Y) { return T.dropdown.onKeyDown(Y) }), 2 & p && i.uIk("aria-expanded", T.dropdown.isOpen()) }, features: [i._Bn([{ provide: wu, useExisting: (0, i.Gpc)(() => v) }]), i.qOj] }), v })(), $u = (() => { class v { constructor(p, T, P, Y, Re, Ke, yt, Vt) { this._changeDetector = p, this._document = Y, this._ngZone = Re, this._elementRef = Ke, this._renderer = yt, this._destroyCloseHandlers$ = new we.x, this._bodyContainer = null, this._open = !1, this.openChange = new i.vpe, this.placement = P.placement, this.popperOptions = P.popperOptions, this.container = P.container, this.autoClose = P.autoClose, this._positioning = Ir(T), this.display = Vt ? "static" : "dynamic" } ngAfterContentInit() { this._ngZone.onStable.pipe((0, nt.q)(1)).subscribe(() => { this._applyPlacementClasses(), this._open && this._setCloseHandlers() }) } ngOnChanges(p) { if (p.container && this._open && this._applyContainer(this.container), p.placement && !p.placement.firstChange && (this._positioning.setOptions({ hostElement: this._anchor.nativeElement, targetElement: this._bodyContainer || this._menu.nativeElement, placement: this.placement, appendToBody: "body" === this.container }), this._applyPlacementClasses()), p.dropdownClass) { const { currentValue: T, previousValue: P } = p.dropdownClass; this._applyCustomDropdownClass(T, P) } p.autoClose && this._open && (this.autoClose = p.autoClose.currentValue, this._setCloseHandlers()) } isOpen() { return this._open } open() { this._open || (this._open = !0, this._applyContainer(this.container), this.openChange.emit(!0), this._setCloseHandlers(), this._anchor && (this._anchor.nativeElement.focus(), "dynamic" === this.display && this._ngZone.runOutsideAngular(() => { this._positioning.createPopper({ hostElement: this._anchor.nativeElement, targetElement: this._bodyContainer || this._menu.nativeElement, placement: this.placement, appendToBody: "body" === this.container, updatePopperOptions: p => this.popperOptions(ca([0, 2])(p)) }), this._applyPlacementClasses(), this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positionMenu()) }))) } _setCloseHandlers() { this._destroyCloseHandlers$.next(), Qo(this._ngZone, this._document, this.autoClose, p => { this.close(), 0 === p && this._anchor.nativeElement.focus() }, this._destroyCloseHandlers$, this._menu ? [this._menu.nativeElement] : [], this._anchor ? [this._anchor.nativeElement] : [], ".dropdown-item,.dropdown-divider") } close() { this._open && (this._open = !1, this._resetContainer(), this._positioning.destroy(), this._zoneSubscription?.unsubscribe(), this._destroyCloseHandlers$.next(), this.openChange.emit(!1), this._changeDetector.markForCheck()) } toggle() { this.isOpen() ? this.close() : this.open() } ngOnDestroy() { this.close() } onKeyDown(p) { const T = p.which, P = this._getMenuElements(); let Y = -1, Re = null; const Ke = this._isEventFromToggle(p); if (!Ke && P.length && P.forEach((yt, Vt) => { yt.contains(p.target) && (Re = yt), yt === this._document.activeElement && (Y = Vt) }), T !== Sr.Space && T !== Sr.Enter) { if (T !== Sr.Tab) { if (Ke || Re) { if (this.open(), P.length) { switch (T) { case Sr.ArrowDown: Y = Math.min(Y + 1, P.length - 1); break; case Sr.ArrowUp: if (this._isDropup() && -1 === Y) { Y = P.length - 1; break } Y = Math.max(Y - 1, 0); break; case Sr.Home: Y = 0; break; case Sr.End: Y = P.length - 1 }P[Y].focus() } p.preventDefault() } } else if (p.target && this.isOpen() && this.autoClose) { if (this._anchor.nativeElement === p.target) return void ("body" !== this.container || p.shiftKey ? p.shiftKey && this.close() : (this._renderer.setAttribute(this._menu.nativeElement, "tabindex", "0"), this._menu.nativeElement.focus(), this._renderer.removeAttribute(this._menu.nativeElement, "tabindex"))); if ("body" === this.container) { const yt = this._menu.nativeElement.querySelectorAll(aa); p.shiftKey && p.target === yt[0] ? (this._anchor.nativeElement.focus(), p.preventDefault()) : !p.shiftKey && p.target === yt[yt.length - 1] && (this._anchor.nativeElement.focus(), this.close()) } else (0, Te.R)(p.target, "focusout").pipe((0, nt.q)(1)).subscribe(({ relatedTarget: yt }) => { this._elementRef.nativeElement.contains(yt) || this.close() }) } } else Re && (!0 === this.autoClose || "inside" === this.autoClose) && (0, Te.R)(Re, "click").pipe((0, nt.q)(1)).subscribe(() => this.close()) } _isDropup() { return this._elementRef.nativeElement.classList.contains("dropup") } _isEventFromToggle(p) { return this._anchor.nativeElement.contains(p.target) } _getMenuElements() { const p = this._menu; return null == p ? [] : p.menuItems.filter(T => !T.disabled).map(T => T.elementRef.nativeElement) } _positionMenu() { const p = this._menu; this.isOpen() && p && ("dynamic" === this.display ? (this._positioning.update(), this._applyPlacementClasses()) : this._applyPlacementClasses(this._getFirstPlacement(this.placement))) } _getFirstPlacement(p) { return Array.isArray(p) ? p[0] : p.split(" ")[0] } _resetContainer() { const p = this._renderer; this._menu && p.appendChild(this._elementRef.nativeElement, this._menu.nativeElement), this._bodyContainer && (p.removeChild(this._document.body, this._bodyContainer), this._bodyContainer = null) } _applyContainer(p = null) { if (this._resetContainer(), "body" === p) { const T = this._renderer, P = this._menu.nativeElement, Y = this._bodyContainer = this._bodyContainer || T.createElement("div"); T.setStyle(Y, "position", "absolute"), T.setStyle(P, "position", "static"), T.setStyle(Y, "z-index", "1055"), T.appendChild(Y, P), T.appendChild(this._document.body, Y) } this._applyCustomDropdownClass(this.dropdownClass) } _applyCustomDropdownClass(p, T) { const P = "body" === this.container ? this._bodyContainer : this._elementRef.nativeElement; P && (T && this._renderer.removeClass(P, T), p && this._renderer.addClass(P, p)) } _applyPlacementClasses(p) { const T = this._menu; if (T) { p || (p = this._getFirstPlacement(this.placement)); const P = this._renderer, Y = this._elementRef.nativeElement; P.removeClass(Y, "dropup"), P.removeClass(Y, "dropdown"); const { nativeElement: Re } = T; "static" === this.display ? (T.placement = null, P.setAttribute(Re, "data-bs-popper", "static")) : (T.placement = p, P.removeAttribute(Re, "data-bs-popper")); const Ke = -1 !== p.search("^top") ? "dropup" : "dropdown"; P.addClass(Y, Ke); const yt = this._bodyContainer; yt && (P.removeClass(yt, "dropup"), P.removeClass(yt, "dropdown"), P.addClass(yt, Ke)) } } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.sBO), i.Y36(_l), i.Y36(Qr), i.Y36(m.K0), i.Y36(i.R0b), i.Y36(i.SBq), i.Y36(i.Qsj), i.Y36(rc, 8)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbDropdown", ""]], contentQueries: function (p, T, P) { if (1 & p && (i.Suo(P, ic, 5), i.Suo(P, wu, 5)), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T._menu = Y.first), i.iGM(Y = i.CRH()) && (T._anchor = Y.first) } }, hostVars: 2, hostBindings: function (p, T) { 2 & p && i.ekj("show", T.isOpen()) }, inputs: { autoClose: "autoClose", dropdownClass: "dropdownClass", _open: ["open", "_open"], placement: "placement", popperOptions: "popperOptions", container: "container", display: "display" }, outputs: { openChange: "openChange" }, exportAs: ["ngbDropdown"], features: [i.TTD] }), v })(), Xr = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({}), v })(); class ws { constructor(A, p, T) { this.nodes = A, this.viewRef = p, this.componentRef = T } } class vp { constructor(A, p, T, P, Y, Re) { this._componentType = A, this._injector = p, this._viewContainerRef = T, this._renderer = P, this._ngZone = Y, this._applicationRef = Re, this._windowRef = null, this._contentRef = null } open(A, p, T = !1) { this._windowRef || (this._contentRef = this._getContentRef(A, p), this._windowRef = this._viewContainerRef.createComponent(this._componentType, { injector: this._injector, projectableNodes: this._contentRef.nodes })); const { nativeElement: P } = this._windowRef.location, Y = this._ngZone.onStable.pipe((0, nt.q)(1), (0, rn.z)(() => xi(this._ngZone, P, ({ classList: Re }) => Re.add("show"), { animation: T, runningTransition: "continue" }))); return { windowRef: this._windowRef, transition$: Y } } close(A = !1) { return this._windowRef ? xi(this._ngZone, this._windowRef.location.nativeElement, ({ classList: p }) => p.remove("show"), { animation: A, runningTransition: "stop" }).pipe((0, st.b)(() => { this._windowRef && (this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._windowRef.hostView)), this._windowRef = null), this._contentRef?.viewRef && (this._applicationRef.detachView(this._contentRef.viewRef), this._contentRef.viewRef.destroy(), this._contentRef = null) })) : (0, Ce.of)(void 0) } _getContentRef(A, p) { if (A) { if (A instanceof i.Rgc) { const T = A.createEmbeddedView(p); return this._applicationRef.attachView(T), new ws([T.rootNodes], T) } return new ws([[this._renderer.createText(`${A}`)]]) } return new ws([]) } } let pd = (() => { class v { constructor(p, T) { this._el = p, this._zone = T } ngOnInit() { this._zone.onStable.asObservable().pipe((0, nt.q)(1)).subscribe(() => { xi(this._zone, this._el.nativeElement, (p, T) => { T && xr(p), p.classList.add("show") }, { animation: this.animation, runningTransition: "continue" }) }) } hide() { return xi(this._zone, this._el.nativeElement, ({ classList: p }) => p.remove("show"), { animation: this.animation, runningTransition: "stop" }) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq), i.Y36(i.R0b)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-modal-backdrop"]], hostAttrs: [2, "z-index", "1055"], hostVars: 6, hostBindings: function (p, T) { 2 & p && (i.Tol("modal-backdrop" + (T.backdropClass ? " " + T.backdropClass : "")), i.ekj("show", !T.animation)("fade", T.animation)) }, inputs: { animation: "animation", backdropClass: "backdropClass" }, decls: 0, vars: 0, template: function (p, T) { }, encapsulation: 2 }), v })(); class Ua { close(A) { } dismiss(A) { } } class Zh { constructor(A, p, T, P) { this._windowCmptRef = A, this._contentRef = p, this._backdropCmptRef = T, this._beforeDismiss = P, this._closed = new we.x, this._dismissed = new we.x, this._hidden = new we.x, A.instance.dismissEvent.subscribe(Y => { this.dismiss(Y) }), this.result = new Promise((Y, Re) => { this._resolve = Y, this._reject = Re }), this.result.then(null, () => { }) } get componentInstance() { if (this._contentRef && this._contentRef.componentRef) return this._contentRef.componentRef.instance } get closed() { return this._closed.asObservable().pipe((0, Ve.R)(this._hidden)) } get dismissed() { return this._dismissed.asObservable().pipe((0, Ve.R)(this._hidden)) } get hidden() { return this._hidden.asObservable() } get shown() { return this._windowCmptRef.instance.shown.asObservable() } close(A) { this._windowCmptRef && (this._closed.next(A), this._resolve(A), this._removeModalElements()) } _dismiss(A) { this._dismissed.next(A), this._reject(A), this._removeModalElements() } dismiss(A) { if (this._windowCmptRef) if (this._beforeDismiss) { const p = this._beforeDismiss(); ri(p) ? p.then(T => { !1 !== T && this._dismiss(A) }, () => { }) : !1 !== p && this._dismiss(A) } else this._dismiss(A) } _removeModalElements() { const A = this._windowCmptRef.instance.hide(), p = this._backdropCmptRef ? this._backdropCmptRef.instance.hide() : (0, Ce.of)(void 0); A.subscribe(() => { const { nativeElement: T } = this._windowCmptRef.location; T.parentNode.removeChild(T), this._windowCmptRef.destroy(), this._contentRef && this._contentRef.viewRef && this._contentRef.viewRef.destroy(), this._windowCmptRef = null, this._contentRef = null }), p.subscribe(() => { if (this._backdropCmptRef) { const { nativeElement: T } = this._backdropCmptRef.location; T.parentNode.removeChild(T), this._backdropCmptRef.destroy(), this._backdropCmptRef = null } }), (0, _t.$)(A, p).subscribe(() => { this._hidden.next(), this._hidden.complete() }) } } var ru = (() => { return (v = ru || (ru = {}))[v.BACKDROP_CLICK = 0] = "BACKDROP_CLICK", v[v.ESC = 1] = "ESC", ru; var v })(); let qh = (() => { class v { constructor(p, T, P) { this._document = p, this._elRef = T, this._zone = P, this._closed$ = new we.x, this._elWithFocus = null, this.backdrop = !0, this.keyboard = !0, this.dismissEvent = new i.vpe, this.shown = new we.x, this.hidden = new we.x } get fullscreenClass() { return !0 === this.fullscreen ? " modal-fullscreen" : $e(this.fullscreen) ? ` modal-fullscreen-${this.fullscreen}-down` : "" } dismiss(p) { this.dismissEvent.emit(p) } ngOnInit() { this._elWithFocus = this._document.activeElement, this._zone.onStable.asObservable().pipe((0, nt.q)(1)).subscribe(() => { this._show() }) } ngOnDestroy() { this._disableEventHandling() } hide() { const { nativeElement: p } = this._elRef, T = { animation: this.animation, runningTransition: "stop" }, P = xi(this._zone, p, () => p.classList.remove("show"), T), Y = xi(this._zone, this._dialogEl.nativeElement, () => { }, T), Re = (0, _t.$)(P, Y); return Re.subscribe(() => { this.hidden.next(), this.hidden.complete() }), this._disableEventHandling(), this._restoreFocus(), Re } _show() { const p = { animation: this.animation, runningTransition: "continue" }, T = xi(this._zone, this._elRef.nativeElement, (Y, Re) => { Re && xr(Y), Y.classList.add("show") }, p), P = xi(this._zone, this._dialogEl.nativeElement, () => { }, p); (0, _t.$)(T, P).subscribe(() => { this.shown.next(), this.shown.complete() }), this._enableEventHandling(), this._setFocus() } _enableEventHandling() { const { nativeElement: p } = this._elRef; this._zone.runOutsideAngular(() => { (0, Te.R)(p, "keydown").pipe((0, Ve.R)(this._closed$), (0, Be.h)(P => P.which === Sr.Escape)).subscribe(P => { this.keyboard ? requestAnimationFrame(() => { P.defaultPrevented || this._zone.run(() => this.dismiss(ru.ESC)) }) : "static" === this.backdrop && this._bumpBackdrop() }); let T = !1; (0, Te.R)(this._dialogEl.nativeElement, "mousedown").pipe((0, Ve.R)(this._closed$), (0, st.b)(() => T = !1), (0, Ue.w)(() => (0, Te.R)(p, "mouseup").pipe((0, Ve.R)(this._closed$), (0, nt.q)(1))), (0, Be.h)(({ target: P }) => p === P)).subscribe(() => { T = !0 }), (0, Te.R)(p, "click").pipe((0, Ve.R)(this._closed$)).subscribe(({ target: P }) => { p === P && ("static" === this.backdrop ? this._bumpBackdrop() : !0 === this.backdrop && !T && this._zone.run(() => this.dismiss(ru.BACKDROP_CLICK))), T = !1 }) }) } _disableEventHandling() { this._closed$.next() } _setFocus() { const { nativeElement: p } = this._elRef; if (!p.contains(document.activeElement)) { const T = p.querySelector("[ngbAutofocus]"), P = la(p)[0]; (T || P || p).focus() } } _restoreFocus() { const p = this._document.body, T = this._elWithFocus; let P; P = T && T.focus && p.contains(T) ? T : p, this._zone.runOutsideAngular(() => { setTimeout(() => P.focus()), this._elWithFocus = null }) } _bumpBackdrop() { "static" === this.backdrop && xi(this._zone, this._elRef.nativeElement, ({ classList: p }) => (p.add("modal-static"), () => p.remove("modal-static")), { animation: this.animation, runningTransition: "continue" }) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(m.K0), i.Y36(i.SBq), i.Y36(i.R0b)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-modal-window"]], viewQuery: function (p, T) { if (1 & p && i.Gf(oo, 7), 2 & p) { let P; i.iGM(P = i.CRH()) && (T._dialogEl = P.first) } }, hostAttrs: ["role", "dialog", "tabindex", "-1"], hostVars: 7, hostBindings: function (p, T) { 2 & p && (i.uIk("aria-modal", !0)("aria-labelledby", T.ariaLabelledBy)("aria-describedby", T.ariaDescribedBy), i.Tol("modal d-block" + (T.windowClass ? " " + T.windowClass : "")), i.ekj("fade", T.animation)) }, inputs: { animation: "animation", ariaLabelledBy: "ariaLabelledBy", ariaDescribedBy: "ariaDescribedBy", backdrop: "backdrop", centered: "centered", fullscreen: "fullscreen", keyboard: "keyboard", scrollable: "scrollable", size: "size", windowClass: "windowClass", modalDialogClass: "modalDialogClass" }, outputs: { dismissEvent: "dismiss" }, ngContentSelectors: zo, decls: 4, vars: 2, consts: [["role", "document"], ["dialog", ""], [1, "modal-content"]], template: function (p, T) { 1 & p && (i.F$t(), i.TgZ(0, "div", 0, 1)(2, "div", 2), i.Hsn(3), i.qZA()()), 2 & p && i.Tol("modal-dialog" + (T.size ? " modal-" + T.size : "") + (T.centered ? " modal-dialog-centered" : "") + T.fullscreenClass + (T.scrollable ? " modal-dialog-scrollable" : "") + (T.modalDialogClass ? " " + T.modalDialogClass : "")) }, styles: ["ngb-modal-window .component-host-scrollable{display:flex;flex-direction:column;overflow:hidden}\n"], encapsulation: 2 }), v })(), vh = (() => { class v { constructor(p) { this._document = p } hide() { const p = Math.abs(window.innerWidth - this._document.documentElement.clientWidth), T = this._document.body, P = T.style, { overflow: Y, paddingRight: Re } = P; if (p > 0) { const Ke = parseFloat(window.getComputedStyle(T).paddingRight); P.paddingRight = `${Ke + p}px` } return P.overflow = "hidden", () => { p > 0 && (P.paddingRight = Re), P.overflow = Y } } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(m.K0)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), iu = (() => { class v { constructor(p, T, P, Y, Re, Ke) { this._applicationRef = p, this._injector = T, this._document = P, this._scrollBar = Y, this._rendererFactory = Re, this._ngZone = Ke, this._activeWindowCmptHasChanged = new we.x, this._ariaHiddenValues = new Map, this._scrollBarRestoreFn = null, this._backdropAttributes = ["animation", "backdropClass"], this._modalRefs = [], this._windowAttributes = ["animation", "ariaLabelledBy", "ariaDescribedBy", "backdrop", "centered", "fullscreen", "keyboard", "scrollable", "size", "windowClass", "modalDialogClass"], this._windowCmpts = [], this._activeInstances = new i.vpe, this._activeWindowCmptHasChanged.subscribe(() => { if (this._windowCmpts.length) { const yt = this._windowCmpts[this._windowCmpts.length - 1]; ps(this._ngZone, yt.location.nativeElement, this._activeWindowCmptHasChanged), this._revertAriaHidden(), this._setAriaHidden(yt.location.nativeElement) } }) } _restoreScrollBar() { const p = this._scrollBarRestoreFn; p && (this._scrollBarRestoreFn = null, p()) } _hideScrollBar() { this._scrollBarRestoreFn || (this._scrollBarRestoreFn = this._scrollBar.hide()) } open(p, T, P) { const Y = P.container instanceof HTMLElement ? P.container : Nn(P.container) ? this._document.querySelector(P.container) : this._document.body, Re = this._rendererFactory.createRenderer(null, null); if (!Y) throw new Error(`The specified modal container "${P.container || "body"}" was not found in the DOM.`); this._hideScrollBar(); const Ke = new Ua, yt = this._getContentRef(P.injector || p, T, Ke, P); let Vt = !1 !== P.backdrop ? this._attachBackdrop(Y) : void 0, Wt = this._attachWindowComponent(Y, yt.nodes), vn = new Zh(Wt, yt, Vt, P.beforeDismiss); return this._registerModalRef(vn), this._registerWindowCmpt(Wt), vn.hidden.pipe((0, nt.q)(1)).subscribe(() => Promise.resolve(!0).then(() => { this._modalRefs.length || (Re.removeClass(this._document.body, "modal-open"), this._restoreScrollBar(), this._revertAriaHidden()) })), Ke.close = In => { vn.close(In) }, Ke.dismiss = In => { vn.dismiss(In) }, this._applyWindowOptions(Wt.instance, P), 1 === this._modalRefs.length && Re.addClass(this._document.body, "modal-open"), Vt && Vt.instance && (this._applyBackdropOptions(Vt.instance, P), Vt.changeDetectorRef.detectChanges()), Wt.changeDetectorRef.detectChanges(), vn } get activeInstances() { return this._activeInstances } dismissAll(p) { this._modalRefs.forEach(T => T.dismiss(p)) } hasOpenModals() { return this._modalRefs.length > 0 } _attachBackdrop(p) { let T = (0, i.LMc)(pd, { environmentInjector: this._applicationRef.injector, elementInjector: this._injector }); return this._applicationRef.attachView(T.hostView), p.appendChild(T.location.nativeElement), T } _attachWindowComponent(p, T) { let P = (0, i.LMc)(qh, { environmentInjector: this._applicationRef.injector, elementInjector: this._injector, projectableNodes: T }); return this._applicationRef.attachView(P.hostView), p.appendChild(P.location.nativeElement), P } _applyWindowOptions(p, T) { this._windowAttributes.forEach(P => { Nn(T[P]) && (p[P] = T[P]) }) } _applyBackdropOptions(p, T) { this._backdropAttributes.forEach(P => { Nn(T[P]) && (p[P] = T[P]) }) } _getContentRef(p, T, P, Y) { return T ? T instanceof i.Rgc ? this._createFromTemplateRef(T, P) : $e(T) ? this._createFromString(T) : this._createFromComponent(p, T, P, Y) : new ws([]) } _createFromTemplateRef(p, T) { const Y = p.createEmbeddedView({ $implicit: T, close(Re) { T.close(Re) }, dismiss(Re) { T.dismiss(Re) } }); return this._applicationRef.attachView(Y), new ws([Y.rootNodes], Y) } _createFromString(p) { const T = this._document.createTextNode(`${p}`); return new ws([[T]]) } _createFromComponent(p, T, P, Y) { const Re = i.zs3.create({ providers: [{ provide: Ua, useValue: P }], parent: p }), Ke = (0, i.LMc)(T, { environmentInjector: this._applicationRef.injector, elementInjector: Re }), yt = Ke.location.nativeElement; return Y.scrollable && yt.classList.add("component-host-scrollable"), this._applicationRef.attachView(Ke.hostView), new ws([[yt]], Ke.hostView, Ke) } _setAriaHidden(p) { const T = p.parentElement; T && p !== this._document.body && (Array.from(T.children).forEach(P => { P !== p && "SCRIPT" !== P.nodeName && (this._ariaHiddenValues.set(P, P.getAttribute("aria-hidden")), P.setAttribute("aria-hidden", "true")) }), this._setAriaHidden(T)) } _revertAriaHidden() { this._ariaHiddenValues.forEach((p, T) => { p ? T.setAttribute("aria-hidden", p) : T.removeAttribute("aria-hidden") }), this._ariaHiddenValues.clear() } _registerModalRef(p) { const T = () => { const P = this._modalRefs.indexOf(p); P > -1 && (this._modalRefs.splice(P, 1), this._activeInstances.emit(this._modalRefs)) }; this._modalRefs.push(p), this._activeInstances.emit(this._modalRefs), p.result.then(T, T) } _registerWindowCmpt(p) { this._windowCmpts.push(p), this._activeWindowCmptHasChanged.next(), p.onDestroy(() => { const T = this._windowCmpts.indexOf(p); T > -1 && (this._windowCmpts.splice(T, 1), this._activeWindowCmptHasChanged.next()) }) } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(i.z2F), i.LFG(i.zs3), i.LFG(m.K0), i.LFG(vh), i.LFG(i.FYo), i.LFG(i.R0b)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), bh = (() => { class v { constructor(p) { this._ngbConfig = p, this.backdrop = !0, this.fullscreen = !1, this.keyboard = !0 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), rl = (() => { class v { constructor(p, T, P) { this._injector = p, this._modalStack = T, this._config = P } open(p, T = {}) { const P = { ...this._config, animation: this._config.animation, ...T }; return this._modalStack.open(this._injector, p, P) } get activeInstances() { return this._modalStack.activeInstances } dismissAll(p) { this._modalStack.dismissAll(p) } hasOpenModals() { return this._modalStack.hasOpenModals() } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(i.zs3), i.LFG(iu), i.LFG(bh)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), gd = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ providers: [rl] }), v })(), kf = (() => { class v { constructor(p) { this._ngbConfig = p, this.destroyOnHide = !0, this.orientation = "horizontal", this.roles = "tablist", this.keyboard = !1 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(); const Yh = v => Nn(v) && "" !== v; let bg = 0, Wu = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbNavContent", ""]] }), v })(), md = (() => { class v { constructor(p, T) { this._nav = p, this.elementRef = T, this.disabled = !1, this.shown = new i.vpe, this.hidden = new i.vpe } ngAfterContentChecked() { this.contentTpl = this.contentTpls.first } ngOnInit() { Nn(this.domId) || (this.domId = "ngb-nav-" + bg++) } get active() { return this._nav.activeId === this.id } get id() { return Yh(this._id) ? this._id : this.domId } get panelDomId() { return `${this.domId}-panel` } isPanelInDom() { return (Nn(this.destroyOnHide) ? !this.destroyOnHide : !this._nav.destroyOnHide) || this.active } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36((0, i.Gpc)(() => sc)), i.Y36(i.SBq)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbNavItem", ""]], contentQueries: function (p, T, P) { if (1 & p && i.Suo(P, Wu, 4), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.contentTpls = Y) } }, hostVars: 2, hostBindings: function (p, T) { 2 & p && i.ekj("nav-item", !0) }, inputs: { destroyOnHide: "destroyOnHide", disabled: "disabled", domId: "domId", _id: ["ngbNavItem", "_id"] }, outputs: { shown: "shown", hidden: "hidden" }, exportAs: ["ngbNavItem"] }), v })(), sc = (() => { class v { constructor(p, T, P, Y) { this.role = p, this._cd = P, this._document = Y, this.activeIdChange = new i.vpe, this.shown = new i.vpe, this.hidden = new i.vpe, this.destroy$ = new we.x, this.navItemChange$ = new we.x, this.navChange = new i.vpe, this.animation = T.animation, this.destroyOnHide = T.destroyOnHide, this.orientation = T.orientation, this.roles = T.roles, this.keyboard = T.keyboard } click(p) { p.disabled || this._updateActiveId(p.id) } onKeyDown(p) { if ("tablist" !== this.roles || !this.keyboard) return; const T = p.which, P = this.links.filter(Ke => !Ke.navItem.disabled), { length: Y } = P; let Re = -1; if (P.forEach((Ke, yt) => { Ke.elRef.nativeElement === this._document.activeElement && (Re = yt) }), Y) { switch (T) { case Sr.ArrowLeft: if ("vertical" === this.orientation) return; Re = (Re - 1 + Y) % Y; break; case Sr.ArrowRight: if ("vertical" === this.orientation) return; Re = (Re + 1) % Y; break; case Sr.ArrowDown: if ("horizontal" === this.orientation) return; Re = (Re + 1) % Y; break; case Sr.ArrowUp: if ("horizontal" === this.orientation) return; Re = (Re - 1 + Y) % Y; break; case Sr.Home: Re = 0; break; case Sr.End: Re = Y - 1 }"changeWithArrows" === this.keyboard && this.select(P[Re].navItem.id), P[Re].elRef.nativeElement.focus(), p.preventDefault() } } select(p) { this._updateActiveId(p, !1) } ngAfterContentInit() { if (!Nn(this.activeId)) { const p = this.items.first ? this.items.first.id : null; Yh(p) && (this._updateActiveId(p, !1), this._cd.detectChanges()) } this.items.changes.pipe((0, Ve.R)(this.destroy$)).subscribe(() => this._notifyItemChanged(this.activeId)) } ngOnChanges({ activeId: p }) { p && !p.firstChange && this._notifyItemChanged(p.currentValue) } ngOnDestroy() { this.destroy$.next() } _updateActiveId(p, T = !0) { if (this.activeId !== p) { let P = !1; T && this.navChange.emit({ activeId: this.activeId, nextId: p, preventDefault: () => { P = !0 } }), P || (this.activeId = p, this.activeIdChange.emit(p), this._notifyItemChanged(p)) } } _notifyItemChanged(p) { this.navItemChange$.next(this._getItemById(p)) } _getItemById(p) { return this.items && this.items.find(T => T.id === p) || null } } return v.\u0275fac = function (p) { return new (p || v)(i.$8M("role"), i.Y36(kf), i.Y36(i.sBO), i.Y36(m.K0)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbNav", ""]], contentQueries: function (p, T, P) { if (1 & p && (i.Suo(P, md, 4), i.Suo(P, si, 5)), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.items = Y), i.iGM(Y = i.CRH()) && (T.links = Y) } }, hostVars: 6, hostBindings: function (p, T) { 1 & p && i.NdJ("keydown.arrowLeft", function (Y) { return T.onKeyDown(Y) })("keydown.arrowRight", function (Y) { return T.onKeyDown(Y) })("keydown.arrowDown", function (Y) { return T.onKeyDown(Y) })("keydown.arrowUp", function (Y) { return T.onKeyDown(Y) })("keydown.Home", function (Y) { return T.onKeyDown(Y) })("keydown.End", function (Y) { return T.onKeyDown(Y) }), 2 & p && (i.uIk("aria-orientation", "vertical" === T.orientation && "tablist" === T.roles ? "vertical" : void 0)("role", T.role ? T.role : T.roles ? "tablist" : void 0), i.ekj("nav", !0)("flex-column", "vertical" === T.orientation)) }, inputs: { activeId: "activeId", animation: "animation", destroyOnHide: "destroyOnHide", orientation: "orientation", roles: "roles", keyboard: "keyboard" }, outputs: { activeIdChange: "activeIdChange", shown: "shown", hidden: "hidden", navChange: "navChange" }, exportAs: ["ngbNav"], features: [i.TTD] }), v })(), si = (() => { class v { constructor(p, T, P, Y) { this.role = p, this.navItem = T, this.nav = P, this.elRef = Y } hasNavItemClass() { return this.navItem.elementRef.nativeElement.nodeType === Node.COMMENT_NODE } } return v.\u0275fac = function (p) { return new (p || v)(i.$8M("role"), i.Y36(md), i.Y36(sc), i.Y36(i.SBq)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["a", "ngbNavLink", ""]], hostAttrs: ["href", ""], hostVars: 14, hostBindings: function (p, T) { 1 & p && i.NdJ("click", function (Y) { return T.nav.click(T.navItem), Y.preventDefault() }), 2 & p && (i.Ikx("id", T.navItem.domId), i.uIk("role", T.role ? T.role : T.nav.roles ? "tab" : void 0)("tabindex", T.navItem.disabled ? -1 : void 0)("aria-controls", T.navItem.isPanelInDom() ? T.navItem.panelDomId : null)("aria-selected", T.navItem.active)("aria-disabled", T.navItem.disabled), i.ekj("nav-link", !0)("nav-item", T.hasNavItemClass())("active", T.navItem.active)("disabled", T.navItem.disabled)) } }), v })(); const Zu = ({ classList: v }) => (v.remove("show"), () => v.remove("active")), Rc = (v, A) => { A && xr(v), v.classList.add("show") }; let _d = (() => { class v { constructor(p) { this.elRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbNavPane", ""]], hostAttrs: [1, "tab-pane"], hostVars: 5, hostBindings: function (p, T) { 2 & p && (i.Ikx("id", T.item.panelDomId), i.uIk("role", T.role ? T.role : T.nav.roles ? "tabpanel" : void 0)("aria-labelledby", T.item.domId), i.ekj("fade", T.nav.animation)) }, inputs: { item: "item", nav: "nav", role: "role" } }), v })(), Po = (() => { class v { constructor(p, T) { this._cd = p, this._ngZone = T, this._activePane = null } isPanelTransitioning(p) { return this._activePane?.item === p } ngAfterViewInit() { this._updateActivePane(), this.nav.navItemChange$.pipe((0, Ve.R)(this.nav.destroy$), (0, tt.O)(this._activePane?.item || null), (0, Fe.x)(), (0, On.T)(1)).subscribe(p => { const T = { animation: this.nav.animation, runningTransition: "stop" }; this._cd.detectChanges(), this._activePane ? xi(this._ngZone, this._activePane.elRef.nativeElement, Zu, T).subscribe(() => { const P = this._activePane?.item; this._activePane = this._getPaneForItem(p), this._cd.markForCheck(), this._activePane && (this._activePane.elRef.nativeElement.classList.add("active"), xi(this._ngZone, this._activePane.elRef.nativeElement, Rc, T).subscribe(() => { p && (p.shown.emit(), this.nav.shown.emit(p.id)) })), P && (P.hidden.emit(), this.nav.hidden.emit(P.id)) }) : this._updateActivePane() }) } _updateActivePane() { this._activePane = this._getActivePane(), this._activePane?.elRef.nativeElement.classList.add("show"), this._activePane?.elRef.nativeElement.classList.add("active") } _getPaneForItem(p) { return this._panes && this._panes.find(T => T.item === p) || null } _getActivePane() { return this._panes && this._panes.find(p => p.item.active) || null } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.sBO), i.Y36(i.R0b)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["", "ngbNavOutlet", ""]], viewQuery: function (p, T) { if (1 & p && i.Gf(_d, 5), 2 & p) { let P; i.iGM(P = i.CRH()) && (T._panes = P) } }, hostVars: 2, hostBindings: function (p, T) { 2 & p && i.ekj("tab-content", !0) }, inputs: { paneRole: "paneRole", nav: ["ngbNavOutlet", "nav"] }, attrs: xs, decls: 1, vars: 1, consts: [["ngFor", "", 3, "ngForOf"], ["ngbNavPane", "", 3, "item", "nav", "role", 4, "ngIf"], ["ngbNavPane", "", 3, "item", "nav", "role"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function (p, T) { 1 & p && i.YNc(0, ys, 1, 1, "ng-template", 0), 2 & p && i.Q6J("ngForOf", T.nav.items) }, dependencies: [m.sg, m.O5, m.tP, _d], encapsulation: 2, changeDetection: 0 }), v })(), wl = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(), Ro = (() => { class v { constructor() { this.disabled = !1, this.boundaryLinks = !1, this.directionLinks = !0, this.ellipses = !0, this.maxSize = 0, this.pageSize = 10, this.rotate = !1 } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), to = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPaginationEllipsis", ""]] }), v })(), yd = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPaginationFirst", ""]] }), v })(), Ma = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPaginationLast", ""]] }), v })(), Tu = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPaginationNext", ""]] }), v })(), jd = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPaginationNumber", ""]] }), v })(), wh = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPaginationPrevious", ""]] }), v })(), Cl = (() => { class v { constructor(p) { this.templateRef = p } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.Rgc)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["ng-template", "ngbPaginationPages", ""]] }), v })(), Kh = (() => { class v { constructor(p) { this.pageCount = 0, this.pages = [], this.page = 1, this.pageChange = new i.vpe(!0), this.disabled = p.disabled, this.boundaryLinks = p.boundaryLinks, this.directionLinks = p.directionLinks, this.ellipses = p.ellipses, this.maxSize = p.maxSize, this.pageSize = p.pageSize, this.rotate = p.rotate, this.size = p.size } hasPrevious() { return this.page > 1 } hasNext() { return this.page < this.pageCount } nextDisabled() { return !this.hasNext() || this.disabled } previousDisabled() { return !this.hasPrevious() || this.disabled } selectPage(p) { this._updatePages(p) } ngOnChanges(p) { this._updatePages(this.page) } isEllipsis(p) { return -1 === p } _applyEllipses(p, T) { this.ellipses && (p > 0 && (p > 2 ? this.pages.unshift(-1) : 2 === p && this.pages.unshift(2), this.pages.unshift(1)), T < this.pageCount && (T < this.pageCount - 2 ? this.pages.push(-1) : T === this.pageCount - 2 && this.pages.push(this.pageCount - 1), this.pages.push(this.pageCount))) } _applyRotation() { let p = 0, T = this.pageCount, P = Math.floor(this.maxSize / 2); return this.page <= P ? T = this.maxSize : this.pageCount - this.page < P ? p = this.pageCount - this.maxSize : (p = this.page - P - 1, T = this.page + (this.maxSize % 2 == 0 ? P - 1 : P)), [p, T] } _applyPagination() { let T = (Math.ceil(this.page / this.maxSize) - 1) * this.maxSize; return [T, T + this.maxSize] } _setPageInRange(p) { const T = this.page; this.page = he(p, this.pageCount, 1), this.page !== T && Ft(this.collectionSize) && this.pageChange.emit(this.page) } _updatePages(p) { this.pageCount = Math.ceil(this.collectionSize / this.pageSize), Ft(this.pageCount) || (this.pageCount = 0), this.pages.length = 0; for (let T = 1; T <= this.pageCount; T++)this.pages.push(T); if (this._setPageInRange(p), this.maxSize > 0 && this.pageCount > this.maxSize) { let T = 0, P = this.pageCount;[T, P] = this.rotate ? this._applyRotation() : this._applyPagination(), this.pages = this.pages.slice(T, P), this._applyEllipses(T, P) } } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(Ro)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-pagination"]], contentQueries: function (p, T, P) { if (1 & p && (i.Suo(P, to, 5), i.Suo(P, yd, 5), i.Suo(P, Ma, 5), i.Suo(P, Tu, 5), i.Suo(P, jd, 5), i.Suo(P, wh, 5), i.Suo(P, Cl, 5)), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.tplEllipsis = Y.first), i.iGM(Y = i.CRH()) && (T.tplFirst = Y.first), i.iGM(Y = i.CRH()) && (T.tplLast = Y.first), i.iGM(Y = i.CRH()) && (T.tplNext = Y.first), i.iGM(Y = i.CRH()) && (T.tplNumber = Y.first), i.iGM(Y = i.CRH()) && (T.tplPrevious = Y.first), i.iGM(Y = i.CRH()) && (T.tplPages = Y.first) } }, hostAttrs: ["role", "navigation"], inputs: { disabled: "disabled", boundaryLinks: "boundaryLinks", directionLinks: "directionLinks", ellipses: "ellipses", rotate: "rotate", collectionSize: "collectionSize", maxSize: "maxSize", page: "page", pageSize: "pageSize", size: "size" }, outputs: { pageChange: "pageChange" }, features: [i.TTD], decls: 20, vars: 12, consts: function () { let A, p, T, P, Y, Re, Ke, yt; return A = $localize`:@@ngb.pagination.first:`, p = $localize`:@@ngb.pagination.previous:`, T = $localize`:@@ngb.pagination.next:`, P = $localize`:@@ngb.pagination.last:`, Y = $localize`:@@ngb.pagination.first-aria:First`, Re = $localize`:@@ngb.pagination.previous-aria:Previous`, Ke = $localize`:@@ngb.pagination.next-aria:Next`, yt = $localize`:@@ngb.pagination.last-aria:Last`, [["first", ""], ["previous", ""], ["next", ""], ["last", ""], ["ellipsis", ""], ["defaultNumber", ""], ["defaultPages", ""], ["class", "page-item", 3, "disabled", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["aria-hidden", "true"], A, p, T, P, ["class", "visually-hidden", 4, "ngIf"], [1, "visually-hidden"], ["class", "page-item", 3, "active", "disabled", 4, "ngFor", "ngForOf"], [1, "page-item"], ["class", "page-link", "tabindex", "-1", "aria-disabled", "true", 4, "ngIf"], ["class", "page-link", "href", "", 3, "click", 4, "ngIf"], ["tabindex", "-1", "aria-disabled", "true", 1, "page-link"], ["href", "", 1, "page-link", 3, "click"], ["aria-label", Y, "href", "", 1, "page-link", 3, "click"], ["aria-label", Re, "href", "", 1, "page-link", 3, "click"], ["aria-label", Ke, "href", "", 1, "page-link", 3, "click"], ["aria-label", yt, "href", "", 1, "page-link", 3, "click"]] }, template: function (p, T) { if (1 & p && (i.YNc(0, hr, 2, 0, "ng-template", null, 0, i.W1O), i.YNc(2, Xs, 2, 0, "ng-template", null, 1, i.W1O), i.YNc(4, Q, 2, 0, "ng-template", null, 2, i.W1O), i.YNc(6, q, 2, 0, "ng-template", null, 3, i.W1O), i.YNc(8, $, 1, 0, "ng-template", null, 4, i.W1O), i.YNc(10, Rt, 2, 2, "ng-template", null, 5, i.W1O), i.YNc(12, ql, 1, 1, "ng-template", null, 6, i.W1O), i.TgZ(14, "ul"), i.YNc(15, Fa, 3, 9, "li", 7), i.YNc(16, Kl, 3, 8, "li", 7), i.YNc(17, dl, 0, 0, "ng-template", 8), i.YNc(18, hs, 3, 9, "li", 7), i.YNc(19, hl, 3, 9, "li", 7), i.qZA()), 2 & p) { const P = i.MAs(13); i.xp6(14), i.Tol("pagination" + (T.size ? " pagination-" + T.size : "")), i.xp6(1), i.Q6J("ngIf", T.boundaryLinks), i.xp6(1), i.Q6J("ngIf", T.directionLinks), i.xp6(1), i.Q6J("ngTemplateOutlet", (null == T.tplPages ? null : T.tplPages.templateRef) || P)("ngTemplateOutletContext", i.kEZ(8, Co, T.page, T.pages, T.disabled)), i.xp6(1), i.Q6J("ngIf", T.directionLinks), i.xp6(1), i.Q6J("ngIf", T.boundaryLinks) } }, dependencies: [m.sg, m.O5, m.tP], encapsulation: 2, changeDetection: 0 }), v })(), vd = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(); class bd { constructor(A, p) { this.open = A, this.close = p, p || (this.close = A) } isManual() { return "manual" === this.open || "manual" === this.close } } const Pf = { hover: ["mouseenter", "mouseleave"], focus: ["focusin", "focusout"] }, ui = v => v > 0 ? (0, Kt.g)(v) : A => A; function $d(v, A, p, T, P, Y, Re = 0, Ke = 0) { const yt = function qu(v, A = Pf) { const p = (v || "").trim(); if (0 === p.length) return []; const T = p.split(/\s+/).map(Y => Y.split(":")).map(Y => { let Re = A[Y[0]] || Y; return new bd(Re[0], Re[1]) }), P = T.filter(Y => Y.isManual()); if (P.length > 1) throw "Triggers parse error: only one manual trigger is allowed"; if (1 === P.length && T.length > 1) throw "Triggers parse error: manual trigger can't be mixed with other triggers"; return T }(p); if (1 === yt.length && yt[0].isManual()) return () => { }; const Vt = function Rf(v, A, p, T) { return new J.y(P => { const Y = [], Re = () => P.next(!0), Ke = () => P.next(!1), yt = () => P.next(!T()); return p.forEach(Vt => { Vt.open === Vt.close ? Y.push(v.listen(A, Vt.open, yt)) : Y.push(v.listen(A, Vt.open, Re), v.listen(A, Vt.close, Ke)) }), () => { Y.forEach(Vt => Vt()) } }) }(v, A, yt, T).pipe(function Ff(v, A, p) { return T => { let P = null; const Y = T.pipe((0, Ne.U)(yt => ({ open: yt })), (0, Be.h)(yt => { const Vt = p(); return Vt === yt.open || P && P.open !== Vt ? (P && P.open !== yt.open && (P = null), !1) : (P = yt, !0) }), (0, qn.B)()), Re = Y.pipe((0, Be.h)(yt => yt.open), ui(v)), Ke = Y.pipe((0, Be.h)(yt => !yt.open), ui(A)); return (0, Qe.T)(Re, Ke).pipe((0, Be.h)(yt => yt === P && (P = null, yt.open !== p())), (0, Ne.U)(yt => yt.open)) } }(Re, Ke, T)).subscribe(Wt => Wt ? P() : Y()); return () => Vt.unsubscribe() } let wd = (() => { class v { constructor(p) { this._ngbConfig = p, this.autoClose = !0, this.placement = "auto", this.popperOptions = T => T, this.triggers = "click", this.disablePopover = !1, this.openDelay = 0, this.closeDelay = 0 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), oc = 0, Tl = (() => { class v { isTitleTemplate() { return this.title instanceof i.Rgc } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-popover-window"]], hostAttrs: ["role", "tooltip"], hostVars: 5, hostBindings: function (p, T) { 2 & p && (i.Ikx("id", T.id), i.Tol("popover" + (T.popoverClass ? " " + T.popoverClass : "")), i.ekj("fade", T.animation)) }, inputs: { animation: "animation", title: "title", id: "id", popoverClass: "popoverClass", context: "context" }, ngContentSelectors: zo, decls: 4, vars: 1, consts: [["data-popper-arrow", "", 1, "popover-arrow"], ["class", "popover-header", 4, "ngIf"], [1, "popover-body"], [1, "popover-header"], ["simpleTitle", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function (p, T) { 1 & p && (i.F$t(), i._UZ(0, "div", 0), i.YNc(1, Jl, 4, 2, "h3", 1), i.TgZ(2, "div", 2), i.Hsn(3), i.qZA()), 2 & p && (i.xp6(1), i.Q6J("ngIf", T.title)) }, dependencies: [m.O5, m.tP], encapsulation: 2, changeDetection: 0 }), v })(), il = (() => { class v { constructor(p, T, P, Y, Re, Ke, yt, Vt, Wt, vn) { this._elementRef = p, this._renderer = P, this._ngZone = yt, this._document = Vt, this._changeDetector = Wt, this.shown = new i.vpe, this.hidden = new i.vpe, this._ngbPopoverWindowId = "ngb-popover-" + oc++, this._windowRef = null, this.animation = Ke.animation, this.autoClose = Ke.autoClose, this.placement = Ke.placement, this.popperOptions = Ke.popperOptions, this.triggers = Ke.triggers, this.container = Ke.container, this.disablePopover = Ke.disablePopover, this.popoverClass = Ke.popoverClass, this.openDelay = Ke.openDelay, this.closeDelay = Ke.closeDelay, this._positioning = Ir(T), this._popupService = new vp(Tl, Y, Re, P, this._ngZone, vn) } _isDisabled() { return !(!this.disablePopover && (this.ngbPopover || this.popoverTitle)) } open(p) { if (!this._windowRef && !this._isDisabled()) { const { windowRef: T, transition$: P } = this._popupService.open(this.ngbPopover, p, this.animation); this._windowRef = T, this._windowRef.setInput("animation", this.animation), this._windowRef.setInput("title", this.popoverTitle), this._windowRef.setInput("context", p), this._windowRef.setInput("popoverClass", this.popoverClass), this._windowRef.setInput("id", this._ngbPopoverWindowId), this._renderer.setAttribute(this._getPositionTargetElement(), "aria-describedby", this._ngbPopoverWindowId), "body" === this.container && this._document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement), this._windowRef.changeDetectorRef.detectChanges(), this._windowRef.changeDetectorRef.markForCheck(), this._ngZone.runOutsideAngular(() => { this._positioning.createPopper({ hostElement: this._getPositionTargetElement(), targetElement: this._windowRef.location.nativeElement, placement: this.placement, appendToBody: "body" === this.container, baseClass: "bs-popover", updatePopperOptions: Y => this.popperOptions(ca([0, 8])(Y)) }), Promise.resolve().then(() => { this._positioning.update(), this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positioning.update()) }) }), Qo(this._ngZone, this._document, this.autoClose, () => this.close(), this.hidden, [this._windowRef.location.nativeElement]), P.subscribe(() => this.shown.emit()) } } close(p = this.animation) { this._windowRef && (this._renderer.removeAttribute(this._getPositionTargetElement(), "aria-describedby"), this._popupService.close(p).subscribe(() => { this._windowRef = null, this._positioning.destroy(), this._zoneSubscription?.unsubscribe(), this.hidden.emit(), this._changeDetector.markForCheck() })) } toggle() { this._windowRef ? this.close() : this.open() } isOpen() { return null != this._windowRef } ngOnInit() { this._unregisterListenersFn = $d(this._renderer, this._elementRef.nativeElement, this.triggers, this.isOpen.bind(this), this.open.bind(this), this.close.bind(this), +this.openDelay, +this.closeDelay) } ngOnChanges({ ngbPopover: p, popoverTitle: T, disablePopover: P, popoverClass: Y }) { Y && this.isOpen() && (this._windowRef.instance.popoverClass = Y.currentValue), (p || T || P) && this._isDisabled() && this.close() } ngOnDestroy() { this.close(!1), this._unregisterListenersFn?.() } _getPositionTargetElement() { return ($e(this.positionTarget) ? this._document.querySelector(this.positionTarget) : this.positionTarget) || this._elementRef.nativeElement } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq), i.Y36(_l), i.Y36(i.Qsj), i.Y36(i.zs3), i.Y36(i.s_b), i.Y36(wd), i.Y36(i.R0b), i.Y36(m.K0), i.Y36(i.sBO), i.Y36(i.z2F)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbPopover", ""]], inputs: { animation: "animation", autoClose: "autoClose", ngbPopover: "ngbPopover", popoverTitle: "popoverTitle", placement: "placement", popperOptions: "popperOptions", triggers: "triggers", positionTarget: "positionTarget", container: "container", disablePopover: "disablePopover", popoverClass: "popoverClass", openDelay: "openDelay", closeDelay: "closeDelay" }, outputs: { shown: "shown", hidden: "hidden" }, exportAs: ["ngbPopover"], features: [i.TTD] }), v })(), ac = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(), Yu = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(), Du = (() => { class v { constructor() { this.max = 10, this.readonly = !1, this.resettable = !1, this.tabindex = 0 } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), Zs = (() => { class v { constructor(p, T) { this._changeDetectorRef = T, this.contexts = [], this.disabled = !1, this.hover = new i.vpe, this.leave = new i.vpe, this.rateChange = new i.vpe(!0), this.onChange = P => { }, this.onTouched = () => { }, this.max = p.max, this.readonly = p.readonly, this.tabindex = p.tabindex } ariaValueText() { return `${this.nextRate} out of ${this.max}` } isInteractive() { return !this.readonly && !this.disabled } enter(p) { this.isInteractive() && this._updateState(p), this.hover.emit(p) } handleBlur() { this.onTouched() } handleClick(p) { this.isInteractive() && this.update(this.resettable && this.rate === p ? 0 : p) } handleKeyDown(p) { switch (p.which) { case Sr.ArrowDown: case Sr.ArrowLeft: this.update(this.rate - 1); break; case Sr.ArrowUp: case Sr.ArrowRight: this.update(this.rate + 1); break; case Sr.Home: this.update(0); break; case Sr.End: this.update(this.max); break; default: return }p.preventDefault() } ngOnChanges(p) { p.rate && this.update(this.rate), p.max && this._updateMax() } ngOnInit() { this._setupContexts(), this._updateState(this.rate) } registerOnChange(p) { this.onChange = p } registerOnTouched(p) { this.onTouched = p } reset() { this.leave.emit(this.nextRate), this._updateState(this.rate) } setDisabledState(p) { this.disabled = p } update(p, T = !0) { const P = he(p, this.max, 0); this.isInteractive() && this.rate !== P && (this.rate = P, this.rateChange.emit(this.rate)), T && (this.onChange(this.rate), this.onTouched()), this._updateState(this.rate) } writeValue(p) { this.update(p, !1), this._changeDetectorRef.markForCheck() } _updateState(p) { this.nextRate = p, this.contexts.forEach((T, P) => T.fill = Math.round(100 * he(p - P, 1, 0))) } _updateMax() { this.max > 0 && (this._setupContexts(), this.update(this.rate)) } _setupContexts() { this.contexts = Array.from({ length: this.max }, (p, T) => ({ fill: 0, index: T })) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(Du), i.Y36(i.sBO)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-rating"]], contentQueries: function (p, T, P) { if (1 & p && i.Suo(P, i.Rgc, 5), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.starTemplateFromContent = Y.first) } }, hostAttrs: ["role", "slider", "aria-valuemin", "0", 1, "d-inline-flex"], hostVars: 5, hostBindings: function (p, T) { 1 & p && i.NdJ("blur", function () { return T.handleBlur() })("keydown", function (Y) { return T.handleKeyDown(Y) })("mouseleave", function () { return T.reset() }), 2 & p && (i.Ikx("tabindex", T.disabled ? -1 : T.tabindex), i.uIk("aria-valuemax", T.max)("aria-valuenow", T.nextRate)("aria-valuetext", T.ariaValueText())("aria-disabled", !!T.readonly || null)) }, inputs: { max: "max", rate: "rate", readonly: "readonly", resettable: "resettable", starTemplate: "starTemplate", tabindex: "tabindex" }, outputs: { hover: "hover", leave: "leave", rateChange: "rateChange" }, features: [i._Bn([{ provide: kn.JU, useExisting: (0, i.Gpc)(() => v), multi: !0 }]), i.TTD], decls: 3, vars: 1, consts: [["t", ""], ["ngFor", "", 3, "ngForOf"], [1, "visually-hidden"], [3, "mouseenter", "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function (p, T) { 1 & p && (i.YNc(0, Ql, 1, 1, "ng-template", null, 0, i.W1O), i.YNc(2, Cc, 4, 5, "ng-template", 1)), 2 & p && (i.xp6(2), i.Q6J("ngForOf", T.contexts)) }, dependencies: [m.sg, m.tP], encapsulation: 2, changeDetection: 0 }), v })(), Wd = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(), br = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(); const yr = (v, A) => { const { classList: p } = v; if (A) return p.add("fade"), xr(v), p.add("show", "showing"), () => { p.remove("showing") }; p.add("show") }, Ni = ({ classList: v }) => (v.add("showing"), () => { v.remove("show", "showing") }); let Dl = (() => { class v { constructor(p) { this._ngbConfig = p, this.autohide = !0, this.delay = 5e3, this.ariaLive = "polite" } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), Ku = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbToastHeader", ""]] }), v })(), Lf = (() => { class v { constructor(p, T, P, Y) { this.ariaLive = p, this._zone = P, this._element = Y, this.contentHeaderTpl = null, this.shown = new i.vpe, this.hidden = new i.vpe, null == this.ariaLive && (this.ariaLive = T.ariaLive), this.delay = T.delay, this.autohide = T.autohide, this.animation = T.animation } ngAfterContentInit() { this._zone.onStable.asObservable().pipe((0, nt.q)(1)).subscribe(() => { this._init(), this.show() }) } ngOnChanges(p) { "autohide" in p && (this._clearTimeout(), this._init()) } hide() { this._clearTimeout(); const p = xi(this._zone, this._element.nativeElement, Ni, { animation: this.animation, runningTransition: "stop" }); return p.subscribe(() => { this.hidden.emit() }), p } show() { const p = xi(this._zone, this._element.nativeElement, yr, { animation: this.animation, runningTransition: "continue" }); return p.subscribe(() => { this.shown.emit() }), p } _init() { this.autohide && !this._timeoutID && (this._timeoutID = setTimeout(() => this.hide(), this.delay)) } _clearTimeout() { this._timeoutID && (clearTimeout(this._timeoutID), this._timeoutID = null) } } return v.\u0275fac = function (p) { return new (p || v)(i.$8M("aria-live"), i.Y36(Dl), i.Y36(i.R0b), i.Y36(i.SBq)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-toast"]], contentQueries: function (p, T, P) { if (1 & p && i.Suo(P, Ku, 7, i.Rgc), 2 & p) { let Y; i.iGM(Y = i.CRH()) && (T.contentHeaderTpl = Y.first) } }, hostAttrs: ["role", "alert", "aria-atomic", "true", 1, "toast"], hostVars: 3, hostBindings: function (p, T) { 2 & p && (i.uIk("aria-live", T.ariaLive), i.ekj("fade", T.animation)) }, inputs: { animation: "animation", delay: "delay", autohide: "autohide", header: "header" }, outputs: { shown: "shown", hidden: "hidden" }, exportAs: ["ngbToast"], features: [i.TTD], ngContentSelectors: zo, decls: 5, vars: 1, consts: function () { let A; return A = $localize`:@@ngb.toast.close-aria:Close`, [["headerTpl", ""], [3, "ngIf"], [1, "toast-body"], [1, "me-auto"], [1, "toast-header"], [3, "ngTemplateOutlet"], ["type", "button", "aria-label", A, 1, "btn-close", 3, "click"]] }, template: function (p, T) { 1 & p && (i.F$t(), i.YNc(0, La, 2, 1, "ng-template", null, 0, i.W1O), i.YNc(2, Ja, 3, 1, "ng-template", 1), i.TgZ(3, "div", 2), i.Hsn(4), i.qZA()), 2 & p && (i.xp6(2), i.Q6J("ngIf", T.contentHeaderTpl || T.header)) }, dependencies: [m.O5, m.tP], styles: ["ngb-toast{display:block}ngb-toast .toast-header .close{margin-left:auto;margin-bottom:.25rem}\n"], encapsulation: 2 }), v })(), su = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(), Fc = (() => { class v { constructor(p) { this._ngbConfig = p, this.autoClose = !0, this.placement = "auto", this.popperOptions = T => T, this.triggers = "hover focus", this.disableTooltip = !1, this.openDelay = 0, this.closeDelay = 0 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), lc = 0, Su = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-tooltip-window"]], hostAttrs: ["role", "tooltip"], hostVars: 5, hostBindings: function (p, T) { 2 & p && (i.Ikx("id", T.id), i.Tol("tooltip" + (T.tooltipClass ? " " + T.tooltipClass : "")), i.ekj("fade", T.animation)) }, inputs: { animation: "animation", id: "id", tooltipClass: "tooltipClass" }, ngContentSelectors: zo, decls: 3, vars: 0, consts: [["data-popper-arrow", "", 1, "tooltip-arrow"], [1, "tooltip-inner"]], template: function (p, T) { 1 & p && (i.F$t(), i._UZ(0, "div", 0), i.TgZ(1, "div", 1), i.Hsn(2), i.qZA()) }, encapsulation: 2, changeDetection: 0 }), v })(), Eh = (() => { class v { constructor(p, T, P, Y, Re, Ke, yt, Vt, Wt, vn) { this._elementRef = p, this._renderer = P, this._ngZone = yt, this._document = Vt, this._changeDetector = Wt, this.shown = new i.vpe, this.hidden = new i.vpe, this._ngbTooltipWindowId = "ngb-tooltip-" + lc++, this._windowRef = null, this.animation = Ke.animation, this.autoClose = Ke.autoClose, this.placement = Ke.placement, this.popperOptions = Ke.popperOptions, this.triggers = Ke.triggers, this.container = Ke.container, this.disableTooltip = Ke.disableTooltip, this.tooltipClass = Ke.tooltipClass, this.openDelay = Ke.openDelay, this.closeDelay = Ke.closeDelay, this._popupService = new vp(Su, Y, Re, P, this._ngZone, vn), this._positioning = Ir(T) } set ngbTooltip(p) { this._ngbTooltip = p, !p && this._windowRef && this.close() } get ngbTooltip() { return this._ngbTooltip } open(p) { if (!this._windowRef && this._ngbTooltip && !this.disableTooltip) { const { windowRef: T, transition$: P } = this._popupService.open(this._ngbTooltip, p, this.animation); this._windowRef = T, this._windowRef.setInput("animation", this.animation), this._windowRef.setInput("tooltipClass", this.tooltipClass), this._windowRef.setInput("id", this._ngbTooltipWindowId), this._renderer.setAttribute(this._getPositionTargetElement(), "aria-describedby", this._ngbTooltipWindowId), "body" === this.container && this._document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement), this._windowRef.changeDetectorRef.detectChanges(), this._windowRef.changeDetectorRef.markForCheck(), this._ngZone.runOutsideAngular(() => { this._positioning.createPopper({ hostElement: this._getPositionTargetElement(), targetElement: this._windowRef.location.nativeElement, placement: this.placement, appendToBody: "body" === this.container, baseClass: "bs-tooltip", updatePopperOptions: Y => this.popperOptions(Y) }), Promise.resolve().then(() => { this._positioning.update(), this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positioning.update()) }) }), Qo(this._ngZone, this._document, this.autoClose, () => this.close(), this.hidden, [this._windowRef.location.nativeElement]), P.subscribe(() => this.shown.emit()) } } close(p = this.animation) { null != this._windowRef && (this._renderer.removeAttribute(this._getPositionTargetElement(), "aria-describedby"), this._popupService.close(p).subscribe(() => { this._windowRef = null, this._positioning.destroy(), this._zoneSubscription?.unsubscribe(), this.hidden.emit(), this._changeDetector.markForCheck() })) } toggle() { this._windowRef ? this.close() : this.open() } isOpen() { return null != this._windowRef } ngOnInit() { this._unregisterListenersFn = $d(this._renderer, this._elementRef.nativeElement, this.triggers, this.isOpen.bind(this), this.open.bind(this), this.close.bind(this), +this.openDelay, +this.closeDelay) } ngOnChanges({ tooltipClass: p }) { p && this.isOpen() && (this._windowRef.instance.tooltipClass = p.currentValue) } ngOnDestroy() { this.close(!1), this._unregisterListenersFn?.() } _getPositionTargetElement() { return ($e(this.positionTarget) ? this._document.querySelector(this.positionTarget) : this.positionTarget) || this._elementRef.nativeElement } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq), i.Y36(_l), i.Y36(i.Qsj), i.Y36(i.zs3), i.Y36(i.s_b), i.Y36(Fc), i.Y36(i.R0b), i.Y36(m.K0), i.Y36(i.sBO), i.Y36(i.z2F)) }, v.\u0275dir = i.lG2({ type: v, selectors: [["", "ngbTooltip", ""]], inputs: { animation: "animation", autoClose: "autoClose", placement: "placement", popperOptions: "popperOptions", triggers: "triggers", positionTarget: "positionTarget", container: "container", disableTooltip: "disableTooltip", tooltipClass: "tooltipClass", openDelay: "openDelay", closeDelay: "closeDelay", ngbTooltip: "ngbTooltip" }, outputs: { shown: "shown", hidden: "hidden" }, exportAs: ["ngbTooltip"], features: [i.TTD] }), v })(), Lc = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({}), v })(), ea = (() => { class v { constructor() { this.highlightClass = "ngb-highlight", this.accentSensitive = !0 } ngOnChanges(p) { !this.accentSensitive && !String.prototype.normalize && (console.warn("The `accentSensitive` input in `ngb-highlight` cannot be set to `false` in a browser that does not implement the `String.normalize` function. You will have to include a polyfill in your application to use this feature in the current browser."), this.accentSensitive = !0); const T = Z(this.result), P = Array.isArray(this.term) ? this.term : [this.term], Y = Vt => this.accentSensitive ? Vt : mi(Vt), Re = P.map(Vt => function kr(v) { return v.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") }(Y(Z(Vt)))).filter(Vt => Vt), Ke = this.accentSensitive ? T : mi(T), yt = Re.length ? Ke.split(new RegExp(`(${Re.join("|")})`, "gmi")) : [T]; if (this.accentSensitive) this.parts = yt; else { let Vt = 0; this.parts = yt.map(Wt => T.substring(Vt, Vt += Wt.length)) } } } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-highlight"]], inputs: { highlightClass: "highlightClass", result: "result", term: "term", accentSensitive: "accentSensitive" }, features: [i.TTD], decls: 1, vars: 1, consts: [["ngFor", "", 3, "ngForOf"], [3, "class", 4, "ngIf", "ngIfElse"], ["even", ""]], template: function (p, T) { 1 & p && i.YNc(0, Da, 3, 2, "ng-template", 0), 2 & p && i.Q6J("ngForOf", T.parts) }, dependencies: [m.sg, m.O5], styles: [".ngb-highlight{font-weight:700}\n"], encapsulation: 2, changeDetection: 0 }), v })(); new i.OlP("live announcer delay", { providedIn: "root", factory: function Ed() { return 100 } }); let Xu = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [m.ez] }), v })(); var Sh = (() => { return (v = Sh || (Sh = {}))[v.BACKDROP_CLICK = 0] = "BACKDROP_CLICK", v[v.ESC = 1] = "ESC", Sh; var v })(); let Bc = (() => { class v { constructor(p, T) { this._el = p, this._zone = T, this.dismissEvent = new i.vpe } ngOnInit() { this._zone.onStable.asObservable().pipe((0, nt.q)(1)).subscribe(() => { xi(this._zone, this._el.nativeElement, (p, T) => { T && xr(p), p.classList.add("show") }, { animation: this.animation, runningTransition: "continue" }) }) } hide() { return xi(this._zone, this._el.nativeElement, ({ classList: p }) => p.remove("show"), { animation: this.animation, runningTransition: "stop" }) } dismiss() { this.static || this.dismissEvent.emit(Sh.BACKDROP_CLICK) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(i.SBq), i.Y36(i.R0b)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-offcanvas-backdrop"]], hostVars: 6, hostBindings: function (p, T) { 1 & p && i.NdJ("mousedown", function () { return T.dismiss() }), 2 & p && (i.Tol("offcanvas-backdrop" + (T.backdropClass ? " " + T.backdropClass : "")), i.ekj("show", !T.animation)("fade", T.animation)) }, inputs: { animation: "animation", backdropClass: "backdropClass", static: "static" }, outputs: { dismissEvent: "dismiss" }, decls: 0, vars: 0, template: function (p, T) { }, encapsulation: 2 }), v })(), Bf = (() => { class v { constructor(p, T, P) { this._document = p, this._elRef = T, this._zone = P, this._closed$ = new we.x, this._elWithFocus = null, this.keyboard = !0, this.position = "start", this.dismissEvent = new i.vpe, this.shown = new we.x, this.hidden = new we.x } dismiss(p) { this.dismissEvent.emit(p) } ngOnInit() { this._elWithFocus = this._document.activeElement, this._zone.onStable.asObservable().pipe((0, nt.q)(1)).subscribe(() => { this._show() }) } ngOnDestroy() { this._disableEventHandling() } hide() { const { nativeElement: p } = this._elRef, P = xi(this._zone, this._elRef.nativeElement, Y => (p.classList.remove("showing"), p.classList.add("hiding"), () => p.classList.remove("show", "hiding")), { animation: this.animation, runningTransition: "stop" }); return P.subscribe(() => { this.hidden.next(), this.hidden.complete() }), this._disableEventHandling(), this._restoreFocus(), P } _show() { xi(this._zone, this._elRef.nativeElement, (P, Y) => (Y && xr(P), P.classList.add("show", "showing"), () => P.classList.remove("showing")), { animation: this.animation, runningTransition: "continue" }).subscribe(() => { this.shown.next(), this.shown.complete() }), this._enableEventHandling(), this._setFocus() } _enableEventHandling() { const { nativeElement: p } = this._elRef; this._zone.runOutsideAngular(() => { (0, Te.R)(p, "keydown").pipe((0, Ve.R)(this._closed$), (0, Be.h)(T => T.which === Sr.Escape)).subscribe(T => { this.keyboard && requestAnimationFrame(() => { T.defaultPrevented || this._zone.run(() => this.dismiss(Sh.ESC)) }) }) }) } _disableEventHandling() { this._closed$.next() } _setFocus() { const { nativeElement: p } = this._elRef; if (!p.contains(document.activeElement)) { const T = p.querySelector("[ngbAutofocus]"), P = la(p)[0]; (T || P || p).focus() } } _restoreFocus() { const p = this._document.body, T = this._elWithFocus; let P; P = T && T.focus && p.contains(T) ? T : p, this._zone.runOutsideAngular(() => { setTimeout(() => P.focus()), this._elWithFocus = null }) } } return v.\u0275fac = function (p) { return new (p || v)(i.Y36(m.K0), i.Y36(i.SBq), i.Y36(i.R0b)) }, v.\u0275cmp = i.Xpm({ type: v, selectors: [["ngb-offcanvas-panel"]], hostAttrs: ["role", "dialog", "tabindex", "-1"], hostVars: 5, hostBindings: function (p, T) { 2 & p && (i.uIk("aria-modal", !0)("aria-labelledby", T.ariaLabelledBy)("aria-describedby", T.ariaDescribedBy), i.Tol("offcanvas offcanvas-" + T.position + (T.panelClass ? " " + T.panelClass : ""))) }, inputs: { animation: "animation", ariaLabelledBy: "ariaLabelledBy", ariaDescribedBy: "ariaDescribedBy", keyboard: "keyboard", panelClass: "panelClass", position: "position" }, outputs: { dismissEvent: "dismiss" }, ngContentSelectors: zo, decls: 1, vars: 0, template: function (p, T) { 1 & p && (i.F$t(), i.Hsn(0)) }, encapsulation: 2 }), v })(); class Td { close(A) { } dismiss(A) { } } class Ih { constructor(A, p, T, P) { this._panelCmptRef = A, this._contentRef = p, this._backdropCmptRef = T, this._beforeDismiss = P, this._closed = new we.x, this._dismissed = new we.x, this._hidden = new we.x, A.instance.dismissEvent.subscribe(Y => { this.dismiss(Y) }), T && T.instance.dismissEvent.subscribe(Y => { this.dismiss(Y) }), this.result = new Promise((Y, Re) => { this._resolve = Y, this._reject = Re }), this.result.then(null, () => { }) } get componentInstance() { if (this._contentRef && this._contentRef.componentRef) return this._contentRef.componentRef.instance } get closed() { return this._closed.asObservable().pipe((0, Ve.R)(this._hidden)) } get dismissed() { return this._dismissed.asObservable().pipe((0, Ve.R)(this._hidden)) } get hidden() { return this._hidden.asObservable() } get shown() { return this._panelCmptRef.instance.shown.asObservable() } close(A) { this._panelCmptRef && (this._closed.next(A), this._resolve(A), this._removeOffcanvasElements()) } _dismiss(A) { this._dismissed.next(A), this._reject(A), this._removeOffcanvasElements() } dismiss(A) { if (this._panelCmptRef) if (this._beforeDismiss) { const p = this._beforeDismiss(); ri(p) ? p.then(T => { !1 !== T && this._dismiss(A) }, () => { }) : !1 !== p && this._dismiss(A) } else this._dismiss(A) } _removeOffcanvasElements() { const A = this._panelCmptRef.instance.hide(), p = this._backdropCmptRef ? this._backdropCmptRef.instance.hide() : (0, Ce.of)(void 0); A.subscribe(() => { const { nativeElement: T } = this._panelCmptRef.location; T.parentNode.removeChild(T), this._panelCmptRef.destroy(), this._contentRef && this._contentRef.viewRef && this._contentRef.viewRef.destroy(), this._panelCmptRef = null, this._contentRef = null }), p.subscribe(() => { if (this._backdropCmptRef) { const { nativeElement: T } = this._backdropCmptRef.location; T.parentNode.removeChild(T), this._backdropCmptRef.destroy(), this._backdropCmptRef = null } }), (0, _t.$)(A, p).subscribe(() => { this._hidden.next(), this._hidden.complete() }) } } let Zd = (() => { class v { constructor(p, T, P, Y, Re) { this._applicationRef = p, this._injector = T, this._document = P, this._scrollBar = Y, this._ngZone = Re, this._activePanelCmptHasChanged = new we.x, this._scrollBarRestoreFn = null, this._backdropAttributes = ["animation", "backdropClass"], this._panelAttributes = ["animation", "ariaDescribedBy", "ariaLabelledBy", "keyboard", "panelClass", "position"], this._activeInstance = new i.vpe, this._activePanelCmptHasChanged.subscribe(() => { this._panelCmpt && ps(this._ngZone, this._panelCmpt.location.nativeElement, this._activePanelCmptHasChanged) }) } _restoreScrollBar() { const p = this._scrollBarRestoreFn; p && (this._scrollBarRestoreFn = null, p()) } _hideScrollBar() { this._scrollBarRestoreFn || (this._scrollBarRestoreFn = this._scrollBar.hide()) } open(p, T, P) { const Y = P.container instanceof HTMLElement ? P.container : Nn(P.container) ? this._document.querySelector(P.container) : this._document.body; if (!Y) throw new Error(`The specified offcanvas container "${P.container || "body"}" was not found in the DOM.`); P.scroll || this._hideScrollBar(); const Re = new Td, Ke = this._getContentRef(P.injector || p, T, Re); let yt = !1 !== P.backdrop ? this._attachBackdrop(Y) : void 0, Vt = this._attachWindowComponent(Y, Ke.nodes), Wt = new Ih(Vt, Ke, yt, P.beforeDismiss); return this._registerOffcanvasRef(Wt), this._registerPanelCmpt(Vt), Wt.hidden.pipe((0, nr.x)(() => this._restoreScrollBar())).subscribe(), Re.close = vn => { Wt.close(vn) }, Re.dismiss = vn => { Wt.dismiss(vn) }, this._applyPanelOptions(Vt.instance, P), yt && yt.instance && (this._applyBackdropOptions(yt.instance, P), yt.changeDetectorRef.detectChanges()), Vt.changeDetectorRef.detectChanges(), Wt } get activeInstance() { return this._activeInstance } dismiss(p) { this._offcanvasRef?.dismiss(p) } hasOpenOffcanvas() { return !!this._offcanvasRef } _attachBackdrop(p) { let T = (0, i.LMc)(Bc, { environmentInjector: this._applicationRef.injector, elementInjector: this._injector }); return this._applicationRef.attachView(T.hostView), p.appendChild(T.location.nativeElement), T } _attachWindowComponent(p, T) { let P = (0, i.LMc)(Bf, { environmentInjector: this._applicationRef.injector, elementInjector: this._injector, projectableNodes: T }); return this._applicationRef.attachView(P.hostView), p.appendChild(P.location.nativeElement), P } _applyPanelOptions(p, T) { this._panelAttributes.forEach(P => { Nn(T[P]) && (p[P] = T[P]) }) } _applyBackdropOptions(p, T) { this._backdropAttributes.forEach(P => { Nn(T[P]) && (p[P] = T[P]) }), p.static = "static" === T.backdrop } _getContentRef(p, T, P) { return T ? T instanceof i.Rgc ? this._createFromTemplateRef(T, P) : $e(T) ? this._createFromString(T) : this._createFromComponent(p, T, P) : new ws([]) } _createFromTemplateRef(p, T) { const Y = p.createEmbeddedView({ $implicit: T, close(Re) { T.close(Re) }, dismiss(Re) { T.dismiss(Re) } }); return this._applicationRef.attachView(Y), new ws([Y.rootNodes], Y) } _createFromString(p) { const T = this._document.createTextNode(`${p}`); return new ws([[T]]) } _createFromComponent(p, T, P) { const Y = i.zs3.create({ providers: [{ provide: Td, useValue: P }], parent: p }), Re = (0, i.LMc)(T, { environmentInjector: this._applicationRef.injector, elementInjector: Y }), Ke = Re.location.nativeElement; return this._applicationRef.attachView(Re.hostView), new ws([[Ke]], Re.hostView, Re) } _registerOffcanvasRef(p) { const T = () => { this._offcanvasRef = void 0, this._activeInstance.emit(this._offcanvasRef) }; this._offcanvasRef = p, this._activeInstance.emit(this._offcanvasRef), p.result.then(T, T) } _registerPanelCmpt(p) { this._panelCmpt = p, this._activePanelCmptHasChanged.next(), p.onDestroy(() => { this._panelCmpt = void 0, this._activePanelCmptHasChanged.next() }) } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(i.z2F), i.LFG(i.zs3), i.LFG(m.K0), i.LFG(vh), i.LFG(i.R0b)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), qd = (() => { class v { constructor(p) { this._ngbConfig = p, this.backdrop = !0, this.keyboard = !0, this.position = "start", this.scroll = !1 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(p) { this._animation = p } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(qo)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), ks = (() => { class v { constructor(p, T, P) { this._injector = p, this._offcanvasStack = T, this._config = P } open(p, T = {}) { const P = { ...this._config, animation: this._config.animation, ...T }; return this._offcanvasStack.open(this._injector, p, P) } get activeInstance() { return this._offcanvasStack.activeInstance } dismiss(p) { this._offcanvasStack.dismiss(p) } hasOpenOffcanvas() { return this._offcanvasStack.hasOpenOffcanvas() } } return v.\u0275fac = function (p) { return new (p || v)(i.LFG(i.zs3), i.LFG(Zd), i.LFG(qd)) }, v.\u0275prov = i.Yz7({ token: v, factory: v.\u0275fac, providedIn: "root" }), v })(), ou = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({}), v })(); const Yd = [Sc, Lu, xc, Vs, Oi, Xr, gd, wl, ou, vd, ac, Yu, Wd, br, su, Lc, Xu]; let Vc = (() => { class v { } return v.\u0275fac = function (p) { return new (p || v) }, v.\u0275mod = i.oAB({ type: v }), v.\u0275inj = i.cJS({ imports: [Yd, Sc, Lu, xc, Vs, Oi, Xr, gd, wl, ou, vd, ac, Yu, Wd, br, su, Lc, Xu] }), v })() }, 259: (un, Je, L) => { "use strict"; L.d(Je, { C6: () => i.getApps, Mq: () => i.getApp }); var i = L(9681); (0, i.registerVersion)("firebase", "9.15.0", "app") }, 9260: (un, Je, L) => { "use strict"; L.d(Je, { Z: () => i.Z }); var i = L(3942); i.Z.registerVersion("firebase", "9.15.0", "app-compat") }, 9169: (un, Je, L) => { "use strict"; L.r(Je); var i = L(5861), m = L(3942), J = L(2090), ye = L(9681), Ce = L(1877), we = L(655), Te = L(4859); const rt = function gt() { return { "admin-restricted-operation": "This operation is restricted to administrators only.", "argument-error": "", "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use MasterAuthentication with the provided API key. Review your key configuration in the Google API console.", "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.", "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.", "code-expired": "The SMS code has expired. Please re-send the verification code to try again.", "cordova-not-ready": "Cordova framework is not ready.", "cors-unsupported": "This browser is not supported.", "credential-already-in-use": "This credential is already associated with a different user account.", "custom-token-mismatch": "The custom token corresponds to a different audience.", "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.", "dependent-sdk-initialized-before-auth": "Another MasterSDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other MasterSDK.", "dynamic-link-not-activated": "Please activate Dynamic Links in the MasterConsole and agree to the terms and conditions.", "email-change-needs-verification": "Multi-factor users must always have a verified email.", "email-already-in-use": "The email address is already in use by another account.", "emulator-config-failed": 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.', "expired-action-code": "The action code has expired.", "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.", "internal-error": "An internal AuthError has occurred.", "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.", "invalid-app-id": "The mobile app identifier is not registed for the current project.", "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.", "invalid-auth-event": "An internal AuthError has occurred.", "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.", "invalid-continue-uri": "The continue URL provided in the request is invalid.", "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.", "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.", "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.", "invalid-email": "The email address is badly formatted.", "invalid-emulator-scheme": "Emulator URL must start with a valid scheme (http:// or https://).", "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.", "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.", "invalid-credential": "The supplied auth credential is malformed or has expired.", "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the MasterConsole.", "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.", "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.", "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.", "unauthorized-domain": "This domain is not authorized for OAuth operations for your Masterproject. Edit the list of authorized domains from the Masterconsole.", "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.", "wrong-password": "The password is invalid or the user does not have a password.", "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.", "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].", "invalid-provider-id": "The specified provider ID is invalid.", "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.", "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the MasterConsole.", "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.", "invalid-tenant-id": "The Auth instance's tenant ID is invalid.", "login-blocked": "Login blocked by user-provided method: {$originalMessage}", "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.", "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Masterconsole.", "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.", "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.", "missing-continue-uri": "A continue URL must be provided in the request.", "missing-iframe-start": "An internal AuthError has occurred.", "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.", "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.", "missing-multi-factor-info": "No second factor identifier is provided.", "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.", "missing-phone-number": "To send verification codes, provide a phone number for the recipient.", "missing-verification-id": "The phone auth credential was created with an empty verification ID.", "app-deleted": "This instance of FirebaseApp has been deleted.", "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.", "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.", "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.", "network-request-failed": "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.", "no-auth-event": "An internal AuthError has occurred.", "no-such-provider": "User was not linked to an account with the given provider.", "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.", "operation-not-allowed": "The given sign-in provider is disabled for this Masterproject. Enable it in the Masterconsole, under the sign-in method tab of the Auth section.", "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.', "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.", "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.", "provider-already-linked": "User can only be linked to one identity for the given provider.", "quota-exceeded": "The project's quota for this operation has been exceeded.", "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.", "redirect-operation-pending": "A redirect sign-in operation is already pending.", "rejected-credential": "The request contains malformed or mismatching credentials.", "second-factor-already-in-use": "The second factor is already enrolled on this account.", "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.", "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID", timeout: "The operation has timed out.", "user-token-expired": "The user's credential is no longer valid. The user must sign in again.", "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.", "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Masterconsole.", "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.", "unsupported-persistence-type": "The current environment does not support the specified persistence type.", "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.", "unverified-email": "The operation requires a verified email.", "user-cancelled": "The user did not grant your application the permissions it requested.", "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.", "user-disabled": "The user account has been disabled by an administrator.", "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.", "user-signed-out": "", "weak-password": "The password must be 6 characters long or more.", "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled.", "already-initialized": "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance." } }, wt = function Se() { return { "dependent-sdk-initialized-before-auth": "Another MasterSDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other MasterSDK." } }, De = new J.LL("auth", "Firebase", { "dependent-sdk-initialized-before-auth": "Another MasterSDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other MasterSDK." }), _t = new Ce.Yd("@firebase/auth"); function Qe(O, ...C) { _t.logLevel <= Ce.in.ERROR && _t.error(`Auth (${ye.SDK_VERSION}): ${O}`, ...C) } function ct(O, ...C) { throw nt(O, ...C) } function Oe(O, ...C) { return nt(O, ...C) } function Ve(O, C, S) { const F = Object.assign(Object.assign({}, wt()), { [C]: S }); return new J.LL("auth", "Firebase", F).create(C, { appName: O.name }) } function Be(O, C, S) { if (!(C instanceof S)) throw S.name !== C.constructor.name && ct(O, "argument-error"), Ve(O, "argument-error", `Type of ${C.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`) } function nt(O, ...C) { if ("string" != typeof O) { const S = C[0], F = [...C.slice(1)]; return F[0] && (F[0].appName = O.name), O._errorFactory.create(S, ...F) } return De.create(O, ...C) } function Ne(O, C, ...S) { if (!O) throw nt(C, ...S) } function tt(O) { const C = "INTERNAL ASSERTION FAILED: " + O; throw Qe(C), new Error(C) } function Fe(O, C) { O || tt(C) } const Ue = new Map; function st(O) { Fe(O instanceof Function, "Expected a class definition"); let C = Ue.get(O); return C ? (Fe(C instanceof O, "Instance stored in cache mismatched with class"), C) : (C = new O, Ue.set(O, C), C) } function rn() { var O; return typeof self < "u" && (null === (O = self.location) || void 0 === O ? void 0 : O.href) || "" } function On() { return "http:" === qn() || "https:" === qn() } function qn() { var O; return typeof self < "u" && (null === (O = self.location) || void 0 === O ? void 0 : O.protocol) || null } class fn { constructor(C, S) { this.shortDelay = C, this.longDelay = S, Fe(S > C, "Short delay should be less than long delay!"), this.isMobile = (0, J.uI)() || (0, J.b$)() } get() { return function nr() { return !(typeof navigator < "u" && navigator && "onLine" in navigator && "boolean" == typeof navigator.onLine && (On() || (0, J.ru)() || "connection" in navigator)) || navigator.onLine }() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay) } } function It(O, C) { Fe(O.emulator, "Emulator should always be set here"); const { url: S } = O.emulator; return C ? `${S}${C.startsWith("/") ? C.slice(1) : C}` : S } class Yt { static initialize(C, S, F) { this.fetchImpl = C, S && (this.headersImpl = S), F && (this.responseImpl = F) } static fetch() { return this.fetchImpl ? this.fetchImpl : typeof self < "u" && "fetch" in self ? self.fetch : void tt("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static headers() { return this.headersImpl ? this.headersImpl : typeof self < "u" && "Headers" in self ? self.Headers : void tt("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static response() { return this.responseImpl ? this.responseImpl : typeof self < "u" && "Response" in self ? self.Response : void tt("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } } const pt = { CREDENTIAL_MISMATCH: "custom-token-mismatch", MISSING_CUSTOM_TOKEN: "internal-error", INVALID_IDENTIFIER: "invalid-email", MISSING_CONTINUE_URI: "internal-error", INVALID_PASSWORD: "wrong-password", MISSING_PASSWORD: "internal-error", EMAIL_EXISTS: "email-already-in-use", PASSWORD_LOGIN_DISABLED: "operation-not-allowed", INVALID_IDP_RESPONSE: "invalid-credential", INVALID_PENDING_TOKEN: "invalid-credential", FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use", MISSING_REQ_TYPE: "internal-error", EMAIL_NOT_FOUND: "user-not-found", RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests", EXPIRED_OOB_CODE: "expired-action-code", INVALID_OOB_CODE: "invalid-action-code", MISSING_OOB_CODE: "internal-error", CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login", INVALID_ID_TOKEN: "invalid-user-token", TOKEN_EXPIRED: "user-token-expired", USER_NOT_FOUND: "user-token-expired", TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests", INVALID_CODE: "invalid-verification-code", INVALID_SESSION_INFO: "invalid-verification-id", INVALID_TEMPORARY_PROOF: "invalid-credential", MISSING_SESSION_INFO: "missing-verification-id", SESSION_EXPIRED: "code-expired", MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name", UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri", INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id", ADMIN_ONLY_OPERATION: "admin-restricted-operation", INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session", MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found", MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info", MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session", SECOND_FACTOR_EXISTS: "second-factor-already-in-use", SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded", BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error" }, Pt = new fn(3e4, 6e4); function Ze(O, C) { return O.tenantId && !C.tenantId ? Object.assign(Object.assign({}, C), { tenantId: O.tenantId }) : C } function Ot(O, C, S, F) { return le.apply(this, arguments) } function le() { return (le = (0, i.Z)(function* (O, C, S, F, ie = {}) { return Xe(O, ie, (0, i.Z)(function* () { let ge = {}, Tt = {}; F && ("GET" === C ? Tt = F : ge = { body: JSON.stringify(F) }); const tn = (0, J.xO)(Object.assign({ key: O.config.apiKey }, Tt)).slice(1), Pn = yield O._getAdditionalHeaders(); return Pn["Content-Type"] = "application/json", O.languageCode && (Pn["X-Firebase-Locale"] = O.languageCode), Yt.fetch()(wn(O, O.config.apiHost, S, tn), Object.assign({ method: C, headers: Pn, referrerPolicy: "no-referrer" }, ge)) })) })).apply(this, arguments) } function Xe(O, C, S) { return kt.apply(this, arguments) } function kt() { return (kt = (0, i.Z)(function* (O, C, S) { O._canInitEmulator = !1; const F = Object.assign(Object.assign({}, pt), C); try { const ie = new Jn(O), ge = yield Promise.race([S(), ie.promise]); ie.clearNetworkTimeout(); const Tt = yield ge.json(); if ("needConfirmation" in Tt) throw or(O, "account-exists-with-different-credential", Tt); if (ge.ok && !("errorMessage" in Tt)) return Tt; { const tn = ge.ok ? Tt.errorMessage : Tt.error.message, [Pn, tr] = tn.split(" : "); if ("FEDERATED_USER_ID_ALREADY_LINKED" === Pn) throw or(O, "credential-already-in-use", Tt); if ("EMAIL_EXISTS" === Pn) throw or(O, "email-already-in-use", Tt); if ("USER_DISABLED" === Pn) throw or(O, "user-disabled", Tt); const br = F[Pn] || Pn.toLowerCase().replace(/[_\s]+/g, "-"); if (tr) throw Ve(O, br, tr); ct(O, br) } } catch (ie) { if (ie instanceof J.ZR) throw ie; ct(O, "network-request-failed") } })).apply(this, arguments) } function an(O, C, S, F) { return jt.apply(this, arguments) } function jt() { return (jt = (0, i.Z)(function* (O, C, S, F, ie = {}) { const ge = yield Ot(O, C, S, F, ie); return "mfaPendingCredential" in ge && ct(O, "multi-factor-auth-required", { _serverResponse: ge }), ge })).apply(this, arguments) } function wn(O, C, S, F) { const ie = `${C}${S}?${F}`; return O.config.emulator ? It(O.config, ie) : `${O.config.apiScheme}://${ie}` } class Jn { constructor(C) { this.auth = C, this.timer = null, this.promise = new Promise((S, F) => { this.timer = setTimeout(() => F(Oe(this.auth, "network-request-failed")), Pt.get()) }) } clearNetworkTimeout() { clearTimeout(this.timer) } } function or(O, C, S) { const F = { appName: O.name }; S.email && (F.email = S.email), S.phoneNumber && (F.phoneNumber = S.phoneNumber); const ie = Oe(O, C, F); return ie.customData._tokenResponse = S, ie } function dn() { return (dn = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:delete", C) })).apply(this, arguments) } function ue(O, C) { return it.apply(this, arguments) } function it() { return (it = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:update", C) })).apply(this, arguments) } function lt(O, C) { return Nt.apply(this, arguments) } function Nt() { return (Nt = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:lookup", C) })).apply(this, arguments) } function gn(O) { if (O) try { const C = new Date(Number(O)); if (!isNaN(C.getTime())) return C.toUTCString() } catch { } } function pn() { return (pn = (0, i.Z)(function* (O, C = !1) { const S = (0, J.m9)(O), F = yield S.getIdToken(C), ie = yn(F); Ne(ie && ie.exp && ie.auth_time && ie.iat, S.auth, "internal-error"); const ge = "object" == typeof ie.Master? ie.Master: void 0, Tt = ge?.sign_in_provider; return { claims: ie, token: F, authTime: gn(Fn(ie.auth_time)), issuedAtTime: gn(Fn(ie.iat)), expirationTime: gn(Fn(ie.exp)), signInProvider: Tt || null, signInSecondFactor: ge?.sign_in_second_factor || null } })).apply(this, arguments) } function Fn(O) { return 1e3 * Number(O) } function yn(O) { const [C, S, F] = O.split("."); if (void 0 === C || void 0 === S || void 0 === F) return Qe("JWT malformed, contained fewer than 3 sections"), null; try { const ie = (0, J.tV)(S); return ie ? JSON.parse(ie) : (Qe("Failed to decode base64 JWT payload"), null) } catch (ie) { return Qe("Caught error parsing JWT payload as JSON", ie?.toString()), null } } function ur(O, C) { return dr.apply(this, arguments) } function dr() { return (dr = (0, i.Z)(function* (O, C, S = !1) { if (S) return C; try { return yield C } catch (F) { throw F instanceof J.ZR && Kr(F) && O.auth.currentUser === O && (yield O.auth.signOut()), F } })).apply(this, arguments) } function Kr({ code: O }) { return "auth/user-disabled" === O || "auth/user-token-expired" === O } class vr { constructor(C) { this.user = C, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4 } _start() { this.isRunning || (this.isRunning = !0, this.schedule()) } _stop() { this.isRunning && (this.isRunning = !1, null !== this.timerId && clearTimeout(this.timerId)) } getInterval(C) { var S; if (C) { const F = this.errorBackoff; return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), F } { this.errorBackoff = 3e4; const ie = (null !== (S = this.user.stsTokenManager.expirationTime) && void 0 !== S ? S : 0) - Date.now() - 3e5; return Math.max(0, ie) } } schedule(C = !1) { var S = this; if (!this.isRunning) return; const F = this.getInterval(C); this.timerId = setTimeout((0, i.Z)(function* () { yield S.iteration() }), F) } iteration() { var C = this; return (0, i.Z)(function* () { try { yield C.user.getIdToken(!0) } catch (S) { return void ("auth/network-request-failed" === S?.code && C.schedule(!0)) } C.schedule() })() } } class At { constructor(C, S) { this.createdAt = C, this.lastLoginAt = S, this._initializeTime() } _initializeTime() { this.lastSignInTime = gn(this.lastLoginAt), this.creationTime = gn(this.createdAt) } _copy(C) { this.createdAt = C.createdAt, this.lastLoginAt = C.lastLoginAt, this._initializeTime() } toJSON() { return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt } } } function ln(O) { return Ae.apply(this, arguments) } function Ae() { return (Ae = (0, i.Z)(function* (O) { var C; const S = O.auth, F = yield O.getIdToken(), ie = yield ur(O, lt(S, { idToken: F })); Ne(ie?.users.length, S, "internal-error"); const ge = ie.users[0]; O._notifyReloadListener(ge); const Tt = null !== (C = ge.providerUserInfo) && void 0 !== C && C.length ? sn(ge.providerUserInfo) : [], tn = bn(O.providerData, Tt), br = !!O.isAnonymous && !(O.email && ge.passwordHash || tn?.length), yr = { uid: ge.localId, displayName: ge.displayName || null, photoURL: ge.photoUrl || null, email: ge.email || null, emailVerified: ge.emailVerified || !1, phoneNumber: ge.phoneNumber || null, tenantId: ge.tenantId || null, providerData: tn, metadata: new At(ge.createdAt, ge.lastLoginAt), isAnonymous: br }; Object.assign(O, yr) })).apply(this, arguments) } function Gt() { return (Gt = (0, i.Z)(function* (O) { const C = (0, J.m9)(O); yield ln(C), yield C.auth._persistUserIfCurrent(C), C.auth._notifyListenersIfCurrent(C) })).apply(this, arguments) } function bn(O, C) { return [...O.filter(F => !C.some(ie => ie.providerId === F.providerId)), ...C] } function sn(O) { return O.map(C => { var { providerId: S } = C, F = (0, we._T)(C, ["providerId"]); return { providerId: S, uid: F.rawId || "", displayName: F.displayName || null, email: F.email || null, phoneNumber: F.phoneNumber || null, photoURL: F.photoUrl || null } }) } function vt() { return (vt = (0, i.Z)(function* (O, C) { const S = yield Xe(O, {}, (0, i.Z)(function* () { const F = (0, J.xO)({ grant_type: "refresh_token", refresh_token: C }).slice(1), { tokenApiHost: ie, apiKey: ge } = O.config, Tt = wn(O, ie, "/v1/token", `key=${ge}`), tn = yield O._getAdditionalHeaders(); return tn["Content-Type"] = "application/x-www-form-urlencoded", Yt.fetch()(Tt, { method: "POST", headers: tn, body: F }) })); return { accessToken: S.access_token, expiresIn: S.expires_in, refreshToken: S.refresh_token } })).apply(this, arguments) } class Le { constructor() { this.refreshToken = null, this.accessToken = null, this.expirationTime = null } get isExpired() { return !this.expirationTime || Date.now() > this.expirationTime - 3e4 } updateFromServerResponse(C) { Ne(C.idToken, "internal-error"), Ne(typeof C.idToken < "u", "internal-error"), Ne(typeof C.refreshToken < "u", "internal-error"); const S = "expiresIn" in C && typeof C.expiresIn < "u" ? Number(C.expiresIn) : function Qn(O) { const C = yn(O); return Ne(C, "internal-error"), Ne(typeof C.exp < "u", "internal-error"), Ne(typeof C.iat < "u", "internal-error"), Number(C.exp) - Number(C.iat) }(C.idToken); this.updateTokensAndExpiration(C.idToken, C.refreshToken, S) } getToken(C, S = !1) { var F = this; return (0, i.Z)(function* () { return Ne(!F.accessToken || F.refreshToken, C, "user-token-expired"), S || !F.accessToken || F.isExpired ? F.refreshToken ? (yield F.refresh(C, F.refreshToken), F.accessToken) : null : F.accessToken })() } clearRefreshToken() { this.refreshToken = null } refresh(C, S) { var F = this; return (0, i.Z)(function* () { const { accessToken: ie, refreshToken: ge, expiresIn: Tt } = yield function Bt(O, C) { return vt.apply(this, arguments) }(C, S); F.updateTokensAndExpiration(ie, ge, Number(Tt)) })() } updateTokensAndExpiration(C, S, F) { this.refreshToken = S || null, this.accessToken = C || null, this.expirationTime = Date.now() + 1e3 * F } static fromJSON(C, S) { const { refreshToken: F, accessToken: ie, expirationTime: ge } = S, Tt = new Le; return F && (Ne("string" == typeof F, "internal-error", { appName: C }), Tt.refreshToken = F), ie && (Ne("string" == typeof ie, "internal-error", { appName: C }), Tt.accessToken = ie), ge && (Ne("number" == typeof ge, "internal-error", { appName: C }), Tt.expirationTime = ge), Tt } toJSON() { return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime } } _assign(C) { this.accessToken = C.accessToken, this.refreshToken = C.refreshToken, this.expirationTime = C.expirationTime } _clone() { return Object.assign(new Le, this.toJSON()) } _performRefresh() { return tt("not implemented") } } function qe(O, C) { Ne("string" == typeof O || typeof O > "u", "internal-error", { appName: C }) } class Zt { constructor(C) { var { uid: S, auth: F, stsTokenManager: ie } = C, ge = (0, we._T)(C, ["uid", "auth", "stsTokenManager"]); this.providerId = "firebase", this.proactiveRefresh = new vr(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = S, this.auth = F, this.stsTokenManager = ie, this.accessToken = ie.accessToken, this.displayName = ge.displayName || null, this.email = ge.email || null, this.emailVerified = ge.emailVerified || !1, this.phoneNumber = ge.phoneNumber || null, this.photoURL = ge.photoURL || null, this.isAnonymous = ge.isAnonymous || !1, this.tenantId = ge.tenantId || null, this.providerData = ge.providerData ? [...ge.providerData] : [], this.metadata = new At(ge.createdAt || void 0, ge.lastLoginAt || void 0) } getIdToken(C) { var S = this; return (0, i.Z)(function* () { const F = yield ur(S, S.stsTokenManager.getToken(S.auth, C)); return Ne(F, S.auth, "internal-error"), S.accessToken !== F && (S.accessToken = F, yield S.auth._persistUserIfCurrent(S), S.auth._notifyListenersIfCurrent(S)), F })() } getIdTokenResult(C) { return function _r(O) { return pn.apply(this, arguments) }(this, C) } reload() { return function Et(O) { return Gt.apply(this, arguments) }(this) } _assign(C) { this !== C && (Ne(this.uid === C.uid, this.auth, "internal-error"), this.displayName = C.displayName, this.photoURL = C.photoURL, this.email = C.email, this.emailVerified = C.emailVerified, this.phoneNumber = C.phoneNumber, this.isAnonymous = C.isAnonymous, this.tenantId = C.tenantId, this.providerData = C.providerData.map(S => Object.assign({}, S)), this.metadata._copy(C.metadata), this.stsTokenManager._assign(C.stsTokenManager)) } _clone(C) { return new Zt(Object.assign(Object.assign({}, this), { auth: C, stsTokenManager: this.stsTokenManager._clone() })) } _onReload(C) { Ne(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = C, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null) } _notifyReloadListener(C) { this.reloadListener ? this.reloadListener(C) : this.reloadUserInfo = C } _startProactiveRefresh() { this.proactiveRefresh._start() } _stopProactiveRefresh() { this.proactiveRefresh._stop() } _updateTokensIfNecessary(C, S = !1) { var F = this; return (0, i.Z)(function* () { let ie = !1; C.idToken && C.idToken !== F.stsTokenManager.accessToken && (F.stsTokenManager.updateFromServerResponse(C), ie = !0), S && (yield ln(F)), yield F.auth._persistUserIfCurrent(F), ie && F.auth._notifyListenersIfCurrent(F) })() } delete() { var C = this; return (0, i.Z)(function* () { const S = yield C.getIdToken(); return yield ur(C, function Ht(O, C) { return dn.apply(this, arguments) }(C.auth, { idToken: S })), C.stsTokenManager.clearRefreshToken(), C.auth.signOut() })() } toJSON() { return Object.assign(Object.assign({ uid: this.uid, email: this.email || void 0, emailVerified: this.emailVerified, displayName: this.displayName || void 0, isAnonymous: this.isAnonymous, photoURL: this.photoURL || void 0, phoneNumber: this.phoneNumber || void 0, tenantId: this.tenantId || void 0, providerData: this.providerData.map(C => Object.assign({}, C)), stsTokenManager: this.stsTokenManager.toJSON(), _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { apiKey: this.auth.config.apiKey, appName: this.auth.name }) } get refreshToken() { return this.stsTokenManager.refreshToken || "" } static _fromJSON(C, S) { var F, ie, ge, Tt, tn, Pn, tr, br; const yr = null !== (F = S.displayName) && void 0 !== F ? F : void 0, Ni = null !== (ie = S.email) && void 0 !== ie ? ie : void 0, Dl = null !== (ge = S.phoneNumber) && void 0 !== ge ? ge : void 0, Ku = null !== (Tt = S.photoURL) && void 0 !== Tt ? Tt : void 0, Lf = null !== (tn = S.tenantId) && void 0 !== tn ? tn : void 0, su = null !== (Pn = S._redirectEventId) && void 0 !== Pn ? Pn : void 0, Fc = null !== (tr = S.createdAt) && void 0 !== tr ? tr : void 0, lc = null !== (br = S.lastLoginAt) && void 0 !== br ? br : void 0, { uid: Su, emailVerified: Eh, isAnonymous: Lc, providerData: ea, stsTokenManager: Th } = S; Ne(Su && Th, C, "internal-error"); const Dh = Le.fromJSON(this.name, Th); Ne("string" == typeof Su, C, "internal-error"), qe(yr, C.name), qe(Ni, C.name), Ne("boolean" == typeof Eh, C, "internal-error"), Ne("boolean" == typeof Lc, C, "internal-error"), qe(Dl, C.name), qe(Ku, C.name), qe(Lf, C.name), qe(su, C.name), qe(Fc, C.name), qe(lc, C.name); const Cd = new Zt({ uid: Su, auth: C, email: Ni, emailVerified: Eh, displayName: yr, isAnonymous: Lc, photoURL: Ku, phoneNumber: Dl, tenantId: Lf, stsTokenManager: Dh, createdAt: Fc, lastLoginAt: lc }); return ea && Array.isArray(ea) && (Cd.providerData = ea.map(Ed => Object.assign({}, Ed))), su && (Cd._redirectEventId = su), Cd } static _fromIdTokenResponse(C, S, F = !1) { return (0, i.Z)(function* () { const ie = new Le; ie.updateFromServerResponse(S); const ge = new Zt({ uid: S.localId, auth: C, stsTokenManager: ie, isAnonymous: F }); return yield ln(ge), ge })() } } const ke = (() => { class O { constructor() { this.type = "NONE", this.storage = {} } _isAvailable() { return (0, i.Z)(function* () { return !0 })() } _set(S, F) { var ie = this; return (0, i.Z)(function* () { ie.storage[S] = F })() } _get(S) { var F = this; return (0, i.Z)(function* () { const ie = F.storage[S]; return void 0 === ie ? null : ie })() } _remove(S) { var F = this; return (0, i.Z)(function* () { delete F.storage[S] })() } _addListener(S, F) { } _removeListener(S, F) { } } return O.type = "NONE", O })(); function et(O, C, S) { return `firebase:${O}:${C}:${S}` } class Lt { constructor(C, S, F) { this.persistence = C, this.auth = S, this.userKey = F; const { config: ie, name: ge } = this.auth; this.fullUserKey = et(this.userKey, ie.apiKey, ge), this.fullPersistenceKey = et("persistence", ie.apiKey, ge), this.boundEventHandler = S._onStorageEvent.bind(S), this.persistence._addListener(this.fullUserKey, this.boundEventHandler) } setCurrentUser(C) { return this.persistence._set(this.fullUserKey, C.toJSON()) } getCurrentUser() { var C = this; return (0, i.Z)(function* () { const S = yield C.persistence._get(C.fullUserKey); return S ? Zt._fromJSON(C.auth, S) : null })() } removeCurrentUser() { return this.persistence._remove(this.fullUserKey) } savePersistenceForRedirect() { return this.persistence._set(this.fullPersistenceKey, this.persistence.type) } setPersistence(C) { var S = this; return (0, i.Z)(function* () { if (S.persistence === C) return; const F = yield S.getCurrentUser(); return yield S.removeCurrentUser(), S.persistence = C, F ? S.setCurrentUser(F) : void 0 })() } delete() { this.persistence._removeListener(this.fullUserKey, this.boundEventHandler) } static create(C, S, F = "authUser") { return (0, i.Z)(function* () { if (!S.length) return new Lt(st(ke), C, F); const ie = (yield Promise.all(S.map(function () { var tr = (0, i.Z)(function* (br) { if (yield br._isAvailable()) return br }); return function (br) { return tr.apply(this, arguments) } }()))).filter(tr => tr); let ge = ie[0] || st(ke); const Tt = et(F, C.config.apiKey, C.name); let tn = null; for (const tr of S) try { const br = yield tr._get(Tt); if (br) { const yr = Zt._fromJSON(C, br); tr !== ge && (tn = yr), ge = tr; break } } catch { } const Pn = ie.filter(tr => tr._shouldAllowMigration); return ge._shouldAllowMigration && Pn.length ? (ge = Pn[0], tn && (yield ge._set(Tt, tn.toJSON())), yield Promise.all(S.map(function () { var tr = (0, i.Z)(function* (br) { if (br !== ge) try { yield br._remove(Tt) } catch { } }); return function (br) { return tr.apply(this, arguments) } }())), new Lt(ge, C, F)) : new Lt(ge, C, F) })() } } function mt(O) { const C = O.toLowerCase(); if (C.includes("opera/") || C.includes("opr/") || C.includes("opios/")) return "Opera"; if (Fr(C)) return "IEMobile"; if (C.includes("msie") || C.includes("trident/")) return "IE"; if (C.includes("edge/")) return "Edge"; if (An(C)) return "Firefox"; if (C.includes("silk/")) return "Silk"; if (Ye(C)) return "Blackberry"; if (Ie(C)) return "Webos"; if (ar(C)) return "Safari"; if ((C.includes("chrome/") || sr(C)) && !C.includes("edge/")) return "Chrome"; if (ze(C)) return "Android"; { const F = O.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/); if (2 === F?.length) return F[1] } return "Other" } function An(O = (0, J.z$)()) { return /firefox\//i.test(O) } function ar(O = (0, J.z$)()) { const C = O.toLowerCase(); return C.includes("safari/") && !C.includes("chrome/") && !C.includes("crios/") && !C.includes("android") } function sr(O = (0, J.z$)()) { return /crios\//i.test(O) } function Fr(O = (0, J.z$)()) { return /iemobile/i.test(O) } function ze(O = (0, J.z$)()) { return /android/i.test(O) } function Ye(O = (0, J.z$)()) { return /blackberry/i.test(O) } function Ie(O = (0, J.z$)()) { return /webos/i.test(O) } function Ct(O = (0, J.z$)()) { return /iphone|ipad|ipod/i.test(O) || /macintosh/i.test(O) && /mobile/i.test(O) } function ti(O = (0, J.z$)()) { return Ct(O) || ze(O) || Ie(O) || Ye(O) || /windows phone/i.test(O) || Fr(O) } function ss(O, C = []) { let S; switch (O) { case "Browser": S = mt((0, J.z$)()); break; case "Worker": S = `${mt((0, J.z$)())}-${O}`; break; default: S = O }const F = C.length ? C.join(",") : "FirebaseCore-web"; return `${S}/JsCore/${ye.SDK_VERSION}/${F}` } class Ps { constructor(C) { this.auth = C, this.queue = [] } pushCallback(C, S) { const F = ge => new Promise((Tt, tn) => { try { Tt(C(ge)) } catch (Pn) { tn(Pn) } }); F.onAbort = S, this.queue.push(F); const ie = this.queue.length - 1; return () => { this.queue[ie] = () => Promise.resolve() } } runMiddleware(C) { var S = this; return (0, i.Z)(function* () { if (S.auth.currentUser === C) return; const F = []; try { for (const ie of S.queue) yield ie(C), ie.onAbort && F.push(ie.onAbort) } catch (ie) { F.reverse(); for (const ge of F) try { ge() } catch { } throw S.auth._errorFactory.create("login-blocked", { originalMessage: ie?.message }) } })() } } class vo { constructor(C, S, F) { this.app = C, this.heartbeatServiceProvider = S, this.config = F, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new Bi(this), this.idTokenSubscription = new Bi(this), this.beforeStateQueue = new Ps(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = De, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = C.name, this.clientVersion = F.sdkClientVersion } _initializeWithPersistence(C, S) { var F = this; return S && (this._popupRedirectResolver = st(S)), this._initializationPromise = this.queue((0, i.Z)(function* () { var ie, ge; if (!F._deleted && (F.persistenceManager = yield Lt.create(F, C), !F._deleted)) { if (null !== (ie = F._popupRedirectResolver) && void 0 !== ie && ie._shouldInitProactively) try { yield F._popupRedirectResolver._initialize(F) } catch { } yield F.initializeCurrentUser(S), F.lastNotifiedUid = (null === (ge = F.currentUser) || void 0 === ge ? void 0 : ge.uid) || null, !F._deleted && (F._isInitialized = !0) } })), this._initializationPromise } _onStorageEvent() { var C = this; return (0, i.Z)(function* () { if (C._deleted) return; const S = yield C.assertedPersistence.getCurrentUser(); if (C.currentUser || S) { if (C.currentUser && S && C.currentUser.uid === S.uid) return C._currentUser._assign(S), void (yield C.currentUser.getIdToken()); yield C._updateCurrentUser(S, !0) } })() } initializeCurrentUser(C) { var S = this; return (0, i.Z)(function* () { var F; const ie = yield S.assertedPersistence.getCurrentUser(); let ge = ie, Tt = !1; if (C && S.config.authDomain) { yield S.getOrInitRedirectPersistenceManager(); const tn = null === (F = S.redirectUser) || void 0 === F ? void 0 : F._redirectEventId, Pn = ge?._redirectEventId, tr = yield S.tryRedirectSignIn(C); (!tn || tn === Pn) && tr?.user && (ge = tr.user, Tt = !0) } if (!ge) return S.directlySetCurrentUser(null); if (!ge._redirectEventId) { if (Tt) try { yield S.beforeStateQueue.runMiddleware(ge) } catch (tn) { ge = ie, S._popupRedirectResolver._overrideRedirectResult(S, () => Promise.reject(tn)) } return ge ? S.reloadAndSetCurrentUserOrClear(ge) : S.directlySetCurrentUser(null) } return Ne(S._popupRedirectResolver, S, "argument-error"), yield S.getOrInitRedirectPersistenceManager(), S.redirectUser && S.redirectUser._redirectEventId === ge._redirectEventId ? S.directlySetCurrentUser(ge) : S.reloadAndSetCurrentUserOrClear(ge) })() } tryRedirectSignIn(C) { var S = this; return (0, i.Z)(function* () { let F = null; try { F = yield S._popupRedirectResolver._completeRedirectFn(S, C, !0) } catch { yield S._setRedirectUser(null) } return F })() } reloadAndSetCurrentUserOrClear(C) { var S = this; return (0, i.Z)(function* () { try { yield ln(C) } catch (F) { if ("auth/network-request-failed" !== F?.code) return S.directlySetCurrentUser(null) } return S.directlySetCurrentUser(C) })() } useDeviceLanguage() { this.languageCode = function kn() { if (typeof navigator > "u") return null; const O = navigator; return O.languages && O.languages[0] || O.language || null }() } _delete() { var C = this; return (0, i.Z)(function* () { C._deleted = !0 })() } updateCurrentUser(C) { var S = this; return (0, i.Z)(function* () { const F = C ? (0, J.m9)(C) : null; return F && Ne(F.auth.config.apiKey === S.config.apiKey, S, "invalid-user-token"), S._updateCurrentUser(F && F._clone(S)) })() } _updateCurrentUser(C, S = !1) { var F = this; return (0, i.Z)(function* () { if (!F._deleted) return C && Ne(F.tenantId === C.tenantId, F, "tenant-id-mismatch"), S || (yield F.beforeStateQueue.runMiddleware(C)), F.queue((0, i.Z)(function* () { yield F.directlySetCurrentUser(C), F.notifyAuthListeners() })) })() } signOut() { var C = this; return (0, i.Z)(function* () { return yield C.beforeStateQueue.runMiddleware(null), (C.redirectPersistenceManager || C._popupRedirectResolver) && (yield C._setRedirectUser(null)), C._updateCurrentUser(null, !0) })() } setPersistence(C) { var S = this; return this.queue((0, i.Z)(function* () { yield S.assertedPersistence.setPersistence(st(C)) })) } _getPersistence() { return this.assertedPersistence.persistence.type } _updateErrorMap(C) { this._errorFactory = new J.LL("auth", "Firebase", C()) } onAuthStateChanged(C, S, F) { return this.registerStateListener(this.authStateSubscription, C, S, F) } beforeAuthStateChanged(C, S) { return this.beforeStateQueue.pushCallback(C, S) } onIdTokenChanged(C, S, F) { return this.registerStateListener(this.idTokenSubscription, C, S, F) } toJSON() { var C; return { apiKey: this.config.apiKey, authDomain: this.config.authDomain, appName: this.name, currentUser: null === (C = this._currentUser) || void 0 === C ? void 0 : C.toJSON() } } _setRedirectUser(C, S) { var F = this; return (0, i.Z)(function* () { const ie = yield F.getOrInitRedirectPersistenceManager(S); return null === C ? ie.removeCurrentUser() : ie.setCurrentUser(C) })() } getOrInitRedirectPersistenceManager(C) { var S = this; return (0, i.Z)(function* () { if (!S.redirectPersistenceManager) { const F = C && st(C) || S._popupRedirectResolver; Ne(F, S, "argument-error"), S.redirectPersistenceManager = yield Lt.create(S, [st(F._redirectPersistence)], "redirectUser"), S.redirectUser = yield S.redirectPersistenceManager.getCurrentUser() } return S.redirectPersistenceManager })() } _redirectUserForId(C) { var S = this; return (0, i.Z)(function* () { var F, ie; return S._isInitialized && (yield S.queue((0, i.Z)(function* () { }))), (null === (F = S._currentUser) || void 0 === F ? void 0 : F._redirectEventId) === C ? S._currentUser : (null === (ie = S.redirectUser) || void 0 === ie ? void 0 : ie._redirectEventId) === C ? S.redirectUser : null })() } _persistUserIfCurrent(C) { var S = this; return (0, i.Z)(function* () { if (C === S.currentUser) return S.queue((0, i.Z)(function* () { return S.directlySetCurrentUser(C) })) })() } _notifyListenersIfCurrent(C) { C === this.currentUser && this.notifyAuthListeners() } _key() { return `${this.config.authDomain}:${this.config.apiKey}:${this.name}` } _startProactiveRefresh() { this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh() } _stopProactiveRefresh() { this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh() } get _currentUser() { return this.currentUser } notifyAuthListeners() { var C, S; if (!this._isInitialized) return; this.idTokenSubscription.next(this.currentUser); const F = null !== (S = null === (C = this.currentUser) || void 0 === C ? void 0 : C.uid) && void 0 !== S ? S : null; this.lastNotifiedUid !== F && (this.lastNotifiedUid = F, this.authStateSubscription.next(this.currentUser)) } registerStateListener(C, S, F, ie) { if (this._deleted) return () => { }; const ge = "function" == typeof S ? S : S.next.bind(S), Tt = this._isInitialized ? Promise.resolve() : this._initializationPromise; return Ne(Tt, this, "internal-error"), Tt.then(() => ge(this.currentUser)), "function" == typeof S ? C.addObserver(S, F, ie) : C.addObserver(S) } directlySetCurrentUser(C) { var S = this; return (0, i.Z)(function* () { S.currentUser && S.currentUser !== C && S._currentUser._stopProactiveRefresh(), C && S.isProactiveRefreshEnabled && C._startProactiveRefresh(), S.currentUser = C, C ? yield S.assertedPersistence.setCurrentUser(C) : yield S.assertedPersistence.removeCurrentUser() })() } queue(C) { return this.operations = this.operations.then(C, C), this.operations } get assertedPersistence() { return Ne(this.persistenceManager, this, "internal-error"), this.persistenceManager } _logFramework(C) { !C || this.frameworks.includes(C) || (this.frameworks.push(C), this.frameworks.sort(), this.clientVersion = ss(this.config.clientPlatform, this._getFrameworks())) } _getFrameworks() { return this.frameworks } _getAdditionalHeaders() { var C = this; return (0, i.Z)(function* () { var S; const F = { "X-Client-Version": C.clientVersion }; C.app.options.appId && (F["X-Firebase-gmpid"] = C.app.options.appId); const ie = yield null === (S = C.heartbeatServiceProvider.getImmediate({ optional: !0 })) || void 0 === S ? void 0 : S.getHeartbeatsHeader(); return ie && (F["X-Firebase-Client"] = ie), F })() } } function Dr(O) { return (0, J.m9)(O) } class Bi { constructor(C) { this.auth = C, this.observer = null, this.addObserver = (0, J.ne)(S => this.observer = S) } get next() { return Ne(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer) } } function ya(O) { const C = O.indexOf(":"); return C < 0 ? "" : O.substr(0, C + 1) } function Hr(O) { if (!O) return null; const C = Number(O); return isNaN(C) ? null : C } class Ei { constructor(C, S) { this.providerId = C, this.signInMethod = S } toJSON() { return tt("not implemented") } _getIdTokenResponse(C) { return tt("not implemented") } _linkToIdToken(C, S) { return tt("not implemented") } _getReauthenticationResolver(C) { return tt("not implemented") } } function Gi(O, C) { return Qi.apply(this, arguments) } function Qi() { return (Qi = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:resetPassword", Ze(O, C)) })).apply(this, arguments) } function Gs(O, C) { return Ln.apply(this, arguments) } function Ln() { return (Ln = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:update", C) })).apply(this, arguments) } function pr(O, C) { return ni.apply(this, arguments) } function ni() { return (ni = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:update", Ze(O, C)) })).apply(this, arguments) } function Xi() { return (Xi = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signInWithPassword", Ze(O, C)) })).apply(this, arguments) } function Ti(O, C) { return _s.apply(this, arguments) } function _s() { return (_s = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:sendOobCode", Ze(O, C)) })).apply(this, arguments) } function Di(O, C) { return Rs.apply(this, arguments) } function Rs() { return (Rs = (0, i.Z)(function* (O, C) { return Ti(O, C) })).apply(this, arguments) } function js(O, C) { return Mr.apply(this, arguments) } function Mr() { return (Mr = (0, i.Z)(function* (O, C) { return Ti(O, C) })).apply(this, arguments) } function ba(O, C) { return So.apply(this, arguments) } function So() { return (So = (0, i.Z)(function* (O, C) { return Ti(O, C) })).apply(this, arguments) } function al(O, C) { return Vi.apply(this, arguments) } function Vi() { return (Vi = (0, i.Z)(function* (O, C) { return Ti(O, C) })).apply(this, arguments) } function Ho() { return (Ho = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signInWithEmailLink", Ze(O, C)) })).apply(this, arguments) } function Fs() { return (Fs = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signInWithEmailLink", Ze(O, C)) })).apply(this, arguments) } class cs extends Ei { constructor(C, S, F, ie = null) { super("password", F), this._email = C, this._password = S, this._tenantId = ie } static _fromEmailAndPassword(C, S) { return new cs(C, S, "password") } static _fromEmailAndCode(C, S, F = null) { return new cs(C, S, "emailLink", F) } toJSON() { return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId } } static fromJSON(C) { const S = "string" == typeof C ? JSON.parse(C) : C; if (S?.email && S?.password) { if ("password" === S.signInMethod) return this._fromEmailAndPassword(S.email, S.password); if ("emailLink" === S.signInMethod) return this._fromEmailAndCode(S.email, S.password, S.tenantId) } return null } _getIdTokenResponse(C) { var S = this; return (0, i.Z)(function* () { switch (S.signInMethod) { case "password": return function as(O, C) { return Xi.apply(this, arguments) }(C, { returnSecureToken: !0, email: S._email, password: S._password }); case "emailLink": return function ls(O, C) { return Ho.apply(this, arguments) }(C, { email: S._email, oobCode: S._password }); default: ct(C, "internal-error") } })() } _linkToIdToken(C, S) { var F = this; return (0, i.Z)(function* () { switch (F.signInMethod) { case "password": return Gs(C, { idToken: S, returnSecureToken: !0, email: F._email, password: F._password }); case "emailLink": return function no(O, C) { return Fs.apply(this, arguments) }(C, { idToken: S, email: F._email, oobCode: F._password }); default: ct(C, "internal-error") } })() } _getReauthenticationResolver(C) { return this._getIdTokenResponse(C) } } function ro(O, C) { return ft.apply(this, arguments) } function ft() { return (ft = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signInWithIdp", Ze(O, C)) })).apply(this, arguments) } class Mt extends Ei { constructor() { super(...arguments), this.pendingToken = null } static _fromParams(C) { const S = new Mt(C.providerId, C.signInMethod); return C.idToken || C.accessToken ? (C.idToken && (S.idToken = C.idToken), C.accessToken && (S.accessToken = C.accessToken), C.nonce && !C.pendingToken && (S.nonce = C.nonce), C.pendingToken && (S.pendingToken = C.pendingToken)) : C.oauthToken && C.oauthTokenSecret ? (S.accessToken = C.oauthToken, S.secret = C.oauthTokenSecret) : ct("argument-error"), S } toJSON() { return { idToken: this.idToken, accessToken: this.accessToken, secret: this.secret, nonce: this.nonce, pendingToken: this.pendingToken, providerId: this.providerId, signInMethod: this.signInMethod } } static fromJSON(C) { const S = "string" == typeof C ? JSON.parse(C) : C, { providerId: F, signInMethod: ie } = S, ge = (0, we._T)(S, ["providerId", "signInMethod"]); if (!F || !ie) return null; const Tt = new Mt(F, ie); return Tt.idToken = ge.idToken || void 0, Tt.accessToken = ge.accessToken || void 0, Tt.secret = ge.secret, Tt.nonce = ge.nonce, Tt.pendingToken = ge.pendingToken || null, Tt } _getIdTokenResponse(C) { return ro(C, this.buildRequest()) } _linkToIdToken(C, S) { const F = this.buildRequest(); return F.idToken = S, ro(C, F) } _getReauthenticationResolver(C) { const S = this.buildRequest(); return S.autoCreate = !1, ro(C, S) } buildRequest() { const C = { requestUri: "http://localhost", returnSecureToken: !0 }; if (this.pendingToken) C.pendingToken = this.pendingToken; else { const S = {}; this.idToken && (S.id_token = this.idToken), this.accessToken && (S.access_token = this.accessToken), this.secret && (S.oauth_token_secret = this.secret), S.providerId = this.providerId, this.nonce && !this.pendingToken && (S.nonce = this.nonce), C.postBody = (0, J.xO)(S) } return C } } function hn(O, C) { return Sn.apply(this, arguments) } function Sn() { return (Sn = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:sendVerificationCode", Ze(O, C)) })).apply(this, arguments) } function lr() { return (lr = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signInWithPhoneNumber", Ze(O, C)) })).apply(this, arguments) } function Vr() { return (Vr = (0, i.Z)(function* (O, C) { const S = yield an(O, "POST", "/v1/accounts:signInWithPhoneNumber", Ze(O, C)); if (S.temporaryProof) throw or(O, "account-exists-with-different-credential", S); return S })).apply(this, arguments) } const Ai = { USER_NOT_FOUND: "user-not-found" }; function Ds() { return (Ds = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signInWithPhoneNumber", Ze(O, Object.assign(Object.assign({}, C), { operation: "REAUTH" })), Ai) })).apply(this, arguments) } class gr extends Ei { constructor(C) { super("phone", "phone"), this.params = C } static _fromVerification(C, S) { return new gr({ verificationId: C, verificationCode: S }) } static _fromTokenResponse(C, S) { return new gr({ phoneNumber: C, temporaryProof: S }) } _getIdTokenResponse(C) { return function Yn(O, C) { return lr.apply(this, arguments) }(C, this._makeVerificationRequest()) } _linkToIdToken(C, S) { return function wr(O, C) { return Vr.apply(this, arguments) }(C, Object.assign({ idToken: S }, this._makeVerificationRequest())) } _getReauthenticationResolver(C) { return function Ts(O, C) { return Ds.apply(this, arguments) }(C, this._makeVerificationRequest()) } _makeVerificationRequest() { const { temporaryProof: C, phoneNumber: S, verificationId: F, verificationCode: ie } = this.params; return C && S ? { temporaryProof: C, phoneNumber: S } : { sessionInfo: F, code: ie } } toJSON() { const C = { providerId: this.providerId }; return this.params.phoneNumber && (C.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (C.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (C.verificationCode = this.params.verificationCode), this.params.verificationId && (C.verificationId = this.params.verificationId), C } static fromJSON(C) { "string" == typeof C && (C = JSON.parse(C)); const { verificationId: S, verificationCode: F, phoneNumber: ie, temporaryProof: ge } = C; return F || S || ie || ge ? new gr({ verificationId: S, verificationCode: F, phoneNumber: ie, temporaryProof: ge }) : null } } class bo { constructor(C) { var S, F, ie, ge, Tt, tn; const Pn = (0, J.zd)((0, J.pd)(C)), tr = null !== (S = Pn.apiKey) && void 0 !== S ? S : null, br = null !== (F = Pn.oobCode) && void 0 !== F ? F : null, yr = function xl(O) { switch (O) { case "recoverEmail": return "RECOVER_EMAIL"; case "resetPassword": return "PASSWORD_RESET"; case "signIn": return "EMAIL_SIGNIN"; case "verifyEmail": return "VERIFY_EMAIL"; case "verifyAndChangeEmail": return "VERIFY_AND_CHANGE_EMAIL"; case "revertSecondFactorAddition": return "REVERT_SECOND_FACTOR_ADDITION"; default: return null } }(null !== (ie = Pn.mode) && void 0 !== ie ? ie : null); Ne(tr && br && yr, "argument-error"), this.apiKey = tr, this.operation = yr, this.code = br, this.continueUrl = null !== (ge = Pn.continueUrl) && void 0 !== ge ? ge : null, this.languageCode = null !== (Tt = Pn.languageCode) && void 0 !== Tt ? Tt : null, this.tenantId = null !== (tn = Pn.tenantId) && void 0 !== tn ? tn : null } static parseLink(C) { const S = function us(O) { const C = (0, J.zd)((0, J.pd)(O)).link, S = C ? (0, J.zd)((0, J.pd)(C)).deep_link_id : null, F = (0, J.zd)((0, J.pd)(O)).deep_link_id; return (F ? (0, J.zd)((0, J.pd)(F)).link : null) || F || S || C || O }(C); try { return new bo(S) } catch { return null } } } let Io = (() => { class O { constructor() { this.providerId = O.PROVIDER_ID } static credential(S, F) { return cs._fromEmailAndPassword(S, F) } static credentialWithLink(S, F) { const ie = bo.parseLink(F); return Ne(ie, "argument-error"), cs._fromEmailAndCode(S, ie.code, ie.tenantId) } } return O.PROVIDER_ID = "password", O.EMAIL_PASSWORD_SIGN_IN_METHOD = "password", O.EMAIL_LINK_SIGN_IN_METHOD = "emailLink", O })(); class Xn { constructor(C) { this.providerId = C, this.defaultLanguageCode = null, this.customParameters = {} } setDefaultLanguage(C) { this.defaultLanguageCode = C } setCustomParameters(C) { return this.customParameters = C, this } getCustomParameters() { return this.customParameters } } class uo extends Xn { constructor() { super(...arguments), this.scopes = [] } addScope(C) { return this.scopes.includes(C) || this.scopes.push(C), this } getScopes() { return [...this.scopes] } } class Si extends uo { static credentialFromJSON(C) { const S = "string" == typeof C ? JSON.parse(C) : C; return Ne("providerId" in S && "signInMethod" in S, "argument-error"), Mt._fromParams(S) } credential(C) { return this._credential(Object.assign(Object.assign({}, C), { nonce: C.rawNonce })) } _credential(C) { return Ne(C.idToken || C.accessToken, "argument-error"), Mt._fromParams(Object.assign(Object.assign({}, C), { providerId: this.providerId, signInMethod: this.providerId })) } static credentialFromResult(C) { return Si.oauthCredentialFromTaggedObject(C) } static credentialFromError(C) { return Si.oauthCredentialFromTaggedObject(C.customData || {}) } static oauthCredentialFromTaggedObject({ _tokenResponse: C }) { if (!C) return null; const { oauthIdToken: S, oauthAccessToken: F, oauthTokenSecret: ie, pendingToken: ge, nonce: Tt, providerId: tn } = C; if (!F && !ie && !S && !ge || !tn) return null; try { return new Si(tn)._credential({ idToken: S, accessToken: F, nonce: Tt, pendingToken: ge }) } catch { return null } } } let ka = (() => { class O extends uo { constructor() { super("facebook.com") } static credential(S) { return Mt._fromParams({ providerId: O.PROVIDER_ID, signInMethod: O.FACEBOOK_SIGN_IN_METHOD, accessToken: S }) } static credentialFromResult(S) { return O.credentialFromTaggedObject(S) } static credentialFromError(S) { return O.credentialFromTaggedObject(S.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: S }) { if (!S || !("oauthAccessToken" in S) || !S.oauthAccessToken) return null; try { return O.credential(S.oauthAccessToken) } catch { return null } } } return O.FACEBOOK_SIGN_IN_METHOD = "facebook.com", O.PROVIDER_ID = "facebook.com", O })(), io = (() => { class O extends uo { constructor() { super("google.com"), this.addScope("profile") } static credential(S, F) { return Mt._fromParams({ providerId: O.PROVIDER_ID, signInMethod: O.GOOGLE_SIGN_IN_METHOD, idToken: S, accessToken: F }) } static credentialFromResult(S) { return O.credentialFromTaggedObject(S) } static credentialFromError(S) { return O.credentialFromTaggedObject(S.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: S }) { if (!S) return null; const { oauthIdToken: F, oauthAccessToken: ie } = S; if (!F && !ie) return null; try { return O.credential(F, ie) } catch { return null } } } return O.GOOGLE_SIGN_IN_METHOD = "google.com", O.PROVIDER_ID = "google.com", O })(), Wl = (() => { class O extends uo { constructor() { super("github.com") } static credential(S) { return Mt._fromParams({ providerId: O.PROVIDER_ID, signInMethod: O.GITHUB_SIGN_IN_METHOD, accessToken: S }) } static credentialFromResult(S) { return O.credentialFromTaggedObject(S) } static credentialFromError(S) { return O.credentialFromTaggedObject(S.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: S }) { if (!S || !("oauthAccessToken" in S) || !S.oauthAccessToken) return null; try { return O.credential(S.oauthAccessToken) } catch { return null } } } return O.GITHUB_SIGN_IN_METHOD = "github.com", O.PROVIDER_ID = "github.com", O })(); class Ys extends Ei { constructor(C, S) { super(C, C), this.pendingToken = S } _getIdTokenResponse(C) { return ro(C, this.buildRequest()) } _linkToIdToken(C, S) { const F = this.buildRequest(); return F.idToken = S, ro(C, F) } _getReauthenticationResolver(C) { const S = this.buildRequest(); return S.autoCreate = !1, ro(C, S) } toJSON() { return { signInMethod: this.signInMethod, providerId: this.providerId, pendingToken: this.pendingToken } } static fromJSON(C) { const S = "string" == typeof C ? JSON.parse(C) : C, { providerId: F, signInMethod: ie, pendingToken: ge } = S; return F && ie && ge && F === ie ? new Ys(F, ge) : null } static _create(C, S) { return new Ys(C, S) } buildRequest() { return { requestUri: "http://localhost", returnSecureToken: !0, pendingToken: this.pendingToken } } } class so extends Xn { constructor(C) { Ne(C.startsWith("saml."), "argument-error"), super(C) } static credentialFromResult(C) { return so.samlCredentialFromTaggedObject(C) } static credentialFromError(C) { return so.samlCredentialFromTaggedObject(C.customData || {}) } static credentialFromJSON(C) { const S = Ys.fromJSON(C); return Ne(S, "argument-error"), S } static samlCredentialFromTaggedObject({ _tokenResponse: C }) { if (!C) return null; const { pendingToken: S, providerId: F } = C; if (!S || !F) return null; try { return Ys._create(F, S) } catch { return null } } } let jo = (() => { class O extends uo { constructor() { super("twitter.com") } static credential(S, F) { return Mt._fromParams({ providerId: O.PROVIDER_ID, signInMethod: O.TWITTER_SIGN_IN_METHOD, oauthToken: S, oauthTokenSecret: F }) } static credentialFromResult(S) { return O.credentialFromTaggedObject(S) } static credentialFromError(S) { return O.credentialFromTaggedObject(S.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: S }) { if (!S) return null; const { oauthAccessToken: F, oauthTokenSecret: ie } = S; if (!F || !ie) return null; try { return O.credential(F, ie) } catch { return null } } } return O.TWITTER_SIGN_IN_METHOD = "twitter.com", O.PROVIDER_ID = "twitter.com", O })(); function na(O, C) { return Zl.apply(this, arguments) } function Zl() { return (Zl = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signUp", Ze(O, C)) })).apply(this, arguments) } class pi { constructor(C) { this.user = C.user, this.providerId = C.providerId, this._tokenResponse = C._tokenResponse, this.operationType = C.operationType } static _fromIdTokenResponse(C, S, F, ie = !1) { return (0, i.Z)(function* () { const ge = yield Zt._fromIdTokenResponse(C, F, ie), Tt = Ss(F); return new pi({ user: ge, providerId: Tt, _tokenResponse: F, operationType: S }) })() } static _forOperation(C, S, F) { return (0, i.Z)(function* () { yield C._updateTokensIfNecessary(F, !0); const ie = Ss(F); return new pi({ user: C, providerId: ie, _tokenResponse: F, operationType: S }) })() } } function Ss(O) { return O.providerId ? O.providerId : "phoneNumber" in O ? "phone" : null } function wo() { return (wo = (0, i.Z)(function* (O) { var C; const S = Dr(O); if (yield S._initializationPromise, null !== (C = S.currentUser) && void 0 !== C && C.isAnonymous) return new pi({ user: S.currentUser, providerId: null, operationType: "signIn" }); const F = yield na(S, { returnSecureToken: !0 }), ie = yield pi._fromIdTokenResponse(S, "signIn", F, !0); return yield S._updateCurrentUser(ie.user), ie })).apply(this, arguments) } class ho extends J.ZR { constructor(C, S, F, ie) { var ge; super(S.code, S.message), this.operationType = F, this.user = ie, Object.setPrototypeOf(this, ho.prototype), this.customData = { appName: C.name, tenantId: null !== (ge = C.tenantId) && void 0 !== ge ? ge : void 0, _serverResponse: S.customData._serverResponse, operationType: F } } static _fromErrorAndOperation(C, S, F, ie) { return new ho(C, S, F, ie) } } function Ao(O, C, S, F) { return ("reauthenticate" === C ? S._getReauthenticationResolver(O) : S._getIdTokenResponse(O)).catch(ge => { throw "auth/multi-factor-auth-required" === ge.code ? ho._fromErrorAndOperation(O, ge, C, F) : ge }) } function rs(O) { return new Set(O.map(({ providerId: C }) => C).filter(C => !!C)) } function Wo() { return (Wo = (0, i.Z)(function* (O, C) { const S = (0, J.m9)(O); yield As(!0, S, C); const { providerUserInfo: F } = yield ue(S.auth, { idToken: yield S.getIdToken(), deleteProvider: [C] }), ie = rs(F || []); return S.providerData = S.providerData.filter(ge => ie.has(ge.providerId)), ie.has("phone") || (S.phoneNumber = null), yield S.auth._persistUserIfCurrent(S), S })).apply(this, arguments) } function Za(O, C) { return fo.apply(this, arguments) } function fo() { return (fo = (0, i.Z)(function* (O, C, S = !1) { const F = yield ur(O, C._linkToIdToken(O.auth, yield O.getIdToken()), S); return pi._forOperation(O, "link", F) })).apply(this, arguments) } function As(O, C, S) { return Pa.apply(this, arguments) } function Pa() { return (Pa = (0, i.Z)(function* (O, C, S) { yield ln(C); const ie = !1 === O ? "provider-already-linked" : "no-such-provider"; Ne(rs(C.providerData).has(S) === O, C.auth, ie) })).apply(this, arguments) } function Ks(O, C) { return Ls.apply(this, arguments) } function Ls() { return (Ls = (0, i.Z)(function* (O, C, S = !1) { const { auth: F } = O, ie = "reauthenticate"; try { const ge = yield ur(O, Ao(F, ie, C, O), S); Ne(ge.idToken, F, "internal-error"); const Tt = yn(ge.idToken); Ne(Tt, F, "internal-error"); const { sub: tn } = Tt; return Ne(O.uid === tn, F, "user-mismatch"), pi._forOperation(O, ie, ge) } catch (ge) { throw "auth/user-not-found" === ge?.code && ct(F, "user-mismatch"), ge } })).apply(this, arguments) } function xo(O, C) { return Ii.apply(this, arguments) } function Ii() { return (Ii = (0, i.Z)(function* (O, C, S = !1) { const F = "signIn", ie = yield Ao(O, F, C), ge = yield pi._fromIdTokenResponse(O, F, ie); return S || (yield O._updateCurrentUser(ge.user)), ge })).apply(this, arguments) } function Ui(O, C) { return Js.apply(this, arguments) } function Js() { return (Js = (0, i.Z)(function* (O, C) { return xo(Dr(O), C) })).apply(this, arguments) } function ds(O, C) { return Mo.apply(this, arguments) } function Mo() { return (Mo = (0, i.Z)(function* (O, C) { const S = (0, J.m9)(O); return yield As(!1, S, C.providerId), Za(S, C) })).apply(this, arguments) } function Ra(O, C) { return gi.apply(this, arguments) } function gi() { return (gi = (0, i.Z)(function* (O, C) { return Ks((0, J.m9)(O), C) })).apply(this, arguments) } function Ml(O, C) { return wa.apply(this, arguments) } function wa() { return (wa = (0, i.Z)(function* (O, C) { return an(O, "POST", "/v1/accounts:signInWithCustomToken", Ze(O, C)) })).apply(this, arguments) } function Zr() { return (Zr = (0, i.Z)(function* (O, C) { const S = Dr(O), F = yield Ml(S, { token: C, returnSecureToken: !0 }), ie = yield pi._fromIdTokenResponse(S, "signIn", F); return yield S._updateCurrentUser(ie.user), ie })).apply(this, arguments) } class oo { constructor(C, S) { this.factorId = C, this.uid = S.mfaEnrollmentId, this.enrollmentTime = new Date(S.enrolledAt).toUTCString(), this.displayName = S.displayName } static _fromServerResponse(C, S) { return "phoneInfo" in S ? xs._fromServerResponse(C, S) : ct(C, "internal-error") } } class xs extends oo { constructor(C) { super("phone", C), this.phoneNumber = C.phoneInfo } static _fromServerResponse(C, S) { return new xs(S) } } function Oo(O, C, S) { var F; Ne((null === (F = S.url) || void 0 === F ? void 0 : F.length) > 0, O, "invalid-continue-uri"), Ne(typeof S.dynamicLinkDomain > "u" || S.dynamicLinkDomain.length > 0, O, "invalid-dynamic-link-domain"), C.continueUrl = S.url, C.dynamicLinkDomain = S.dynamicLinkDomain, C.canHandleCodeInApp = S.handleCodeInApp, S.iOS && (Ne(S.iOS.bundleId.length > 0, O, "missing-ios-bundle-id"), C.iOSBundleId = S.iOS.bundleId), S.android && (Ne(S.android.packageName.length > 0, O, "missing-android-pkg-name"), C.androidInstallApp = S.android.installApp, C.androidMinimumVersionCode = S.android.minimumVersion, C.androidPackageName = S.android.packageName) } function qa() { return (qa = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O), ie = { requestType: "PASSWORD_RESET", email: C }; S && Oo(F, ie, S), yield js(F, ie) })).apply(this, arguments) } function hr() { return (hr = (0, i.Z)(function* (O, C, S) { yield Gi((0, J.m9)(O), { oobCode: C, newPassword: S }) })).apply(this, arguments) } function Q() { return (Q = (0, i.Z)(function* (O, C) { yield pr((0, J.m9)(O), { oobCode: C }) })).apply(this, arguments) } function q(O, C) { return $.apply(this, arguments) } function $() { return ($ = (0, i.Z)(function* (O, C) { const S = (0, J.m9)(O), F = yield Gi(S, { oobCode: C }), ie = F.requestType; switch (Ne(ie, S, "internal-error"), ie) { case "EMAIL_SIGNIN": break; case "VERIFY_AND_CHANGE_EMAIL": Ne(F.newEmail, S, "internal-error"); break; case "REVERT_SECOND_FACTOR_ADDITION": Ne(F.mfaInfo, S, "internal-error"); default: Ne(F.email, S, "internal-error") }let ge = null; return F.mfaInfo && (ge = oo._fromServerResponse(Dr(S), F.mfaInfo)), { data: { email: ("VERIFY_AND_CHANGE_EMAIL" === F.requestType ? F.newEmail : F.email) || null, previousEmail: ("VERIFY_AND_CHANGE_EMAIL" === F.requestType ? F.email : F.newEmail) || null, multiFactorInfo: ge }, operation: ie } })).apply(this, arguments) } function Rt() { return (Rt = (0, i.Z)(function* (O, C) { const { data: S } = yield q((0, J.m9)(O), C); return S.email })).apply(this, arguments) } function wi() { return (wi = (0, i.Z)(function* (O, C, S) { const F = Dr(O), ie = yield na(F, { returnSecureToken: !0, email: C, password: S }), ge = yield pi._fromIdTokenResponse(F, "signIn", ie); return yield F._updateCurrentUser(ge.user), ge })).apply(this, arguments) } function ll() { return (ll = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O), ie = { requestType: "EMAIL_SIGNIN", email: C }; Ne(S.handleCodeInApp, F, "argument-error"), S && Oo(F, ie, S), yield ba(F, ie) })).apply(this, arguments) } function ql() { return (ql = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O), ie = Io.credentialWithLink(C, S || rn()); return Ne(ie._tenantId === (F.tenantId || null), F, "tenant-id-mismatch"), Ui(F, ie) })).apply(this, arguments) } function cl(O, C) { return po.apply(this, arguments) } function po() { return (po = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:createAuthUri", Ze(O, C)) })).apply(this, arguments) } function ul() { return (ul = (0, i.Z)(function* (O, C) { const F = { identifier: C, continueUri: On() ? rn() : "http://localhost" }, { signinMethods: ie } = yield cl((0, J.m9)(O), F); return ie || [] })).apply(this, arguments) } function Kl() { return (Kl = (0, i.Z)(function* (O, C) { const S = (0, J.m9)(O), ie = { requestType: "VERIFY_EMAIL", idToken: yield O.getIdToken() }; C && Oo(S.auth, ie, C); const { email: ge } = yield Di(S.auth, ie); ge !== O.email && (yield O.reload()) })).apply(this, arguments) } function Ms() { return (Ms = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O), ge = { requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: yield O.getIdToken(), newEmail: C }; S && Oo(F.auth, ge, S); const { email: Tt } = yield al(F.auth, ge); Tt !== O.email && (yield O.reload()) })).apply(this, arguments) } function hs(O, C) { return Ca.apply(this, arguments) } function Ca() { return (Ca = (0, i.Z)(function* (O, C) { return Ot(O, "POST", "/v1/accounts:update", C) })).apply(this, arguments) } function Co() { return (Co = (0, i.Z)(function* (O, { displayName: C, photoURL: S }) { if (void 0 === C && void 0 === S) return; const F = (0, J.m9)(O), ge = { idToken: yield F.getIdToken(), displayName: C, photoUrl: S, returnSecureToken: !0 }, Tt = yield ur(F, hs(F.auth, ge)); F.displayName = Tt.displayName || null, F.photoURL = Tt.photoUrl || null; const tn = F.providerData.find(({ providerId: Pn }) => "password" === Pn); tn && (tn.displayName = F.displayName, tn.photoURL = F.photoURL), yield F._updateTokensIfNecessary(Tt) })).apply(this, arguments) } function Jl(O, C, S) { return wc.apply(this, arguments) } function wc() { return (wc = (0, i.Z)(function* (O, C, S) { const { auth: F } = O, ge = { idToken: yield O.getIdToken(), returnSecureToken: !0 }; C && (ge.email = C), S && (ge.password = S); const Tt = yield ur(O, Gs(F, ge)); yield O._updateTokensIfNecessary(Tt, !0) })).apply(this, arguments) } class No { constructor(C, S, F = {}) { this.isNewUser = C, this.providerId = S, this.profile = F } } class Cc extends No { constructor(C, S, F, ie) { super(C, S, F), this.username = ie } } class fl extends No { constructor(C, S) { super(C, "facebook.com", S) } } class mu extends Cc { constructor(C, S) { super(C, "github.com", S, "string" == typeof S?.login ? S?.login : null) } } class Ta extends No { constructor(C, S) { super(C, "google.com", S) } } class Ec extends Cc { constructor(C, S, F) { super(C, "twitter.com", S, F) } } function Ol(O) { const { user: C, _tokenResponse: S } = O; return C.isAnonymous && !S ? { providerId: null, isNewUser: !1, profile: null } : function Ql(O) { var C, S; if (!O) return null; const { providerId: F } = O, ie = O.rawUserInfo ? JSON.parse(O.rawUserInfo) : {}, ge = O.isNewUser || "identitytoolkit#SignupNewUserResponse" === O.kind; if (!F && O?.idToken) { const Tt = null === (S = null === (C = yn(O.idToken)) || void 0 === C ? void 0 : C.firebase) || void 0 === S ? void 0 : S.sign_in_provider; if (Tt) return new No(ge, "anonymous" !== Tt && "custom" !== Tt ? Tt : null) } if (!F) return null; switch (F) { case "facebook.com": return new fl(ge, ie); case "github.com": return new mu(ge, ie); case "google.com": return new Ta(ge, ie); case "twitter.com": return new Ec(ge, ie, O.screenName || null); case "custom": case "anonymous": return new No(ge, null); default: return new No(ge, F, ie) } }(S) } class Ja { constructor(C, S, F) { this.type = C, this.credential = S, this.auth = F } static _fromIdtoken(C, S) { return new Ja("enroll", C, S) } static _fromMfaPendingCredential(C) { return new Ja("signin", C) } toJSON() { return { multiFactorSession: { ["enroll" === this.type ? "idToken" : "pendingCredential"]: this.credential } } } static fromJSON(C) { var S, F; if (C?.multiFactorSession) { if (null !== (S = C.multiFactorSession) && void 0 !== S && S.pendingCredential) return Ja._fromMfaPendingCredential(C.multiFactorSession.pendingCredential); if (null !== (F = C.multiFactorSession) && void 0 !== F && F.idToken) return Ja._fromIdtoken(C.multiFactorSession.idToken) } return null } } class ec { constructor(C, S, F) { this.session = C, this.hints = S, this.signInResolver = F } static _fromError(C, S) { const F = Dr(C), ie = S.customData._serverResponse, ge = (ie.mfaInfo || []).map(tn => oo._fromServerResponse(F, tn)); Ne(ie.mfaPendingCredential, F, "internal-error"); const Tt = Ja._fromMfaPendingCredential(ie.mfaPendingCredential); return new ec(Tt, ge, function () { var tn = (0, i.Z)(function* (Pn) { const tr = yield Pn._process(F, Tt); delete ie.mfaInfo, delete ie.mfaPendingCredential; const br = Object.assign(Object.assign({}, ie), { idToken: tr.idToken, refreshToken: tr.refreshToken }); switch (S.operationType) { case "signIn": const yr = yield pi._fromIdTokenResponse(F, S.operationType, br); return yield F._updateCurrentUser(yr.user), yr; case "reauthenticate": return Ne(S.user, F, "internal-error"), pi._forOperation(S.user, S.operationType, br); default: ct(F, "internal-error") } }); return function (Pn) { return tn.apply(this, arguments) } }()) } resolveSignIn(C) { var S = this; return (0, i.Z)(function* () { return S.signInResolver(C) })() } } function Da(O, C) { return Ot(O, "POST", "/v2/accounts/mfaEnrollment:start", Ze(O, C)) } class kl { constructor(C) { this.user = C, this.enrolledFactors = [], C._onReload(S => { S.mfaInfo && (this.enrolledFactors = S.mfaInfo.map(F => oo._fromServerResponse(C.auth, F))) }) } static _fromUser(C) { return new kl(C) } getSession() { var C = this; return (0, i.Z)(function* () { return Ja._fromIdtoken(yield C.user.getIdToken(), C.user.auth) })() } enroll(C, S) { var F = this; return (0, i.Z)(function* () { const ie = C, ge = yield F.getSession(), Tt = yield ur(F.user, ie._process(F.user.auth, ge, S)); return yield F.user._updateTokensIfNecessary(Tt), F.user.reload() })() } unenroll(C) { var S = this; return (0, i.Z)(function* () { const F = "string" == typeof C ? C : C.uid, ie = yield S.user.getIdToken(), ge = yield ur(S.user, function _u(O, C) { return Ot(O, "POST", "/v2/accounts/mfaEnrollment:withdraw", Ze(O, C)) }(S.user.auth, { idToken: ie, mfaEnrollmentId: F })); S.enrolledFactors = S.enrolledFactors.filter(({ uid: Tt }) => Tt !== F), yield S.user._updateTokensIfNecessary(ge); try { yield S.user.reload() } catch (Tt) { if ("auth/user-token-expired" !== Tt?.code) throw Tt } })() } } const z = new WeakMap, Z = "__sak"; class he { constructor(C, S) { this.storageRetriever = C, this.type = S } _isAvailable() { try { return this.storage ? (this.storage.setItem(Z, "1"), this.storage.removeItem(Z), Promise.resolve(!0)) : Promise.resolve(!1) } catch { return Promise.resolve(!1) } } _set(C, S) { return this.storage.setItem(C, JSON.stringify(S)), Promise.resolve() } _get(C) { const S = this.storage.getItem(C); return Promise.resolve(S ? JSON.parse(S) : null) } _remove(C) { return this.storage.removeItem(C), Promise.resolve() } get storage() { return this.storageRetriever() } } const ri = (() => { class O extends he { constructor() { super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (S, F) => this.onStorageEvent(S, F), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = function $e() { const O = (0, J.z$)(); return ar(O) || Ct(O) }() && function Br() { try { return !(!window || window === window.top) } catch { return !1 } }(), this.fallbackToPolling = ti(), this._shouldAllowMigration = !0 } forAllChangedKeys(S) { for (const F of Object.keys(this.listeners)) { const ie = this.storage.getItem(F), ge = this.localCache[F]; ie !== ge && S(F, ge, ie) } } onStorageEvent(S, F = !1) { if (!S.key) return void this.forAllChangedKeys((tn, Pn, tr) => { this.notifyListeners(tn, tr) }); const ie = S.key; if (F ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) { const tn = this.storage.getItem(ie); if (S.newValue !== tn) null !== S.newValue ? this.storage.setItem(ie, S.newValue) : this.storage.removeItem(ie); else if (this.localCache[ie] === S.newValue && !F) return } const ge = () => { const tn = this.storage.getItem(ie); !F && this.localCache[ie] === tn || this.notifyListeners(ie, tn) }, Tt = this.storage.getItem(ie); !function zn() { return (0, J.w1)() && 10 === document.documentMode }() || Tt === S.newValue || S.newValue === S.oldValue ? ge() : setTimeout(ge, 10) } notifyListeners(S, F) { this.localCache[S] = F; const ie = this.listeners[S]; if (ie) for (const ge of Array.from(ie)) ge(F && JSON.parse(F)) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(() => { this.forAllChangedKeys((S, F, ie) => { this.onStorageEvent(new StorageEvent("storage", { key: S, oldValue: F, newValue: ie }), !0) }) }, 1e3) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } attachListener() { window.addEventListener("storage", this.boundEventHandler) } detachListener() { window.removeEventListener("storage", this.boundEventHandler) } _addListener(S, F) { 0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[S] || (this.listeners[S] = new Set, this.localCache[S] = this.storage.getItem(S)), this.listeners[S].add(F) } _removeListener(S, F) { this.listeners[S] && (this.listeners[S].delete(F), 0 === this.listeners[S].size && delete this.listeners[S]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling()) } _set(S, F) { var ie = () => super._set, ge = this; return (0, i.Z)(function* () { yield ie().call(ge, S, F), ge.localCache[S] = JSON.stringify(F) })() } _get(S) { var F = () => super._get, ie = this; return (0, i.Z)(function* () { const ge = yield F().call(ie, S); return ie.localCache[S] = JSON.stringify(ge), ge })() } _remove(S) { var F = () => super._remove, ie = this; return (0, i.Z)(function* () { yield F().call(ie, S), delete ie.localCache[S] })() } } return O.type = "LOCAL", O })(), kr = (() => { class O extends he { constructor() { super(() => window.localStorage, "SESSION") } _addListener(S, F) { } _removeListener(S, F) { } } return O.type = "SESSION", O })(); let fs = (() => { class O { constructor(S) { this.eventTarget = S, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this) } static _getInstance(S) { const F = this.receivers.find(ge => ge.isListeningto(S)); if (F) return F; const ie = new O(S); return this.receivers.push(ie), ie } isListeningto(S) { return this.eventTarget === S } handleEvent(S) { var F = this; return (0, i.Z)(function* () { const ie = S, { eventId: ge, eventType: Tt, data: tn } = ie.data, Pn = F.handlersMap[Tt]; if (!Pn?.size) return; ie.ports[0].postMessage({ status: "ack", eventId: ge, eventType: Tt }); const tr = Array.from(Pn).map(function () { var yr = (0, i.Z)(function* (Ni) { return Ni(ie.origin, tn) }); return function (Ni) { return yr.apply(this, arguments) } }()), br = yield function Or(O) { return Promise.all(O.map(function () { var C = (0, i.Z)(function* (S) { try { return { fulfilled: !0, value: yield S } } catch (F) { return { fulfilled: !1, reason: F } } }); return function (S) { return C.apply(this, arguments) } }())) }(tr); ie.ports[0].postMessage({ status: "done", eventId: ge, eventType: Tt, response: br }) })() } _subscribe(S, F) { 0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[S] || (this.handlersMap[S] = new Set), this.handlersMap[S].add(F) } _unsubscribe(S, F) { this.handlersMap[S] && F && this.handlersMap[S].delete(F), (!F || 0 === this.handlersMap[S].size) && delete this.handlersMap[S], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler) } } return O.receivers = [], O })(); function xr(O = "", C = 10) { let S = ""; for (let F = 0; F < C; F++)S += Math.floor(10 * Math.random()); return O + S } class Os { constructor(C) { this.target = C, this.handlers = new Set } removeMessageHandler(C) { C.messageChannel && (C.messageChannel.port1.removeEventListener("message", C.onMessage), C.messageChannel.port1.close()), this.handlers.delete(C) } _send(C, S, F = 50) { var ie = this; return (0, i.Z)(function* () { const ge = typeof MessageChannel < "u" ? new MessageChannel : null; if (!ge) throw new Error("connection_unavailable"); let Tt, tn; return new Promise((Pn, tr) => { const br = xr("", 20); ge.port1.start(); const yr = setTimeout(() => { tr(new Error("unsupported_event")) }, F); tn = { messageChannel: ge, onMessage(Ni) { const Dl = Ni; if (Dl.data.eventId === br) switch (Dl.data.status) { case "ack": clearTimeout(yr), Tt = setTimeout(() => { tr(new Error("timeout")) }, 3e3); break; case "done": clearTimeout(Tt), Pn(Dl.data.response); break; default: clearTimeout(yr), clearTimeout(Tt), tr(new Error("invalid_response")) } } }, ie.handlers.add(tn), ge.port1.addEventListener("message", tn.onMessage), ie.target.postMessage({ eventType: C, eventId: br, data: S }, [ge.port2]) }).finally(() => { tn && ie.removeMessageHandler(tn) }) })() } } function mi() { return window } function To() { return typeof mi().WorkerGlobalScope < "u" && "function" == typeof mi().importScripts } function Ba() { return (Ba = (0, i.Z)(function* () { if (!navigator?.serviceWorker) return null; try { return (yield navigator.serviceWorker.ready).active } catch { return null } })).apply(this, arguments) } const Dc = "firebaseLocalStorageDb", Zo = "firebaseLocalStorage", qo = "fbase_key"; class gl { constructor(C) { this.request = C } toPromise() { return new Promise((C, S) => { this.request.addEventListener("success", () => { C(this.request.result) }), this.request.addEventListener("error", () => { S(this.request.error) }) }) } } function ko(O, C) { return O.transaction([Zo], C ? "readwrite" : "readonly").objectStore(Zo) } function Rl() { const O = indexedDB.open(Dc, 1); return new Promise((C, S) => { O.addEventListener("error", () => { S(O.error) }), O.addEventListener("upgradeneeded", () => { const F = O.result; try { F.createObjectStore(Zo, { keyPath: qo }) } catch (ie) { S(ie) } }), O.addEventListener("success", (0, i.Z)(function* () { const F = O.result; F.objectStoreNames.contains(Zo) ? C(F) : (F.close(), yield function Pl() { const O = indexedDB.deleteDatabase(Dc); return new gl(O).toPromise() }(), C(yield Rl())) })) }) } function $s(O, C, S) { return Fl.apply(this, arguments) } function Fl() { return (Fl = (0, i.Z)(function* (O, C, S) { const F = ko(O, !0).put({ [qo]: C, value: S }); return new gl(F).toPromise() })).apply(this, arguments) } function Qa() { return (Qa = (0, i.Z)(function* (O, C) { const S = ko(O, !1).get(C), F = yield new gl(S).toPromise(); return void 0 === F ? null : F.value })).apply(this, arguments) } function Xa(O, C) { const S = ko(O, !0).delete(C); return new gl(S).toPromise() } const Ll = (() => { class O { constructor() { this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => { }, () => { }) } _openDb() { var S = this; return (0, i.Z)(function* () { return S.db || (S.db = yield Rl()), S.db })() } _withRetries(S) { var F = this; return (0, i.Z)(function* () { let ie = 0; for (; ;)try { const ge = yield F._openDb(); return yield S(ge) } catch (ge) { if (ie++ > 3) throw ge; F.db && (F.db.close(), F.db = void 0) } })() } initializeServiceWorkerMessaging() { var S = this; return (0, i.Z)(function* () { return To() ? S.initializeReceiver() : S.initializeSender() })() } initializeReceiver() { var S = this; return (0, i.Z)(function* () { S.receiver = fs._getInstance(function xi() { return To() ? self : null }()), S.receiver._subscribe("keyChanged", function () { var F = (0, i.Z)(function* (ie, ge) { return { keyProcessed: (yield S._poll()).includes(ge.key) } }); return function (ie, ge) { return F.apply(this, arguments) } }()), S.receiver._subscribe("ping", function () { var F = (0, i.Z)(function* (ie, ge) { return ["keyChanged"] }); return function (ie, ge) { return F.apply(this, arguments) } }()) })() } initializeSender() { var S = this; return (0, i.Z)(function* () { var F, ie; if (S.activeServiceWorker = yield function go() { return Ba.apply(this, arguments) }(), !S.activeServiceWorker) return; S.sender = new Os(S.activeServiceWorker); const ge = yield S.sender._send("ping", {}, 800); ge && null !== (F = ge[0]) && void 0 !== F && F.fulfilled && null !== (ie = ge[0]) && void 0 !== ie && ie.value.includes("keyChanged") && (S.serviceWorkerReceiverAvailable = !0) })() } notifyServiceWorker(S) { var F = this; return (0, i.Z)(function* () { if (F.sender && F.activeServiceWorker && function Va() { var O; return (null === (O = navigator?.serviceWorker) || void 0 === O ? void 0 : O.controller) || null }() === F.activeServiceWorker) try { yield F.sender._send("keyChanged", { key: S }, F.serviceWorkerReceiverAvailable ? 800 : 50) } catch { } })() } _isAvailable() { return (0, i.Z)(function* () { try { if (!indexedDB) return !1; const S = yield Rl(); return yield $s(S, Z, "1"), yield Xa(S, Z), !0 } catch { } return !1 })() } _withPendingWrite(S) { var F = this; return (0, i.Z)(function* () { F.pendingWrites++; try { yield S() } finally { F.pendingWrites-- } })() } _set(S, F) { var ie = this; return (0, i.Z)(function* () { return ie._withPendingWrite((0, i.Z)(function* () { return yield ie._withRetries(ge => $s(ge, S, F)), ie.localCache[S] = F, ie.notifyServiceWorker(S) })) })() } _get(S) { var F = this; return (0, i.Z)(function* () { const ie = yield F._withRetries(ge => function Bs(O, C) { return Qa.apply(this, arguments) }(ge, S)); return F.localCache[S] = ie, ie })() } _remove(S) { var F = this; return (0, i.Z)(function* () { return F._withPendingWrite((0, i.Z)(function* () { return yield F._withRetries(ie => Xa(ie, S)), delete F.localCache[S], F.notifyServiceWorker(S) })) })() } _poll() { var S = this; return (0, i.Z)(function* () { const F = yield S._withRetries(Tt => { const tn = ko(Tt, !1).getAll(); return new gl(tn).toPromise() }); if (!F) return []; if (0 !== S.pendingWrites) return []; const ie = [], ge = new Set; for (const { fbase_key: Tt, value: tn } of F) ge.add(Tt), JSON.stringify(S.localCache[Tt]) !== JSON.stringify(tn) && (S.notifyListeners(Tt, tn), ie.push(Tt)); for (const Tt of Object.keys(S.localCache)) S.localCache[Tt] && !ge.has(Tt) && (S.notifyListeners(Tt, null), ie.push(Tt)); return ie })() } notifyListeners(S, F) { this.localCache[S] = F; const ie = this.listeners[S]; if (ie) for (const ge of Array.from(ie)) ge(F) } startPolling() { var S = this; this.stopPolling(), this.pollTimer = setInterval((0, i.Z)(function* () { return S._poll() }), 800) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } _addListener(S, F) { 0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[S] || (this.listeners[S] = new Set, this._get(S)), this.listeners[S].add(F) } _removeListener(S, F) { this.listeners[S] && (this.listeners[S].delete(F), 0 === this.listeners[S].size && delete this.listeners[S]), 0 === Object.keys(this.listeners).length && this.stopPolling() } } return O.type = "LOCAL", O })(); function yu(O, C) { return Ot(O, "POST", "/v2/accounts/mfaSignIn:start", Ze(O, C)) } function Ic() { return (Ic = (0, i.Z)(function* (O) { return (yield Ot(O, "GET", "/v1/recaptchaParams")).recaptchaSiteKey || "" })).apply(this, arguments) } function ia(O) { return new Promise((C, S) => { const F = document.createElement("script"); F.setAttribute("src", O), F.onload = C, F.onerror = ie => { const ge = Oe("internal-error"); ge.customData = ie, S(ge) }, F.type = "text/javascript", F.charset = "UTF-8", function ra() { var O, C; return null !== (C = null === (O = document.getElementsByTagName("head")) || void 0 === O ? void 0 : O[0]) && void 0 !== C ? C : document }().appendChild(F) }) } function Ac(O) { return `__${O}${Math.floor(1e6 * Math.random())}` } const Ko = 1e12; class Bu { constructor(C) { this.auth = C, this.counter = Ko, this._widgets = new Map } render(C, S) { const F = this.counter; return this._widgets.set(F, new Qc(C, this.auth.name, S || {})), this.counter++, F } reset(C) { var S; const F = C || Ko; null === (S = this._widgets.get(F)) || void 0 === S || S.delete(), this._widgets.delete(F) } getResponse(C) { var S; return (null === (S = this._widgets.get(C || Ko)) || void 0 === S ? void 0 : S.getResponse()) || "" } execute(C) { var S = this; return (0, i.Z)(function* () { var F; return null === (F = S._widgets.get(C || Ko)) || void 0 === F || F.execute(), "" })() } } class Qc { constructor(C, S, F) { this.params = F, this.timerId = null, this.deleted = !1, this.responseToken = null, this.clickHandler = () => { this.execute() }; const ie = "string" == typeof C ? document.getElementById(C) : C; Ne(ie, "argument-error", { appName: S }), this.container = ie, this.isVisible = "invisible" !== this.params.size, this.isVisible ? this.execute() : this.container.addEventListener("click", this.clickHandler) } getResponse() { return this.checkIfDeleted(), this.responseToken } delete() { this.checkIfDeleted(), this.deleted = !0, this.timerId && (clearTimeout(this.timerId), this.timerId = null), this.container.removeEventListener("click", this.clickHandler) } execute() { this.checkIfDeleted(), !this.timerId && (this.timerId = window.setTimeout(() => { this.responseToken = function Sa(O) { const C = [], S = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (let F = 0; F < O; F++)C.push(S.charAt(Math.floor(Math.random() * S.length))); return C.join("") }(50); const { callback: C, "expired-callback": S } = this.params; if (C) try { C(this.responseToken) } catch { } this.timerId = window.setTimeout(() => { if (this.timerId = null, this.responseToken = null, S) try { S() } catch { } this.isVisible && this.execute() }, 6e4) }, 500)) } checkIfDeleted() { if (this.deleted) throw new Error("reCAPTCHA mock was already deleted!") } } const ao = Ac("rcb"), xc = new fn(3e4, 6e4); class Ia { constructor() { var C; this.hostLanguage = "", this.counter = 0, this.librarySeparatelyLoaded = !(null === (C = mi().grecaptcha) || void 0 === C || !C.render) } load(C, S = "") { return Ne(function Vs(O) { return O.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(O) }(S), C, "argument-error"), this.shouldResolveImmediately(S) ? Promise.resolve(mi().grecaptcha) : new Promise((F, ie) => { const ge = mi().setTimeout(() => { ie(Oe(C, "network-request-failed")) }, xc.get()); mi()[ao] = () => { mi().clearTimeout(ge), delete mi()[ao]; const tn = mi().grecaptcha; if (!tn) return void ie(Oe(C, "internal-error")); const Pn = tn.render; tn.render = (tr, br) => { const yr = Pn(tr, br); return this.counter++, yr }, this.hostLanguage = S, F(tn) }, ia(`https://www.google.com/recaptcha/api.js??${(0, J.xO)({ onload: ao, render: "explicit", hl: S })}`).catch(() => { clearTimeout(ge), ie(Oe(C, "internal-error")) }) }) } clearedOneInstance() { this.counter-- } shouldResolveImmediately(C) { var S; return !(null === (S = mi().grecaptcha) || void 0 === S || !S.render) && (C === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded) } } class ii { load(C) { return (0, i.Z)(function* () { return new Bu(C) })() } clearedOneInstance() { } } const tc = "recaptcha", ud = { theme: "light", type: "image" }; class vu { constructor(C, S = Object.assign({}, ud), F) { this.parameters = S, this.type = tc, this.destroyed = !1, this.widgetId = null, this.tokenChangeListeners = new Set, this.renderPromise = null, this.recaptcha = null, this.auth = Dr(F), this.isInvisible = "invisible" === this.parameters.size, Ne(typeof document < "u", this.auth, "operation-not-supported-in-this-environment"); const ie = "string" == typeof C ? document.getElementById(C) : C; Ne(ie, this.auth, "argument-error"), this.container = ie, this.parameters.callback = this.makeTokenCallback(this.parameters.callback), this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new ii : new Ia, this.validateStartingState() } verify() { var C = this; return (0, i.Z)(function* () { C.assertNotDestroyed(); const S = yield C.render(), F = C.getAssertedRecaptcha(); return F.getResponse(S) || new Promise(ge => { const Tt = tn => { tn && (C.tokenChangeListeners.delete(Tt), ge(tn)) }; C.tokenChangeListeners.add(Tt), C.isInvisible && F.execute(S) }) })() } render() { try { this.assertNotDestroyed() } catch (C) { return Promise.reject(C) } return this.renderPromise || (this.renderPromise = this.makeRenderPromise().catch(C => { throw this.renderPromise = null, C })), this.renderPromise } _reset() { this.assertNotDestroyed(), null !== this.widgetId && this.getAssertedRecaptcha().reset(this.widgetId) } clear() { this.assertNotDestroyed(), this.destroyed = !0, this._recaptchaLoader.clearedOneInstance(), this.isInvisible || this.container.childNodes.forEach(C => { this.container.removeChild(C) }) } validateStartingState() { Ne(!this.parameters.sitekey, this.auth, "argument-error"), Ne(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error"), Ne(typeof document < "u", this.auth, "operation-not-supported-in-this-environment") } makeTokenCallback(C) { return S => { if (this.tokenChangeListeners.forEach(F => F(S)), "function" == typeof C) C(S); else if ("string" == typeof C) { const F = mi()[C]; "function" == typeof F && F(S) } } } assertNotDestroyed() { Ne(!this.destroyed, this.auth, "internal-error") } makeRenderPromise() { var C = this; return (0, i.Z)(function* () { if (yield C.init(), !C.widgetId) { let S = C.container; if (!C.isInvisible) { const F = document.createElement("div"); S.appendChild(F), S = F } C.widgetId = C.getAssertedRecaptcha().render(S, C.parameters) } return C.widgetId })() } init() { var C = this; return (0, i.Z)(function* () { Ne(On() && !To(), C.auth, "internal-error"), yield function ci() { let O = null; return new Promise(C => { "complete" !== document.readyState ? (O = () => C(), window.addEventListener("load", O)) : C() }).catch(C => { throw O && window.removeEventListener("load", O), C }) }(), C.recaptcha = yield C._recaptchaLoader.load(C.auth, C.auth.languageCode || void 0); const S = yield function eo(O) { return Ic.apply(this, arguments) }(C.auth); Ne(S, C.auth, "internal-error"), C.parameters.sitekey = S })() } getAssertedRecaptcha() { return Ne(this.recaptcha, this.auth, "internal-error"), this.recaptcha } } class Aa { constructor(C, S) { this.verificationId = C, this.onConfirmation = S } confirm(C) { const S = gr._fromVerification(this.verificationId, C); return this.onConfirmation(S) } } function Mc() { return (Mc = (0, i.Z)(function* (O, C, S) { const F = Dr(O), ie = yield Jo(F, C, (0, J.m9)(S)); return new Aa(ie, ge => Ui(F, ge)) })).apply(this, arguments) } function cn() { return (cn = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O); yield As(!1, F, "phone"); const ie = yield Jo(F.auth, C, (0, J.m9)(S)); return new Aa(ie, ge => ds(F, ge)) })).apply(this, arguments) } function Pe() { return (Pe = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O), ie = yield Jo(F.auth, C, (0, J.m9)(S)); return new Aa(ie, ge => Ra(F, ge)) })).apply(this, arguments) } function Jo(O, C, S) { return ml.apply(this, arguments) } function ml() { return (ml = (0, i.Z)(function* (O, C, S) { var F; const ie = yield S.verify(); try { let ge; if (Ne("string" == typeof ie, O, "argument-error"), Ne(S.type === tc, O, "argument-error"), ge = "string" == typeof C ? { phoneNumber: C } : C, "session" in ge) { const Tt = ge.session; if ("phoneNumber" in ge) return Ne("enroll" === Tt.type, O, "internal-error"), (yield Da(O, { idToken: Tt.credential, phoneEnrollmentInfo: { phoneNumber: ge.phoneNumber, recaptchaToken: ie } })).phoneSessionInfo.sessionInfo; { Ne("signin" === Tt.type, O, "internal-error"); const tn = (null === (F = ge.multiFactorHint) || void 0 === F ? void 0 : F.uid) || ge.multiFactorUid; return Ne(tn, O, "missing-multi-factor-info"), (yield yu(O, { mfaPendingCredential: Tt.credential, mfaEnrollmentId: tn, phoneSignInInfo: { recaptchaToken: ie } })).phoneResponseInfo.sessionInfo } } { const { sessionInfo: Tt } = yield hn(O, { phoneNumber: ge.phoneNumber, recaptchaToken: ie }); return Tt } } finally { S._reset() } })).apply(this, arguments) } function Bl() { return (Bl = (0, i.Z)(function* (O, C) { yield Za((0, J.m9)(O), C) })).apply(this, arguments) } let Xc = (() => { class O { constructor(S) { this.providerId = O.PROVIDER_ID, this.auth = Dr(S) } verifyPhoneNumber(S, F) { return Jo(this.auth, S, (0, J.m9)(F)) } static credential(S, F) { return gr._fromVerification(S, F) } static credentialFromResult(S) { return O.credentialFromTaggedObject(S) } static credentialFromError(S) { return O.credentialFromTaggedObject(S.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: S }) { if (!S) return null; const { phoneNumber: F, temporaryProof: ie } = S; return F && ie ? gr._fromTokenResponse(F, ie) : null } } return O.PROVIDER_ID = "phone", O.PHONE_SIGN_IN_METHOD = "phone", O })(); function ji(O, C) { return C ? st(C) : (Ne(O._popupRedirectResolver, O, "argument-error"), O._popupRedirectResolver) } class R extends Ei { constructor(C) { super("custom", "custom"), this.params = C } _getIdTokenResponse(C) { return ro(C, this._buildIdpRequest()) } _linkToIdToken(C, S) { return ro(C, this._buildIdpRequest(S)) } _getReauthenticationResolver(C) { return ro(C, this._buildIdpRequest()) } _buildIdpRequest(C) { const S = { requestUri: this.params.requestUri, sessionId: this.params.sessionId, postBody: this.params.postBody, tenantId: this.params.tenantId, pendingToken: this.params.pendingToken, returnSecureToken: !0, returnIdpCredential: !0 }; return C && (S.idToken = C), S } } function V(O) { return xo(O.auth, new R(O), O.bypassAuthState) } function M(O) { const { auth: C, user: S } = O; return Ne(S, C, "internal-error"), Ks(S, new R(O), O.bypassAuthState) } function G(O) { return X.apply(this, arguments) } function X() { return (X = (0, i.Z)(function* (O) { const { auth: C, user: S } = O; return Ne(S, C, "internal-error"), Za(S, new R(O), O.bypassAuthState) })).apply(this, arguments) } class ce { constructor(C, S, F, ie, ge = !1) { this.auth = C, this.resolver = F, this.user = ie, this.bypassAuthState = ge, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(S) ? S : [S] } execute() { var C = this; return new Promise(function () { var S = (0, i.Z)(function* (F, ie) { C.pendingPromise = { resolve: F, reject: ie }; try { C.eventManager = yield C.resolver._initialize(C.auth), yield C.onExecution(), C.eventManager.registerConsumer(C) } catch (ge) { C.reject(ge) } }); return function (F, ie) { return S.apply(this, arguments) } }()) } onAuthEvent(C) { var S = this; return (0, i.Z)(function* () { const { urlResponse: F, sessionId: ie, postBody: ge, tenantId: Tt, error: tn, type: Pn } = C; if (tn) return void S.reject(tn); const tr = { auth: S.auth, requestUri: F, sessionId: ie, tenantId: Tt || void 0, postBody: ge || void 0, user: S.user, bypassAuthState: S.bypassAuthState }; try { S.resolve(yield S.getIdpTask(Pn)(tr)) } catch (br) { S.reject(br) } })() } onError(C) { this.reject(C) } getIdpTask(C) { switch (C) { case "signInViaPopup": case "signInViaRedirect": return V; case "linkViaPopup": case "linkViaRedirect": return G; case "reauthViaPopup": case "reauthViaRedirect": return M; default: ct(this.auth, "internal-error") } } resolve(C) { Fe(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(C), this.unregisterAndCleanUp() } reject(C) { Fe(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(C), this.unregisterAndCleanUp() } unregisterAndCleanUp() { this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp() } } const be = new fn(2e3, 1e4); function on() { return (on = (0, i.Z)(function* (O, C, S) { const F = Dr(O); Be(O, C, Xn); const ie = ji(F, S); return new Sr(F, "signInViaPopup", C, ie).executeNotNull() })).apply(this, arguments) } function Vn() { return (Vn = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O); Be(F.auth, C, Xn); const ie = ji(F.auth, S); return new Sr(F.auth, "reauthViaPopup", C, ie, F).executeNotNull() })).apply(this, arguments) } function Gr() { return (Gr = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O); Be(F.auth, C, Xn); const ie = ji(F.auth, S); return new Sr(F.auth, "linkViaPopup", C, ie, F).executeNotNull() })).apply(this, arguments) } let Sr = (() => { class O extends ce { constructor(S, F, ie, ge, Tt) { super(S, F, ge, Tt), this.provider = ie, this.authWindow = null, this.pollId = null, O.currentPopupAction && O.currentPopupAction.cancel(), O.currentPopupAction = this } executeNotNull() { var S = this; return (0, i.Z)(function* () { const F = yield S.execute(); return Ne(F, S.auth, "internal-error"), F })() } onExecution() { var S = this; return (0, i.Z)(function* () { Fe(1 === S.filter.length, "Popup operations only handle one event"); const F = xr(); S.authWindow = yield S.resolver._openPopup(S.auth, S.provider, S.filter[0], F), S.authWindow.associatedEvent = F, S.resolver._originValidation(S.auth).catch(ie => { S.reject(ie) }), S.resolver._isIframeWebStorageSupported(S.auth, ie => { ie || S.reject(Oe(S.auth, "web-storage-unsupported")) }), S.pollUserCancellation() })() } get eventId() { var S; return (null === (S = this.authWindow) || void 0 === S ? void 0 : S.associatedEvent) || null } cancel() { this.reject(Oe(this.auth, "cancelled-popup-request")) } cleanUp() { this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, O.currentPopupAction = null } pollUserCancellation() { const S = () => { var F, ie; this.pollId = null !== (ie = null === (F = this.authWindow) || void 0 === F ? void 0 : F.window) && void 0 !== ie && ie.closed ? window.setTimeout(() => { this.pollId = null, this.reject(Oe(this.auth, "popup-closed-by-user")) }, 2e3) : window.setTimeout(S, be.get()) }; S() } } return O.currentPopupAction = null, O })(); const Wi = new Map; class sa extends ce { constructor(C, S, F = !1) { super(C, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], S, void 0, F), this.eventId = null } execute() { var C = () => super.execute, S = this; return (0, i.Z)(function* () { let F = Wi.get(S.auth._key()); if (!F) { try { const ge = (yield function bu(O, C) { return lo.apply(this, arguments) }(S.resolver, S.auth)) ? yield C().call(S) : null; F = () => Promise.resolve(ge) } catch (ie) { F = () => Promise.reject(ie) } Wi.set(S.auth._key(), F) } return S.bypassAuthState || Wi.set(S.auth._key(), () => Promise.resolve(null)), F() })() } onAuthEvent(C) { var S = () => super.onAuthEvent, F = this; return (0, i.Z)(function* () { if ("signInViaRedirect" === C.type) return S().call(F, C); if ("unknown" !== C.type) { if (C.eventId) { const ie = yield F.auth._redirectUserForId(C.eventId); if (ie) return F.user = ie, S().call(F, C); F.resolve(null) } } else F.resolve(null) })() } onExecution() { return (0, i.Z)(function* () { })() } cleanUp() { } } function lo() { return (lo = (0, i.Z)(function* (O, C) { const S = la(C), F = aa(O); if (!(yield F._isAvailable())) return !1; const ie = "true" === (yield F._get(S)); return yield F._remove(S), ie })).apply(this, arguments) } function oa(O, C) { return Ns.apply(this, arguments) } function Ns() { return (Ns = (0, i.Z)(function* (O, C) { return aa(O)._set(la(C), "true") })).apply(this, arguments) } function Qo(O, C) { Wi.set(O._key(), C) } function aa(O) { return st(O._redirectPersistence) } function la(O) { return et("pendingRedirect", O.config.apiKey, O.name) } function W() { return (W = (0, i.Z)(function* (O, C, S) { const F = Dr(O); Be(O, C, Xn); const ie = ji(F, S); return yield oa(ie, F), ie._openRedirect(F, C, "signInViaRedirect") })).apply(this, arguments) } function We() { return (We = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O); Be(F.auth, C, Xn); const ie = ji(F.auth, S); yield oa(ie, F.auth); const ge = yield Pr(F); return ie._openRedirect(F.auth, C, "reauthViaRedirect", ge) })).apply(this, arguments) } function _n() { return (_n = (0, i.Z)(function* (O, C, S) { const F = (0, J.m9)(O); Be(F.auth, C, Xn); const ie = ji(F.auth, S); yield As(!1, F, C.providerId), yield oa(ie, F.auth); const ge = yield Pr(F); return ie._openRedirect(F.auth, C, "linkViaRedirect", ge) })).apply(this, arguments) } function er() { return (er = (0, i.Z)(function* (O, C) { return yield Dr(O)._initializationPromise, ir(O, C, !1) })).apply(this, arguments) } function ir(O, C) { return Ir.apply(this, arguments) } function Ir() { return (Ir = (0, i.Z)(function* (O, C, S = !1) { const F = Dr(O), ie = ji(F, C), Tt = yield new sa(F, ie, S).execute(); return Tt && !S && (delete Tt.user._redirectEventId, yield F._persistUserIfCurrent(Tt.user), yield F._setRedirectUser(null, C)), Tt })).apply(this, arguments) } function Pr(O) { return ca.apply(this, arguments) } function ca() { return (ca = (0, i.Z)(function* (O) { const C = xr(`${O.uid}:::`); return O._redirectEventId = C, yield O.auth._setRedirectUser(O), yield O.auth._persistUserIfCurrent(O), C })).apply(this, arguments) } class Vl { constructor(C) { this.auth = C, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now() } registerConsumer(C) { this.consumers.add(C), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, C) && (this.sendToConsumer(this.queuedRedirectEvent, C), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null) } unregisterConsumer(C) { this.consumers.delete(C) } onEvent(C) { if (this.hasEventBeenHandled(C)) return !1; let S = !1; return this.consumers.forEach(F => { this.isEventForConsumer(C, F) && (S = !0, this.sendToConsumer(C, F), this.saveEventToCache(C)) }), this.hasHandledPotentialRedirect || !function nl(O) { switch (O.type) { case "signInViaRedirect": case "linkViaRedirect": case "reauthViaRedirect": return !0; case "unknown": return _l(O); default: return !1 } }(C) || (this.hasHandledPotentialRedirect = !0, S || (this.queuedRedirectEvent = C, S = !0)), S } sendToConsumer(C, S) { var F; if (C.error && !_l(C)) { const ie = (null === (F = C.error.code) || void 0 === F ? void 0 : F.split("auth/")[1]) || "internal-error"; S.onError(Oe(this.auth, ie)) } else S.onAuthEvent(C) } isEventForConsumer(C, S) { const F = null === S.eventId || !!C.eventId && C.eventId === S.eventId; return S.filter.includes(C.type) && F } hasEventBeenHandled(C) { return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(Uu(C)) } saveEventToCache(C) { this.cachedEventUids.add(Uu(C)), this.lastProcessedEventTime = Date.now() } } function Uu(O) { return [O.type, O.eventId, O.sessionId, O.tenantId].filter(C => C).join("-") } function _l({ type: O, error: C }) { return "unknown" === O && "auth/no-auth-event" === C?.code } function nc(O) { return eu.apply(this, arguments) } function eu() { return (eu = (0, i.Z)(function* (O, C = {}) { return Ot(O, "GET", "/v1/projects", C) })).apply(this, arguments) } const If = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, dp = /^https?/; function Af() { return (Af = (0, i.Z)(function* (O) { if (O.config.emulator) return; const { authorizedDomains: C } = yield nc(O); for (const S of C) try { if (xf(S)) return } catch { } ct(O, "unauthorized-domain") })).apply(this, arguments) } function xf(O) { const C = rn(), { protocol: S, hostname: F } = new URL(C); if (O.startsWith("chrome-extension://")) { const Tt = new URL(O); return "" === Tt.hostname && "" === F ? "chrome-extension:" === S && O.replace("chrome-extension://", "") === C.replace("chrome-extension://", "") : "chrome-extension:" === S && Tt.hostname === F } if (!dp.test(S)) return !1; if (If.test(O)) return F === O; const ie = O.replace(/\./g, "\\."); return new RegExp("^(.+\\." + ie + "|" + ie + ")$", "i").test(F) } const Uh = new fn(3e4, 6e4); function hp() { const O = mi().___jsl; if (O?.H) for (const C of Object.keys(O.H)) if (O.H[C].r = O.H[C].r || [], O.H[C].L = O.H[C].L || [], O.H[C].r = [...O.H[C].L], O.CP) for (let S = 0; S < O.CP.length; S++)O.CP[S] = null } let fh = null; function pg(O) { return fh = fh || function fg(O) { return new Promise((C, S) => { var F, ie, ge; function Tt() { hp(), gapi.load("gapi.iframes", { callback: () => { C(gapi.iframes.getContext()) }, ontimeout: () => { hp(), S(Oe(O, "network-request-failed")) }, timeout: Uh.get() }) } if (null !== (ie = null === (F = mi().gapi) || void 0 === F ? void 0 : F.iframes) && void 0 !== ie && ie.Iframe) C(gapi.iframes.getContext()); else { if (null === (ge = mi().gapi) || void 0 === ge || !ge.load) { const tn = Ac("iframefcb"); return mi()[tn] = () => { gapi.load ? Tt() : S(Oe(O, "network-request-failed")) }, ia(`https://apis.google.com/js/api.js?onload=${tn}`).catch(Pn => S(Pn)) } Tt() } }).catch(C => { throw fh = null, C }) }(O), fh } const fp = new fn(5e3, 15e3), mg = { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" }, "aria-hidden": "true", tabindex: "-1" }, _g = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]); function yg(O) { const C = O.config; Ne(C.authDomain, O, "auth-domain-config-required"); const S = C.emulator ? It(C, "emulator/auth/iframe") : `https://${O.config.authDomain}/__/auth/iframe`, F = { apiKey: C.apiKey, appName: O.name, v: ye.SDK_VERSION }, ie = _g.get(O.config.apiHost); ie && (F.eid = ie); const ge = O._getFrameworks(); return ge.length && (F.fw = ge.join(",")), `${S}?${(0, J.xO)(F).slice(1)}` } function Hh() { return Hh = (0, i.Z)(function* (O) { const C = yield pg(O), S = mi().gapi; return Ne(S, O, "internal-error"), C.open({ where: document.body, url: yg(O), messageHandlersFilter: S.iframes.CROSS_ORIGIN_IFRAMES_FILTER, attributes: mg, dontclear: !0 }, F => new Promise(function () { var ie = (0, i.Z)(function* (ge, Tt) { yield F.restyle({ setHideOnLeave: !1 }); const tn = Oe(O, "network-request-failed"), Pn = mi().setTimeout(() => { Tt(tn) }, fp.get()); function tr() { mi().clearTimeout(Pn), ge(F) } F.ping(tr).then(tr, () => { Tt(tn) }) }); return function (ge, Tt) { return ie.apply(this, arguments) } }())) }), Hh.apply(this, arguments) } const mo = { location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no" }; class vl { constructor(C) { this.window = C, this.associatedEvent = null } close() { if (this.window) try { this.window.close() } catch { } } } function gh(O, C, S, F, ie, ge) { Ne(O.config.authDomain, O, "auth-domain-config-required"), Ne(O.config.apiKey, O, "invalid-api-key"); const Tt = { apiKey: O.config.apiKey, appName: O.name, authType: S, redirectUrl: F, v: ye.SDK_VERSION, eventId: ie }; if (C instanceof Xn) { C.setDefaultLanguage(O.languageCode), Tt.providerId = C.providerId || "", (0, J.xb)(C.getCustomParameters()) || (Tt.customParameters = JSON.stringify(C.getCustomParameters())); for (const [Pn, tr] of Object.entries(ge || {})) Tt[Pn] = tr } if (C instanceof uo) { const Pn = C.getScopes().filter(tr => "" !== tr); Pn.length > 0 && (Tt.scopes = Pn.join(",")) } O.tenantId && (Tt.tid = O.tenantId); const tn = Tt; for (const Pn of Object.keys(tn)) void 0 === tn[Pn] && delete tn[Pn]; return `${function Hd({ config: O }) { return O.emulator ? It(O, "emulator/auth/handler") : `https://${O.authDomain}/__/auth/handler` }(O)}?${(0, J.xO)(tn).slice(1)}` } const Hu = "webStorageSupport", zd = class tu { constructor() { this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = kr, this._completeRedirectFn = ir, this._overrideRedirectResult = Qo } _openPopup(C, S, F, ie) { var ge = this; return (0, i.Z)(function* () { var Tt; Fe(null === (Tt = ge.eventManagers[C._key()]) || void 0 === Tt ? void 0 : Tt.manager, "_initialize() not called before _openPopup()"); const tn = gh(C, S, F, rn(), ie); return function ph(O, C, S, F = 500, ie = 600) { const ge = Math.max((window.screen.availHeight - ie) / 2, 0).toString(), Tt = Math.max((window.screen.availWidth - F) / 2, 0).toString(); let tn = ""; const Pn = Object.assign(Object.assign({}, mo), { width: F.toString(), height: ie.toString(), top: ge, left: Tt }), tr = (0, J.z$)().toLowerCase(); S && (tn = sr(tr) ? "_blank" : S), An(tr) && (C = C || "http://localhost", Pn.scrollbars = "yes"); const br = Object.entries(Pn).reduce((Ni, [Dl, Ku]) => `${Ni}${Dl}=${Ku},`, ""); if (function xn(O = (0, J.z$)()) { var C; return Ct(O) && !(null === (C = window.navigator) || void 0 === C || !C.standalone) }(tr) && "_self" !== tn) return function Gh(O, C) { const S = document.createElement("a"); S.href = O, S.target = C; const F = document.createEvent("MouseEvent"); F.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), S.dispatchEvent(F) }(C || "", tn), new vl(null); const yr = window.open(C || "", tn, br); Ne(yr, O, "popup-blocked"); try { yr.focus() } catch { } return new vl(yr) }(C, tn, xr()) })() } _openRedirect(C, S, F, ie) { var ge = this; return (0, i.Z)(function* () { return yield ge._originValidation(C), function bs(O) { mi().location.href = O }(gh(C, S, F, rn(), ie)), new Promise(() => { }) })() } _initialize(C) { const S = C._key(); if (this.eventManagers[S]) { const { manager: ie, promise: ge } = this.eventManagers[S]; return ie ? Promise.resolve(ie) : (Fe(ge, "If manager is not set, promise should be"), ge) } const F = this.initAndGetManager(C); return this.eventManagers[S] = { promise: F }, F.catch(() => { delete this.eventManagers[S] }), F } initAndGetManager(C) { var S = this; return (0, i.Z)(function* () { const F = yield function wm(O) { return Hh.apply(this, arguments) }(C), ie = new Vl(C); return F.register("authEvent", ge => (Ne(ge?.authEvent, C, "invalid-auth-event"), { status: ie.onEvent(ge.authEvent) ? "ACK" : "ERROR" }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), S.eventManagers[C._key()] = { manager: ie }, S.iframes[C._key()] = F, ie })() } _isIframeWebStorageSupported(C, S) { this.iframes[C._key()].send(Hu, { type: Hu }, ie => { var ge; const Tt = null === (ge = ie?.[0]) || void 0 === ge ? void 0 : ge[Hu]; void 0 !== Tt && S(!!Tt), ct(C, "internal-error") }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER) } _originValidation(C) { const S = C._key(); return this.originValidationPromises[S] || (this.originValidationPromises[S] = function hh(O) { return Af.apply(this, arguments) }(C)), this.originValidationPromises[S] } get _shouldInitProactively() { return ti() || ar() || Ct() } }; class Mf { constructor(C) { this.factorId = C } _process(C, S, F) { switch (S.type) { case "enroll": return this._finalizeEnroll(C, S.credential, F); case "signin": return this._finalizeSignIn(C, S.credential); default: return tt("unexpected MultiFactorSessionType") } } } class Of extends Mf { constructor(C) { super("phone"), this.credential = C } static _fromCredential(C) { return new Of(C) } _finalizeEnroll(C, S, F) { return function Nl(O, C) { return Ot(O, "POST", "/v2/accounts/mfaEnrollment:finalize", Ze(O, C)) }(C, { idToken: S, displayName: F, phoneVerificationInfo: this.credential._makeVerificationRequest() }) } _finalizeSignIn(C, S) { return function Lu(O, C) { return Ot(O, "POST", "/v2/accounts/mfaSignIn:finalize", Ze(O, C)) }(C, { mfaPendingCredential: S, phoneVerificationInfo: this.credential._makeVerificationRequest() }) } } let xa = (() => { class O { constructor() { } static assertion(S) { return Of._fromCredential(S) } } return O.FACTOR_ID = "phone", O })(); var bl = "@firebase/auth"; class hd { constructor(C) { this.auth = C, this.internalListeners = new Map } getUid() { var C; return this.assertAuthConfigured(), (null === (C = this.auth.currentUser) || void 0 === C ? void 0 : C.uid) || null } getToken(C) { var S = this; return (0, i.Z)(function* () { return S.assertAuthConfigured(), yield S.auth._initializationPromise, S.auth.currentUser ? { accessToken: yield S.auth.currentUser.getIdToken(C) } : null })() } addAuthTokenListener(C) { if (this.assertAuthConfigured(), this.internalListeners.has(C)) return; const S = this.auth.onIdTokenChanged(F => { C(F?.stsTokenManager.accessToken || null) }); this.internalListeners.set(C, S), this.updateProactiveRefresh() } removeAuthTokenListener(C) { this.assertAuthConfigured(); const S = this.internalListeners.get(C); S && (this.internalListeners.delete(C), S(), this.updateProactiveRefresh()) } assertAuthConfigured() { Ne(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth") } updateProactiveRefresh() { this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh() } } function zu() { return window } function jh() { return (jh = (0, i.Z)(function* (O, C, S) { var F; const { BuildInfo: ie } = zu(); Fe(C.sessionId, "AuthEvent did not contain a session ID"); const ge = yield ju(C.sessionId), Tt = {}; return Ct() ? Tt.ibi = ie.packageName : ze() ? Tt.apn = ie.packageName : ct(O, "operation-not-supported-in-this-environment"), ie.displayName && (Tt.appDisplayName = ie.displayName), Tt.sessionId = ge, gh(O, S, C.type, void 0, null !== (F = C.eventId) && void 0 !== F ? F : void 0, Tt) })).apply(this, arguments) } function yh() { return (yh = (0, i.Z)(function* (O) { const { BuildInfo: C } = zu(), S = {}; Ct() ? S.iosBundleId = C.packageName : ze() ? S.androidPackageName = C.packageName : ct(O, "operation-not-supported-in-this-environment"), yield nc(O, S) })).apply(this, arguments) } function Gu() { return (Gu = (0, i.Z)(function* (O, C, S) { const { cordova: F } = zu(); let ie = () => { }; try { yield new Promise((ge, Tt) => { let tn = null; function Pn() { var yr; ge(); const Ni = null === (yr = F.plugins.browsertab) || void 0 === yr ? void 0 : yr.close; "function" == typeof Ni && Ni(), "function" == typeof S?.close && S.close() } function tr() { tn || (tn = window.setTimeout(() => { Tt(Oe(O, "redirect-cancelled-by-user")) }, 2e3)) } function br() { "visible" === document?.visibilityState && tr() } C.addPassiveListener(Pn), document.addEventListener("resume", tr, !1), ze() && document.addEventListener("visibilitychange", br, !1), ie = () => { C.removePassiveListener(Pn), document.removeEventListener("resume", tr, !1), document.removeEventListener("visibilitychange", br, !1), tn && window.clearTimeout(tn) } }) } finally { ie() } })).apply(this, arguments) } function ju(O) { return fd.apply(this, arguments) } function fd() { return (fd = (0, i.Z)(function* (O) { const C = Zi(O), S = yield crypto.subtle.digest("SHA-256", C); return Array.from(new Uint8Array(S)).map(ie => ie.toString(16).padStart(2, "0")).join("") })).apply(this, arguments) } function Zi(O) { if (Fe(/[0-9a-zA-Z]+/.test(O), "Can only convert alpha-numeric strings"), typeof TextEncoder < "u") return (new TextEncoder).encode(O); const C = new ArrayBuffer(O.length), S = new Uint8Array(C); for (let F = 0; F < O.length; F++)S[F] = O.charCodeAt(F); return S } (0, J.Pz)("authIdTokenMaxAge"), function Gd(O) { (0, ye._registerComponent)(new Te.wA("auth", (C, { options: S }) => { const F = C.getProvider("app").getImmediate(), ie = C.getProvider("heartbeat"), { apiKey: ge, authDomain: Tt } = F.options; return ((tn, Pn) => { Ne(ge && !ge.includes(":"), "invalid-api-key", { appName: tn.name }), Ne(!Tt?.includes(":"), "argument-error", { appName: tn.name }); const tr = { apiKey: ge, authDomain: Tt, clientPlatform: O, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: ss(O) }, br = new vo(tn, Pn, tr); return function Kt(O, C) { const S = C?.persistence || [], F = (Array.isArray(S) ? S : [S]).map(st); C?.errorMap && O._updateErrorMap(C.errorMap), O._initializeWithPersistence(F, C?.popupRedirectResolver) }(br, S), br })(F, ie) }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((C, S, F) => { C.getProvider("auth-internal").initialize() })), (0, ye._registerComponent)(new Te.wA("auth-internal", C => { const S = Dr(C.getProvider("auth").getImmediate()); return new hd(S) }, "PRIVATE").setInstantiationMode("EXPLICIT")), (0, ye.registerVersion)(bl, "0.21.0", function Xo(O) { switch (O) { case "Node": return "node"; case "ReactNative": return "rn"; case "Worker": return "webworker"; case "Cordova": return "cordova"; default: return } }(O)), (0, ye.registerVersion)(bl, "0.21.0", "esm2017") }("Browser"); class Qr extends Vl { constructor() { super(...arguments), this.passiveListeners = new Set, this.initPromise = new Promise(C => { this.resolveInialized = C }) } addPassiveListener(C) { this.passiveListeners.add(C) } removePassiveListener(C) { this.passiveListeners.delete(C) } resetRedirect() { this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1 } onEvent(C) { return this.resolveInialized(), this.passiveListeners.forEach(S => S(C)), super.onEvent(C) } initialized() { var C = this; return (0, i.Z)(function* () { yield C.initPromise })() } } function ic(O) { return wu.apply(this, arguments) } function wu() { return (wu = (0, i.Z)(function* (O) { const C = yield Hs()._get(Xr(O)); return C && (yield Hs()._remove(Xr(O))), C })).apply(this, arguments) } function $u() { const O = [], C = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (let S = 0; S < 20; S++) { const F = Math.floor(Math.random() * C.length); O.push(C.charAt(F)) } return O.join("") } function Hs() { return st(ri) } function Xr(O) { return et("authEvent", O.config.apiKey, O.name) } function pd(O) { if (!O?.includes("?")) return {}; const [C, ...S] = O.split("?"); return (0, J.zd)(S.join("?")) } const ru = class Zh { constructor() { this._redirectPersistence = kr, this._shouldInitProactively = !0, this.eventManagers = new Map, this.originValidationPromises = {}, this._completeRedirectFn = ir, this._overrideRedirectResult = Qo } _initialize(C) { var S = this; return (0, i.Z)(function* () { const F = C._key(); let ie = S.eventManagers.get(F); return ie || (ie = new Qr(C), S.eventManagers.set(F, ie), S.attachCallbackListeners(C, ie)), ie })() } _openPopup(C) { ct(C, "operation-not-supported-in-this-environment") } _openRedirect(C, S, F, ie) { var ge = this; return (0, i.Z)(function* () { !function Wh(O) { var C, S, F, ie, ge, Tt, tn, Pn, tr, br; const yr = zu(); Ne("function" == typeof (null === (C = yr?.universalLinks) || void 0 === C ? void 0 : C.subscribe), O, "invalid-cordova-configuration", { missingPlugin: "cordova-universal-links-plugin-fix" }), Ne(typeof (null === (S = yr?.BuildInfo) || void 0 === S ? void 0 : S.packageName) < "u", O, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-buildInfo" }), Ne("function" == typeof (null === (ge = null === (ie = null === (F = yr?.cordova) || void 0 === F ? void 0 : F.plugins) || void 0 === ie ? void 0 : ie.browsertab) || void 0 === ge ? void 0 : ge.openUrl), O, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), Ne("function" == typeof (null === (Pn = null === (tn = null === (Tt = yr?.cordova) || void 0 === Tt ? void 0 : Tt.plugins) || void 0 === tn ? void 0 : tn.browsertab) || void 0 === Pn ? void 0 : Pn.isAvailable), O, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), Ne("function" == typeof (null === (br = null === (tr = yr?.cordova) || void 0 === tr ? void 0 : tr.InAppBrowser) || void 0 === br ? void 0 : br.open), O, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-inappbrowser" }) }(C); const Tt = yield ge._initialize(C); yield Tt.initialized(), Tt.resetRedirect(), function kc() { Wi.clear() }(), yield ge._originValidation(C); const tn = function rc(O, C, S = null) { return { type: C, eventId: S, urlResponse: null, sessionId: $u(), postBody: null, tenantId: O.tenantId, error: Oe(O, "no-auth-event") } }(C, F, ie); yield function ts(O, C) { return Hs()._set(Xr(O), C) }(C, tn); const Pn = yield function Nf(O, C, S) { return jh.apply(this, arguments) }(C, tn, S), tr = yield function $h(O) { const { cordova: C } = zu(); return new Promise(S => { C.plugins.browsertab.isAvailable(F => { let ie = null; F ? C.plugins.browsertab.openUrl(O) : ie = C.InAppBrowser.open(O, function nn(O = (0, J.z$)()) { return /(iPad|iPhone|iPod).*OS 7_\d/i.test(O) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(O) }() ? "_blank" : "_system", "location=yes"), S(ie) }) }) }(Pn); return function yp(O, C, S) { return Gu.apply(this, arguments) }(C, Tt, tr) })() } _isIframeWebStorageSupported(C, S) { throw new Error("Method not implemented.") } _originValidation(C) { const S = C._key(); return this.originValidationPromises[S] || (this.originValidationPromises[S] = function _p(O) { return yh.apply(this, arguments) }(C)), this.originValidationPromises[S] } attachCallbackListeners(C, S) { const { universalLinks: F, handleOpenURL: ie, BuildInfo: ge } = zu(), Tt = setTimeout((0, i.Z)(function* () { yield ic(C), S.onEvent(qh()) }), 500), tn = function () { var br = (0, i.Z)(function* (yr) { clearTimeout(Tt); const Ni = yield ic(C); let Dl = null; Ni && yr?.url && (Dl = function Cu(O, C) { var S, F; const ie = function vp(O) { const C = pd(O), S = C.link ? decodeURIComponent(C.link) : void 0, F = pd(S).link, ie = C.deep_link_id ? decodeURIComponent(C.deep_link_id) : void 0; return pd(ie).link || ie || F || S || O }(C); if (ie.includes("/__/auth/callback")) { const ge = pd(ie), Tt = ge.firebaseError ? function ws(O) { try { return JSON.parse(O) } catch { return null } }(decodeURIComponent(ge.firebaseError)) : null, tn = null === (F = null === (S = Tt?.code) || void 0 === S ? void 0 : S.split("auth/")) || void 0 === F ? void 0 : F[1], Pn = tn ? Oe(tn) : null; return Pn ? { type: O.type, eventId: O.eventId, tenantId: O.tenantId, error: Pn, urlResponse: null, sessionId: null, postBody: null } : { type: O.type, eventId: O.eventId, tenantId: O.tenantId, sessionId: O.sessionId, urlResponse: ie, postBody: null } } return null }(Ni, yr.url)), S.onEvent(Dl || qh()) }); return function (Ni) { return br.apply(this, arguments) } }(); typeof F < "u" && "function" == typeof F.subscribe && F.subscribe(null, tn); const Pn = ie, tr = `${ge.packageName.toLowerCase()}://`; zu().handleOpenURL = function () { var br = (0, i.Z)(function* (yr) { if (yr.toLowerCase().startsWith(tr) && tn({ url: yr }), "function" == typeof Pn) try { Pn(yr) } catch (Ni) { console.error(Ni) } }); return function (yr) { return br.apply(this, arguments) } }() } }; function qh() { return { type: "unknown", eventId: null, sessionId: null, urlResponse: null, postBody: null, tenantId: null, error: Oe("no-auth-event") } } function gd() { var O; return (null === (O = self?.location) || void 0 === O ? void 0 : O.protocol) || null } function Yh(O = (0, J.z$)()) { return !("file:" !== gd() && "ionic:" !== gd() && "capacitor:" !== gd() || !O.toLowerCase().match(/iphone|ipad|ipod|android/)) } function si() { try { const O = self.localStorage, C = xr(); if (O) return O.setItem(C, "1"), O.removeItem(C), !function sc(O = (0, J.z$)()) { return function Wu() { return (0, J.w1)() && 11 === document?.documentMode }() || function md(O = (0, J.z$)()) { return /Edge\/\d+/.test(O) }(O) }() || (0, J.hl)() } catch { return Zu() && (0, J.hl)() } return !1 } function Zu() { return typeof global < "u" && "WorkerGlobalScope" in global && "importScripts" in global } function Rc() { return (function kf() { return "http:" === gd() || "https:" === gd() }() || (0, J.ru)() || Yh()) && !function bg() { return (0, J.b$)() || (0, J.UG)() }() && si() && !Zu() } function _d() { return Yh() && typeof document < "u" } function Eu() { return (Eu = (0, i.Z)(function* () { return !!_d() && new Promise(O => { const C = setTimeout(() => { O(!1) }, 1e3); document.addEventListener("deviceready", () => { clearTimeout(C), O(!0) }) }) })).apply(this, arguments) } const Ro = { LOCAL: "local", NONE: "none", SESSION: "session" }, to = Ne, yd = "persistence"; function Tu(O) { return jd.apply(this, arguments) } function jd() { return (jd = (0, i.Z)(function* (O) { yield O._initializationPromise; const C = Cl(), S = et(yd, O.config.apiKey, O.name); C && C.setItem(S, O._getPersistence()) })).apply(this, arguments) } function Cl() { var O; try { return (null === (O = function wl() { return typeof window < "u" ? window : null }()) || void 0 === O ? void 0 : O.localStorage) || null } catch { return null } } const Kh = Ne; class El { constructor() { this.browserResolver = st(zd), this.cordovaResolver = st(ru), this.underlyingResolver = null, this._redirectPersistence = kr, this._completeRedirectFn = ir, this._overrideRedirectResult = Qo } _initialize(C) { var S = this; return (0, i.Z)(function* () { return yield S.selectUnderlyingResolver(), S.assertedUnderlyingResolver._initialize(C) })() } _openPopup(C, S, F, ie) { var ge = this; return (0, i.Z)(function* () { return yield ge.selectUnderlyingResolver(), ge.assertedUnderlyingResolver._openPopup(C, S, F, ie) })() } _openRedirect(C, S, F, ie) { var ge = this; return (0, i.Z)(function* () { return yield ge.selectUnderlyingResolver(), ge.assertedUnderlyingResolver._openRedirect(C, S, F, ie) })() } _isIframeWebStorageSupported(C, S) { this.assertedUnderlyingResolver._isIframeWebStorageSupported(C, S) } _originValidation(C) { return this.assertedUnderlyingResolver._originValidation(C) } get _shouldInitProactively() { return _d() || this.browserResolver._shouldInitProactively } get assertedUnderlyingResolver() { return Kh(this.underlyingResolver, "internal-error"), this.underlyingResolver } selectUnderlyingResolver() { var C = this; return (0, i.Z)(function* () { if (C.underlyingResolver) return; const S = yield function Po() { return Eu.apply(this, arguments) }(); C.underlyingResolver = S ? C.cordovaResolver : C.browserResolver })() } } function vd(O) { return O.unwrap() } function Pf(O) { return Rf(O) } function Rf(O) { const { _tokenResponse: C } = O instanceof J.ZR ? O.customData : O; if (!C) return null; if (!(O instanceof J.ZR) && "temporaryProof" in C && "phoneNumber" in C) return Xc.credentialFromResult(O); const S = C.providerId; if (!S || "password" === S) return null; let F; switch (S) { case "google.com": F = io; break; case "facebook.com": F = ka; break; case "github.com": F = Wl; break; case "twitter.com": F = jo; break; default: const { oauthIdToken: ie, oauthAccessToken: ge, oauthTokenSecret: Tt, pendingToken: tn, nonce: Pn } = C; return ge || Tt || ie || tn ? tn ? S.startsWith("saml.") ? Ys._create(S, tn) : Mt._fromParams({ providerId: S, signInMethod: S, pendingToken: tn, idToken: ie, accessToken: ge }) : new Si(S).credential({ idToken: ie, accessToken: ge, rawNonce: Pn }) : null }return O instanceof J.ZR ? F.credentialFromError(O) : F.credentialFromResult(O) } function ui(O, C) { return C.catch(S => { throw S instanceof J.ZR && function qu(O, C) { var S; const F = null === (S = C.customData) || void 0 === S ? void 0 : S._tokenResponse; if ("auth/multi-factor-auth-required" === C?.code) C.resolver = new wd(O, function yi(O, C) { var S; const F = (0, J.m9)(O), ie = C; return Ne(C.customData.operationType, F, "argument-error"), Ne(null === (S = ie.customData._serverResponse) || void 0 === S ? void 0 : S.mfaPendingCredential, F, "argument-error"), ec._fromError(F, ie) }(O, C)); else if (F) { const ie = Rf(C), ge = C; ie && (ge.credential = ie, ge.tenantId = F.tenantId || void 0, ge.email = F.email || void 0, ge.phoneNumber = F.phoneNumber || void 0) } }(O, S), S }).then(S => { const ie = S.user; return { operationType: S.operationType, credential: Pf(S), additionalUserInfo: Ol(S), user: oc.getOrCreate(ie) } }) } function Ff(O, C) { return $d.apply(this, arguments) } function $d() { return ($d = (0, i.Z)(function* (O, C) { const S = yield C; return { verificationId: S.verificationId, confirm: F => ui(O, S.confirm(F)) } })).apply(this, arguments) } class wd { constructor(C, S) { this.resolver = S, this.auth = function bd(O) { return O.wrapped() }(C) } get session() { return this.resolver.session } get hints() { return this.resolver.hints } resolveSignIn(C) { return ui(vd(this.auth), this.resolver.resolveSignIn(C)) } } class oc { constructor(C) { this._delegate = C, this.multiFactor = function re(O) { const C = (0, J.m9)(O); return z.has(C) || z.set(C, kl._fromUser(C)), z.get(C) }(C) } static getOrCreate(C) { return oc.USER_MAP.has(C) || oc.USER_MAP.set(C, new oc(C)), oc.USER_MAP.get(C) } delete() { return this._delegate.delete() } reload() { return this._delegate.reload() } toJSON() { return this._delegate.toJSON() } getIdTokenResult(C) { return this._delegate.getIdTokenResult(C) } getIdToken(C) { return this._delegate.getIdToken(C) } linkAndRetrieveDataWithCredential(C) { return this.linkWithCredential(C) } linkWithCredential(C) { var S = this; return (0, i.Z)(function* () { return ui(S.auth, ds(S._delegate, C)) })() } linkWithPhoneNumber(C, S) { var F = this; return (0, i.Z)(function* () { return Ff(F.auth, function Oc(O, C, S) { return cn.apply(this, arguments) }(F._delegate, C, S)) })() } linkWithPopup(C) { var S = this; return (0, i.Z)(function* () { return ui(S.auth, function Lr(O, C, S) { return Gr.apply(this, arguments) }(S._delegate, C, El)) })() } linkWithRedirect(C) { var S = this; return (0, i.Z)(function* () { return yield Tu(Dr(S.auth)), function xt(O, C, S) { return function zt(O, C, S) { return _n.apply(this, arguments) }(O, C, S) }(S._delegate, C, El) })() } reauthenticateAndRetrieveDataWithCredential(C) { return this.reauthenticateWithCredential(C) } reauthenticateWithCredential(C) { var S = this; return (0, i.Z)(function* () { return ui(S.auth, Ra(S._delegate, C)) })() } reauthenticateWithPhoneNumber(C, S) { return Ff(this.auth, function tl(O, C, S) { return Pe.apply(this, arguments) }(this._delegate, C, S)) } reauthenticateWithPopup(C) { return ui(this.auth, function Kn(O, C, S) { return Vn.apply(this, arguments) }(this._delegate, C, El)) } reauthenticateWithRedirect(C) { var S = this; return (0, i.Z)(function* () { return yield Tu(Dr(S.auth)), function ee(O, C, S) { return function de(O, C, S) { return We.apply(this, arguments) }(O, C, S) }(S._delegate, C, El) })() } sendEmailVerification(C) { return function Yl(O, C) { return Kl.apply(this, arguments) }(this._delegate, C) } unlink(C) { var S = this; return (0, i.Z)(function* () { return yield function Is(O, C) { return Wo.apply(this, arguments) }(S._delegate, C), S })() } updateEmail(C) { return function bc(O, C) { return Jl((0, J.m9)(O), C, null) }(this._delegate, C) } updatePassword(C) { return function Ea(O, C) { return Jl((0, J.m9)(O), null, C) }(this._delegate, C) } updatePhoneNumber(C) { return function Nc(O, C) { return Bl.apply(this, arguments) }(this._delegate, C) } updateProfile(C) { return function hl(O, C) { return Co.apply(this, arguments) }(this._delegate, C) } verifyBeforeUpdateEmail(C, S) { return function dl(O, C, S) { return Ms.apply(this, arguments) }(this._delegate, C, S) } get emailVerified() { return this._delegate.emailVerified } get isAnonymous() { return this._delegate.isAnonymous } get metadata() { return this._delegate.metadata } get phoneNumber() { return this._delegate.phoneNumber } get providerData() { return this._delegate.providerData } get refreshToken() { return this._delegate.refreshToken } get tenantId() { return this._delegate.tenantId } get displayName() { return this._delegate.displayName } get email() { return this._delegate.email } get photoURL() { return this._delegate.photoURL } get providerId() { return this._delegate.providerId } get uid() { return this._delegate.uid } get auth() { return this._delegate.auth } } oc.USER_MAP = new WeakMap; const Tl = Ne; let il = (() => { class O { constructor(S, F) { if (this.app = S, F.isInitialized()) return this._delegate = F.getImmediate(), void this.linkUnderlyingAuth(); const { apiKey: ie } = S.options; Tl(ie, "invalid-api-key", { appName: S.name }), Tl(ie, "invalid-api-key", { appName: S.name }); const ge = typeof window < "u" ? El : void 0; this._delegate = F.initialize({ options: { persistence: ei(ie, S.name), popupRedirectResolver: ge } }), this._delegate._updateErrorMap(rt), this.linkUnderlyingAuth() } get emulatorConfig() { return this._delegate.emulatorConfig } get currentUser() { return this._delegate.currentUser ? oc.getOrCreate(this._delegate.currentUser) : null } get languageCode() { return this._delegate.languageCode } set languageCode(S) { this._delegate.languageCode = S } get settings() { return this._delegate.settings } get tenantId() { return this._delegate.tenantId } set tenantId(S) { this._delegate.tenantId = S } useDeviceLanguage() { this._delegate.useDeviceLanguage() } signOut() { return this._delegate.signOut() } useEmulator(S, F) { !function _a(O, C, S) { const F = Dr(O); Ne(F._canInitEmulator, F, "emulator-config-failed"), Ne(/^https?:\/\//.test(C), F, "invalid-emulator-scheme"); const ie = !!S?.disableWarnings, ge = ya(C), { host: Tt, port: tn } = function va(O) { const C = ya(O), S = /(\/\/)?([^?#/]+)/.exec(O.substr(C.length)); if (!S) return { host: "", port: null }; const F = S[2].split("@").pop() || "", ie = /^(\[[^\]]+\])(:|$)/.exec(F); if (ie) { const ge = ie[1]; return { host: ge, port: Hr(F.substr(ge.length + 1)) } } { const [ge, Tt] = F.split(":"); return { host: ge, port: Hr(Tt) } } }(C); F.config.emulator = { url: `${ge}//${Tt}${null === tn ? "" : `:${tn}`}/` }, F.settings.appVerificationDisabledForTesting = !0, F.emulatorConfig = Object.freeze({ host: Tt, port: tn, protocol: ge.replace(":", ""), options: Object.freeze({ disableWarnings: ie }) }), ie || function Ji() { function O() { const C = document.createElement("p"), S = C.style; C.innerText = "Running in emulator mode. Do not use with production credentials.", S.position = "fixed", S.width = "100%", S.backgroundColor = "#ffffff", S.border = ".1em solid #000000", S.color = "#b50000", S.bottom = "0px", S.left = "0px", S.margin = "0px", S.zIndex = "10000", S.textAlign = "center", C.classList.add("firebase-emulator-warning"), document.body.appendChild(C) } typeof console < "u" && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", O) : O()) }() }(this._delegate, S, F) } applyActionCode(S) { return function Xs(O, C) { return Q.apply(this, arguments) }(this._delegate, S) } checkActionCode(S) { return q(this._delegate, S) } confirmPasswordReset(S, F) { return function ys(O, C, S) { return hr.apply(this, arguments) }(this._delegate, S, F) } createUserWithEmailAndPassword(S, F) { var ie = this; return (0, i.Z)(function* () { return ui(ie._delegate, function Bn(O, C, S) { return wi.apply(this, arguments) }(ie._delegate, S, F)) })() } fetchProvidersForEmail(S) { return this.fetchSignInMethodsForEmail(S) } fetchSignInMethodsForEmail(S) { return function Fa(O, C) { return ul.apply(this, arguments) }(this._delegate, S) } isSignInWithEmailLink(S) { return function qc(O, C) { return "EMAIL_SIGNIN" === bo.parseLink(C)?.operation }(0, S) } getRedirectResult() { var S = this; return (0, i.Z)(function* () { Tl(Rc(), S._delegate, "operation-not-supported-in-this-environment"); const F = yield function jn(O, C) { return er.apply(this, arguments) }(S._delegate, El); return F ? ui(S._delegate, Promise.resolve(F)) : { credential: null, user: null } })() } addFrameworkForLogging(S) { !function vh(O, C) { Dr(O)._logFramework(C) }(this._delegate, S) } onAuthStateChanged(S, F, ie) { const { next: ge, error: Tt, complete: tn } = ac(S, F, ie); return this._delegate.onAuthStateChanged(ge, Tt, tn) } onIdTokenChanged(S, F, ie) { const { next: ge, error: Tt, complete: tn } = ac(S, F, ie); return this._delegate.onIdTokenChanged(ge, Tt, tn) } sendSignInLinkToEmail(S, F) { return function zr(O, C, S) { return ll.apply(this, arguments) }(this._delegate, S, F) } sendPasswordResetEmail(S, F) { return function Hi(O, C, S) { return qa.apply(this, arguments) }(this._delegate, S, F || void 0) } setPersistence(S) { var F = this; return (0, i.Z)(function* () { let ie; switch (function Ma(O, C) { to(Object.values(Ro).includes(C), O, "invalid-persistence-type"), (0, J.b$)() ? to(C !== Ro.SESSION, O, "unsupported-persistence-type") : (0, J.UG)() ? to(C === Ro.NONE, O, "unsupported-persistence-type") : Zu() ? to(C === Ro.NONE || C === Ro.LOCAL && (0, J.hl)(), O, "unsupported-persistence-type") : to(C === Ro.NONE || si(), O, "unsupported-persistence-type") }(F._delegate, S), S) { case Ro.SESSION: ie = kr; break; case Ro.LOCAL: ie = (yield st(Ll)._isAvailable()) ? Ll : ri; break; case Ro.NONE: ie = ke; break; default: return ct("argument-error", { appName: F._delegate.name }) }return F._delegate.setPersistence(ie) })() } signInAndRetrieveDataWithCredential(S) { return this.signInWithCredential(S) } signInAnonymously() { return ui(this._delegate, function $o(O) { return wo.apply(this, arguments) }(this._delegate)) } signInWithCredential(S) { return ui(this._delegate, Ui(this._delegate, S)) } signInWithCustomToken(S) { return ui(this._delegate, function Qs(O, C) { return Zr.apply(this, arguments) }(this._delegate, S)) } signInWithEmailAndPassword(S, F) { return ui(this._delegate, function Jt(O, C, S) { return Ui((0, J.m9)(O), Io.credential(C, S)) }(this._delegate, S, F)) } signInWithEmailLink(S, F) { return ui(this._delegate, function vs(O, C, S) { return ql.apply(this, arguments) }(this._delegate, S, F)) } signInWithPhoneNumber(S, F) { return Ff(this._delegate, function Mi(O, C, S) { return Mc.apply(this, arguments) }(this._delegate, S, F)) } signInWithPopup(S) { var F = this; return (0, i.Z)(function* () { return Tl(Rc(), F._delegate, "operation-not-supported-in-this-environment"), ui(F._delegate, function St(O, C, S) { return on.apply(this, arguments) }(F._delegate, S, El)) })() } signInWithRedirect(S) { var F = this; return (0, i.Z)(function* () { return Tl(Rc(), F._delegate, "operation-not-supported-in-this-environment"), yield Tu(F._delegate), function ps(O, C, S) { return function vi(O, C, S) { return W.apply(this, arguments) }(O, C, S) }(F._delegate, S, El) })() } updateCurrentUser(S) { return this._delegate.updateCurrentUser(S) } verifyPasswordResetCode(S) { return function me(O, C) { return Rt.apply(this, arguments) }(this._delegate, S) } unwrap() { return this._delegate } _delete() { return this._delegate._delete() } linkUnderlyingAuth() { this._delegate.wrapped = () => this } } return O.Persistence = Ro, O })(); function ac(O, C, S) { let F = O; "function" != typeof O && ({ next: F, error: C, complete: S } = O); const ie = F; return { next: Tt => ie(Tt && oc.getOrCreate(Tt)), error: C, complete: S } } function ei(O, C) { const S = function wh(O, C) { const S = Cl(); if (!S) return []; const F = et(yd, O, C); switch (S.getItem(F)) { case Ro.NONE: return [ke]; case Ro.LOCAL: return [Ll, kr]; case Ro.SESSION: return [kr]; default: return [] } }(O, C); if (typeof self < "u" && !S.includes(Ll) && S.push(Ll), typeof window < "u") for (const F of [ri, kr]) S.includes(F) || S.push(F); return S.includes(ke) || S.push(ke), S } class Ch { constructor() { this.providerId = "phone", this._delegate = new Xc(vd(m.Z.auth())) } static credential(C, S) { return Xc.credential(C, S) } verifyPhoneNumber(C, S) { return this._delegate.verifyPhoneNumber(C, S) } unwrap() { return this._delegate } } Ch.PHONE_SIGN_IN_METHOD = Xc.PHONE_SIGN_IN_METHOD, Ch.PROVIDER_ID = Xc.PROVIDER_ID; const Yu = Ne; class Du { constructor(C, S, F = m.Z.app()) { var ie; Yu(null === (ie = F.options) || void 0 === ie ? void 0 : ie.apiKey, "invalid-api-key", { appName: F.name }), this._delegate = new vu(C, S, F.auth()), this.type = this._delegate.type } clear() { this._delegate.clear() } render() { return this._delegate.render() } verify() { return this._delegate.verify() } } !function Wd(O) { O.INTERNAL.registerComponent(new Te.wA("auth-compat", C => { const S = C.getProvider("app-compat").getImmediate(), F = C.getProvider("auth"); return new il(S, F) }, "PUBLIC").setServiceProps({ ActionCodeInfo: { Operation: { EMAIL_SIGNIN: "EMAIL_SIGNIN", PASSWORD_RESET: "PASSWORD_RESET", RECOVER_EMAIL: "RECOVER_EMAIL", REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION", VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL", VERIFY_EMAIL: "VERIFY_EMAIL" } }, EmailAuthProvider: Io, FacebookAuthProvider: ka, GithubAuthProvider: Wl, GoogleAuthProvider: io, OAuthProvider: Si, SAMLAuthProvider: so, PhoneAuthProvider: Ch, PhoneMultiFactorGenerator: xa, RecaptchaVerifier: Du, TwitterAuthProvider: jo, Auth: il, AuthCredential: Ei, Error: J.ZR }).setInstantiationMode("LAZY").setMultipleInstances(!1)), O.registerVersion("@firebase/auth-compat", "0.3.0") }(m.Z) }, 8766: (un, Je, L) => { "use strict"; L.d(Je, { Lj: () => ct, X3: () => Qe }); var i = L(5861); let J, ye; const Te = new WeakMap, Ee = new WeakMap, _e = new WeakMap, ae = new WeakMap, ve = new WeakMap; let Se = { get(Ne, tt, Fe) { if (Ne instanceof IDBTransaction) { if ("done" === tt) return Ee.get(Ne); if ("objectStoreNames" === tt) return Ne.objectStoreNames || _e.get(Ne); if ("store" === tt) return Fe.objectStoreNames[1] ? void 0 : Fe.objectStore(Fe.objectStoreNames[0]) } return je(Ne[tt]) }, set: (Ne, tt, Fe) => (Ne[tt] = Fe, !0), has: (Ne, tt) => Ne instanceof IDBTransaction && ("done" === tt || "store" === tt) || tt in Ne }; function De(Ne) { return "function" == typeof Ne ? function wt(Ne) { return Ne !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? function we() { return ye || (ye = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) }().includes(Ne) ? function (...tt) { return Ne.apply(_t(this), tt), je(Te.get(this)) } : function (...tt) { return je(Ne.apply(_t(this), tt)) } : function (tt, ...Fe) { const Ue = Ne.call(_t(this), tt, ...Fe); return _e.set(Ue, tt.sort ? tt.sort() : [tt]), je(Ue) } }(Ne) : (Ne instanceof IDBTransaction && function gt(Ne) { if (Ee.has(Ne)) return; const tt = new Promise((Fe, Ue) => { const st = () => { Ne.removeEventListener("complete", ht), Ne.removeEventListener("error", Kt), Ne.removeEventListener("abort", Kt) }, ht = () => { Fe(), st() }, Kt = () => { Ue(Ne.error || new DOMException("AbortError", "AbortError")), st() }; Ne.addEventListener("complete", ht), Ne.addEventListener("error", Kt), Ne.addEventListener("abort", Kt) }); Ee.set(Ne, tt) }(Ne), ((Ne, tt) => tt.some(Fe => Ne instanceof Fe))(Ne, function Ce() { return J || (J = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) }()) ? new Proxy(Ne, Se) : Ne) } function je(Ne) { if (Ne instanceof IDBRequest) return function xe(Ne) { const tt = new Promise((Fe, Ue) => { const st = () => { Ne.removeEventListener("success", ht), Ne.removeEventListener("error", Kt) }, ht = () => { Fe(je(Ne.result)), st() }, Kt = () => { Ue(Ne.error), st() }; Ne.addEventListener("success", ht), Ne.addEventListener("error", Kt) }); return tt.then(Fe => { Fe instanceof IDBCursor && Te.set(Fe, Ne) }).catch(() => { }), ve.set(tt, Ne), tt }(Ne); if (ae.has(Ne)) return ae.get(Ne); const tt = De(Ne); return tt !== Ne && (ae.set(Ne, tt), ve.set(tt, Ne)), tt } const _t = Ne => ve.get(Ne); function Qe(Ne, tt, { blocked: Fe, upgrade: Ue, blocking: st, terminated: ht } = {}) { const Kt = indexedDB.open(Ne, tt), rn = je(Kt); return Ue && Kt.addEventListener("upgradeneeded", On => { Ue(je(Kt.result), On.oldVersion, On.newVersion, je(Kt.transaction)) }), Fe && Kt.addEventListener("blocked", () => Fe()), rn.then(On => { ht && On.addEventListener("close", () => ht()), st && On.addEventListener("versionchange", () => st()) }).catch(() => { }), rn } function ct(Ne, { blocked: tt } = {}) { const Fe = indexedDB.deleteDatabase(Ne); return tt && Fe.addEventListener("blocked", () => tt()), je(Fe).then(() => { }) } const Oe = ["get", "getKey", "getAll", "getAllKeys", "count"], Ve = ["put", "add", "delete", "clear"], Be = new Map; function nt(Ne, tt) { if (!(Ne instanceof IDBDatabase) || tt in Ne || "string" != typeof tt) return; if (Be.get(tt)) return Be.get(tt); const Fe = tt.replace(/FromIndex$/, ""), Ue = tt !== Fe, st = Ve.includes(Fe); if (!(Fe in (Ue ? IDBIndex : IDBObjectStore).prototype) || !st && !Oe.includes(Fe)) return; const ht = function () { var Kt = (0, i.Z)(function* (rn, ...On) { const qn = this.transaction(rn, st ? "readwrite" : "readonly"); let nr = qn.store; return Ue && (nr = nr.index(On.shift())), (yield Promise.all([nr[Fe](...On), st && qn.done]))[0] }); return function (On) { return Kt.apply(this, arguments) } }(); return Be.set(tt, ht), ht } !function rt(Ne) { Se = Ne(Se) }(Ne => ({ ...Ne, get: (tt, Fe, Ue) => nt(tt, Fe) || Ne.get(tt, Fe, Ue), has: (tt, Fe) => !!nt(tt, Fe) || Ne.has(tt, Fe) })) }, 2851: (un, Je, L) => { "use strict"; L.d(Je, { e4: () => or }); var i = L(4650), m = L(6895); class kn { constructor(dn, ue, it, lt) { this.r = dn, this.g = ue, this.b = it, this.a = lt } } class fn { constructor(dn, ue, it, lt) { this.h = dn, this.s = ue, this.v = it, this.a = lt } } class It { constructor(dn, ue, it, lt) { this.h = dn, this.s = ue, this.l = it, this.a = lt } } class Yt { constructor(dn, ue, it, lt, Nt = 1) { this.c = dn, this.m = ue, this.y = it, this.k = lt, this.a = Nt } } let kt = (() => { class Ht { constructor() { this.active = null } setActive(ue) { this.active && this.active !== ue && "inline" !== this.active.cpDialogDisplay && this.active.closeDialog(), this.active = ue } hsva2hsla(ue) { const it = ue.h, lt = ue.s, Nt = ue.v, gn = ue.a; if (0 === Nt) return new It(it, 0, 0, gn); if (0 === lt && 1 === Nt) return new It(it, 1, 1, gn); { const Hn = Nt * (2 - lt) / 2; return new It(it, Nt * lt / (1 - Math.abs(2 * Hn - 1)), Hn, gn) } } hsla2hsva(ue) { const it = Math.min(ue.h, 1), lt = Math.min(ue.s, 1), Nt = Math.min(ue.l, 1), gn = Math.min(ue.a, 1); if (0 === Nt) return new fn(it, 0, 0, gn); { const Hn = Nt + lt * (1 - Math.abs(2 * Nt - 1)) / 2; return new fn(it, 2 * (Hn - Nt) / Hn, Hn, gn) } } hsvaToRgba(ue) { let it, lt, Nt; const gn = ue.h, Hn = ue.s, _r = ue.v, pn = ue.a, Fn = Math.floor(6 * gn), yn = 6 * gn - Fn, Qn = _r * (1 - Hn), ur = _r * (1 - yn * Hn), dr = _r * (1 - (1 - yn) * Hn); switch (Fn % 6) { case 0: it = _r, lt = dr, Nt = Qn; break; case 1: it = ur, lt = _r, Nt = Qn; break; case 2: it = Qn, lt = _r, Nt = dr; break; case 3: it = Qn, lt = ur, Nt = _r; break; case 4: it = dr, lt = Qn, Nt = _r; break; case 5: it = _r, lt = Qn, Nt = ur; break; default: it = 0, lt = 0, Nt = 0 }return new kn(it, lt, Nt, pn) } cmykToRgb(ue) { return new kn((1 - ue.c) * (1 - ue.k), (1 - ue.m) * (1 - ue.k), (1 - ue.y) * (1 - ue.k), ue.a) } rgbaToCmyk(ue) { const it = 1 - Math.max(ue.r, ue.g, ue.b); return 1 === it ? new Yt(0, 0, 0, 1, ue.a) : new Yt((1 - ue.r - it) / (1 - it), (1 - ue.g - it) / (1 - it), (1 - ue.b - it) / (1 - it), it, ue.a) } rgbaToHsva(ue) { let it, lt; const Nt = Math.min(ue.r, 1), gn = Math.min(ue.g, 1), Hn = Math.min(ue.b, 1), _r = Math.min(ue.a, 1), pn = Math.max(Nt, gn, Hn), Fn = Math.min(Nt, gn, Hn), yn = pn, Qn = pn - Fn; if (lt = 0 === pn ? 0 : Qn / pn, pn === Fn) it = 0; else { switch (pn) { case Nt: it = (gn - Hn) / Qn + (gn < Hn ? 6 : 0); break; case gn: it = (Hn - Nt) / Qn + 2; break; case Hn: it = (Nt - gn) / Qn + 4; break; default: it = 0 }it /= 6 } return new fn(it, lt, yn, _r) } rgbaToHex(ue, it) { let lt = "#" + (16777216 | ue.r << 16 | ue.g << 8 | ue.b).toString(16).substr(1); return it && (lt += (256 | Math.round(255 * ue.a)).toString(16).substr(1)), lt } normalizeCMYK(ue) { return new Yt(ue.c / 100, ue.m / 100, ue.y / 100, ue.k / 100, ue.a) } denormalizeCMYK(ue) { return new Yt(Math.floor(100 * ue.c), Math.floor(100 * ue.m), Math.floor(100 * ue.y), Math.floor(100 * ue.k), ue.a) } denormalizeRGBA(ue) { return new kn(Math.round(255 * ue.r), Math.round(255 * ue.g), Math.round(255 * ue.b), ue.a) } stringToHsva(ue = "", it = !1) { let lt = null; ue = (ue || "").toLowerCase(); const Nt = [{ re: /(rgb)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*%?,\s*(\d{1,3})\s*%?(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/, parse: function (gn) { return new kn(parseInt(gn[2], 10) / 255, parseInt(gn[3], 10) / 255, parseInt(gn[4], 10) / 255, isNaN(parseFloat(gn[5])) ? 1 : parseFloat(gn[5])) } }, { re: /(hsl)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/, parse: function (gn) { return new It(parseInt(gn[2], 10) / 360, parseInt(gn[3], 10) / 100, parseInt(gn[4], 10) / 100, isNaN(parseFloat(gn[5])) ? 1 : parseFloat(gn[5])) } }]; Nt.push(it ? { re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})?$/, parse: function (gn) { return new kn(parseInt(gn[1], 16) / 255, parseInt(gn[2], 16) / 255, parseInt(gn[3], 16) / 255, parseInt(gn[4] || "FF", 16) / 255) } } : { re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/, parse: function (gn) { return new kn(parseInt(gn[1], 16) / 255, parseInt(gn[2], 16) / 255, parseInt(gn[3], 16) / 255, 1) } }), Nt.push({ re: /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/, parse: function (gn) { return new kn(parseInt(gn[1] + gn[1], 16) / 255, parseInt(gn[2] + gn[2], 16) / 255, parseInt(gn[3] + gn[3], 16) / 255, 1) } }); for (const gn in Nt) if (Nt.hasOwnProperty(gn)) { const Hn = Nt[gn], _r = Hn.re.exec(ue), pn = _r && Hn.parse(_r); if (pn) return pn instanceof kn ? lt = this.rgbaToHsva(pn) : pn instanceof It && (lt = this.hsla2hsva(pn)), lt } return lt } outputFormat(ue, it, lt) { switch ("auto" === it && (it = ue.a < 1 ? "rgba" : "hex"), it) { case "hsla": const Nt = this.hsva2hsla(ue), gn = new It(Math.round(360 * Nt.h), Math.round(100 * Nt.s), Math.round(100 * Nt.l), Math.round(100 * Nt.a) / 100); return ue.a < 1 || "always" === lt ? "hsla(" + gn.h + "," + gn.s + "%," + gn.l + "%," + gn.a + ")" : "hsl(" + gn.h + "," + gn.s + "%," + gn.l + "%)"; case "rgba": const Hn = this.denormalizeRGBA(this.hsvaToRgba(ue)); return ue.a < 1 || "always" === lt ? "rgba(" + Hn.r + "," + Hn.g + "," + Hn.b + "," + Math.round(100 * Hn.a) / 100 + ")" : "rgb(" + Hn.r + "," + Hn.g + "," + Hn.b + ")"; default: const _r = "always" === lt || "forced" === lt; return this.rgbaToHex(this.denormalizeRGBA(this.hsvaToRgba(ue)), _r) } } } return Ht.\u0275fac = function (ue) { return new (ue || Ht) }, Ht.\u0275prov = i.Yz7({ token: Ht, factory: Ht.\u0275fac }), Ht })(); typeof window < "u" && window; let or = (() => { class Ht { } return Ht.\u0275fac = function (ue) { return new (ue || Ht) }, Ht.\u0275mod = i.oAB({ type: Ht }), Ht.\u0275inj = i.cJS({ providers: [kt], imports: [m.ez] }), Ht })() }, 8769: (un, Je, L) => { "use strict"; L.d(Je, { To: () => Pt, qZ: () => pt, u_: () => Yt }); var i = L(4650), m = L(4006), J = L(7340), ye = L(6895); const Ce = ["hueSlider"], we = ["alphaSlider"]; function Te(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.TgZ(0, "div", 8), i.NdJ("newValue", function (kt) { i.CHM(le); const an = i.oxw(); return i.KtG(an.onSliderChange("saturation-lightness", kt)) }), i.TgZ(1, "div", 9), i._UZ(2, "div"), i.qZA()() } if (2 & Ze) { const le = i.oxw(); i.Udp("background-color", le.hueSliderColor), i.Q6J("rgX", 1)("rgY", 1), i.xp6(1), i.Udp("top", null == le.slider ? null : le.slider.v, "px")("left", null == le.slider ? null : le.slider.s, "px") } } function Ee(Ze, Ot) { if (1 & Ze && (i.TgZ(0, "div", 10), i._UZ(1, "div", 11)(2, "div", 12), i.qZA()), 2 & Ze) { const le = i.oxw(); i.xp6(2), i.Udp("background-color", le.selectedColor) } } function _e(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.TgZ(0, "div", 13, 14), i.NdJ("newValue", function (kt) { i.CHM(le); const an = i.oxw(); return i.KtG(an.onSliderChange("hue", kt)) }), i.TgZ(2, "div", 15)(3, "div"), i._UZ(4, "div"), i.qZA()()() } if (2 & Ze) { const le = i.oxw(); i.Q6J("rgX", 1), i.xp6(2), i.Udp("left", null == le.slider ? null : le.slider.h, "px") } } function ae(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.TgZ(0, "div", 16, 17), i.NdJ("newValue", function (kt) { i.CHM(le); const an = i.oxw(); return i.KtG(an.onSliderChange("alpha", kt)) }), i._UZ(2, "div", 18), i.TgZ(3, "div", 15)(4, "div"), i._UZ(5, "div"), i.qZA()()() } if (2 & Ze) { const le = i.oxw(); i.Q6J("rgX", 1), i.xp6(2), i.Q6J("ngStyle", le.getBackgroundColor(le.alphaSliderColor)), i.xp6(1), i.Udp("left", null == le.slider ? null : le.slider.a, "px") } } const ve = ["dialog"]; function xe(Ze, Ot) { 1 & Ze && i._UZ(0, "div", 11) } function gt(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.ynx(0), i.TgZ(1, "div", 8)(2, "div", 9), i.NdJ("click", function () { const an = i.CHM(le).$implicit, jt = i.oxw(2); return i.KtG(jt.onColorClick(an)) }), i.YNc(3, xe, 1, 0, "div", 10), i.qZA()(), i.BQk() } if (2 & Ze) { const le = Ot.$implicit, Xe = Ot.index, kt = i.oxw(2); i.xp6(2), i.ekj("colornull", !le), i.Q6J("ngStyle", kt.getBackgroundColor(le)), i.xp6(1), i.Q6J("ngIf", Xe == kt.indexSeleccionado) } } function Se(Ze, Ot) { if (1 & Ze && i._UZ(0, "div", 17), 2 & Ze) { const le = i.oxw(3); i.Q6J("ngStyle", le.getBackgroundColor(le.color)) } } function rt(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.TgZ(0, "div", 12), i.NdJ("click", function () { i.CHM(le); const kt = i.oxw(2); return i.KtG(kt.addColor()) }), i.YNc(1, Se, 1, 1, "div", 13), i.O4$(), i.TgZ(2, "svg", 14), i._UZ(3, "path", 15)(4, "path", 16), i.qZA()() } if (2 & Ze) { const le = i.oxw(2); i.xp6(1), i.Q6J("ngIf", !le.indexSeleccionado) } } function wt(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.TgZ(0, "color-picker", 18), i.NdJ("colorChange", function (kt) { i.CHM(le); const an = i.oxw(2); return i.KtG(an.onChangeColorPicker(kt)) })("onAlphaChange", function (kt) { i.CHM(le); const an = i.oxw(2); return i.KtG(an.onAlphaChange(kt)) }), i.qZA() } if (2 & Ze) { const le = i.oxw(2); i.Q6J("controls", le.colorPickerControls)("color", le.hsva) } } function De(Ze, Ot) { if (1 & Ze && (i.ynx(0), i.TgZ(1, "div", 4), i.YNc(2, gt, 4, 4, "ng-container", 5), i.YNc(3, rt, 5, 1, "div", 6), i.YNc(4, wt, 1, 2, "color-picker", 7), i.qZA(), i.BQk()), 2 & Ze) { const le = i.oxw(); i.xp6(1), i.Q6J("@colorsAnimation", le.colorsAnimationEffect), i.xp6(1), i.Q6J("ngForOf", le.palette), i.xp6(1), i.Q6J("ngIf", !le.hideColorPicker && "only-alpha" != le.colorPickerControls), i.xp6(1), i.Q6J("ngIf", !le.hideColorPicker && "only-alpha" == le.colorPickerControls) } } function je(Ze, Ot) { 1 & Ze && i._UZ(0, "div", 11) } const _t = function (Ze) { return { background: Ze } }; function Qe(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.O4$(), i.kcU(), i.ynx(0), i.TgZ(1, "div", 8)(2, "div", 24), i.NdJ("click", function () { const an = i.CHM(le).$implicit, jt = i.oxw(2); return i.KtG(jt.changeColor(an)) }), i.YNc(3, je, 1, 0, "div", 10), i.qZA()(), i.BQk() } if (2 & Ze) { const le = Ot.$implicit, Xe = i.oxw(2); i.xp6(2), i.ekj("colornull", !le), i.Q6J("ngStyle", i.VKq(4, _t, le)), i.xp6(1), i.Q6J("ngIf", Xe.isSelected(le)) } } function ct(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.ynx(0), i.TgZ(1, "div", 4)(2, "div", 19)(3, "div", 20), i.NdJ("click", function () { i.CHM(le); const kt = i.oxw(); return i.KtG(kt.onClickBack()) }), i.O4$(), i.TgZ(4, "svg", 21), i._UZ(5, "path", 22)(6, "path", 23), i.qZA()()(), i.YNc(7, Qe, 4, 6, "ng-container", 5), i.qZA(), i.BQk() } if (2 & Ze) { const le = i.oxw(); i.xp6(1), i.Q6J("@colorsAnimation", le.colorsAnimationEffect), i.xp6(6), i.Q6J("ngForOf", le.variants) } } function Oe(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.ynx(0), i.TgZ(1, "div", 25)(2, "div", 26), i.NdJ("click", function () { i.CHM(le); const kt = i.oxw(); return i.KtG(kt.onClickBack()) }), i.O4$(), i.TgZ(3, "svg", 21), i._UZ(4, "path", 22)(5, "path", 23), i.qZA()(), i.kcU(), i.TgZ(6, "button", 27), i.NdJ("click", function () { i.CHM(le); const kt = i.oxw(); return i.KtG(kt.emitClose("cancel")) }), i._uU(7), i.qZA(), i.TgZ(8, "button", 27), i.NdJ("click", function () { i.CHM(le); const kt = i.oxw(); return i.KtG(kt.emitClose("accept")) }), i._uU(9), i.qZA()(), i.TgZ(10, "div", 28)(11, "color-picker", 29), i.NdJ("sliderChange", function (kt) { i.CHM(le); const an = i.oxw(); return i.KtG(an.onChangeColorPicker(kt)) }), i.qZA()(), i.BQk() } if (2 & Ze) { const le = i.oxw(); i.xp6(7), i.hij(" ", le.cancelLabel, " "), i.xp6(2), i.hij(" ", le.acceptLabel, " "), i.xp6(2), i.Q6J("controls", le.colorPickerControls)("color", le.hsva) } } function Ve(Ze, Ot) { if (1 & Ze) { const le = i.EpF(); i.TgZ(0, "div", 30)(1, "p", 31), i.NdJ("click", function () { i.CHM(le); const kt = i.oxw(); return i.KtG(kt.nextFormat()) }), i._uU(2), i.qZA(), i.TgZ(3, "div", 32)(4, "input", 33, 34), i.NdJ("keyup", function () { i.CHM(le); const kt = i.MAs(5), an = i.oxw(); return i.KtG(an.changeColorManual(kt.value)) })("keydown.enter", function () { i.CHM(le); const kt = i.oxw(); return i.KtG(kt.emitClose("accept")) }), i.qZA()()() } if (2 & Ze) { const le = i.oxw(); i.xp6(2), i.Oqu(le.colorFormats[le.format]), i.xp6(2), i.Udp("font-size", le.color && le.color.length > 23 ? 9 : 10, "px")("letter-spacing", le.color && le.color.length > 16 ? 0 : 1.5, "px"), i.Q6J("value", le.color) } } var Be = (() => { return (Ze = Be || (Be = {}))[Ze.HEX = 0] = "HEX", Ze[Ze.RGBA = 1] = "RGBA", Ze[Ze.HSLA = 2] = "HSLA", Ze[Ze.CMYK = 3] = "CMYK", Be; var Ze })(); const nt = [{ color: "rojo", preview: "#E57373", variants: ["#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373", "#EF5350", "#F44336", "#E53935", "#D32F2F", "#C62828"] }, { color: "rosa", preview: "#F06292", variants: ["#FCE4EC", "#F8BBD0", "#F48FB1", "#F06292", "#EC407A", "#E91E63", "#D81B60", "#C2185B", "#AD1457"] }, { color: "purpura", preview: "#BA68C8", variants: ["#F3E5F5", "#E1BEE7", "#CE93D8", "#BA68C8", "#AB47BC", "#9C27B0", "#8E24AA", "#7B1FA2", "#6A1B9A"] }, { color: "purpura oscuro", preview: "#9575CD", variants: ["#EDE7F6", "#D1C4E9", "#B39DDB", "#9575CD", "#7E57C2", "#673AB7", "#5E35B1", "#512DA8", "#4527A0"] }, { color: "indigo", preview: "#7986CB", variants: ["#E8EAF6", "#C5CAE9", "#9FA8DA", "#7986CB", "#5C6BC0", "#3F51B5", "#3949AB", "#303F9F", "#283593"] }, { color: "azul", preview: "#64B5F6", variants: ["#E3F2FD", "#BBDEFB", "#90CAF9", "#64B5F6", "#42A5F5", "#2196F3", "#1E88E5", "#1976D2", "#1565C0"] }, { color: "celeste", preview: "#4FC3F7", variants: ["#E1F5FE", "#B3E5FC", "#81D4FA", "#4FC3F7", "#29B6F6", "#03A9F4", "#039BE5", "#0288D1", "#0277BD"] }, { color: "cyan", preview: "#4DD0E1", variants: ["#E0F7FA", "#B2EBF2", "#80DEEA", "#4DD0E1", "#26C6DA", "#00BCD4", "#00ACC1", "#0097A7", "#00838F"] }, { color: "color", preview: "#4DB6AC", variants: ["#E0F2F1", "#B2DFDB", "#80CBC4", "#4DB6AC", "#26A69A", "#009688", "#00897B", "#00796B", "#00695C"] }, { color: "verde", preview: "#81C784", variants: ["#E8F5E9", "#C8E6C9", "#A5D6A7", "#81C784", "#66BB6A", "#4CAF50", "#43A047", "#388E3C", "#2E7D32"] }, { color: "verde claro", preview: "#AED581", variants: ["#F1F8E9", "#DCEDC8", "#C5E1A5", "#AED581", "#9CCC65", "#8BC34A", "#7CB342", "#689F38", "#558B2F"] }, { color: "lima", preview: "#DCE775", variants: ["#F9FBE7", "#F0F4C3", "#E6EE9C", "#DCE775", "#D4E157", "#CDDC39", "#C0CA33", "#AFB42B", "#9E9D24"] }, { color: "amarillo", preview: "#FFF176", variants: ["#FFFDE7", "#FFF9C4", "#FFF59D", "#FFF176", "#FFEE58", "#FFEB3B", "#FDD835", "#FBC02D", "#F9A825"] }, { color: "ambar", preview: "#FFD54F", variants: ["#FFF8E1", "#FFECB3", "#FFE082", "#FFD54F", "#FFCA28", "#FFC107", "#FFB300", "#FFA000", "#FF8F00"] }, { color: "naranja", preview: "#FFB74D", variants: ["#FFF3E0", "#FFE0B2", "#FFCC80", "#FFB74D", "#FFA726", "#FF9800", "#FB8C00", "#F57C00", "#EF6C00"] }, { color: "naranja oscuro", preview: "#FF8A65", variants: ["#FBE9E7", "#FFCCBC", "#FFAB91", "#FF8A65", "#FF7043", "#FF5722", "#F4511E", "#E64A19", "#D84315"] }, { color: "marron", preview: "#A1887F", variants: ["#EFEBE9", "#D7CCC8", "#BCAAA4", "#A1887F", "#8D6E63", "#795548", "#6D4C41", "#5D4037", "#4E342E"] }, { color: "escala de grises", preview: "#E0E0E0", variants: ["#FFFFFF", "#FAFAFA", "#F5F5F5", "#EEEEEE", "#E0E0E0", "#BDBDBD", "#9E9E9E", "#757575", "#616161", "#424242", "#000000"] }, { color: "azul gris", preview: "#90A4AE", variants: ["#ECEFF1", "#CFD8DC", "#B0BEC5", "#90A4AE", "#78909C", "#607D8B", "#546E7A", "#455A64", "#37474F"] }], Ne = ["hex", "rgba", "hsla"]; class tt { constructor(Ot, le, Xe, kt) { this.r = Ot, this.g = le, this.b = Xe, this.a = kt } denormalize() { return this.r = Math.round(255 * this.r), this.g = Math.round(255 * this.g), this.b = Math.round(255 * this.b), this } toString() { return this.denormalize(), "rgb" + (1 != this.a ? "a(" : "(") + this.r + ", " + this.g + ", " + this.b + (1 != this.a ? ", " + this.a.toPrecision(2) + ")" : ")") } } class Fe { constructor(Ot, le, Xe, kt) { this.h = Ot, this.s = le, this.v = Xe, this.a = kt, this.onChange = new i.vpe(!0) } onColorChange(Ot) { this.s = Ot.s / Ot.rgX, this.v = Ot.v / Ot.rgY } onHueChange(Ot) { this.h = Ot.v / Ot.rgX } onValueChange(Ot) { this.v = Ot.v / Ot.rgX } onAlphaChange(Ot) { this.a = Ot.v / Ot.rgX } } class Ue { constructor(Ot, le, Xe, kt) { this.h = Ot, this.s = le, this.l = Xe, this.a = kt } denormalize() { return this.h = Math.round(360 * this.h), this.s = Math.round(100 * this.s), this.l = Math.round(100 * this.l), this } toString() { return "hsl" + (1 != this.a ? "a(" : "(") + this.h + ", " + this.s + "%, " + this.l + "%" + (1 != this.a ? ", " + this.a.toPrecision(2) + ")" : ")") } } class st { constructor(Ot, le, Xe, kt, an = 1) { this.c = Ot, this.m = le, this.y = Xe, this.k = kt, this.a = an } } class ht { constructor(Ot) { Ot && (this.preview = Ot.preview, this.variants = Ot.variants) } } let Kt = (() => { class Ze { constructor() { } toFormat(le, Xe) { var kt = ""; if (le) switch (Xe) { case Be.HEX: (jt = this.hsvaToRgba(le)).denormalize(), kt = this.rgbaToHex(jt, !0); break; case Be.HSLA: var an = this.hsva2hsla(le); an.denormalize(), kt = an.toString(); break; case Be.RGBA: kt = (jt = this.hsvaToRgba(le)).toString(); break; case Be.CMYK: var jt = this.hsvaToRgba(le); this.rgbaToCmyk(jt) }return kt } stringToFormat(le, Xe) { var kt = this.stringToHsva(le, !0); return this.toFormat(kt, Xe) } hsva2hsla(le) { const Xe = le.h, kt = le.s, an = le.v, jt = le.a; if (0 === an) return new Ue(Xe, 0, 0, jt); if (0 === kt && 1 === an) return new Ue(Xe, 1, 1, jt); { const wn = an * (2 - kt) / 2; return new Ue(Xe, an * kt / (1 - Math.abs(2 * wn - 1)), wn, jt) } } hsla2hsva(le) { const Xe = Math.min(le.h, 1), kt = Math.min(le.s, 1), an = Math.min(le.l, 1), jt = Math.min(le.a, 1); if (0 === an) return new Fe(Xe, 0, 0, jt); { const wn = an + kt * (1 - Math.abs(2 * an - 1)) / 2; return new Fe(Xe, 2 * (wn - an) / wn, wn, jt) } } hsvaToRgba(le) { let Xe, kt, an; const jt = le.h, wn = le.s, Jn = le.v, or = le.a, Ht = Math.floor(6 * jt), dn = 6 * jt - Ht, ue = Jn * (1 - wn), it = Jn * (1 - dn * wn), lt = Jn * (1 - (1 - dn) * wn); switch (Ht % 6) { case 0: Xe = Jn, kt = lt, an = ue; break; case 1: Xe = it, kt = Jn, an = ue; break; case 2: Xe = ue, kt = Jn, an = lt; break; case 3: Xe = ue, kt = it, an = Jn; break; case 4: Xe = lt, kt = ue, an = Jn; break; case 5: Xe = Jn, kt = ue, an = it; break; default: Xe = 0, kt = 0, an = 0 }return new tt(Xe, kt, an, or) } cmykToRgb(le) { return new tt((1 - le.c) * (1 - le.k), (1 - le.m) * (1 - le.k), (1 - le.y) * (1 - le.k), le.a) } rgbaToCmyk(le) { const Xe = 1 - Math.max(le.r, le.g, le.b); return 1 === Xe ? new st(0, 0, 0, 1, le.a) : new st((1 - le.r - Xe) / (1 - Xe), (1 - le.g - Xe) / (1 - Xe), (1 - le.b - Xe) / (1 - Xe), Xe, le.a) } rgbaToHsva(le) { let Xe, kt; const an = Math.min(le.r, 1), jt = Math.min(le.g, 1), wn = Math.min(le.b, 1), Jn = Math.min(le.a, 1), or = Math.max(an, jt, wn), Ht = Math.min(an, jt, wn), dn = or, ue = or - Ht; if (kt = 0 === or ? 0 : ue / or, or === Ht) Xe = 0; else { switch (or) { case an: Xe = (jt - wn) / ue + (jt < wn ? 6 : 0); break; case jt: Xe = (wn - an) / ue + 2; break; case wn: Xe = (an - jt) / ue + 4; break; default: Xe = 0 }Xe /= 6 } return new Fe(Xe, kt, dn, Jn) } rgbaToHex(le, Xe) { let kt = "#" + (16777216 | le.r << 16 | le.g << 8 | le.b).toString(16).substr(1); return 1 != le.a && (kt += (256 | Math.round(255 * le.a)).toString(16).substr(1)), kt } normalizeCMYK(le) { return new st(le.c / 100, le.m / 100, le.y / 100, le.k / 100, le.a) } denormalizeCMYK(le) { return new st(Math.floor(100 * le.c), Math.floor(100 * le.m), Math.floor(100 * le.y), Math.floor(100 * le.k), le.a) } denormalizeRGBA(le) { return new tt(Math.round(255 * le.r), Math.round(255 * le.g), Math.round(255 * le.b), le.a) } stringToHsva(le = "", Xe = !0) { let kt = null; le = (le || "").toLowerCase(); const an = [{ re: /(rgb)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*%?,\s*(\d{1,3})\s*%?(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/, parse: function (jt) { return new tt(parseInt(jt[2], 10) / 255, parseInt(jt[3], 10) / 255, parseInt(jt[4], 10) / 255, isNaN(parseFloat(jt[5])) ? 1 : parseFloat(jt[5])) } }, { re: /(hsl)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/, parse: function (jt) { return new Ue(parseInt(jt[2], 10) / 360, parseInt(jt[3], 10) / 100, parseInt(jt[4], 10) / 100, isNaN(parseFloat(jt[5])) ? 1 : parseFloat(jt[5])) } }]; an.push(Xe ? { re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})?$/, parse: function (jt) { return new tt(parseInt(jt[1], 16) / 255, parseInt(jt[2], 16) / 255, parseInt(jt[3], 16) / 255, parseInt(jt[4] || "FF", 16) / 255) } } : { re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/, parse: function (jt) { return new tt(parseInt(jt[1], 16) / 255, parseInt(jt[2], 16) / 255, parseInt(jt[3], 16) / 255, 1) } }), an.push({ re: /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/, parse: function (jt) { return new tt(parseInt(jt[1] + jt[1], 16) / 255, parseInt(jt[2] + jt[2], 16) / 255, parseInt(jt[3] + jt[3], 16) / 255, 1) } }); for (const jt in an) if (an.hasOwnProperty(jt)) { const wn = an[jt], Jn = wn.re.exec(le), or = Jn && wn.parse(Jn); if (or) return or instanceof tt ? kt = this.rgbaToHsva(or) : or instanceof Ue && (kt = this.hsla2hsva(or)), kt } return kt } outputFormat(le) { return this.hsvaToRgba(le).toString() } getFormatByString(le) { if (le) { le = le.toLowerCase(); let kt = /(rgba\((\d{1,3},\s?){3}(1|0?\.\d+)\)|rgb\(\d{1,3}(,\s?\d{1,3}){2}\))/, an = /(hsla\((\d{1,3}%?,\s?){3}(1|0?\.\d+)\)|hsl\(\d{1,3}%?(,\s?\d{1,3}%?){2}\))/; if (/(#([\da-f]{3}(?:[\da-f]{3})?(?:[\da-f]{2})?))/.test(le)) return "hex"; if (kt.test(le)) return "rgba"; if (an.test(le)) return "hsla" } return "hex" } } return Ze.\u0275fac = function (le) { return new (le || Ze) }, Ze.\u0275prov = i.Yz7({ token: Ze, factory: Ze.\u0275fac }), Ze })(); class rn { constructor(Ot, le, Xe, kt) { this.h = Ot, this.s = le, this.v = Xe, this.a = kt } } class On { constructor(Ot, le, Xe, kt) { this.h = Ot, this.s = le, this.v = Xe, this.a = kt } } let qn = (() => { class Ze { constructor(le) { this.elRef = le, this.dragEnd = new i.vpe, this.dragStart = new i.vpe, this.newValue = new i.vpe, this.listenerMove = Xe => this.move(Xe), this.listenerStop = () => this.stop() } mouseDown(le) { this.start(le) } touchStart(le) { this.start(le) } move(le) { le.preventDefault(), this.setCursor(le) } start(le) { this.setCursor(le), le.stopPropagation(), document.addEventListener("mouseup", this.listenerStop), document.addEventListener("touchend", this.listenerStop), document.addEventListener("mousemove", this.listenerMove), document.addEventListener("touchmove", this.listenerMove), this.dragStart.emit() } stop() { document.removeEventListener("mouseup", this.listenerStop), document.removeEventListener("touchend", this.listenerStop), document.removeEventListener("mousemove", this.listenerMove), document.removeEventListener("touchmove", this.listenerMove), this.dragEnd.emit() } getX(le) { const Xe = this.elRef.nativeElement.getBoundingClientRect(); return (void 0 !== le.pageX ? le.pageX : le.touches[0].pageX) - Xe.left - window.pageXOffset } getY(le) { const Xe = this.elRef.nativeElement.getBoundingClientRect(); return (void 0 !== le.pageY ? le.pageY : le.touches[0].pageY) - Xe.top - window.pageYOffset } setCursor(le) { const Xe = this.elRef.nativeElement.offsetWidth, kt = this.elRef.nativeElement.offsetHeight, an = Math.max(0, Math.min(this.getX(le), Xe)), jt = Math.max(0, Math.min(this.getY(le), kt)); void 0 !== this.rgX && void 0 !== this.rgY ? this.newValue.emit({ s: an / Xe, v: 1 - jt / kt, rgX: this.rgX, rgY: this.rgY }) : void 0 === this.rgX && void 0 !== this.rgY ? this.newValue.emit({ v: jt / kt, rgY: this.rgY }) : void 0 !== this.rgX && void 0 === this.rgY && this.newValue.emit({ v: an / Xe, rgX: this.rgX }) } } return Ze.\u0275fac = function (le) { return new (le || Ze)(i.Y36(i.SBq)) }, Ze.\u0275dir = i.lG2({ type: Ze, selectors: [["", "slider", ""]], hostBindings: function (le, Xe) { 1 & le && i.NdJ("mousedown", function (an) { return Xe.mouseDown(an) })("touchstart", function (an) { return Xe.touchStart(an) }) }, inputs: { rgX: "rgX", rgY: "rgY", slider: "slider" }, outputs: { dragEnd: "dragEnd", dragStart: "dragStart", newValue: "newValue" } }), Ze })(), nr = (() => { class Ze { constructor(le, Xe) { this.service = le, this.cdr = Xe, this.color = new Fe(0, 1, 1, 1), this.controls = "default", this.sliderChange = new i.vpe(!1), this.onAlphaChange = new i.vpe(!1), this.hsva = new Fe(0, 1, 1, 1), this.selectedColor = "#000000", this.fallbackColor = "#000000" } ngOnInit() { this.color || (this.color = new Fe(0, 1, 1, 1)), this.slider = new rn(0, 0, 0, 0), this.update() } ngOnDestroy() { } ngOnChanges(le) { le.color && this.color && this.update() } ngAfterViewInit() { this.sliderDimMax = new On(this.hueSlider?.nativeElement.offsetWidth || 140, 220, 130, this.alphaSlider?.nativeElement.offsetWidth || 140), this.update() } onSliderChange(le, Xe) { switch (le) { case "saturation-lightness": this.hsva.onColorChange(Xe); break; case "hue": this.hsva.onHueChange(Xe); break; case "alpha": this.hsva.onAlphaChange(Xe), this.onAlphaChange.emit(Xe); break; case "value": this.hsva.onValueChange(Xe) }this.update(), this.setColor(this.outputColor) } setColor(le) { this.color = le, this.sliderChange.emit(this.color) } getBackgroundColor(le) { return { background: "linear-gradient(90deg, rgba(36,0,0,0) 0%, " + le + " 100%)" } } update() { if (this.hsva = this.color, this.sliderDimMax) { let le = this.service.hsvaToRgba(this.hsva).denormalize(), Xe = this.service.hsvaToRgba(new Fe(this.hsva.h, 1, 1, 1)).denormalize(); this.hueSliderColor = "rgb(" + Xe.r + "," + Xe.g + "," + Xe.b + ")", this.alphaSliderColor = "rgb(" + le.r + "," + le.g + "," + le.b + ")", this.outputColor = this.hsva, this.selectedColor = this.service.hsvaToRgba(this.hsva).toString(), this.slider = new rn(this.hsva.h * this.sliderDimMax.h - 5, this.hsva.s * this.sliderDimMax.s - 8, (1 - this.hsva.v) * this.sliderDimMax.v - 8, this.hsva.a * this.sliderDimMax.a - 5), this.cdr.detectChanges() } } } return Ze.\u0275fac = function (le) { return new (le || Ze)(i.Y36(Kt), i.Y36(i.sBO)) }, Ze.\u0275cmp = i.Xpm({ type: Ze, selectors: [["color-picker"]], viewQuery: function (le, Xe) { if (1 & le && (i.Gf(Ce, 5), i.Gf(we, 5)), 2 & le) { let kt; i.iGM(kt = i.CRH()) && (Xe.hueSlider = kt.first), i.iGM(kt = i.CRH()) && (Xe.alphaSlider = kt.first) } }, inputs: { color: "color", controls: "controls" }, outputs: { sliderChange: "sliderChange", onAlphaChange: "onAlphaChange" }, features: [i.TTD], decls: 8, vars: 4, consts: [[1, "color-picker", 3, "click"], ["dialogPopup", ""], ["class", "saturation-lightness", 3, "slider", "rgX", "rgY", "background-color", "newValue", 4, "ngIf"], [1, "hue-alpha", "box"], ["class", "left", 4, "ngIf"], [1, "right"], ["class", "hue", 3, "slider", "rgX", "newValue", 4, "ngIf"], ["class", "alpha", 3, "slider", "rgX", "newValue", 4, "ngIf"], [1, "saturation-lightness", 3, "slider", "rgX", "rgY", "newValue"], [1, "cursor"], [1, "left"], [1, "selected-color-background"], [1, "selected-color"], [1, "hue", 3, "slider", "rgX", "newValue"], ["hueSlider", ""], [1, "sliderCursor"], [1, "alpha", 3, "slider", "rgX", "newValue"], ["alphaSlider", ""], [1, "alpha-gradient", 3, "ngStyle"]], template: function (le, Xe) { 1 & le && (i.TgZ(0, "div", 0, 1), i.NdJ("click", function (an) { return an.stopPropagation() }), i.YNc(2, Te, 3, 8, "div", 2), i.TgZ(3, "div", 3), i.YNc(4, Ee, 3, 2, "div", 4), i.TgZ(5, "div", 5), i.YNc(6, _e, 5, 3, "div", 6), i.YNc(7, ae, 6, 4, "div", 7), i.qZA()()()), 2 & le && (i.xp6(2), i.Q6J("ngIf", "only-alpha" != Xe.controls), i.xp6(2), i.Q6J("ngIf", "only-alpha" != Xe.controls), i.xp6(2), i.Q6J("ngIf", "only-alpha" != Xe.controls), i.xp6(1), i.Q6J("ngIf", "no-alpha" != Xe.controls)) }, dependencies: [ye.O5, ye.PC, qn], styles: [".color-picker{position:relative;z-index:1000;width:220px;height:auto;cursor:default;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;touch-action:none}.color-picker *{box-sizing:border-box;margin:0;font-size:11px}.color-picker input{width:0;height:26px;min-width:0;font-size:13px;text-align:center;color:#000}.color-picker input:invalid,.color-picker input:-moz-ui-invalid,.color-picker input:-moz-submit-invalid{box-shadow:none}.color-picker input::-webkit-inner-spin-button,.color-picker input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.color-picker .sliderCursor{width:10px;border-radius:5px;position:absolute;margin-top:-3px;border:1px solid black}.color-picker .sliderCursor>div{border:2px solid white;border-radius:5px}.color-picker .sliderCursor>div>div{border-radius:5px;border:1px solid black;height:24px}.color-picker .cursor{position:absolute;width:21px;border:3px solid black;border-radius:100%;margin:-2px 0 0 -2px}.color-picker .cursor>div{height:15px;border:3px solid white;border-radius:100%}.color-picker .box{display:flex;padding:4px 8px}.color-picker .left{position:relative;padding:16px 8px}.color-picker .right{flex:1 1 auto;display:flex;flex-direction:column;gap:10px;padding:12px 8px}.color-picker .hue-alpha{display:flex;align-items:center;margin-bottom:3px}.color-picker .hue{direction:ltr;width:100%;height:24px;border:none;border-radius:5px;position:relative;cursor:pointer;background-size:100% 100%;background:linear-gradient(to right,red 0%,#ff0 17%,lime 33%,cyan 50%,blue 66%,#f0f 83%,red 100%)}.color-picker .alpha{direction:ltr;position:relative;width:100%;height:24px;border:none;border-radius:5px;cursor:pointer;background-image:linear-gradient(45deg,#ccc 25%,transparent 25%),linear-gradient(-45deg,#ccc 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#ccc 75%),linear-gradient(-45deg,transparent 75%,#ccc 75%);background-size:16px 16px;background-position:0 0,0 8px,8px -8px,-8px 0px}.color-picker .alpha-gradient{width:100%;height:100%;border-radius:5px;position:absolute}.color-picker .selected-color{position:absolute;top:16px;left:8px;width:40px;height:40px;box-shadow:0 1px 1px 1px #00000026;border-radius:50%}.color-picker .selected-color-background{width:40px;height:40px;border-radius:50%;background-image:linear-gradient(45deg,#ccc 25%,transparent 25%),linear-gradient(-45deg,#ccc 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#ccc 75%),linear-gradient(-45deg,transparent 75%,#ccc 75%);background-size:16px 16px;background-position:0 0,0 8px,8px -8px,-8px 0px}.color-picker .saturation-lightness{direction:ltr;cursor:crosshair;width:100%;position:relative;height:130px;border:none;touch-action:manipulation;background-image:linear-gradient(to top,#000 0%,transparent 100%),linear-gradient(to right,#fff 0%,transparent 100%)}\n"], encapsulation: 2 }), Ze })(), kn = (() => { class Ze { constructor(le, Xe) { this.service = le, this.cdr = Xe, this.color = "#000000", this.previewColor = "#000000", this.hsva = new Fe(0, 1, 1, 1), this.colorsAnimationEffect = "slide-in", this.palette = nt, this.variants = [], this.colorFormats = Ne, this.format = Be.HEX, this.canChangeFormat = !0, this.menu = 1, this.hideColorPicker = !1, this.hideTextInput = !1, this.colorPickerControls = "default" } click(le) { this.isOutside(le) && this.emitClose("cancel") } onScroll() { this.onScreenMovement() } onResize() { this.onScreenMovement() } ngOnInit() { this.setPosition(), this.hsva = this.service.stringToHsva(this.color), this.indexSeleccionado = this.findIndexSelectedColor(this.palette) } ngAfterViewInit() { this.setPositionY() } onScreenMovement() { this.setPosition(), this.setPositionY(), this.panelRef.nativeElement.style.transition || (this.panelRef.nativeElement.style.transition = "transform 0.5s ease-out") } findIndexSelectedColor(le) { let Xe; if (this.color) for (let kt = 0; kt < le.length; kt++) { const an = le[kt]; "string" == typeof an ? this.service.stringToFormat(this.color, Be.HEX) == this.service.stringToFormat(an, Be.HEX) && (Xe = kt) : void 0 === an ? this.color = void 0 : null != this.findIndexSelectedColor(an.variants) && (Xe = kt) } return Xe } iniciate(le, Xe, kt, an, jt, wn, Jn, or, Ht, dn, ue, it) { if (this.colorPickerControls = ue, this.triggerInstance = le, this.TriggerBBox = Xe, this.color = kt, this.hideColorPicker = or, this.hideTextInput = Jn, this.acceptLabel = Ht, this.cancelLabel = dn, wn ? Ne.includes(wn) ? (this.format = Ne.indexOf(wn.toLowerCase()), this.canChangeFormat = !1, this.service.getFormatByString(this.color) != wn.toLowerCase() && this.setColor(this.service.stringToHsva(this.color))) : (console.error("Format provided is invalid, using HEX"), this.format = Be.HEX) : this.format = Ne.indexOf(this.service.getFormatByString(this.color)), this.previewColor = this.color, this.palette = an ?? nt, this.colorsAnimationEffect = jt, "top" == it) { let lt = this.TriggerBBox.nativeElement.getBoundingClientRect(); this.positionString = "transform: translateY(calc( -100% - " + lt.height + "px ))" } } setPosition() { if (this.TriggerBBox) { const Xe = this.TriggerBBox.nativeElement.getBoundingClientRect(); this.top = Xe.top + Xe.height, this.left = Xe.left + 250 > window.innerWidth ? Xe.right < 250 ? window.innerWidth / 2 - 125 : Xe.right - 250 : Xe.left } } setPositionY() { const le = this.TriggerBBox.nativeElement.getBoundingClientRect(), Xe = this.panelRef.nativeElement.getBoundingClientRect(); this.positionString = le.bottom + Xe.height > window.innerHeight ? le.top < Xe.height ? "transform: translateY(-" + le.bottom + "px );" : "transform: translateY(calc( -100% - " + le.height + "px ));" : "", this.cdr.detectChanges() } hasVariant(le) { return !!this.previewColor && "string" != typeof le && le.variants.some(Xe => Xe.toUpperCase() == this.previewColor.toUpperCase()) } isSelected(le) { return !!this.previewColor && "string" == typeof le && le.toUpperCase() == this.previewColor.toUpperCase() } getBackgroundColor(le) { return "string" == typeof le ? { background: le } : { background: le?.preview } } onAlphaChange(le) { this.palette = this.ChangeAlphaOnPalette(le, this.palette) } ChangeAlphaOnPalette(le, Xe) { var kt = []; for (let an = 0; an < Xe.length; an++) { const jt = Xe[an]; if ("string" == typeof jt) { let wn = this.service.stringToHsva(jt); wn.onAlphaChange(le), kt.push(this.service.toFormat(wn, this.format)) } else { let wn = new ht, Jn = this.service.stringToHsva(jt.preview); Jn.onAlphaChange(le), wn.preview = this.service.toFormat(Jn, this.format), wn.variants = this.ChangeAlphaOnPalette(le, jt.variants), kt.push(wn) } } return kt } changeColor(le) { this.setColor(this.service.stringToHsva(le)), this.emitClose("accept") } onChangeColorPicker(le) { this.temporalColor = le, this.color = this.service.toFormat(le, this.format), this.triggerInstance.sliderChange(this.service.toFormat(le, this.format)) } changeColorManual(le) { this.previewColor = le, this.color = le, this.hsva = this.service.stringToHsva(le), this.temporalColor = this.hsva, this.triggerInstance.setColor(this.color) } setColor(le) { this.hsva = le, this.color = this.service.toFormat(le, this.format), this.setPreviewColor(le), this.triggerInstance.setColor(this.color) } setPreviewColor(le) { this.previewColor = le ? this.service.hsvaToRgba(le).toString() : void 0 } onChange() { } onColorClick(le) { "string" == typeof le || void 0 === le ? this.changeColor(le) : (this.variants = le.variants, this.menu = 2) } addColor() { this.menu = 3, this.backupColor = this.color, this.temporalColor = this.service.stringToHsva(this.color) } nextFormat() { this.canChangeFormat && (this.format = (this.format + 1) % this.colorFormats.length, this.setColor(this.hsva)) } emitClose(le) { 3 == this.menu && ("cancel" == le || "accept" == le && this.setColor(this.temporalColor)), this.triggerInstance.close() } onClickBack() { 3 == this.menu && (this.color = this.backupColor, this.hsva = this.service.stringToHsva(this.color)), this.indexSeleccionado = this.findIndexSelectedColor(this.palette), this.menu = 1 } isOutside(le) { return le.target.classList.contains("ngx-colors-overlay") } } return Ze.\u0275fac = function (le) { return new (le || Ze)(i.Y36(Kt), i.Y36(i.sBO)) }, Ze.\u0275cmp = i.Xpm({ type: Ze, selectors: [["ngx-colors-panel"]], viewQuery: function (le, Xe) { if (1 & le && i.Gf(ve, 5), 2 & le) { let kt; i.iGM(kt = i.CRH()) && (Xe.panelRef = kt.first) } }, hostVars: 4, hostBindings: function (le, Xe) { 1 & le && i.NdJ("mousedown", function (an) { return Xe.click(an) }, !1, i.evT)("scroll", function () { return Xe.onScroll() }, !1, i.evT)("resize", function () { return Xe.onResize() }, !1, i.Jf7), 2 & le && i.Udp("top", Xe.top, "px")("left", Xe.left, "px") }, decls: 6, vars: 6, consts: [[1, "opened"], ["dialog", ""], [4, "ngIf"], ["class", "manual-input-wrapper", 4, "ngIf"], [1, "colors"], [4, "ngFor", "ngForOf"], ["style", "background: rgb(245 245 245); position: relative", "class", "circle button", 3, "click", 4, "ngIf"], [3, "controls", "color", "colorChange", "onAlphaChange", 4, "ngIf"], [1, "circle", "wrapper", "color"], [1, "circle", "color", "circle-border", 3, "ngStyle", "click"], ["class", "selected", 4, "ngIf"], [1, "selected"], [1, "circle", "button", 2, "background", "rgb(245 245 245)", "position", "relative", 3, "click"], ["style", "\n            position: absolute;\n            height: 7px;\n            width: 7px;\n            border: 1px solid rgba(0, 0, 0, 0.03);\n            border-radius: 100%;\n            top: 0;\n            right: 0;\n          ", 3, "ngStyle", 4, "ngIf"], ["xmlns", "http://www.w3.org/2000/svg", "height", "24px", "viewBox", "0 0 24 24", "width", "24px", "fill", "#222222"], ["d", "M24 24H0V0h24v24z", "fill", "none", "opacity", ".87"], ["d", "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"], [2, "position", "absolute", "height", "7px", "width", "7px", "border", "1px solid rgba(0, 0, 0, 0.03)", "border-radius", "100%", "top", "0", "right", "0", 3, "ngStyle"], [3, "controls", "color", "colorChange", "onAlphaChange"], [1, "circle", "wrapper"], [1, "add", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "width", "24", "height", "24", "viewBox", "0 0 24 24"], ["d", "M0 0h24v24H0z", "fill", "none"], ["d", "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"], [1, "circle", "circle-border", 3, "ngStyle", "click"], [1, "nav-wrapper"], [1, "round-button", "button", 2, "float", "left", 3, "click"], [2, "float", "right", 3, "click"], [1, "color-picker-wrapper"], [3, "controls", "color", "sliderChange"], [1, "manual-input-wrapper"], [3, "click"], [1, "g-input"], ["placeholder", "#FFFFFF", "type", "text", 3, "value", "keyup", "keydown.enter"], ["paintInput", ""]], template: function (le, Xe) { 1 & le && (i.TgZ(0, "div", 0, 1), i.YNc(2, De, 5, 4, "ng-container", 2), i.YNc(3, ct, 8, 2, "ng-container", 2), i.YNc(4, Oe, 12, 4, "ng-container", 2), i.YNc(5, Ve, 6, 6, "div", 3), i.qZA()), 2 & le && (i.Akn(Xe.positionString), i.xp6(2), i.Q6J("ngIf", 1 == Xe.menu), i.xp6(1), i.Q6J("ngIf", 2 == Xe.menu), i.xp6(1), i.Q6J("ngIf", 3 == Xe.menu), i.xp6(1), i.Q6J("ngIf", !Xe.hideTextInput)) }, dependencies: [ye.sg, ye.O5, ye.PC, nr], styles: ["[_nghost-%COMP%]{position:fixed;z-index:2001}.hidden[_ngcontent-%COMP%]{display:none}.button[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}.top[_ngcontent-%COMP%]{transform:translateY(-100%)}.opened[_ngcontent-%COMP%]{box-sizing:border-box;box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f;background:#fff;width:250px;border-radius:5px;position:absolute}.opened[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{border:none;font-family:inherit;font-size:12px;background-color:unset;-webkit-user-select:none;user-select:none;padding:10px;letter-spacing:1px;color:#222;border-radius:3px;line-height:20px}.opened[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover, .opened[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]:hover{background-color:#0000000d;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1);transition-property:opacity,background-color;transition-duration:.2s,.2s;transition-timing-function:cubic-bezier(.35,0,.25,1),cubic-bezier(.35,0,.25,1);transition-delay:0s,0s}.opened[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:focus{outline:none}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;align-items:center;margin:15px}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle[_ngcontent-%COMP%]{height:34px;width:34px;box-sizing:border-box;border-radius:100%;cursor:pointer}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle[_ngcontent-%COMP%]   .add[_ngcontent-%COMP%]{font-size:20px;line-height:45px;text-align:center}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle[_ngcontent-%COMP%]   .selected[_ngcontent-%COMP%]{border:2px solid white;border-radius:100%;height:28px;width:28px;box-sizing:border-box;margin:2px}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle.colornull[_ngcontent-%COMP%]{background:linear-gradient(135deg,rgba(236,236,236,.7) 0%,rgba(236,236,236,.7) 45%,#de0f00 50%,rgba(236,236,236,.7) 55%,rgba(236,236,236,.7) 100%)}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle.wrapper[_ngcontent-%COMP%]{margin:0 5px 5px;flex:34px 0 0}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle.button[_ngcontent-%COMP%]{margin:0 5px 5px}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle.wrapper.color[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,#ccc 25%,transparent 25%),linear-gradient(-45deg,#ccc 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#ccc 75%),linear-gradient(-45deg,transparent 75%,#ccc 75%);background-size:16px 16px;background-position:0 0,0 8px,8px -8px,-8px 0px}.opened[_ngcontent-%COMP%]   .colors[_ngcontent-%COMP%]   .circle-border[_ngcontent-%COMP%]{border:1px solid rgba(0,0,0,.03)}.opened[_ngcontent-%COMP%]   .color-picker-wrapper[_ngcontent-%COMP%]{margin:5px 15px}.opened[_ngcontent-%COMP%]   .nav-wrapper[_ngcontent-%COMP%]{overflow:hidden;margin:5px}.opened[_ngcontent-%COMP%]   .nav-wrapper[_ngcontent-%COMP%]   .round-button[_ngcontent-%COMP%]{padding:5px 0;width:40px;height:40px;box-sizing:border-box;border-radius:100%;text-align:center;line-height:45px}.opened[_ngcontent-%COMP%]   .manual-input-wrapper[_ngcontent-%COMP%]{display:flex;margin:15px;font-family:sans-serif}.opened[_ngcontent-%COMP%]   .manual-input-wrapper[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:0;text-align:center;font-size:10px;letter-spacing:1.5px;text-transform:uppercase;line-height:48px;width:145px;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.opened[_ngcontent-%COMP%]   .manual-input-wrapper[_ngcontent-%COMP%]   .g-input[_ngcontent-%COMP%]{border:1px solid #e8ebed;height:45px;border-radius:5px;width:100%}.opened[_ngcontent-%COMP%]   .manual-input-wrapper[_ngcontent-%COMP%]   .g-input[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:9px;border:none;width:100%;text-transform:uppercase;outline:none;text-align:center;letter-spacing:1px;color:#595b65;height:100%;border-radius:5px;margin:0;padding:0}"], data: { animation: [(0, J.X$)("colorsAnimation", [(0, J.eR)("void => slide-in", [(0, J.IO)(":enter", (0, J.oB)({ opacity: 0 }), { optional: !0 }), (0, J.IO)(":enter", (0, J.EY)("10ms", [(0, J.jt)(".3s ease-in", (0, J.F4)([(0, J.oB)({ opacity: 0, transform: "translatex(-50%)", offset: 0 }), (0, J.oB)({ opacity: .5, transform: "translatex(-10px) scale(1.1)", offset: .3 }), (0, J.oB)({ opacity: 1, transform: "translatex(0)", offset: 1 })]))]), { optional: !0 })]), (0, J.eR)("void => popup", [(0, J.IO)(":enter", (0, J.oB)({ opacity: 0, transform: "scale(0)" }), { optional: !0 }), (0, J.IO)(":enter", (0, J.EY)("10ms", [(0, J.jt)("500ms ease-out", (0, J.F4)([(0, J.oB)({ opacity: .5, transform: "scale(.5)", offset: .3 }), (0, J.oB)({ opacity: 1, transform: "scale(1.1)", offset: .8 }), (0, J.oB)({ opacity: 1, transform: "scale(1)", offset: 1 })]))]), { optional: !0 })])])] } }), Ze })(); const fn = { position: "fixed", height: "100%", width: "100%", "z-index": 2e3, top: 0, left: 0 }; let It = (() => { class Ze { constructor(le, Xe, kt) { this.resolver = le, this.applicationRef = Xe, this.injector = kt } createPanel(le, Xe) { null != this.componentRef && this.removePanel(); const kt = this.resolver.resolveComponentFactory(kn); this.componentRef = kt.create(this.injector), this.applicationRef.attachView(this.componentRef.hostView); const an = this.componentRef.hostView.rootNodes[0]; return this.overlay = document.createElement("div"), this.overlay.id = "ngx-colors-overlay", this.overlay.classList.add("ngx-colors-overlay"), this.overlay.classList.add(Xe), Object.keys(fn).forEach(jt => { this.overlay.style[jt] = fn[jt] }), le ? document.getElementById(le).appendChild(this.overlay) : document.body.appendChild(this.overlay), this.overlay.appendChild(an), this.componentRef } removePanel() { this.applicationRef.detachView(this.componentRef.hostView), this.componentRef.destroy(), this.overlay.remove() } } return Ze.\u0275fac = function (le) { return new (le || Ze)(i.LFG(i._Vd), i.LFG(i.z2F), i.LFG(i.zs3)) }, Ze.\u0275prov = i.Yz7({ token: Ze, factory: Ze.\u0275fac }), Ze })(), Yt = (() => { class Ze { constructor(le, Xe) { this.triggerRef = le, this.panelFactory = Xe, this.color = "", this.colorsAnimation = "slide-in", this.position = "bottom", this.attachTo = void 0, this.overlayClassName = void 0, this.colorPickerControls = "default", this.acceptLabel = "ACCEPT", this.cancelLabel = "CANCEL", this.change = new i.vpe, this.input = new i.vpe, this.slider = new i.vpe, this.isDisabled = !1, this.onTouchedCallback = () => { }, this.onChangeCallback = () => { } } onClick() { this.open() } open() { this.isDisabled || (this.panelRef = this.panelFactory.createPanel(this.attachTo, this.overlayClassName), this.panelRef.instance.iniciate(this, this.triggerRef, this.color, this.palette, this.colorsAnimation, this.format, this.hideTextInput, this.hideColorPicker, this.acceptLabel, this.cancelLabel, this.colorPickerControls, this.position)) } close() { this.panelFactory.removePanel() } onChange() { this.onChangeCallback(this.color) } setDisabledState(le) { this.isDisabled = le, this.triggerRef.nativeElement.style.opacity = le ? .5 : 1 } setColor(le) { this.writeValue(le), this.input.emit(le) } sliderChange(le) { this.slider.emit(le) } get value() { return this.color } set value(le) { this.setColor(le), this.onChangeCallback(le) } writeValue(le) { le !== this.color && (this.color = le, this.onChange(), this.change.emit(le)) } registerOnChange(le) { this.onChangeCallback = le } registerOnTouched(le) { this.onTouchedCallback = le } } return Ze.\u0275fac = function (le) { return new (le || Ze)(i.Y36(i.SBq), i.Y36(It)) }, Ze.\u0275dir = i.lG2({ type: Ze, selectors: [["", "ngx-colors-trigger", ""]], hostBindings: function (le, Xe) { 1 & le && i.NdJ("click", function () { return Xe.onClick() }) }, inputs: { colorsAnimation: "colorsAnimation", palette: "palette", format: "format", position: "position", hideTextInput: "hideTextInput", hideColorPicker: "hideColorPicker", attachTo: "attachTo", overlayClassName: "overlayClassName", colorPickerControls: "colorPickerControls", acceptLabel: "acceptLabel", cancelLabel: "cancelLabel" }, outputs: { change: "change", input: "input", slider: "slider" }, features: [i._Bn([{ provide: m.JU, useExisting: (0, i.Gpc)(() => Ze), multi: !0 }])] }), Ze })(), pt = (() => { class Ze { constructor(le, Xe) { this.cdRef = le, this.triggerDirective = Xe, this.triggerDirectiveColorChangeSubscription = null, this.color = this.triggerDirective.color } ngOnInit() { this.triggerDirectiveColorChangeSubscription = this.triggerDirective.change.subscribe(le => { this.color = le, this.cdRef.markForCheck() }) } ngOnDestroy() { this.triggerDirectiveColorChangeSubscription && this.triggerDirectiveColorChangeSubscription.unsubscribe() } } return Ze.\u0275fac = function (le) { return new (le || Ze)(i.Y36(i.sBO), i.Y36(Yt, 1)) }, Ze.\u0275cmp = i.Xpm({ type: Ze, selectors: [["ngx-colors"]], decls: 4, vars: 5, consts: [[1, "app-color-picker"], [1, "preview"], [1, "preview-background"], [1, "circle", 3, "ngStyle"]], template: function (le, Xe) { 1 & le && (i.TgZ(0, "div", 0)(1, "div", 1)(2, "div", 2), i._UZ(3, "div", 3), i.qZA()()()), 2 & le && (i.xp6(3), i.ekj("colornull", !Xe.color), i.Q6J("ngStyle", i.VKq(3, _t, Xe.color))) }, dependencies: [ye.PC], styles: ["[_nghost-%COMP%]   .app-color-picker[_ngcontent-%COMP%]{line-height:1px;font-family:sans-serif}[_nghost-%COMP%]   .app-color-picker[_ngcontent-%COMP%]   .preview[_ngcontent-%COMP%]{margin:2px;display:inline-block;box-sizing:border-box;border-radius:100%;background:white;cursor:pointer;padding:3px;box-shadow:0 1px 1px #0003,0 1px 1px 1px #00000024,0 1px 1px 1px #0000001f}[_nghost-%COMP%]   .app-color-picker[_ngcontent-%COMP%]   .preview[_ngcontent-%COMP%]   .preview-background[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,#ccc 25%,transparent 25%),linear-gradient(-45deg,#ccc 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#ccc 75%),linear-gradient(-45deg,transparent 75%,#ccc 75%);background-size:16px 16px;background-position:0 0,0 8px,8px -8px,-8px 0px;border-radius:100%}[_nghost-%COMP%]   .app-color-picker[_ngcontent-%COMP%]   .preview[_ngcontent-%COMP%]   .circle[_ngcontent-%COMP%]{height:20px;width:20px;box-sizing:border-box;border-radius:100%;cursor:pointer}[_nghost-%COMP%]   .app-color-picker[_ngcontent-%COMP%]   .preview[_ngcontent-%COMP%]   .circle.colornull[_ngcontent-%COMP%]{background:linear-gradient(135deg,rgba(236,236,236,.7) 0%,rgba(236,236,236,.7) 45%,#de0f00 50%,rgba(236,236,236,.7) 55%,rgba(236,236,236,.7) 100%)}[_nghost-%COMP%]   .app-color-picker[_ngcontent-%COMP%]   .preview[_ngcontent-%COMP%]   .noselected[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,#ccc 25%,transparent 25%),linear-gradient(-45deg,#ccc 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#ccc 75%),linear-gradient(-45deg,transparent 75%,#ccc 75%);background-size:16px 16px;background-position:0 0,0 8px,8px -8px,-8px 0px}"] }), Ze })(), Pt = (() => { class Ze { } return Ze.\u0275fac = function (le) { return new (le || Ze) }, Ze.\u0275mod = i.oAB({ type: Ze }), Ze.\u0275inj = i.cJS({ providers: [Kt, It], imports: [ye.ez] }), Ze })() }, 5869: (un, Je, L) => { "use strict"; L.d(Je, { ML: () => Ay, Mn: () => Ty, tP: () => Hf, FP: () => Od, kI: () => xp }); var i = L(4650), m = L(4006), J = L(7579), ye = L(2722); const Ee = f => { const s = (f => { const s = {}; return Object.keys(f).forEach(l => { f[l] && (s[l] = f[l]) }), s })(f); return Object.entries(s).map(([l, h]) => `${(f => f.replace(/[A-Z]/g, s => `-${s.toLowerCase()}`))(l)}:${h}`).join(";") }; class _e extends Error { constructor(s) { super(s), this.name = this.constructor.name } } function ae(f) { this.content = f } ae.prototype = { constructor: ae, find: function (f) { for (var s = 0; s < this.content.length; s += 2)if (this.content[s] === f) return s; return -1 }, get: function (f) { var s = this.find(f); return -1 == s ? void 0 : this.content[s + 1] }, update: function (f, s, l) { var h = l && l != f ? this.remove(l) : this, y = h.find(f), w = h.content.slice(); return -1 == y ? w.push(l || f, s) : (w[y + 1] = s, l && (w[y] = l)), new ae(w) }, remove: function (f) { var s = this.find(f); if (-1 == s) return this; var l = this.content.slice(); return l.splice(s, 2), new ae(l) }, addToStart: function (f, s) { return new ae([f, s].concat(this.remove(f).content)) }, addToEnd: function (f, s) { var l = this.remove(f).content.slice(); return l.push(f, s), new ae(l) }, addBefore: function (f, s, l) { var h = this.remove(s), y = h.content.slice(), w = h.find(f); return y.splice(-1 == w ? y.length : w, 0, s, l), new ae(y) }, forEach: function (f) { for (var s = 0; s < this.content.length; s += 2)f(this.content[s], this.content[s + 1]) }, prepend: function (f) { return (f = ae.from(f)).size ? new ae(f.content.concat(this.subtract(f).content)) : this }, append: function (f) { return (f = ae.from(f)).size ? new ae(this.subtract(f).content.concat(f.content)) : this }, subtract: function (f) { var s = this; f = ae.from(f); for (var l = 0; l < f.content.length; l += 2)s = s.remove(f.content[l]); return s }, toObject: function () { var f = {}; return this.forEach(function (s, l) { f[s] = l }), f }, get size() { return this.content.length >> 1 } }, ae.from = function (f) { if (f instanceof ae) return f; var s = []; if (f) for (var l in f) s.push(l, f[l]); return new ae(s) }; const ve = ae; function xe(f, s, l) { for (let h = 0; ; h++) { if (h == f.childCount || h == s.childCount) return f.childCount == s.childCount ? null : l; let y = f.child(h), w = s.child(h); if (y != w) { if (!y.sameMarkup(w)) return l; if (y.isText && y.text != w.text) { for (let I = 0; y.text[I] == w.text[I]; I++)l++; return l } if (y.content.size || w.content.size) { let I = xe(y.content, w.content, l + 1); if (null != I) return I } l += y.nodeSize } else l += y.nodeSize } } function gt(f, s, l, h) { for (let y = f.childCount, w = s.childCount; ;) { if (0 == y || 0 == w) return y == w ? null : { a: l, b: h }; let I = f.child(--y), k = s.child(--w), H = I.nodeSize; if (I != k) { if (!I.sameMarkup(k)) return { a: l, b: h }; if (I.isText && I.text != k.text) { let te = 0, se = Math.min(I.text.length, k.text.length); for (; te < se && I.text[I.text.length - te - 1] == k.text[k.text.length - te - 1];)te++, l--, h--; return { a: l, b: h } } if (I.content.size || k.content.size) { let te = gt(I.content, k.content, l - 1, h - 1); if (te) return te } l -= H, h -= H } else l -= H, h -= H } } class Se { constructor(s, l) { if (this.content = s, this.size = l || 0, null == l) for (let h = 0; h < s.length; h++)this.size += s[h].nodeSize } nodesBetween(s, l, h, y = 0, w) { for (let I = 0, k = 0; k < l; I++) { let H = this.content[I], te = k + H.nodeSize; if (te > s && !1 !== h(H, y + k, w || null, I) && H.content.size) { let se = k + 1; H.nodesBetween(Math.max(0, s - se), Math.min(H.content.size, l - se), h, y + se) } k = te } } descendants(s) { this.nodesBetween(0, this.size, s) } textBetween(s, l, h, y) { let w = "", I = !0; return this.nodesBetween(s, l, (k, H) => { k.isText ? (w += k.text.slice(Math.max(s, H) - H, l - H), I = !h) : k.isLeaf ? (y ? w += "function" == typeof y ? y(k) : y : k.type.spec.leafText && (w += k.type.spec.leafText(k)), I = !h) : !I && k.isBlock && (w += h, I = !0) }, 0), w } append(s) { if (!s.size) return this; if (!this.size) return s; let l = this.lastChild, h = s.firstChild, y = this.content.slice(), w = 0; for (l.isText && l.sameMarkup(h) && (y[y.length - 1] = l.withText(l.text + h.text), w = 1); w < s.content.length; w++)y.push(s.content[w]); return new Se(y, this.size + s.size) } cut(s, l = this.size) { if (0 == s && l == this.size) return this; let h = [], y = 0; if (l > s) for (let w = 0, I = 0; I < l; w++) { let k = this.content[w], H = I + k.nodeSize; H > s && ((I < s || H > l) && (k = k.isText ? k.cut(Math.max(0, s - I), Math.min(k.text.length, l - I)) : k.cut(Math.max(0, s - I - 1), Math.min(k.content.size, l - I - 1))), h.push(k), y += k.nodeSize), I = H } return new Se(h, y) } cutByIndex(s, l) { return s == l ? Se.empty : 0 == s && l == this.content.length ? this : new Se(this.content.slice(s, l)) } replaceChild(s, l) { let h = this.content[s]; if (h == l) return this; let y = this.content.slice(), w = this.size + l.nodeSize - h.nodeSize; return y[s] = l, new Se(y, w) } addToStart(s) { return new Se([s].concat(this.content), this.size + s.nodeSize) } addToEnd(s) { return new Se(this.content.concat(s), this.size + s.nodeSize) } eq(s) { if (this.content.length != s.content.length) return !1; for (let l = 0; l < this.content.length; l++)if (!this.content[l].eq(s.content[l])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(s) { let l = this.content[s]; if (!l) throw new RangeError("Index " + s + " out of range for " + this); return l } maybeChild(s) { return this.content[s] || null } forEach(s) { for (let l = 0, h = 0; l < this.content.length; l++) { let y = this.content[l]; s(y, h, l), h += y.nodeSize } } findDiffStart(s, l = 0) { return xe(this, s, l) } findDiffEnd(s, l = this.size, h = s.size) { return gt(this, s, l, h) } findIndex(s, l = -1) { if (0 == s) return wt(0, s); if (s == this.size) return wt(this.content.length, s); if (s > this.size || s < 0) throw new RangeError(`Position ${s} outside of fragment (${this})`); for (let h = 0, y = 0; ; h++) { let I = y + this.child(h).nodeSize; if (I >= s) return I == s || l > 0 ? wt(h + 1, I) : wt(h, y); y = I } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map(s => s.toJSON()) : null } static fromJSON(s, l) { if (!l) return Se.empty; if (!Array.isArray(l)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new Se(l.map(s.nodeFromJSON)) } static fromArray(s) { if (!s.length) return Se.empty; let l, h = 0; for (let y = 0; y < s.length; y++) { let w = s[y]; h += w.nodeSize, y && w.isText && s[y - 1].sameMarkup(w) ? (l || (l = s.slice(0, y)), l[l.length - 1] = w.withText(l[l.length - 1].text + w.text)) : l && l.push(w) } return new Se(l || s, h) } static from(s) { if (!s) return Se.empty; if (s instanceof Se) return s; if (Array.isArray(s)) return this.fromArray(s); if (s.attrs) return new Se([s], s.nodeSize); throw new RangeError("Can not convert " + s + " to a Fragment" + (s.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } } Se.empty = new Se([], 0); const rt = { index: 0, offset: 0 }; function wt(f, s) { return rt.index = f, rt.offset = s, rt } function De(f, s) { if (f === s) return !0; if (!f || "object" != typeof f || !s || "object" != typeof s) return !1; let l = Array.isArray(f); if (Array.isArray(s) != l) return !1; if (l) { if (f.length != s.length) return !1; for (let h = 0; h < f.length; h++)if (!De(f[h], s[h])) return !1 } else { for (let h in f) if (!(h in s) || !De(f[h], s[h])) return !1; for (let h in s) if (!(h in f)) return !1 } return !0 } let je = (() => { class f { constructor(l, h) { this.type = l, this.attrs = h } addToSet(l) { let h, y = !1; for (let w = 0; w < l.length; w++) { let I = l[w]; if (this.eq(I)) return l; if (this.type.excludes(I.type)) h || (h = l.slice(0, w)); else { if (I.type.excludes(this.type)) return l; !y && I.type.rank > this.type.rank && (h || (h = l.slice(0, w)), h.push(this), y = !0), h && h.push(I) } } return h || (h = l.slice()), y || h.push(this), h } removeFromSet(l) { for (let h = 0; h < l.length; h++)if (this.eq(l[h])) return l.slice(0, h).concat(l.slice(h + 1)); return l } isInSet(l) { for (let h = 0; h < l.length; h++)if (this.eq(l[h])) return !0; return !1 } eq(l) { return this == l || this.type == l.type && De(this.attrs, l.attrs) } toJSON() { let l = { type: this.type.name }; for (let h in this.attrs) { l.attrs = this.attrs; break } return l } static fromJSON(l, h) { if (!h) throw new RangeError("Invalid input for Mark.fromJSON"); let y = l.marks[h.type]; if (!y) throw new RangeError(`There is no mark type ${h.type} in this schema`); return y.create(h.attrs) } static sameSet(l, h) { if (l == h) return !0; if (l.length != h.length) return !1; for (let y = 0; y < l.length; y++)if (!l[y].eq(h[y])) return !1; return !0 } static setFrom(l) { if (!l || Array.isArray(l) && 0 == l.length) return f.none; if (l instanceof f) return [l]; let h = l.slice(); return h.sort((y, w) => y.type.rank - w.type.rank), h } } return f.none = [], f })(); class _t extends Error { } class Qe { constructor(s, l, h) { this.content = s, this.openStart = l, this.openEnd = h } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(s, l) { let h = Oe(this.content, s + this.openStart, l); return h && new Qe(h, this.openStart, this.openEnd) } removeBetween(s, l) { return new Qe(ct(this.content, s + this.openStart, l + this.openStart), this.openStart, this.openEnd) } eq(s) { return this.content.eq(s.content) && this.openStart == s.openStart && this.openEnd == s.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let s = { content: this.content.toJSON() }; return this.openStart > 0 && (s.openStart = this.openStart), this.openEnd > 0 && (s.openEnd = this.openEnd), s } static fromJSON(s, l) { if (!l) return Qe.empty; let h = l.openStart || 0, y = l.openEnd || 0; if ("number" != typeof h || "number" != typeof y) throw new RangeError("Invalid input for Slice.fromJSON"); return new Qe(Se.fromJSON(s, l.content), h, y) } static maxOpen(s, l = !0) { let h = 0, y = 0; for (let w = s.firstChild; w && !w.isLeaf && (l || !w.type.spec.isolating); w = w.firstChild)h++; for (let w = s.lastChild; w && !w.isLeaf && (l || !w.type.spec.isolating); w = w.lastChild)y++; return new Qe(s, h, y) } } function ct(f, s, l) { let { index: h, offset: y } = f.findIndex(s), w = f.maybeChild(h), { index: I, offset: k } = f.findIndex(l); if (y == s || w.isText) { if (k != l && !f.child(I).isText) throw new RangeError("Removing non-flat range"); return f.cut(0, s).append(f.cut(l)) } if (h != I) throw new RangeError("Removing non-flat range"); return f.replaceChild(h, w.copy(ct(w.content, s - y - 1, l - y - 1))) } function Oe(f, s, l, h) { let { index: y, offset: w } = f.findIndex(s), I = f.maybeChild(y); if (w == s || I.isText) return h && !h.canReplace(y, y, l) ? null : f.cut(0, s).append(l).append(f.cut(s)); let k = Oe(I.content, s - w - 1, l); return k && f.replaceChild(y, I.copy(k)) } function Ve(f, s, l) { if (l.openStart > f.depth) throw new _t("Inserted content deeper than insertion position"); if (f.depth - l.openStart != s.depth - l.openEnd) throw new _t("Inconsistent open depths"); return Be(f, s, l, 0) } function Be(f, s, l, h) { let y = f.index(h), w = f.node(h); if (y == s.index(h) && h < f.depth - l.openStart) { let I = Be(f, s, l, h + 1); return w.copy(w.content.replaceChild(y, I)) } if (l.content.size) { if (l.openStart || l.openEnd || f.depth != h || s.depth != h) { let { start: I, end: k } = function Kt(f, s) { let l = s.depth - f.openStart, y = s.node(l).copy(f.content); for (let w = l - 1; w >= 0; w--)y = s.node(w).copy(Se.from(y)); return { start: y.resolveNoCache(f.openStart + l), end: y.resolveNoCache(y.content.size - f.openEnd - l) } }(l, f); return Ue(w, st(f, I, k, s, h)) } { let I = f.parent, k = I.content; return Ue(I, k.cut(0, f.parentOffset).append(l.content).append(k.cut(s.parentOffset))) } } return Ue(w, ht(f, s, h)) } function nt(f, s) { if (!s.type.compatibleContent(f.type)) throw new _t("Cannot join " + s.type.name + " onto " + f.type.name) } function Ne(f, s, l) { let h = f.node(l); return nt(h, s.node(l)), h } function tt(f, s) { let l = s.length - 1; l >= 0 && f.isText && f.sameMarkup(s[l]) ? s[l] = f.withText(s[l].text + f.text) : s.push(f) } function Fe(f, s, l, h) { let y = (s || f).node(l), w = 0, I = s ? s.index(l) : y.childCount; f && (w = f.index(l), f.depth > l ? w++ : f.textOffset && (tt(f.nodeAfter, h), w++)); for (let k = w; k < I; k++)tt(y.child(k), h); s && s.depth == l && s.textOffset && tt(s.nodeBefore, h) } function Ue(f, s) { return f.type.checkContent(s), f.copy(s) } function st(f, s, l, h, y) { let w = f.depth > y && Ne(f, s, y + 1), I = h.depth > y && Ne(l, h, y + 1), k = []; return Fe(null, f, y, k), w && I && s.index(y) == l.index(y) ? (nt(w, I), tt(Ue(w, st(f, s, l, h, y + 1)), k)) : (w && tt(Ue(w, ht(f, s, y + 1)), k), Fe(s, l, y, k), I && tt(Ue(I, ht(l, h, y + 1)), k)), Fe(h, null, y, k), new Se(k) } function ht(f, s, l) { let h = []; return Fe(null, f, l, h), f.depth > l && tt(Ue(Ne(f, s, l + 1), ht(f, s, l + 1)), h), Fe(s, null, l, h), new Se(h) } Qe.empty = new Qe(Se.empty, 0, 0); class rn { constructor(s, l, h) { this.pos = s, this.path = l, this.parentOffset = h, this.depth = l.length / 3 - 1 } resolveDepth(s) { return null == s ? this.depth : s < 0 ? this.depth + s : s } get parent() { return this.node(this.depth) } get doc() { return this.node(0) } node(s) { return this.path[3 * this.resolveDepth(s)] } index(s) { return this.path[3 * this.resolveDepth(s) + 1] } indexAfter(s) { return s = this.resolveDepth(s), this.index(s) + (s != this.depth || this.textOffset ? 1 : 0) } start(s) { return 0 == (s = this.resolveDepth(s)) ? 0 : this.path[3 * s - 1] + 1 } end(s) { return s = this.resolveDepth(s), this.start(s) + this.node(s).content.size } before(s) { if (!(s = this.resolveDepth(s))) throw new RangeError("There is no position before the top-level node"); return s == this.depth + 1 ? this.pos : this.path[3 * s - 1] } after(s) { if (!(s = this.resolveDepth(s))) throw new RangeError("There is no position after the top-level node"); return s == this.depth + 1 ? this.pos : this.path[3 * s - 1] + this.path[3 * s].nodeSize } get textOffset() { return this.pos - this.path[this.path.length - 1] } get nodeAfter() { let s = this.parent, l = this.index(this.depth); if (l == s.childCount) return null; let h = this.pos - this.path[this.path.length - 1], y = s.child(l); return h ? s.child(l).cut(h) : y } get nodeBefore() { let s = this.index(this.depth), l = this.pos - this.path[this.path.length - 1]; return l ? this.parent.child(s).cut(0, l) : 0 == s ? null : this.parent.child(s - 1) } posAtIndex(s, l) { l = this.resolveDepth(l); let h = this.path[3 * l], y = 0 == l ? 0 : this.path[3 * l - 1] + 1; for (let w = 0; w < s; w++)y += h.child(w).nodeSize; return y } marks() { let s = this.parent, l = this.index(); if (0 == s.content.size) return je.none; if (this.textOffset) return s.child(l).marks; let h = s.maybeChild(l - 1), y = s.maybeChild(l); if (!h) { let k = h; h = y, y = k } let w = h.marks; for (var I = 0; I < w.length; I++)!1 === w[I].type.spec.inclusive && (!y || !w[I].isInSet(y.marks)) && (w = w[I--].removeFromSet(w)); return w } marksAcross(s) { let l = this.parent.maybeChild(this.index()); if (!l || !l.isInline) return null; let h = l.marks, y = s.parent.maybeChild(s.index()); for (var w = 0; w < h.length; w++)!1 === h[w].type.spec.inclusive && (!y || !h[w].isInSet(y.marks)) && (h = h[w--].removeFromSet(h)); return h } sharedDepth(s) { for (let l = this.depth; l > 0; l--)if (this.start(l) <= s && this.end(l) >= s) return l; return 0 } blockRange(s = this, l) { if (s.pos < this.pos) return s.blockRange(this); for (let h = this.depth - (this.parent.inlineContent || this.pos == s.pos ? 1 : 0); h >= 0; h--)if (s.pos <= this.end(h) && (!l || l(this.node(h)))) return new kn(this, s, h); return null } sameParent(s) { return this.pos - this.parentOffset == s.pos - s.parentOffset } max(s) { return s.pos > this.pos ? s : this } min(s) { return s.pos < this.pos ? s : this } toString() { let s = ""; for (let l = 1; l <= this.depth; l++)s += (s ? "/" : "") + this.node(l).type.name + "_" + this.index(l - 1); return s + ":" + this.parentOffset } static resolve(s, l) { if (!(l >= 0 && l <= s.content.size)) throw new RangeError("Position " + l + " out of range"); let h = [], y = 0, w = l; for (let I = s; ;) { let { index: k, offset: H } = I.content.findIndex(w), te = w - H; if (h.push(I, k, y + H), !te || (I = I.child(k), I.isText)) break; w = te - 1, y += H + 1 } return new rn(l, h, w) } static resolveCached(s, l) { for (let y = 0; y < On.length; y++) { let w = On[y]; if (w.pos == l && w.doc == s) return w } let h = On[qn] = rn.resolve(s, l); return qn = (qn + 1) % nr, h } } let On = [], qn = 0, nr = 12; class kn { constructor(s, l, h) { this.$from = s, this.$to = l, this.depth = h } get start() { return this.$from.before(this.depth + 1) } get end() { return this.$to.after(this.depth + 1) } get parent() { return this.$from.node(this.depth) } get startIndex() { return this.$from.index(this.depth) } get endIndex() { return this.$to.indexAfter(this.depth) } } const fn = Object.create(null); class It { constructor(s, l, h, y = je.none) { this.type = s, this.attrs = l, this.marks = y, this.content = h || Se.empty } get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size } get childCount() { return this.content.childCount } child(s) { return this.content.child(s) } maybeChild(s) { return this.content.maybeChild(s) } forEach(s) { this.content.forEach(s) } nodesBetween(s, l, h, y = 0) { this.content.nodesBetween(s, l, h, y, this) } descendants(s) { this.nodesBetween(0, this.content.size, s) } get textContent() { return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "") } textBetween(s, l, h, y) { return this.content.textBetween(s, l, h, y) } get firstChild() { return this.content.firstChild } get lastChild() { return this.content.lastChild } eq(s) { return this == s || this.sameMarkup(s) && this.content.eq(s.content) } sameMarkup(s) { return this.hasMarkup(s.type, s.attrs, s.marks) } hasMarkup(s, l, h) { return this.type == s && De(this.attrs, l || s.defaultAttrs || fn) && je.sameSet(this.marks, h || je.none) } copy(s = null) { return s == this.content ? this : new It(this.type, this.attrs, s, this.marks) } mark(s) { return s == this.marks ? this : new It(this.type, this.attrs, this.content, s) } cut(s, l = this.content.size) { return 0 == s && l == this.content.size ? this : this.copy(this.content.cut(s, l)) } slice(s, l = this.content.size, h = !1) { if (s == l) return Qe.empty; let y = this.resolve(s), w = this.resolve(l), I = h ? 0 : y.sharedDepth(l), k = y.start(I), te = y.node(I).content.cut(y.pos - k, w.pos - k); return new Qe(te, y.depth - I, w.depth - I) } replace(s, l, h) { return Ve(this.resolve(s), this.resolve(l), h) } nodeAt(s) { for (let l = this; ;) { let { index: h, offset: y } = l.content.findIndex(s); if (l = l.maybeChild(h), !l) return null; if (y == s || l.isText) return l; s -= y + 1 } } childAfter(s) { let { index: l, offset: h } = this.content.findIndex(s); return { node: this.content.maybeChild(l), index: l, offset: h } } childBefore(s) { if (0 == s) return { node: null, index: 0, offset: 0 }; let { index: l, offset: h } = this.content.findIndex(s); if (h < s) return { node: this.content.child(l), index: l, offset: h }; let y = this.content.child(l - 1); return { node: y, index: l - 1, offset: h - y.nodeSize } } resolve(s) { return rn.resolveCached(this, s) } resolveNoCache(s) { return rn.resolve(this, s) } rangeHasMark(s, l, h) { let y = !1; return l > s && this.nodesBetween(s, l, w => (h.isInSet(w.marks) && (y = !0), !y)), y } get isBlock() { return this.type.isBlock } get isTextblock() { return this.type.isTextblock } get inlineContent() { return this.type.inlineContent } get isInline() { return this.type.isInline } get isText() { return this.type.isText } get isLeaf() { return this.type.isLeaf } get isAtom() { return this.type.isAtom } toString() { if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this); let s = this.type.name; return this.content.size && (s += "(" + this.content.toStringInner() + ")"), pt(this.marks, s) } contentMatchAt(s) { let l = this.type.contentMatch.matchFragment(this.content, 0, s); if (!l) throw new Error("Called contentMatchAt on a node with invalid content"); return l } canReplace(s, l, h = Se.empty, y = 0, w = h.childCount) { let I = this.contentMatchAt(s).matchFragment(h, y, w), k = I && I.matchFragment(this.content, l); if (!k || !k.validEnd) return !1; for (let H = y; H < w; H++)if (!this.type.allowsMarks(h.child(H).marks)) return !1; return !0 } canReplaceWith(s, l, h, y) { if (y && !this.type.allowsMarks(y)) return !1; let w = this.contentMatchAt(s).matchType(h), I = w && w.matchFragment(this.content, l); return !!I && I.validEnd } canAppend(s) { return s.content.size ? this.canReplace(this.childCount, this.childCount, s.content) : this.type.compatibleContent(s.type) } check() { this.type.checkContent(this.content); let s = je.none; for (let l = 0; l < this.marks.length; l++)s = this.marks[l].addToSet(s); if (!je.sameSet(s, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(l => l.type.name)}`); this.content.forEach(l => l.check()) } toJSON() { let s = { type: this.type.name }; for (let l in this.attrs) { s.attrs = this.attrs; break } return this.content.size && (s.content = this.content.toJSON()), this.marks.length && (s.marks = this.marks.map(l => l.toJSON())), s } static fromJSON(s, l) { if (!l) throw new RangeError("Invalid input for Node.fromJSON"); let h = null; if (l.marks) { if (!Array.isArray(l.marks)) throw new RangeError("Invalid mark data for Node.fromJSON"); h = l.marks.map(s.markFromJSON) } if ("text" == l.type) { if ("string" != typeof l.text) throw new RangeError("Invalid text node in JSON"); return s.text(l.text, h) } let y = Se.fromJSON(s, l.content); return s.nodeType(l.type).create(l.attrs, y, h) } } It.prototype.text = void 0; class Yt extends It { constructor(s, l, h, y) { if (super(s, l, null, y), !h) throw new RangeError("Empty text nodes are not allowed"); this.text = h } toString() { return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : pt(this.marks, JSON.stringify(this.text)) } get textContent() { return this.text } textBetween(s, l) { return this.text.slice(s, l) } get nodeSize() { return this.text.length } mark(s) { return s == this.marks ? this : new Yt(this.type, this.attrs, this.text, s) } withText(s) { return s == this.text ? this : new Yt(this.type, this.attrs, s, this.marks) } cut(s = 0, l = this.text.length) { return 0 == s && l == this.text.length ? this : this.withText(this.text.slice(s, l)) } eq(s) { return this.sameMarkup(s) && this.text == s.text } toJSON() { let s = super.toJSON(); return s.text = this.text, s } } function pt(f, s) { for (let l = f.length - 1; l >= 0; l--)s = f[l].type.name + "(" + s + ")"; return s } class Pt { constructor(s) { this.validEnd = s, this.next = [], this.wrapCache = [] } static parse(s, l) { let h = new Ze(s, l); if (null == h.next) return Pt.empty; let y = Ot(h); h.next && h.err("Unexpected trailing text"); let w = function dn(f) { let s = Object.create(null); return function l(h) { let y = []; h.forEach(I => { f[I].forEach(({ term: k, to: H }) => { if (!k) return; let te; for (let se = 0; se < y.length; se++)y[se][0] == k && (te = y[se][1]); Ht(f, H).forEach(se => { te || y.push([k, te = []]), -1 == te.indexOf(se) && te.push(se) }) }) }); let w = s[h.join(",")] = new Pt(h.indexOf(f.length - 1) > -1); for (let I = 0; I < y.length; I++) { let k = y[I][1].sort(or); w.next.push({ type: y[I][0], next: s[k.join(",")] || l(k) }) } return w }(Ht(f, 0)) }(function Jn(f) { let s = [[]]; return y(function w(I, k) { if ("choice" == I.type) return I.exprs.reduce((H, te) => H.concat(w(te, k)), []); if ("seq" != I.type) { if ("star" == I.type) { let H = l(); return h(k, H), y(w(I.expr, H), H), [h(H)] } if ("plus" == I.type) { let H = l(); return y(w(I.expr, k), H), y(w(I.expr, H), H), [h(H)] } if ("opt" == I.type) return [h(k)].concat(w(I.expr, k)); if ("range" == I.type) { let H = k; for (let te = 0; te < I.min; te++) { let se = l(); y(w(I.expr, H), se), H = se } if (-1 == I.max) y(w(I.expr, H), H); else for (let te = I.min; te < I.max; te++) { let se = l(); h(H, se), y(w(I.expr, H), se), H = se } return [h(H)] } if ("name" == I.type) return [h(k, void 0, I.value)]; throw new Error("Unknown expr type") } for (let H = 0; ; H++) { let te = w(I.exprs[H], k); if (H == I.exprs.length - 1) return te; y(te, k = l()) } }(f, 0), l()), s; function l() { return s.push([]) - 1 } function h(I, k, H) { let te = { term: H, to: k }; return s[I].push(te), te } function y(I, k) { I.forEach(H => H.to = k) } }(y)); return function ue(f, s) { for (let l = 0, h = [f]; l < h.length; l++) { let y = h[l], w = !y.validEnd, I = []; for (let k = 0; k < y.next.length; k++) { let { type: H, next: te } = y.next[k]; I.push(H.name), w && !(H.isText || H.hasRequiredAttrs()) && (w = !1), -1 == h.indexOf(te) && h.push(te) } w && s.err("Only non-generatable nodes (" + I.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)") } }(w, h), w } matchType(s) { for (let l = 0; l < this.next.length; l++)if (this.next[l].type == s) return this.next[l].next; return null } matchFragment(s, l = 0, h = s.childCount) { let y = this; for (let w = l; y && w < h; w++)y = y.matchType(s.child(w).type); return y } get inlineContent() { return 0 != this.next.length && this.next[0].type.isInline } get defaultType() { for (let s = 0; s < this.next.length; s++) { let { type: l } = this.next[s]; if (!l.isText && !l.hasRequiredAttrs()) return l } return null } compatible(s) { for (let l = 0; l < this.next.length; l++)for (let h = 0; h < s.next.length; h++)if (this.next[l].type == s.next[h].type) return !0; return !1 } fillBefore(s, l = !1, h = 0) { let y = [this]; return function w(I, k) { let H = I.matchFragment(s, h); if (H && (!l || H.validEnd)) return Se.from(k.map(te => te.createAndFill())); for (let te = 0; te < I.next.length; te++) { let { type: se, next: Ge } = I.next[te]; if (!se.isText && !se.hasRequiredAttrs() && -1 == y.indexOf(Ge)) { y.push(Ge); let at = w(Ge, k.concat(se)); if (at) return at } } return null }(this, []) } findWrapping(s) { for (let h = 0; h < this.wrapCache.length; h += 2)if (this.wrapCache[h] == s) return this.wrapCache[h + 1]; let l = this.computeWrapping(s); return this.wrapCache.push(s, l), l } computeWrapping(s) { let l = Object.create(null), h = [{ match: this, type: null, via: null }]; for (; h.length;) { let y = h.shift(), w = y.match; if (w.matchType(s)) { let I = []; for (let k = y; k.type; k = k.via)I.push(k.type); return I.reverse() } for (let I = 0; I < w.next.length; I++) { let { type: k, next: H } = w.next[I]; !k.isLeaf && !k.hasRequiredAttrs() && !(k.name in l) && (!y.type || H.validEnd) && (h.push({ match: k.contentMatch, type: k, via: y }), l[k.name] = !0) } } return null } get edgeCount() { return this.next.length } edge(s) { if (s >= this.next.length) throw new RangeError(`There's no ${s}th edge in this content match`); return this.next[s] } toString() { let s = []; return function l(h) { s.push(h); for (let y = 0; y < h.next.length; y++)-1 == s.indexOf(h.next[y].next) && l(h.next[y].next) }(this), s.map((h, y) => { let w = y + (h.validEnd ? "*" : " ") + " "; for (let I = 0; I < h.next.length; I++)w += (I ? ", " : "") + h.next[I].type.name + "->" + s.indexOf(h.next[I].next); return w }).join("\n") } } Pt.empty = new Pt(!0); class Ze { constructor(s, l) { this.string = s, this.nodeTypes = l, this.inline = null, this.pos = 0, this.tokens = s.split(/\s*(?=\b|\W|$)/), "" == this.tokens[this.tokens.length - 1] && this.tokens.pop(), "" == this.tokens[0] && this.tokens.shift() } get next() { return this.tokens[this.pos] } eat(s) { return this.next == s && (this.pos++ || !0) } err(s) { throw new SyntaxError(s + " (in content expression '" + this.string + "')") } } function Ot(f) { let s = []; do { s.push(le(f)) } while (f.eat("|")); return 1 == s.length ? s[0] : { type: "choice", exprs: s } } function le(f) { let s = []; do { s.push(Xe(f)) } while (f.next && ")" != f.next && "|" != f.next); return 1 == s.length ? s[0] : { type: "seq", exprs: s } } function Xe(f) { let s = function wn(f) { if (f.eat("(")) { let s = Ot(f); return f.eat(")") || f.err("Missing closing paren"), s } if (!/\W/.test(f.next)) { let s = function jt(f, s) { let l = f.nodeTypes, h = l[s]; if (h) return [h]; let y = []; for (let w in l) { let I = l[w]; I.groups.indexOf(s) > -1 && y.push(I) } return 0 == y.length && f.err("No node type or group '" + s + "' found"), y }(f, f.next).map(l => (null == f.inline ? f.inline = l.isInline : f.inline != l.isInline && f.err("Mixing inline and block content"), { type: "name", value: l })); return f.pos++, 1 == s.length ? s[0] : { type: "choice", exprs: s } } f.err("Unexpected token '" + f.next + "'") }(f); for (; ;)if (f.eat("+")) s = { type: "plus", expr: s }; else if (f.eat("*")) s = { type: "star", expr: s }; else if (f.eat("?")) s = { type: "opt", expr: s }; else { if (!f.eat("{")) break; s = an(f, s) } return s } function kt(f) { /\D/.test(f.next) && f.err("Expected number, got '" + f.next + "'"); let s = Number(f.next); return f.pos++, s } function an(f, s) { let l = kt(f), h = l; return f.eat(",") && (h = "}" != f.next ? kt(f) : -1), f.eat("}") || f.err("Unclosed braced range"), { type: "range", min: l, max: h, expr: s } } function or(f, s) { return s - f } function Ht(f, s) { let l = []; return function h(y) { let w = f[y]; if (1 == w.length && !w[0].term) return h(w[0].to); l.push(y); for (let I = 0; I < w.length; I++) { let { term: k, to: H } = w[I]; !k && -1 == l.indexOf(H) && h(H) } }(s), l.sort(or) } function it(f) { let s = Object.create(null); for (let l in f) { let h = f[l]; if (!h.hasDefault) return null; s[l] = h.default } return s } function lt(f, s) { let l = Object.create(null); for (let h in f) { let y = s && s[h]; if (void 0 === y) { let w = f[h]; if (!w.hasDefault) throw new RangeError("No value supplied for attribute " + h); y = w.default } l[h] = y } return l } function Nt(f) { let s = Object.create(null); if (f) for (let l in f) s[l] = new Hn(f[l]); return s } class gn { constructor(s, l, h) { this.name = s, this.schema = l, this.spec = h, this.markSet = null, this.groups = h.group ? h.group.split(" ") : [], this.attrs = Nt(h.attrs), this.defaultAttrs = it(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(h.inline || "text" == s), this.isText = "text" == s } get isInline() { return !this.isBlock } get isTextblock() { return this.isBlock && this.inlineContent } get isLeaf() { return this.contentMatch == Pt.empty } get isAtom() { return this.isLeaf || !!this.spec.atom } get whitespace() { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") } hasRequiredAttrs() { for (let s in this.attrs) if (this.attrs[s].isRequired) return !0; return !1 } compatibleContent(s) { return this == s || this.contentMatch.compatible(s.contentMatch) } computeAttrs(s) { return !s && this.defaultAttrs ? this.defaultAttrs : lt(this.attrs, s) } create(s = null, l, h) { if (this.isText) throw new Error("NodeType.create can't construct text nodes"); return new It(this, this.computeAttrs(s), Se.from(l), je.setFrom(h)) } createChecked(s = null, l, h) { return l = Se.from(l), this.checkContent(l), new It(this, this.computeAttrs(s), l, je.setFrom(h)) } createAndFill(s = null, l, h) { if (s = this.computeAttrs(s), (l = Se.from(l)).size) { let I = this.contentMatch.fillBefore(l); if (!I) return null; l = I.append(l) } let y = this.contentMatch.matchFragment(l), w = y && y.fillBefore(Se.empty, !0); return w ? new It(this, s, l.append(w), je.setFrom(h)) : null } validContent(s) { let l = this.contentMatch.matchFragment(s); if (!l || !l.validEnd) return !1; for (let h = 0; h < s.childCount; h++)if (!this.allowsMarks(s.child(h).marks)) return !1; return !0 } checkContent(s) { if (!this.validContent(s)) throw new RangeError(`Invalid content for node ${this.name}: ${s.toString().slice(0, 50)}`) } allowsMarkType(s) { return null == this.markSet || this.markSet.indexOf(s) > -1 } allowsMarks(s) { if (null == this.markSet) return !0; for (let l = 0; l < s.length; l++)if (!this.allowsMarkType(s[l].type)) return !1; return !0 } allowedMarks(s) { if (null == this.markSet) return s; let l; for (let h = 0; h < s.length; h++)this.allowsMarkType(s[h].type) ? l && l.push(s[h]) : l || (l = s.slice(0, h)); return l ? l.length ? l : je.none : s } static compile(s, l) { let h = Object.create(null); s.forEach((w, I) => h[w] = new gn(w, l, I)); let y = l.spec.topNode || "doc"; if (!h[y]) throw new RangeError("Schema is missing its top node type ('" + y + "')"); if (!h.text) throw new RangeError("Every schema needs a 'text' type"); for (let w in h.text.attrs) throw new RangeError("The text node type should not have attributes"); return h } } class Hn { constructor(s) { this.hasDefault = Object.prototype.hasOwnProperty.call(s, "default"), this.default = s.default } get isRequired() { return !this.hasDefault } } class _r { constructor(s, l, h, y) { this.name = s, this.rank = l, this.schema = h, this.spec = y, this.attrs = Nt(y.attrs), this.excluded = null; let w = it(this.attrs); this.instance = w ? new je(this, w) : null } create(s = null) { return !s && this.instance ? this.instance : new je(this, lt(this.attrs, s)) } static compile(s, l) { let h = Object.create(null), y = 0; return s.forEach((w, I) => h[w] = new _r(w, y++, l, I)), h } removeFromSet(s) { for (var l = 0; l < s.length; l++)s[l].type == this && (s = s.slice(0, l).concat(s.slice(l + 1)), l--); return s } isInSet(s) { for (let l = 0; l < s.length; l++)if (s[l].type == this) return s[l] } excludes(s) { return this.excluded.indexOf(s) > -1 } } function Fn(f, s) { let l = []; for (let h = 0; h < s.length; h++) { let y = s[h], w = f.marks[y], I = w; if (w) l.push(w); else for (let k in f.marks) { let H = f.marks[k]; ("_" == y || H.spec.group && H.spec.group.split(" ").indexOf(y) > -1) && l.push(I = H) } if (!I) throw new SyntaxError("Unknown mark type: '" + s[h] + "'") } return l } class yn { constructor(s, l) { this.schema = s, this.rules = l, this.tags = [], this.styles = [], l.forEach(h => { h.tag ? this.tags.push(h) : h.style && this.styles.push(h) }), this.normalizeLists = !this.tags.some(h => { if (!/^(ul|ol)\b/.test(h.tag) || !h.node) return !1; let y = s.nodes[h.node]; return y.contentMatch.matchType(y) }) } parse(s, l = {}) { let h = new Et(this, l, !1); return h.addAll(s, l.from, l.to), h.finish() } parseSlice(s, l = {}) { let h = new Et(this, l, !0); return h.addAll(s, l.from, l.to), Qe.maxOpen(h.finish()) } matchTag(s, l, h) { for (let y = h ? this.tags.indexOf(h) + 1 : 0; y < this.tags.length; y++) { let w = this.tags[y]; if (bn(s, w.tag) && (void 0 === w.namespace || s.namespaceURI == w.namespace) && (!w.context || l.matchesContext(w.context))) { if (w.getAttrs) { let I = w.getAttrs(s); if (!1 === I) continue; w.attrs = I || void 0 } return w } } } matchStyle(s, l, h, y) { for (let w = y ? this.styles.indexOf(y) + 1 : 0; w < this.styles.length; w++) { let I = this.styles[w], k = I.style; if (!(0 != k.indexOf(s) || I.context && !h.matchesContext(I.context) || k.length > s.length && (61 != k.charCodeAt(s.length) || k.slice(s.length + 1) != l))) { if (I.getAttrs) { let H = I.getAttrs(l); if (!1 === H) continue; I.attrs = H || void 0 } return I } } } static schemaRules(s) { let l = []; function h(y) { let w = null == y.priority ? 50 : y.priority, I = 0; for (; I < l.length; I++) { let k = l[I]; if ((null == k.priority ? 50 : k.priority) < w) break } l.splice(I, 0, y) } for (let y in s.marks) { let w = s.marks[y].spec.parseDOM; w && w.forEach(I => { h(I = Bt(I)), I.mark = y }) } for (let y in s.nodes) { let w = s.nodes[y].spec.parseDOM; w && w.forEach(I => { h(I = Bt(I)), I.node = y }) } return l } static fromSchema(s) { return s.cached.domParser || (s.cached.domParser = new yn(s, yn.schemaRules(s))) } } const Qn = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, ur = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, dr = { ol: !0, ul: !0 }; function ln(f, s, l) { return null != s ? (s ? 1 : 0) | ("full" === s ? 2 : 0) : f && "pre" == f.whitespace ? 3 : -5 & l } class Ae { constructor(s, l, h, y, w, I, k) { this.type = s, this.attrs = l, this.marks = h, this.pendingMarks = y, this.solid = w, this.options = k, this.content = [], this.activeMarks = je.none, this.stashMarks = [], this.match = I || (4 & k ? null : s.contentMatch) } findWrapping(s) { if (!this.match) { if (!this.type) return []; let l = this.type.contentMatch.fillBefore(Se.from(s)); if (!l) { let y, h = this.type.contentMatch; return (y = h.findWrapping(s.type)) ? (this.match = h, y) : null } this.match = this.type.contentMatch.matchFragment(l) } return this.match.findWrapping(s.type) } finish(s) { if (!(1 & this.options)) { let y, h = this.content[this.content.length - 1]; if (h && h.isText && (y = /[ \t\r\n\u000c]+$/.exec(h.text))) { let w = h; h.text.length == y[0].length ? this.content.pop() : this.content[this.content.length - 1] = w.withText(w.text.slice(0, w.text.length - y[0].length)) } } let l = Se.from(this.content); return !s && this.match && (l = l.append(this.match.fillBefore(Se.empty, !0))), this.type ? this.type.create(this.attrs, l, this.marks) : l } popFromStashMark(s) { for (let l = this.stashMarks.length - 1; l >= 0; l--)if (s.eq(this.stashMarks[l])) return this.stashMarks.splice(l, 1)[0] } applyPending(s) { for (let l = 0, h = this.pendingMarks; l < h.length; l++) { let y = h[l]; (this.type ? this.type.allowsMarkType(y.type) : vt(y.type, s)) && !y.isInSet(this.activeMarks) && (this.activeMarks = y.addToSet(this.activeMarks), this.pendingMarks = y.removeFromSet(this.pendingMarks)) } } inlineContext(s) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : s.parentNode && !Qn.hasOwnProperty(s.parentNode.nodeName.toLowerCase()) } } class Et { constructor(s, l, h) { this.parser = s, this.options = l, this.isOpen = h, this.open = 0; let w, y = l.topNode, I = ln(null, l.preserveWhitespace, 0) | (h ? 4 : 0); w = y ? new Ae(y.type, y.attrs, je.none, je.none, !0, l.topMatch || y.type.contentMatch, I) : new Ae(h ? null : s.schema.topNodeType, null, je.none, je.none, !0, null, I), this.nodes = [w], this.find = l.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(s) { if (3 == s.nodeType) this.addTextNode(s); else if (1 == s.nodeType) { let l = s.getAttribute("style"), h = l ? this.readStyles(function sn(f) { let l, s = /\s*([\w-]+)\s*:\s*([^;]+)/g, h = []; for (; l = s.exec(f);)h.push(l[1], l[2].trim()); return h }(l)) : null, y = this.top; if (null != h) for (let w = 0; w < h.length; w++)this.addPendingMark(h[w]); if (this.addElement(s), null != h) for (let w = 0; w < h.length; w++)this.removePendingMark(h[w], y) } } addTextNode(s) { let l = s.nodeValue, h = this.top; if (2 & h.options || h.inlineContext(s) || /[^ \t\r\n\u000c]/.test(l)) { if (1 & h.options) l = 2 & h.options ? l.replace(/\r\n?/g, "\n") : l.replace(/\r?\n|\r/g, " "); else if (l = l.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(l) && this.open == this.nodes.length - 1) { let y = h.content[h.content.length - 1], w = s.previousSibling; (!y || w && "BR" == w.nodeName || y.isText && /[ \t\r\n\u000c]$/.test(y.text)) && (l = l.slice(1)) } l && this.insertNode(this.parser.schema.text(l)), this.findInText(s) } else this.findInside(s) } addElement(s, l) { let y, h = s.nodeName.toLowerCase(); dr.hasOwnProperty(h) && this.parser.normalizeLists && function Gt(f) { for (let s = f.firstChild, l = null; s; s = s.nextSibling) { let h = 1 == s.nodeType ? s.nodeName.toLowerCase() : null; h && dr.hasOwnProperty(h) && l ? (l.appendChild(s), s = l) : "li" == h ? l = s : h && (l = null) } }(s); let w = this.options.ruleFromNode && this.options.ruleFromNode(s) || (y = this.parser.matchTag(s, this, l)); if (w ? w.ignore : ur.hasOwnProperty(h)) this.findInside(s), this.ignoreFallback(s); else if (!w || w.skip || w.closeParent) { w && w.closeParent ? this.open = Math.max(0, this.open - 1) : w && w.skip.nodeType && (s = w.skip); let I, k = this.top, H = this.needsBlock; if (Qn.hasOwnProperty(h)) k.content.length && k.content[0].isInline && this.open && (this.open--, k = this.top), I = !0, k.type || (this.needsBlock = !0); else if (!s.firstChild) return void this.leafFallback(s); this.addAll(s), I && this.sync(k), this.needsBlock = H } else this.addElementByRule(s, w, !1 === w.consuming ? y : void 0) } leafFallback(s) { "BR" == s.nodeName && this.top.type && this.top.type.inlineContent && this.addTextNode(s.ownerDocument.createTextNode("\n")) } ignoreFallback(s) { "BR" == s.nodeName && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-")) } readStyles(s) { let l = je.none; e: for (let h = 0; h < s.length; h += 2)for (let y; ;) { let w = this.parser.matchStyle(s[h], s[h + 1], this, y); if (!w) continue e; if (w.ignore) return null; if (l = this.parser.schema.marks[w.mark].create(w.attrs).addToSet(l), !1 !== w.consuming) break; y = w } return l } addElementByRule(s, l, h) { let y, w, I; l.node ? (w = this.parser.schema.nodes[l.node], w.isLeaf ? this.insertNode(w.create(l.attrs)) || this.leafFallback(s) : y = this.enter(w, l.attrs || null, l.preserveWhitespace)) : (I = this.parser.schema.marks[l.mark].create(l.attrs), this.addPendingMark(I)); let k = this.top; if (w && w.isLeaf) this.findInside(s); else if (h) this.addElement(s, h); else if (l.getContent) this.findInside(s), l.getContent(s, this.parser.schema).forEach(H => this.insertNode(H)); else { let H = s; "string" == typeof l.contentElement ? H = s.querySelector(l.contentElement) : "function" == typeof l.contentElement ? H = l.contentElement(s) : l.contentElement && (H = l.contentElement), this.findAround(s, H, !0), this.addAll(H) } y && this.sync(k) && this.open--, I && this.removePendingMark(I, k) } addAll(s, l, h) { let y = l || 0; for (let w = l ? s.childNodes[l] : s.firstChild, I = null == h ? null : s.childNodes[h]; w != I; w = w.nextSibling, ++y)this.findAtPoint(s, y), this.addDOM(w); this.findAtPoint(s, y) } findPlace(s) { let l, h; for (let y = this.open; y >= 0; y--) { let w = this.nodes[y], I = w.findWrapping(s); if (I && (!l || l.length > I.length) && (l = I, h = w, !I.length) || w.solid) break } if (!l) return !1; this.sync(h); for (let y = 0; y < l.length; y++)this.enterInner(l[y], null, !1); return !0 } insertNode(s) { if (s.isInline && this.needsBlock && !this.top.type) { let l = this.textblockFromContext(); l && this.enterInner(l) } if (this.findPlace(s)) { this.closeExtra(); let l = this.top; l.applyPending(s.type), l.match && (l.match = l.match.matchType(s.type)); let h = l.activeMarks; for (let y = 0; y < s.marks.length; y++)(!l.type || l.type.allowsMarkType(s.marks[y].type)) && (h = s.marks[y].addToSet(h)); return l.content.push(s.mark(h)), !0 } return !1 } enter(s, l, h) { let y = this.findPlace(s.create(l)); return y && this.enterInner(s, l, !0, h), y } enterInner(s, l = null, h = !1, y) { this.closeExtra(); let w = this.top; w.applyPending(s), w.match = w.match && w.match.matchType(s); let I = ln(s, y, w.options); 4 & w.options && 0 == w.content.length && (I |= 4), this.nodes.push(new Ae(s, l, w.activeMarks, w.pendingMarks, h, null, I)), this.open++ } closeExtra(s = !1) { let l = this.nodes.length - 1; if (l > this.open) { for (; l > this.open; l--)this.nodes[l - 1].content.push(this.nodes[l].finish(s)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen) } sync(s) { for (let l = this.open; l >= 0; l--)if (this.nodes[l] == s) return this.open = l, !0; return !1 } get currentPos() { this.closeExtra(); let s = 0; for (let l = this.open; l >= 0; l--) { let h = this.nodes[l].content; for (let y = h.length - 1; y >= 0; y--)s += h[y].nodeSize; l && s++ } return s } findAtPoint(s, l) { if (this.find) for (let h = 0; h < this.find.length; h++)this.find[h].node == s && this.find[h].offset == l && (this.find[h].pos = this.currentPos) } findInside(s) { if (this.find) for (let l = 0; l < this.find.length; l++)null == this.find[l].pos && 1 == s.nodeType && s.contains(this.find[l].node) && (this.find[l].pos = this.currentPos) } findAround(s, l, h) { if (s != l && this.find) for (let y = 0; y < this.find.length; y++)null == this.find[y].pos && 1 == s.nodeType && s.contains(this.find[y].node) && l.compareDocumentPosition(this.find[y].node) & (h ? 2 : 4) && (this.find[y].pos = this.currentPos) } findInText(s) { if (this.find) for (let l = 0; l < this.find.length; l++)this.find[l].node == s && (this.find[l].pos = this.currentPos - (s.nodeValue.length - this.find[l].offset)) } matchesContext(s) { if (s.indexOf("|") > -1) return s.split(/\s*\|\s*/).some(this.matchesContext, this); let l = s.split("/"), h = this.options.context, y = !(this.isOpen || h && h.parent.type != this.nodes[0].type), w = (y ? 0 : 1) - (h ? h.depth + 1 : 0), I = (k, H) => { for (; k >= 0; k--) { let te = l[k]; if ("" == te) { if (k == l.length - 1 || 0 == k) continue; for (; H >= w; H--)if (I(k - 1, H)) return !0; return !1 } { let se = H > 0 || 0 == H && y ? this.nodes[H].type : h && H >= w ? h.node(H - w).type : null; if (!se || se.name != te && -1 == se.groups.indexOf(te)) return !1; H-- } } return !0 }; return I(l.length - 1, this.open) } textblockFromContext() { let s = this.options.context; if (s) for (let l = s.depth; l >= 0; l--) { let h = s.node(l).contentMatchAt(s.indexAfter(l)).defaultType; if (h && h.isTextblock && h.defaultAttrs) return h } for (let l in this.parser.schema.nodes) { let h = this.parser.schema.nodes[l]; if (h.isTextblock && h.defaultAttrs) return h } } addPendingMark(s) { let l = function Le(f, s) { for (let l = 0; l < s.length; l++)if (f.eq(s[l])) return s[l] }(s, this.top.pendingMarks); l && this.top.stashMarks.push(l), this.top.pendingMarks = s.addToSet(this.top.pendingMarks) } removePendingMark(s, l) { for (let h = this.open; h >= 0; h--) { let y = this.nodes[h]; if (y.pendingMarks.lastIndexOf(s) > -1) y.pendingMarks = s.removeFromSet(y.pendingMarks); else { y.activeMarks = s.removeFromSet(y.activeMarks); let I = y.popFromStashMark(s); I && y.type && y.type.allowsMarkType(I.type) && (y.activeMarks = I.addToSet(y.activeMarks)) } if (y == l) break } } } function bn(f, s) { return (f.matches || f.msMatchesSelector || f.webkitMatchesSelector || f.mozMatchesSelector).call(f, s) } function Bt(f) { let s = {}; for (let l in f) s[l] = f[l]; return s } function vt(f, s) { let l = s.schema.nodes; for (let h in l) { let y = l[h]; if (!y.allowsMarkType(f)) continue; let w = [], I = k => { w.push(k); for (let H = 0; H < k.edgeCount; H++) { let { type: te, next: se } = k.edge(H); if (te == s || w.indexOf(se) < 0 && I(se)) return !0 } }; if (I(y.contentMatch)) return !0 } } class qe { constructor(s, l) { this.nodes = s, this.marks = l } serializeFragment(s, l = {}, h) { h || (h = fe(l).createDocumentFragment()); let y = h, w = []; return s.forEach(I => { if (w.length || I.marks.length) { let k = 0, H = 0; for (; k < w.length && H < I.marks.length;) { let te = I.marks[H]; if (this.marks[te.type.name]) { if (!te.eq(w[k][0]) || !1 === te.type.spec.spanning) break; k++, H++ } else H++ } for (; k < w.length;)y = w.pop()[1]; for (; H < I.marks.length;) { let te = I.marks[H++], se = this.serializeMark(te, I.isInline, l); se && (w.push([te, y]), y.appendChild(se.dom), y = se.contentDOM || se.dom) } } y.appendChild(this.serializeNodeInner(I, l)) }), h } serializeNodeInner(s, l) { let { dom: h, contentDOM: y } = qe.renderSpec(fe(l), this.nodes[s.type.name](s)); if (y) { if (s.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec"); this.serializeFragment(s.content, l, y) } return h } serializeNode(s, l = {}) { let h = this.serializeNodeInner(s, l); for (let y = s.marks.length - 1; y >= 0; y--) { let w = this.serializeMark(s.marks[y], s.isInline, l); w && ((w.contentDOM || w.dom).appendChild(h), h = w.dom) } return h } serializeMark(s, l, h = {}) { let y = this.marks[s.type.name]; return y && qe.renderSpec(fe(h), y(s, l)) } static renderSpec(s, l, h = null) { if ("string" == typeof l) return { dom: s.createTextNode(l) }; if (null != l.nodeType) return { dom: l }; if (l.dom && null != l.dom.nodeType) return l; let y = l[0], w = y.indexOf(" "); w > 0 && (h = y.slice(0, w), y = y.slice(w + 1)); let I, k = h ? s.createElementNS(h, y) : s.createElement(y), H = l[1], te = 1; if (H && "object" == typeof H && null == H.nodeType && !Array.isArray(H)) { te = 2; for (let se in H) if (null != H[se]) { let Ge = se.indexOf(" "); Ge > 0 ? k.setAttributeNS(se.slice(0, Ge), se.slice(Ge + 1), H[se]) : k.setAttribute(se, H[se]) } } for (let se = te; se < l.length; se++) { let Ge = l[se]; if (0 === Ge) { if (se < l.length - 1 || se > te) throw new RangeError("Content hole must be the only child of its parent node"); return { dom: k, contentDOM: k } } { let { dom: at, contentDOM: ut } = qe.renderSpec(s, Ge, h); if (k.appendChild(at), ut) { if (I) throw new RangeError("Multiple content holes"); I = ut } } } return { dom: k, contentDOM: I } } static fromSchema(s) { return s.cached.domSerializer || (s.cached.domSerializer = new qe(this.nodesFromSchema(s), this.marksFromSchema(s))) } static nodesFromSchema(s) { let l = Zt(s.nodes); return l.text || (l.text = h => h.text), l } static marksFromSchema(s) { return Zt(s.marks) } } function Zt(f) { let s = {}; for (let l in f) { let h = f[l].spec.toDOM; h && (s[l] = h) } return s } function fe(f) { return f.document || window.document } const et = Math.pow(2, 16); function Lt(f, s) { return f + s * et } function mt(f) { return 65535 & f } class Ye { constructor(s, l, h) { this.pos = s, this.delInfo = l, this.recover = h } get deleted() { return (8 & this.delInfo) > 0 } get deletedBefore() { return (5 & this.delInfo) > 0 } get deletedAfter() { return (6 & this.delInfo) > 0 } get deletedAcross() { return (4 & this.delInfo) > 0 } } class Ie { constructor(s, l = !1) { if (this.ranges = s, this.inverted = l, !s.length && Ie.empty) return Ie.empty } recover(s) { let l = 0, h = mt(s); if (!this.inverted) for (let y = 0; y < h; y++)l += this.ranges[3 * y + 2] - this.ranges[3 * y + 1]; return this.ranges[3 * h] + l + function An(f) { return (f - (65535 & f)) / et }(s) } mapResult(s, l = 1) { return this._map(s, l, !1) } map(s, l = 1) { return this._map(s, l, !0) } _map(s, l, h) { let y = 0, w = this.inverted ? 2 : 1, I = this.inverted ? 1 : 2; for (let k = 0; k < this.ranges.length; k += 3) { let H = this.ranges[k] - (this.inverted ? y : 0); if (H > s) break; let te = this.ranges[k + w], se = this.ranges[k + I], Ge = H + te; if (s <= Ge) { let ut = H + y + ((te ? s == H ? -1 : s == Ge ? 1 : l : l) < 0 ? 0 : se); if (h) return ut; let $t = s == (l < 0 ? H : Ge) ? null : Lt(k / 3, s - H), Dn = s == H ? 2 : s == Ge ? 1 : 4; return (l < 0 ? s != H : s != Ge) && (Dn |= 8), new Ye(ut, Dn, $t) } y += se - te } return h ? s + y : new Ye(s + y, 0, null) } touches(s, l) { let h = 0, y = mt(l), w = this.inverted ? 2 : 1, I = this.inverted ? 1 : 2; for (let k = 0; k < this.ranges.length; k += 3) { let H = this.ranges[k] - (this.inverted ? h : 0); if (H > s) break; let te = this.ranges[k + w]; if (s <= H + te && k == 3 * y) return !0; h += this.ranges[k + I] - te } return !1 } forEach(s) { let l = this.inverted ? 2 : 1, h = this.inverted ? 1 : 2; for (let y = 0, w = 0; y < this.ranges.length; y += 3) { let I = this.ranges[y], k = I - (this.inverted ? w : 0), H = I + (this.inverted ? 0 : w), te = this.ranges[y + l], se = this.ranges[y + h]; s(k, k + te, H, H + se), w += se - te } } invert() { return new Ie(this.ranges, !this.inverted) } toString() { return (this.inverted ? "-" : "") + JSON.stringify(this.ranges) } static offset(s) { return 0 == s ? Ie.empty : new Ie(s < 0 ? [0, -s, 0] : [0, 0, s]) } } Ie.empty = new Ie([]); class Ct { constructor(s = [], l, h = 0, y = s.length) { this.maps = s, this.mirror = l, this.from = h, this.to = y } slice(s = 0, l = this.maps.length) { return new Ct(this.maps, this.mirror, s, l) } copy() { return new Ct(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to) } appendMap(s, l) { this.to = this.maps.push(s), null != l && this.setMirror(this.maps.length - 1, l) } appendMapping(s) { for (let l = 0, h = this.maps.length; l < s.maps.length; l++) { let y = s.getMirror(l); this.appendMap(s.maps[l], null != y && y < l ? h + y : void 0) } } getMirror(s) { if (this.mirror) for (let l = 0; l < this.mirror.length; l++)if (this.mirror[l] == s) return this.mirror[l + (l % 2 ? -1 : 1)] } setMirror(s, l) { this.mirror || (this.mirror = []), this.mirror.push(s, l) } appendMappingInverted(s) { for (let l = s.maps.length - 1, h = this.maps.length + s.maps.length; l >= 0; l--) { let y = s.getMirror(l); this.appendMap(s.maps[l].invert(), null != y && y > l ? h - y - 1 : void 0) } } invert() { let s = new Ct; return s.appendMappingInverted(this), s } map(s, l = 1) { if (this.mirror) return this._map(s, l, !0); for (let h = this.from; h < this.to; h++)s = this.maps[h].map(s, l); return s } mapResult(s, l = 1) { return this._map(s, l, !1) } _map(s, l, h) { let y = 0; for (let w = this.from; w < this.to; w++) { let k = this.maps[w].mapResult(s, l); if (null != k.recover) { let H = this.getMirror(w); if (null != H && H > w && H < this.to) { w = H, s = this.maps[H].recover(k.recover); continue } } y |= k.delInfo, s = k.pos } return h ? s : new Ye(s, y, null) } } const nn = Object.create(null); class xn { getMap() { return Ie.empty } merge(s) { return null } static fromJSON(s, l) { if (!l || !l.stepType) throw new RangeError("Invalid input for Step.fromJSON"); let h = nn[l.stepType]; if (!h) throw new RangeError(`No step type ${l.stepType} defined`); return h.fromJSON(s, l) } static jsonID(s, l) { if (s in nn) throw new RangeError("Duplicate use of step JSON ID " + s); return nn[s] = l, l.prototype.jsonID = s, l } } class zn { constructor(s, l) { this.doc = s, this.failed = l } static ok(s) { return new zn(s, null) } static fail(s) { return new zn(null, s) } static fromReplace(s, l, h, y) { try { return zn.ok(s.replace(l, h, y)) } catch (w) { if (w instanceof _t) return zn.fail(w.message); throw w } } } function ti(f, s, l) { let h = []; for (let y = 0; y < f.childCount; y++) { let w = f.child(y); w.content.size && (w = w.copy(ti(w.content, s, w))), w.isInline && (w = s(w, l, y)), h.push(w) } return Se.fromArray(h) } class Br extends xn { constructor(s, l, h) { super(), this.from = s, this.to = l, this.mark = h } apply(s) { let l = s.slice(this.from, this.to), h = s.resolve(this.from), y = h.node(h.sharedDepth(this.to)), w = new Qe(ti(l.content, (I, k) => I.isAtom && k.type.allowsMarkType(this.mark.type) ? I.mark(this.mark.addToSet(I.marks)) : I, y), l.openStart, l.openEnd); return zn.fromReplace(s, this.from, this.to, w) } invert() { return new ss(this.from, this.to, this.mark) } map(s) { let l = s.mapResult(this.from, 1), h = s.mapResult(this.to, -1); return l.deleted && h.deleted || l.pos >= h.pos ? null : new Br(l.pos, h.pos, this.mark) } merge(s) { return s instanceof Br && s.mark.eq(this.mark) && this.from <= s.to && this.to >= s.from ? new Br(Math.min(this.from, s.from), Math.max(this.to, s.to), this.mark) : null } toJSON() { return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(s, l) { if ("number" != typeof l.from || "number" != typeof l.to) throw new RangeError("Invalid input for AddMarkStep.fromJSON"); return new Br(l.from, l.to, s.markFromJSON(l.mark)) } } xn.jsonID("addMark", Br); class ss extends xn { constructor(s, l, h) { super(), this.from = s, this.to = l, this.mark = h } apply(s) { let l = s.slice(this.from, this.to), h = new Qe(ti(l.content, y => y.mark(this.mark.removeFromSet(y.marks)), s), l.openStart, l.openEnd); return zn.fromReplace(s, this.from, this.to, h) } invert() { return new Br(this.from, this.to, this.mark) } map(s) { let l = s.mapResult(this.from, 1), h = s.mapResult(this.to, -1); return l.deleted && h.deleted || l.pos >= h.pos ? null : new ss(l.pos, h.pos, this.mark) } merge(s) { return s instanceof ss && s.mark.eq(this.mark) && this.from <= s.to && this.to >= s.from ? new ss(Math.min(this.from, s.from), Math.max(this.to, s.to), this.mark) : null } toJSON() { return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(s, l) { if ("number" != typeof l.from || "number" != typeof l.to) throw new RangeError("Invalid input for RemoveMarkStep.fromJSON"); return new ss(l.from, l.to, s.markFromJSON(l.mark)) } } xn.jsonID("removeMark", ss); class Ps extends xn { constructor(s, l) { super(), this.pos = s, this.mark = l } apply(s) { let l = s.nodeAt(this.pos); if (!l) return zn.fail("No node at mark step's position"); let h = l.type.create(l.attrs, null, this.mark.addToSet(l.marks)); return zn.fromReplace(s, this.pos, this.pos + 1, new Qe(Se.from(h), 0, l.isLeaf ? 0 : 1)) } invert(s) { let l = s.nodeAt(this.pos); if (l) { let h = this.mark.addToSet(l.marks); if (h.length == l.marks.length) { for (let y = 0; y < l.marks.length; y++)if (!l.marks[y].isInSet(h)) return new Ps(this.pos, l.marks[y]); return new Ps(this.pos, this.mark) } } return new vo(this.pos, this.mark) } map(s) { let l = s.mapResult(this.pos, 1); return l.deletedAfter ? null : new Ps(l.pos, this.mark) } toJSON() { return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(s, l) { if ("number" != typeof l.pos) throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON"); return new Ps(l.pos, s.markFromJSON(l.mark)) } } xn.jsonID("addNodeMark", Ps); class vo extends xn { constructor(s, l) { super(), this.pos = s, this.mark = l } apply(s) { let l = s.nodeAt(this.pos); if (!l) return zn.fail("No node at mark step's position"); let h = l.type.create(l.attrs, null, this.mark.removeFromSet(l.marks)); return zn.fromReplace(s, this.pos, this.pos + 1, new Qe(Se.from(h), 0, l.isLeaf ? 0 : 1)) } invert(s) { let l = s.nodeAt(this.pos); return l && this.mark.isInSet(l.marks) ? new Ps(this.pos, this.mark) : this } map(s) { let l = s.mapResult(this.pos, 1); return l.deletedAfter ? null : new vo(l.pos, this.mark) } toJSON() { return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(s, l) { if ("number" != typeof l.pos) throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON"); return new vo(l.pos, s.markFromJSON(l.mark)) } } xn.jsonID("removeNodeMark", vo); class Dr extends xn { constructor(s, l, h, y = !1) { super(), this.from = s, this.to = l, this.slice = h, this.structure = y } apply(s) { return this.structure && _a(s, this.from, this.to) ? zn.fail("Structure replace would overwrite content") : zn.fromReplace(s, this.from, this.to, this.slice) } getMap() { return new Ie([this.from, this.to - this.from, this.slice.size]) } invert(s) { return new Dr(this.from, this.from + this.slice.size, s.slice(this.from, this.to)) } map(s) { let l = s.mapResult(this.from, 1), h = s.mapResult(this.to, -1); return l.deletedAcross && h.deletedAcross ? null : new Dr(l.pos, Math.max(l.pos, h.pos), this.slice) } merge(s) { if (!(s instanceof Dr) || s.structure || this.structure) return null; if (this.from + this.slice.size != s.from || this.slice.openEnd || s.slice.openStart) { if (s.to != this.from || this.slice.openStart || s.slice.openEnd) return null; { let l = this.slice.size + s.slice.size == 0 ? Qe.empty : new Qe(s.slice.content.append(this.slice.content), s.slice.openStart, this.slice.openEnd); return new Dr(s.from, this.to, l, this.structure) } } { let l = this.slice.size + s.slice.size == 0 ? Qe.empty : new Qe(this.slice.content.append(s.slice.content), this.slice.openStart, s.slice.openEnd); return new Dr(this.from, this.to + (s.to - s.from), l, this.structure) } } toJSON() { let s = { stepType: "replace", from: this.from, to: this.to }; return this.slice.size && (s.slice = this.slice.toJSON()), this.structure && (s.structure = !0), s } static fromJSON(s, l) { if ("number" != typeof l.from || "number" != typeof l.to) throw new RangeError("Invalid input for ReplaceStep.fromJSON"); return new Dr(l.from, l.to, Qe.fromJSON(s, l.slice), !!l.structure) } } xn.jsonID("replace", Dr); class Bi extends xn { constructor(s, l, h, y, w, I, k = !1) { super(), this.from = s, this.to = l, this.gapFrom = h, this.gapTo = y, this.slice = w, this.insert = I, this.structure = k } apply(s) { if (this.structure && (_a(s, this.from, this.gapFrom) || _a(s, this.gapTo, this.to))) return zn.fail("Structure gap-replace would overwrite content"); let l = s.slice(this.gapFrom, this.gapTo); if (l.openStart || l.openEnd) return zn.fail("Gap is not a flat range"); let h = this.slice.insertAt(this.insert, l.content); return h ? zn.fromReplace(s, this.from, this.to, h) : zn.fail("Content does not fit in gap") } getMap() { return new Ie([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]) } invert(s) { let l = this.gapTo - this.gapFrom; return new Bi(this.from, this.from + this.slice.size + l, this.from + this.insert, this.from + this.insert + l, s.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure) } map(s) { let l = s.mapResult(this.from, 1), h = s.mapResult(this.to, -1), y = s.map(this.gapFrom, -1), w = s.map(this.gapTo, 1); return l.deletedAcross && h.deletedAcross || y < l.pos || w > h.pos ? null : new Bi(l.pos, h.pos, y, w, this.slice, this.insert, this.structure) } toJSON() { let s = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert }; return this.slice.size && (s.slice = this.slice.toJSON()), this.structure && (s.structure = !0), s } static fromJSON(s, l) { if ("number" != typeof l.from || "number" != typeof l.to || "number" != typeof l.gapFrom || "number" != typeof l.gapTo || "number" != typeof l.insert) throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON"); return new Bi(l.from, l.to, l.gapFrom, l.gapTo, Qe.fromJSON(s, l.slice), l.insert, !!l.structure) } } function _a(f, s, l) { let h = f.resolve(s), y = l - s, w = h.depth; for (; y > 0 && w > 0 && h.indexAfter(w) == h.node(w).childCount;)w--, y--; if (y > 0) { let I = h.node(w).maybeChild(h.indexAfter(w)); for (; y > 0;) { if (!I || I.isLeaf) return !0; I = I.firstChild, y-- } } return !1 } function Ji(f, s, l) { return (0 == s || f.canReplace(s, f.childCount)) && (l == f.childCount || f.canReplace(0, l)) } function Ei(f) { let l = f.parent.content.cutByIndex(f.startIndex, f.endIndex); for (let h = f.depth; ; --h) { let y = f.$from.node(h), w = f.$from.index(h), I = f.$to.indexAfter(h); if (h < f.depth && y.canReplace(w, I, l)) return h; if (0 == h || y.type.spec.isolating || !Ji(y, w, I)) break } return null } function Qi(f, s, l = null, h = f) { let y = function Ln(f, s) { let { parent: l, startIndex: h, endIndex: y } = f, w = l.contentMatchAt(h).findWrapping(s); return w && l.canReplaceWith(h, y, w.length ? w[0] : s) ? w : null }(f, s), w = y && function pr(f, s) { let { parent: l, startIndex: h, endIndex: y } = f, w = l.child(h), I = s.contentMatch.findWrapping(w.type); if (!I) return null; let H = (I.length ? I[I.length - 1] : s).contentMatch; for (let te = h; H && te < y; te++)H = H.matchType(l.child(te).type); return H && H.validEnd ? I : null }(h, s); return w ? y.map(Gs).concat({ type: s, attrs: l }).concat(w.map(Gs)) : null } function Gs(f) { return { type: f, attrs: null } } function _s(f, s, l = 1, h) { let y = f.resolve(s), w = y.depth - l, I = h && h[h.length - 1] || y.parent; if (w < 0 || y.parent.type.spec.isolating || !y.parent.canReplace(y.index(), y.parent.childCount) || !I.type.validContent(y.parent.content.cutByIndex(y.index(), y.parent.childCount))) return !1; for (let te = y.depth - 1, se = l - 2; te > w; te--, se--) { let Ge = y.node(te), at = y.index(te); if (Ge.type.spec.isolating) return !1; let ut = Ge.content.cutByIndex(at, Ge.childCount), $t = h && h[se] || Ge; if ($t != Ge && (ut = ut.replaceChild(0, $t.type.create($t.attrs))), !Ge.canReplace(at + 1, Ge.childCount) || !$t.type.validContent(ut)) return !1 } let k = y.indexAfter(w), H = h && h[0]; return y.node(w).canReplaceWith(k, k, H ? H.type : y.node(w + 1).type) } function Rs(f, s) { let l = f.resolve(s), h = l.index(); return function js(f, s) { return !(!f || !s || f.isLeaf || !f.canAppend(s)) }(l.nodeBefore, l.nodeAfter) && l.parent.canReplace(h, h + 1) } function Vi(f, s, l = s, h = Qe.empty) { if (s == l && !h.size) return null; let y = f.resolve(s), w = f.resolve(l); return ls(y, w, h) ? new Dr(s, l, h) : new Ho(y, w, h).fit() } function ls(f, s, l) { return !l.openStart && !l.openEnd && f.start() == s.start() && f.parent.canReplace(f.index(), s.index(), l.content) } xn.jsonID("replaceAround", Bi); class Ho { constructor(s, l, h) { this.$from = s, this.$to = l, this.unplaced = h, this.frontier = [], this.placed = Se.empty; for (let y = 0; y <= s.depth; y++) { let w = s.node(y); this.frontier.push({ type: w.type, match: w.contentMatchAt(s.indexAfter(y)) }) } for (let y = s.depth; y > 0; y--)this.placed = Se.from(s.node(y).copy(this.placed)) } get depth() { return this.frontier.length - 1 } fit() { for (; this.unplaced.size;) { let te = this.findFittable(); te ? this.placeNodes(te) : this.openMore() || this.dropNode() } let s = this.mustMoveInline(), l = this.placed.size - this.depth - this.$from.depth, h = this.$from, y = this.close(s < 0 ? this.$to : h.doc.resolve(s)); if (!y) return null; let w = this.placed, I = h.depth, k = y.depth; for (; I && k && 1 == w.childCount;)w = w.firstChild.content, I--, k--; let H = new Qe(w, I, k); return s > -1 ? new Bi(h.pos, s, this.$to.pos, this.$to.end(), H, l) : H.size || h.pos != this.$to.pos ? new Dr(h.pos, y.pos, H) : null } findFittable() { for (let s = 1; s <= 2; s++)for (let l = this.unplaced.openStart; l >= 0; l--) { let h, y = null; l ? (y = cs(this.unplaced.content, l - 1).firstChild, h = y.content) : h = this.unplaced.content; let w = h.firstChild; for (let I = this.depth; I >= 0; I--) { let te, { type: k, match: H } = this.frontier[I], se = null; if (1 == s && (w ? H.matchType(w.type) || (se = H.fillBefore(Se.from(w), !1)) : y && k.compatibleContent(y.type))) return { sliceDepth: l, frontierDepth: I, parent: y, inject: se }; if (2 == s && w && (te = H.findWrapping(w.type))) return { sliceDepth: l, frontierDepth: I, parent: y, wrap: te }; if (y && H.matchType(y.type)) break } } } openMore() { let { content: s, openStart: l, openEnd: h } = this.unplaced, y = cs(s, l); return !(!y.childCount || y.firstChild.isLeaf || (this.unplaced = new Qe(s, l + 1, Math.max(h, y.size + l >= s.size - h ? l + 1 : 0)), 0)) } dropNode() { let { content: s, openStart: l, openEnd: h } = this.unplaced, y = cs(s, l); if (y.childCount <= 1 && l > 0) { let w = s.size - l <= l + y.size; this.unplaced = new Qe(no(s, l - 1, 1), l - 1, w ? l - 1 : h) } else this.unplaced = new Qe(no(s, l, 1), l, h) } placeNodes({ sliceDepth: s, frontierDepth: l, parent: h, inject: y, wrap: w }) { for (; this.depth > l;)this.closeFrontierNode(); if (w) for (let Dn = 0; Dn < w.length; Dn++)this.openFrontierNode(w[Dn]); let I = this.unplaced, k = h ? h.content : I.content, H = I.openStart - s, te = 0, se = [], { match: Ge, type: at } = this.frontier[l]; if (y) { for (let Dn = 0; Dn < y.childCount; Dn++)se.push(y.child(Dn)); Ge = Ge.matchFragment(y) } let ut = k.size + s - (I.content.size - I.openEnd); for (; te < k.childCount;) { let Dn = k.child(te), $n = Ge.matchType(Dn.type); if (!$n) break; te++, (te > 1 || 0 == H || Dn.content.size) && (Ge = $n, se.push(ro(Dn.mark(at.allowedMarks(Dn.marks)), 1 == te ? H : 0, te == k.childCount ? ut : -1))) } let $t = te == k.childCount; $t || (ut = -1), this.placed = Fs(this.placed, l, Se.from(se)), this.frontier[l].match = Ge, $t && ut < 0 && h && h.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode(); for (let Dn = 0, $n = k; Dn < ut; Dn++) { let fi = $n.lastChild; this.frontier.push({ type: fi.type, match: fi.contentMatchAt(fi.childCount) }), $n = fi.content } this.unplaced = $t ? 0 == s ? Qe.empty : new Qe(no(I.content, s - 1, 1), s - 1, ut < 0 ? I.openEnd : s - 1) : new Qe(no(I.content, s, te), I.openStart, I.openEnd) } mustMoveInline() { if (!this.$to.parent.isTextblock) return -1; let l, s = this.frontier[this.depth]; if (!s.type.isTextblock || !ft(this.$to, this.$to.depth, s.type, s.match, !1) || this.$to.depth == this.depth && (l = this.findCloseLevel(this.$to)) && l.depth == this.depth) return -1; let { depth: h } = this.$to, y = this.$to.after(h); for (; h > 1 && y == this.$to.end(--h);)++y; return y } findCloseLevel(s) { e: for (let l = Math.min(this.depth, s.depth); l >= 0; l--) { let { match: h, type: y } = this.frontier[l], w = l < s.depth && s.end(l + 1) == s.pos + (s.depth - (l + 1)), I = ft(s, l, y, h, w); if (I) { for (let k = l - 1; k >= 0; k--) { let { match: H, type: te } = this.frontier[k], se = ft(s, k, te, H, !0); if (!se || se.childCount) continue e } return { depth: l, fit: I, move: w ? s.doc.resolve(s.after(l + 1)) : s } } } } close(s) { let l = this.findCloseLevel(s); if (!l) return null; for (; this.depth > l.depth;)this.closeFrontierNode(); l.fit.childCount && (this.placed = Fs(this.placed, l.depth, l.fit)), s = l.move; for (let h = l.depth + 1; h <= s.depth; h++) { let y = s.node(h), w = y.type.contentMatch.fillBefore(y.content, !0, s.index(h)); this.openFrontierNode(y.type, y.attrs, w) } return s } openFrontierNode(s, l = null, h) { let y = this.frontier[this.depth]; y.match = y.match.matchType(s), this.placed = Fs(this.placed, this.depth, Se.from(s.create(l, h))), this.frontier.push({ type: s, match: s.contentMatch }) } closeFrontierNode() { let l = this.frontier.pop().match.fillBefore(Se.empty, !0); l.childCount && (this.placed = Fs(this.placed, this.frontier.length, l)) } } function no(f, s, l) { return 0 == s ? f.cutByIndex(l, f.childCount) : f.replaceChild(0, f.firstChild.copy(no(f.firstChild.content, s - 1, l))) } function Fs(f, s, l) { return 0 == s ? f.append(l) : f.replaceChild(f.childCount - 1, f.lastChild.copy(Fs(f.lastChild.content, s - 1, l))) } function cs(f, s) { for (let l = 0; l < s; l++)f = f.firstChild.content; return f } function ro(f, s, l) { if (s <= 0) return f; let h = f.content; return s > 1 && (h = h.replaceChild(0, ro(h.firstChild, s - 1, 1 == h.childCount ? l - 1 : 0))), s > 0 && (h = f.type.contentMatch.fillBefore(h).append(h), l <= 0 && (h = h.append(f.type.contentMatch.matchFragment(h).fillBefore(Se.empty, !0)))), f.copy(h) } function ft(f, s, l, h, y) { let w = f.node(s), I = y ? f.indexAfter(s) : f.index(s); if (I == w.childCount && !l.compatibleContent(w.type)) return null; let k = h.fillBefore(w.content, !0, I); return k && !function dt(f, s, l) { for (let h = l; h < s.childCount; h++)if (!f.allowsMarks(s.child(h).marks)) return !0; return !1 }(l, w.content, I) ? k : null } function Mt(f) { return f.spec.defining || f.spec.definingForContent } function Sn(f, s, l, h, y) { if (s < l) { let w = f.firstChild; f = f.replaceChild(0, w.copy(Sn(w.content, s + 1, l, h, w))) } if (s > h) { let w = y.contentMatchAt(0), I = w.fillBefore(f).append(f); f = I.append(w.matchFragment(I).fillBefore(Se.empty, !0)) } return f } function wr(f, s) { let l = []; for (let y = Math.min(f.depth, s.depth); y >= 0; y--) { let w = f.start(y); if (w < f.pos - (f.depth - y) || s.end(y) > s.pos + (s.depth - y) || f.node(y).type.spec.isolating || s.node(y).type.spec.isolating) break; (w == s.start(y) || y == f.depth && y == s.depth && f.parent.inlineContent && s.parent.inlineContent && y && s.start(y - 1) == w - 1) && l.push(y) } return l } class Vr extends xn { constructor(s, l, h) { super(), this.pos = s, this.attr = l, this.value = h } apply(s) { let l = s.nodeAt(this.pos); if (!l) return zn.fail("No node at attribute step's position"); let h = Object.create(null); for (let w in l.attrs) h[w] = l.attrs[w]; h[this.attr] = this.value; let y = l.type.create(h, null, l.marks); return zn.fromReplace(s, this.pos, this.pos + 1, new Qe(Se.from(y), 0, l.isLeaf ? 0 : 1)) } getMap() { return Ie.empty } invert(s) { return new Vr(this.pos, this.attr, s.nodeAt(this.pos).attrs[this.attr]) } map(s) { let l = s.mapResult(this.pos, 1); return l.deletedAfter ? null : new Vr(l.pos, this.attr, this.value) } toJSON() { return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value } } static fromJSON(s, l) { if ("number" != typeof l.pos || "string" != typeof l.attr) throw new RangeError("Invalid input for AttrStep.fromJSON"); return new Vr(l.pos, l.attr, l.value) } } xn.jsonID("attr", Vr); let Ai = class extends Error { }; Ai = function f(s) { let l = Error.call(this, s); return l.__proto__ = f.prototype, l }, (Ai.prototype = Object.create(Error.prototype)).constructor = Ai, Ai.prototype.name = "TransformError"; class Ts { constructor(s) { this.doc = s, this.steps = [], this.docs = [], this.mapping = new Ct } get before() { return this.docs.length ? this.docs[0] : this.doc } step(s) { let l = this.maybeStep(s); if (l.failed) throw new Ai(l.failed); return this } maybeStep(s) { let l = s.apply(this.doc); return l.failed || this.addStep(s, l.doc), l } get docChanged() { return this.steps.length > 0 } addStep(s, l) { this.docs.push(this.doc), this.steps.push(s), this.mapping.appendMap(s.getMap()), this.doc = l } replace(s, l = s, h = Qe.empty) { let y = Vi(this.doc, s, l, h); return y && this.step(y), this } replaceWith(s, l, h) { return this.replace(s, l, new Qe(Se.from(h), 0, 0)) } delete(s, l) { return this.replace(s, l, Qe.empty) } insert(s, l) { return this.replaceWith(s, s, l) } replaceRange(s, l, h) { return function hn(f, s, l, h) { if (!h.size) return f.deleteRange(s, l); let y = f.doc.resolve(s), w = f.doc.resolve(l); if (ls(y, w, h)) return f.step(new Dr(s, l, h)); let I = wr(y, f.doc.resolve(l)); 0 == I[I.length - 1] && I.pop(); let k = -(y.depth + 1); I.unshift(k); for (let at = y.depth, ut = y.pos - 1; at > 0; at--, ut--) { let $t = y.node(at).type.spec; if ($t.defining || $t.definingAsContext || $t.isolating) break; I.indexOf(at) > -1 ? k = at : y.before(at) == ut && I.splice(1, 0, -at) } let H = I.indexOf(k), te = [], se = h.openStart; for (let at = h.content, ut = 0; ; ut++) { let $t = at.firstChild; if (te.push($t), ut == h.openStart) break; at = $t.content } for (let at = se - 1; at >= 0; at--) { let ut = te[at].type, $t = Mt(ut); if ($t && y.node(H).type != ut) se = at; else if ($t || !ut.isTextblock) break } for (let at = h.openStart; at >= 0; at--) { let ut = (at + se + 1) % (h.openStart + 1), $t = te[ut]; if ($t) for (let Dn = 0; Dn < I.length; Dn++) { let $n = I[(Dn + H) % I.length], fi = !0; $n < 0 && (fi = !1, $n = -$n); let uu = y.node($n - 1), za = y.index($n - 1); if (uu.canReplaceWith(za, za, $t.type, $t.marks)) return f.replace(y.before($n), fi ? w.after($n) : l, new Qe(Sn(h.content, 0, h.openStart, ut), ut, h.openEnd)) } } let Ge = f.steps.length; for (let at = I.length - 1; at >= 0 && (f.replace(s, l, h), !(f.steps.length > Ge)); at--) { let ut = I[at]; ut < 0 || (s = y.before(ut), l = w.after(ut)) } }(this, s, l, h), this } replaceRangeWith(s, l, h) { return function Yn(f, s, l, h) { if (!h.isInline && s == l && f.doc.resolve(s).parent.content.size) { let y = function So(f, s, l) { let h = f.resolve(s); if (h.parent.canReplaceWith(h.index(), h.index(), l)) return s; if (0 == h.parentOffset) for (let y = h.depth - 1; y >= 0; y--) { let w = h.index(y); if (h.node(y).canReplaceWith(w, w, l)) return h.before(y + 1); if (w > 0) return null } if (h.parentOffset == h.parent.content.size) for (let y = h.depth - 1; y >= 0; y--) { let w = h.indexAfter(y); if (h.node(y).canReplaceWith(w, w, l)) return h.after(y + 1); if (w < h.node(y).childCount) return null } return null }(f.doc, s, h.type); null != y && (s = l = y) } f.replaceRange(s, l, new Qe(Se.from(h), 0, 0)) }(this, s, l, h), this } deleteRange(s, l) { return function lr(f, s, l) { let h = f.doc.resolve(s), y = f.doc.resolve(l), w = wr(h, y); for (let I = 0; I < w.length; I++) { let k = w[I], H = I == w.length - 1; if (H && 0 == k || h.node(k).type.contentMatch.validEnd) return f.delete(h.start(k), y.end(k)); if (k > 0 && (H || h.node(k - 1).canReplace(h.index(k - 1), y.indexAfter(k - 1)))) return f.delete(h.before(k), y.after(k)) } for (let I = 1; I <= h.depth && I <= y.depth; I++)if (s - h.start(I) == h.depth - I && l > h.end(I) && y.end(I) - l != y.depth - I) return f.delete(h.before(I), l); f.delete(s, l) }(this, s, l), this } lift(s, l) { return function Gi(f, s, l) { let { $from: h, $to: y, depth: w } = s, I = h.before(w + 1), k = y.after(w + 1), H = I, te = k, se = Se.empty, Ge = 0; for (let $t = w, Dn = !1; $t > l; $t--)Dn || h.index($t) > 0 ? (Dn = !0, se = Se.from(h.node($t).copy(se)), Ge++) : H--; let at = Se.empty, ut = 0; for (let $t = w, Dn = !1; $t > l; $t--)Dn || y.after($t + 1) < y.end($t) ? (Dn = !0, at = Se.from(y.node($t).copy(at)), ut++) : te++; f.step(new Bi(H, te, I, k, new Qe(se.append(at), Ge, ut), se.size - Ge, !0)) }(this, s, l), this } join(s, l = 1) { return function ba(f, s, l) { let h = new Dr(s - l, s + l, Qe.empty, !0); f.step(h) }(this, s, l), this } wrap(s, l) { return function ni(f, s, l) { let h = Se.empty; for (let I = l.length - 1; I >= 0; I--) { if (h.size) { let k = l[I].type.contentMatch.matchFragment(h); if (!k || !k.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") } h = Se.from(l[I].type.create(l[I].attrs, h)) } let y = s.start, w = s.end; f.step(new Bi(y, w, y, w, new Qe(h, 0, 0), l.length, !0)) }(this, s, l), this } setBlockType(s, l = s, h, y = null) { return function as(f, s, l, h, y) { if (!h.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock"); let w = f.steps.length; f.doc.nodesBetween(s, l, (I, k) => { if (I.isTextblock && !I.hasMarkup(h, y) && function Xi(f, s, l) { let h = f.resolve(s), y = h.index(); return h.parent.canReplaceWith(y, y + 1, l) }(f.doc, f.mapping.slice(w).map(k), h)) { f.clearIncompatible(f.mapping.slice(w).map(k, 1), h); let H = f.mapping.slice(w), te = H.map(k, 1), se = H.map(k + I.nodeSize, 1); return f.step(new Bi(te, se, te + 1, se - 1, new Qe(Se.from(h.create(y, null, I.marks)), 0, 0), 1, !0)), !1 } }) }(this, s, l, h, y), this } setNodeMarkup(s, l, h = null, y = []) { return function Ti(f, s, l, h, y) { let w = f.doc.nodeAt(s); if (!w) throw new RangeError("No node at given position"); l || (l = w.type); let I = l.create(h, null, y || w.marks); if (w.isLeaf) return f.replaceWith(s, s + w.nodeSize, I); if (!l.validContent(w.content)) throw new RangeError("Invalid content for node type " + l.name); f.step(new Bi(s, s + w.nodeSize, s + 1, s + w.nodeSize - 1, new Qe(Se.from(I), 0, 0), 1, !0)) }(this, s, l, h, y), this } setNodeAttribute(s, l, h) { return this.step(new Vr(s, l, h)), this } addNodeMark(s, l) { return this.step(new Ps(s, l)), this } removeNodeMark(s, l) { if (!(l instanceof je)) { let h = this.doc.nodeAt(s); if (!h) throw new RangeError("No node at position " + s); if (!(l = l.isInSet(h.marks))) return this } return this.step(new vo(s, l)), this } split(s, l = 1, h) { return function Di(f, s, l = 1, h) { let y = f.doc.resolve(s), w = Se.empty, I = Se.empty; for (let k = y.depth, H = y.depth - l, te = l - 1; k > H; k--, te--) { w = Se.from(y.node(k).copy(w)); let se = h && h[te]; I = Se.from(se ? se.type.create(se.attrs, I) : y.node(k).copy(I)) } f.step(new Dr(s, s, new Qe(w.append(I), l, l), !0)) }(this, s, l, h), this } addMark(s, l, h) { return function ya(f, s, l, h) { let I, k, y = [], w = []; f.doc.nodesBetween(s, l, (H, te, se) => { if (!H.isInline) return; let Ge = H.marks; if (!h.isInSet(Ge) && se.type.allowsMarkType(h.type)) { let at = Math.max(te, s), ut = Math.min(te + H.nodeSize, l), $t = h.addToSet(Ge); for (let Dn = 0; Dn < Ge.length; Dn++)Ge[Dn].isInSet($t) || (I && I.to == at && I.mark.eq(Ge[Dn]) ? I.to = ut : y.push(I = new ss(at, ut, Ge[Dn]))); k && k.to == at ? k.to = ut : w.push(k = new Br(at, ut, h)) } }), y.forEach(H => f.step(H)), w.forEach(H => f.step(H)) }(this, s, l, h), this } removeMark(s, l, h) { return function va(f, s, l, h) { let y = [], w = 0; f.doc.nodesBetween(s, l, (I, k) => { if (!I.isInline) return; w++; let H = null; if (h instanceof _r) { let se, te = I.marks; for (; se = h.isInSet(te);)(H || (H = [])).push(se), te = se.removeFromSet(te) } else h ? h.isInSet(I.marks) && (H = [h]) : H = I.marks; if (H && H.length) { let te = Math.min(k + I.nodeSize, l); for (let se = 0; se < H.length; se++) { let at, Ge = H[se]; for (let ut = 0; ut < y.length; ut++) { let $t = y[ut]; $t.step == w - 1 && Ge.eq(y[ut].style) && (at = $t) } at ? (at.to = te, at.step = w) : y.push({ style: Ge, from: Math.max(k, s), to: te, step: w }) } } }), y.forEach(I => f.step(new ss(I.from, I.to, I.style))) }(this, s, l, h), this } clearIncompatible(s, l, h) { return function Hr(f, s, l, h = l.contentMatch) { let y = f.doc.nodeAt(s), w = [], I = s + 1; for (let k = 0; k < y.childCount; k++) { let H = y.child(k), te = I + H.nodeSize, se = h.matchType(H.type); if (se) { h = se; for (let Ge = 0; Ge < H.marks.length; Ge++)l.allowsMarkType(H.marks[Ge].type) || f.step(new ss(I, te, H.marks[Ge])) } else w.push(new Dr(I, te, Qe.empty)); I = te } if (!h.validEnd) { let k = h.fillBefore(Se.empty, !0); f.replace(I, I, new Qe(k, 0, 0)) } for (let k = w.length - 1; k >= 0; k--)f.step(w[k]) }(this, s, l, h), this } } const Ds = Object.create(null); class gr { constructor(s, l, h) { this.$anchor = s, this.$head = l, this.ranges = h || [new xl(s.min(l), s.max(l))] } get anchor() { return this.$anchor.pos } get head() { return this.$head.pos } get from() { return this.$from.pos } get to() { return this.$to.pos } get $from() { return this.ranges[0].$from } get $to() { return this.ranges[0].$to } get empty() { let s = this.ranges; for (let l = 0; l < s.length; l++)if (s[l].$from.pos != s[l].$to.pos) return !1; return !0 } content() { return this.$from.doc.slice(this.from, this.to, !0) } replace(s, l = Qe.empty) { let h = l.content.lastChild, y = null; for (let k = 0; k < l.openEnd; k++)y = h, h = h.lastChild; let w = s.steps.length, I = this.ranges; for (let k = 0; k < I.length; k++) { let { $from: H, $to: te } = I[k], se = s.mapping.slice(w); s.replaceRange(se.map(H.pos), se.map(te.pos), k ? Qe.empty : l), 0 == k && Wl(s, w, (h ? h.isInline : y && y.isTextblock) ? -1 : 1) } } replaceWith(s, l) { let h = s.steps.length, y = this.ranges; for (let w = 0; w < y.length; w++) { let { $from: I, $to: k } = y[w], H = s.mapping.slice(h), te = H.map(I.pos), se = H.map(k.pos); w ? s.deleteRange(te, se) : (s.replaceRangeWith(te, se, l), Wl(s, h, l.isInline ? -1 : 1)) } } static findFrom(s, l, h = !1) { let y = s.parent.inlineContent ? new Jr(s) : io(s.node(0), s.parent, s.pos, s.index(), l, h); if (y) return y; for (let w = s.depth - 1; w >= 0; w--) { let I = l < 0 ? io(s.node(0), s.node(w), s.before(w + 1), s.index(w), l, h) : io(s.node(0), s.node(w), s.after(w + 1), s.index(w) + 1, l, h); if (I) return I } return null } static near(s, l = 1) { return this.findFrom(s, l) || this.findFrom(s, -l) || new Si(s.node(0)) } static atStart(s) { return io(s, s, 0, 0, 1) || new Si(s) } static atEnd(s) { return io(s, s, s.content.size, s.childCount, -1) || new Si(s) } static fromJSON(s, l) { if (!l || !l.type) throw new RangeError("Invalid input for Selection.fromJSON"); let h = Ds[l.type]; if (!h) throw new RangeError(`No selection type ${l.type} defined`); return h.fromJSON(s, l) } static jsonID(s, l) { if (s in Ds) throw new RangeError("Duplicate use of selection JSON ID " + s); return Ds[s] = l, l.prototype.jsonID = s, l } getBookmark() { return Jr.between(this.$anchor, this.$head).getBookmark() } } gr.prototype.visible = !0; class xl { constructor(s, l) { this.$from = s, this.$to = l } } let us = !1; function bo(f) { !us && !f.parent.inlineContent && (us = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + f.parent.type.name + ")")) } class Jr extends gr { constructor(s, l = s) { bo(s), bo(l), super(s, l) } get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null } map(s, l) { let h = s.resolve(l.map(this.head)); if (!h.parent.inlineContent) return gr.near(h); let y = s.resolve(l.map(this.anchor)); return new Jr(y.parent.inlineContent ? y : h, h) } replace(s, l = Qe.empty) { if (super.replace(s, l), l == Qe.empty) { let h = this.$from.marksAcross(this.$to); h && s.ensureMarks(h) } } eq(s) { return s instanceof Jr && s.anchor == this.anchor && s.head == this.head } getBookmark() { return new Io(this.anchor, this.head) } toJSON() { return { type: "text", anchor: this.anchor, head: this.head } } static fromJSON(s, l) { if ("number" != typeof l.anchor || "number" != typeof l.head) throw new RangeError("Invalid input for TextSelection.fromJSON"); return new Jr(s.resolve(l.anchor), s.resolve(l.head)) } static create(s, l, h = l) { let y = s.resolve(l); return new this(y, h == l ? y : s.resolve(h)) } static between(s, l, h) { let y = s.pos - l.pos; if ((!h || y) && (h = y >= 0 ? 1 : -1), !l.parent.inlineContent) { let w = gr.findFrom(l, h, !0) || gr.findFrom(l, -h, !0); if (!w) return gr.near(l, h); l = w.$head } return s.parent.inlineContent || (0 == y || (s = (gr.findFrom(s, -h, !0) || gr.findFrom(s, h, !0)).$anchor).pos < l.pos != y < 0) && (s = l), new Jr(s, l) } } gr.jsonID("text", Jr); class Io { constructor(s, l) { this.anchor = s, this.head = l } map(s) { return new Io(s.map(this.anchor), s.map(this.head)) } resolve(s) { return Jr.between(s.resolve(this.anchor), s.resolve(this.head)) } } class Xn extends gr { constructor(s) { let l = s.nodeAfter, h = s.node(0).resolve(s.pos + l.nodeSize); super(s, h), this.node = l } map(s, l) { let { deleted: h, pos: y } = l.mapResult(this.anchor), w = s.resolve(y); return h ? gr.near(w) : new Xn(w) } content() { return new Qe(Se.from(this.node), 0, 0) } eq(s) { return s instanceof Xn && s.anchor == this.anchor } toJSON() { return { type: "node", anchor: this.anchor } } getBookmark() { return new uo(this.anchor) } static fromJSON(s, l) { if ("number" != typeof l.anchor) throw new RangeError("Invalid input for NodeSelection.fromJSON"); return new Xn(s.resolve(l.anchor)) } static create(s, l) { return new Xn(s.resolve(l)) } static isSelectable(s) { return !s.isText && !1 !== s.type.spec.selectable } } Xn.prototype.visible = !1, gr.jsonID("node", Xn); class uo { constructor(s) { this.anchor = s } map(s) { let { deleted: l, pos: h } = s.mapResult(this.anchor); return l ? new Io(h, h) : new uo(h) } resolve(s) { let l = s.resolve(this.anchor), h = l.nodeAfter; return h && Xn.isSelectable(h) ? new Xn(l) : gr.near(l) } } class Si extends gr { constructor(s) { super(s.resolve(0), s.resolve(s.content.size)) } replace(s, l = Qe.empty) { if (l == Qe.empty) { s.delete(0, s.doc.content.size); let h = gr.atStart(s.doc); h.eq(s.selection) || s.setSelection(h) } else super.replace(s, l) } toJSON() { return { type: "all" } } static fromJSON(s) { return new Si(s) } map(s) { return new Si(s) } eq(s) { return s instanceof Si } getBookmark() { return ka } } gr.jsonID("all", Si); const ka = { map() { return this }, resolve: f => new Si(f) }; function io(f, s, l, h, y, w = !1) { if (s.inlineContent) return Jr.create(f, l); for (let I = h - (y > 0 ? 0 : 1); y > 0 ? I < s.childCount : I >= 0; I += y) { let k = s.child(I); if (k.isAtom) { if (!w && Xn.isSelectable(k)) return Xn.create(f, l - (y < 0 ? k.nodeSize : 0)) } else { let H = io(f, k, l + y, y < 0 ? k.childCount : 0, y, w); if (H) return H } l += k.nodeSize * y } return null } function Wl(f, s, l) { let h = f.steps.length - 1; if (h < s) return; let I, y = f.steps[h]; (y instanceof Dr || y instanceof Bi) && (f.mapping.maps[h].forEach((k, H, te, se) => { null == I && (I = se) }), f.setSelection(gr.near(f.doc.resolve(I), l))) } class so extends Ts { constructor(s) { super(s.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = Object.create(null), this.time = Date.now(), this.curSelection = s.selection, this.storedMarks = s.storedMarks } get selection() { return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection } setSelection(s) { if (s.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document"); return this.curSelection = s, this.curSelectionFor = this.steps.length, this.updated = -3 & (1 | this.updated), this.storedMarks = null, this } get selectionSet() { return (1 & this.updated) > 0 } setStoredMarks(s) { return this.storedMarks = s, this.updated |= 2, this } ensureMarks(s) { return je.sameSet(this.storedMarks || this.selection.$from.marks(), s) || this.setStoredMarks(s), this } addStoredMark(s) { return this.ensureMarks(s.addToSet(this.storedMarks || this.selection.$head.marks())) } removeStoredMark(s) { return this.ensureMarks(s.removeFromSet(this.storedMarks || this.selection.$head.marks())) } get storedMarksSet() { return (2 & this.updated) > 0 } addStep(s, l) { super.addStep(s, l), this.updated = -3 & this.updated, this.storedMarks = null } setTime(s) { return this.time = s, this } replaceSelection(s) { return this.selection.replace(this, s), this } replaceSelectionWith(s, l = !0) { let h = this.selection; return l && (s = s.mark(this.storedMarks || (h.empty ? h.$from.marks() : h.$from.marksAcross(h.$to) || je.none))), h.replaceWith(this, s), this } deleteSelection() { return this.selection.replace(this), this } insertText(s, l, h) { let y = this.doc.type.schema; if (null == l) return s ? this.replaceSelectionWith(y.text(s), !0) : this.deleteSelection(); { if (null == h && (h = l), h = h ?? l, !s) return this.deleteRange(l, h); let w = this.storedMarks; if (!w) { let I = this.doc.resolve(l); w = h == l ? I.marks() : I.marksAcross(this.doc.resolve(h)) } return this.replaceRangeWith(l, h, y.text(s, w)), this.selection.empty || this.setSelection(gr.near(this.selection.$to)), this } } setMeta(s, l) { return this.meta["string" == typeof s ? s : s.key] = l, this } getMeta(s) { return this.meta["string" == typeof s ? s : s.key] } get isGeneric() { for (let s in this.meta) return !1; return !0 } scrollIntoView() { return this.updated |= 4, this } get scrolledIntoView() { return (4 & this.updated) > 0 } } function jo(f, s) { return s && f ? f.bind(s) : f } class na { constructor(s, l, h) { this.name = s, this.init = jo(l.init, h), this.apply = jo(l.apply, h) } } const Zl = [new na("doc", { init: f => f.doc || f.schema.topNodeType.createAndFill(), apply: f => f.doc }), new na("selection", { init: (f, s) => f.selection || gr.atStart(s.doc), apply: f => f.selection }), new na("storedMarks", { init: f => f.storedMarks || null, apply: (f, s, l, h) => h.selection.$cursor ? f.storedMarks : null }), new na("scrollToSelection", { init: () => 0, apply: (f, s) => f.scrolledIntoView ? s + 1 : s })]; class pi { constructor(s, l) { this.schema = s, this.plugins = [], this.pluginsByKey = Object.create(null), this.fields = Zl.slice(), l && l.forEach(h => { if (this.pluginsByKey[h.key]) throw new RangeError("Adding different instances of a keyed plugin (" + h.key + ")"); this.plugins.push(h), this.pluginsByKey[h.key] = h, h.spec.state && this.fields.push(new na(h.key, h.spec.state, h)) }) } } class Ss { constructor(s) { this.config = s } get schema() { return this.config.schema } get plugins() { return this.config.plugins } apply(s) { return this.applyTransaction(s).state } filterTransaction(s, l = -1) { for (let h = 0; h < this.config.plugins.length; h++)if (h != l) { let y = this.config.plugins[h]; if (y.spec.filterTransaction && !y.spec.filterTransaction.call(y, s, this)) return !1 } return !0 } applyTransaction(s) { if (!this.filterTransaction(s)) return { state: this, transactions: [] }; let l = [s], h = this.applyInner(s), y = null; for (; ;) { let w = !1; for (let I = 0; I < this.config.plugins.length; I++) { let k = this.config.plugins[I]; if (k.spec.appendTransaction) { let H = y ? y[I].n : 0, te = y ? y[I].state : this, se = H < l.length && k.spec.appendTransaction.call(k, H ? l.slice(H) : l, te, h); if (se && h.filterTransaction(se, I)) { if (se.setMeta("appendedTransaction", s), !y) { y = []; for (let Ge = 0; Ge < this.config.plugins.length; Ge++)y.push(Ge < I ? { state: h, n: l.length } : { state: this, n: 0 }) } l.push(se), h = h.applyInner(se), w = !0 } y && (y[I] = { state: h, n: l.length }) } } if (!w) return { state: h, transactions: l } } } applyInner(s) { if (!s.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction"); let l = new Ss(this.config), h = this.config.fields; for (let y = 0; y < h.length; y++) { let w = h[y]; l[w.name] = w.apply(s, this[w.name], this, l) } return l } get tr() { return new so(this) } static create(s) { let l = new pi(s.doc ? s.doc.type.schema : s.schema, s.plugins), h = new Ss(l); for (let y = 0; y < l.fields.length; y++)h[l.fields[y].name] = l.fields[y].init(s, h); return h } reconfigure(s) { let l = new pi(this.schema, s.plugins), h = l.fields, y = new Ss(l); for (let w = 0; w < h.length; w++) { let I = h[w].name; y[I] = this.hasOwnProperty(I) ? this[I] : h[w].init(s, y) } return y } toJSON(s) { let l = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }; if (this.storedMarks && (l.storedMarks = this.storedMarks.map(h => h.toJSON())), s && "object" == typeof s) for (let h in s) { if ("doc" == h || "selection" == h) throw new RangeError("The JSON fields `doc` and `selection` are reserved"); let y = s[h], w = y.spec.state; w && w.toJSON && (l[h] = w.toJSON.call(y, this[y.key])) } return l } static fromJSON(s, l, h) { if (!l) throw new RangeError("Invalid input for EditorState.fromJSON"); if (!s.schema) throw new RangeError("Required config field 'schema' missing"); let y = new pi(s.schema, s.plugins), w = new Ss(y); return y.fields.forEach(I => { if ("doc" == I.name) w.doc = It.fromJSON(s.schema, l.doc); else if ("selection" == I.name) w.selection = gr.fromJSON(w.doc, l.selection); else if ("storedMarks" == I.name) l.storedMarks && (w.storedMarks = l.storedMarks.map(s.schema.markFromJSON)); else { if (h) for (let k in h) { let H = h[k], te = H.spec.state; if (H.key == I.name && te && te.fromJSON && Object.prototype.hasOwnProperty.call(l, k)) return void (w[I.name] = te.fromJSON.call(H, s, l[k], w)) } w[I.name] = I.init(s, w) } }), w } } function $o(f, s, l) { for (let h in f) { let y = f[h]; y instanceof Function ? y = y.bind(s) : "handleDOMEvents" == h && (y = $o(y, s, {})), l[h] = y } return l } class wo { constructor(s) { this.spec = s, this.props = {}, s.props && $o(s.props, this, this.props), this.key = s.key ? s.key.key : Ao("plugin") } getState(s) { return s[this.key] } } const ho = Object.create(null); function Ao(f) { return f in ho ? f + "$" + ++ho[f] : (ho[f] = 0, f + "$") } class rs { constructor(s = "key") { this.key = Ao(s) } get(s) { return s.config.pluginsByKey[this.key] } getState(s) { return s[this.key] } } const Is = function (f) { for (var s = 0; ; s++)if (!(f = f.previousSibling)) return s }, Wo = function (f) { let s = f.assignedSlot || f.parentNode; return s && 11 == s.nodeType ? s.host : s }; let Za = null; const fo = function (f, s, l) { let h = Za || (Za = document.createRange()); return h.setEnd(f, l ?? f.nodeValue.length), h.setStart(f, s || 0), h }, As = function (f, s, l, h) { return l && (Ks(f, s, l, h, -1) || Ks(f, s, l, h, 1)) }, Pa = /^(img|br|input|textarea|hr)$/i; function Ks(f, s, l, h, y) { for (; ;) { if (f == l && s == h) return !0; if (s == (y < 0 ? 0 : Ls(f))) { let w = f.parentNode; if (!w || 1 != w.nodeType || Ii(f) || Pa.test(f.nodeName) || "false" == f.contentEditable) return !1; s = Is(f) + (y < 0 ? 0 : 1), f = w } else { if (1 != f.nodeType) return !1; if ("false" == (f = f.childNodes[s + (y < 0 ? -1 : 0)]).contentEditable) return !1; s = y < 0 ? Ls(f) : 0 } } } function Ls(f) { return 3 == f.nodeType ? f.nodeValue.length : f.childNodes.length } function Ii(f) { let s; for (let l = f; l && !(s = l.pmViewDesc); l = l.parentNode); return s && s.node && s.node.isBlock && (s.dom == f || s.contentDOM == f) } const Ui = function (f) { return f.focusNode && As(f.focusNode, f.focusOffset, f.anchorNode, f.anchorOffset) }; function Js(f, s) { let l = document.createEvent("Event"); return l.initEvent("keydown", !0, !0), l.keyCode = f, l.key = l.code = s, l } const Mo = typeof navigator < "u" ? navigator : null, Ra = typeof document < "u" ? document : null, gi = Mo && Mo.userAgent || "", Ml = /Edge\/(\d+)/.exec(gi), wa = /MSIE \d/.exec(gi), Qs = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(gi), Zr = !!(wa || Qs || Ml), oo = wa ? document.documentMode : Qs ? +Qs[1] : Ml ? +Ml[1] : 0, xs = !Zr && /gecko\/(\d+)/i.test(gi); xs && /Firefox\/(\d+)/.exec(gi); const Oo = !Zr && /Chrome\/(\d+)/.exec(gi), Hi = !!Oo, qa = Oo ? +Oo[1] : 0, ys = !Zr && !!Mo && /Apple Computer/.test(Mo.vendor), hr = ys && (/Mobile\/\w+/.test(gi) || !!Mo && Mo.maxTouchPoints > 2), Xs = hr || !!Mo && /Mac/.test(Mo.platform), Q = /Android \d/.test(gi), q = !!Ra && "webkitFontSmoothing" in Ra.documentElement.style, $ = q ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0; function me(f) { return { left: 0, right: f.documentElement.clientWidth, top: 0, bottom: f.documentElement.clientHeight } } function Rt(f, s) { return "number" == typeof f ? f : f[s] } function Bn(f) { let s = f.getBoundingClientRect(); return { left: s.left, right: s.left + f.clientWidth * (s.width / f.offsetWidth || 1), top: s.top, bottom: s.top + f.clientHeight * (s.height / f.offsetHeight || 1) } } function wi(f, s, l) { let h = f.someProp("scrollThreshold") || 0, y = f.someProp("scrollMargin") || 5, w = f.dom.ownerDocument; for (let I = l || f.dom; I; I = Wo(I)) { if (1 != I.nodeType) continue; let k = I, H = k == w.body, te = H ? me(w) : Bn(k), se = 0, Ge = 0; if (s.top < te.top + Rt(h, "top") ? Ge = -(te.top - s.top + Rt(y, "top")) : s.bottom > te.bottom - Rt(h, "bottom") && (Ge = s.bottom - te.bottom + Rt(y, "bottom")), s.left < te.left + Rt(h, "left") ? se = -(te.left - s.left + Rt(y, "left")) : s.right > te.right - Rt(h, "right") && (se = s.right - te.right + Rt(y, "right")), se || Ge) if (H) w.defaultView.scrollBy(se, Ge); else { let at = k.scrollLeft, ut = k.scrollTop; Ge && (k.scrollTop += Ge), se && (k.scrollLeft += se); let $t = k.scrollLeft - at, Dn = k.scrollTop - ut; s = { left: s.left - $t, top: s.top - Dn, right: s.right - $t, bottom: s.bottom - Dn } } if (H) break } } function zr(f) { let s = [], l = f.ownerDocument; for (let h = f; h && (s.push({ dom: h, top: h.scrollTop, left: h.scrollLeft }), f != l); h = Wo(h)); return s } function qc(f, s) { for (let l = 0; l < f.length; l++) { let { dom: h, top: y, left: w } = f[l]; h.scrollTop != y + s && (h.scrollTop = y + s), h.scrollLeft != w && (h.scrollLeft = w) } } let vs = null; function cl(f, s) { let l, y, h = 2e8, w = 0, I = s.top, k = s.top; for (let H = f.firstChild, te = 0; H; H = H.nextSibling, te++) { let se; if (1 == H.nodeType) se = H.getClientRects(); else { if (3 != H.nodeType) continue; se = fo(H).getClientRects() } for (let Ge = 0; Ge < se.length; Ge++) { let at = se[Ge]; if (at.top <= I && at.bottom >= k) { I = Math.max(at.bottom, I), k = Math.min(at.top, k); let ut = at.left > s.left ? at.left - s.left : at.right < s.left ? s.left - at.right : 0; if (ut < h) { l = H, h = ut, y = ut && 3 == l.nodeType ? { left: at.right < s.left ? at.right : at.left, top: s.top } : s, 1 == H.nodeType && ut && (w = te + (s.left >= (at.left + at.right) / 2 ? 1 : 0)); continue } } !l && (s.left >= at.right && s.top >= at.top || s.left >= at.left && s.top >= at.bottom) && (w = te + 1) } } return l && 3 == l.nodeType ? function po(f, s) { let l = f.nodeValue.length, h = document.createRange(); for (let y = 0; y < l; y++) { h.setEnd(f, y + 1), h.setStart(f, y); let w = hs(h, 1); if (w.top != w.bottom && Fa(s, w)) return { node: f, offset: y + (s.left >= (w.left + w.right) / 2 ? 1 : 0) } } return { node: f, offset: 0 } }(l, y) : !l || h && 1 == l.nodeType ? { node: f, offset: w } : cl(l, y) } function Fa(f, s) { return f.left >= s.left - 1 && f.left <= s.right + 1 && f.top >= s.top - 1 && f.top <= s.bottom + 1 } function dl(f, s, l) { let h = f.childNodes.length; if (h && l.top < l.bottom) for (let y = Math.max(0, Math.min(h - 1, Math.floor(h * (s.top - l.top) / (l.bottom - l.top)) - 2)), w = y; ;) { let I = f.childNodes[w]; if (1 == I.nodeType) { let k = I.getClientRects(); for (let H = 0; H < k.length; H++) { let te = k[H]; if (Fa(s, te)) return dl(I, s, te) } } if ((w = (w + 1) % h) == y) break } return f } function Ms(f, s) { let h, l = f.dom.ownerDocument, y = 0; if (l.caretPositionFromPoint) try { let H = l.caretPositionFromPoint(s.left, s.top); H && ({ offsetNode: h, offset: y } = H) } catch { } if (!h && l.caretRangeFromPoint) { let H = l.caretRangeFromPoint(s.left, s.top); H && ({ startContainer: h, startOffset: y } = H) } let I, w = (f.root.elementFromPoint ? f.root : l).elementFromPoint(s.left, s.top); if (!w || !f.dom.contains(1 != w.nodeType ? w.parentNode : w)) { let H = f.dom.getBoundingClientRect(); if (!Fa(s, H) || (w = dl(f.dom, s, H), !w)) return null } if (ys) for (let H = w; h && H; H = Wo(H))H.draggable && (h = void 0); if (w = function ul(f, s) { let l = f.parentNode; return l && /^li$/i.test(l.nodeName) && s.left < f.getBoundingClientRect().left ? l : f }(w, s), h) { if (xs && 1 == h.nodeType && (y = Math.min(y, h.childNodes.length), y < h.childNodes.length)) { let te, H = h.childNodes[y]; "IMG" == H.nodeName && (te = H.getBoundingClientRect()).right <= s.left && te.bottom > s.top && y++ } h == f.dom && y == h.childNodes.length - 1 && 1 == h.lastChild.nodeType && s.top > h.lastChild.getBoundingClientRect().bottom ? I = f.state.doc.content.size : (0 == y || 1 != h.nodeType || "BR" != h.childNodes[y - 1].nodeName) && (I = function Kl(f, s, l, h) { let y = -1; for (let w = s; w != f.dom;) { let I = f.docView.nearestDesc(w, !0); if (!I) return null; if (I.node.isBlock && I.parent) { let k = I.dom.getBoundingClientRect(); if (k.left > h.left || k.top > h.top) y = I.posBefore; else { if (!(k.right < h.left || k.bottom < h.top)) break; y = I.posAfter } } w = I.dom.parentNode } return y > -1 ? y : f.docView.posFromDOM(s, l, 1) }(f, h, y, s)) } null == I && (I = function Yl(f, s, l) { let { node: h, offset: y } = cl(s, l), w = -1; if (1 == h.nodeType && !h.firstChild) { let I = h.getBoundingClientRect(); w = I.left != I.right && l.left > (I.left + I.right) / 2 ? 1 : -1 } return f.docView.posFromDOM(h, y, w) }(f, w, s)); let k = f.docView.nearestDesc(w, !0); return { pos: I, inside: k ? k.posAtStart - k.border : -1 } } function hs(f, s) { let l = f.getClientRects(); return l.length ? l[s < 0 ? 0 : l.length - 1] : f.getBoundingClientRect() } const Ca = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; function hl(f, s, l) { let { node: h, offset: y, atom: w } = f.docView.domFromPos(s, l < 0 ? -1 : 1), I = q || xs; if (3 == h.nodeType) { if (!I || !Ca.test(h.nodeValue) && (l < 0 ? y : y != h.nodeValue.length)) { let H = y, te = y, se = l < 0 ? 1 : -1; return l < 0 && !y ? (te++, se = -1) : l >= 0 && y == h.nodeValue.length ? (H--, se = 1) : l < 0 ? H-- : te++, Co(hs(fo(h, H, te), 1), se < 0) } { let H = hs(fo(h, y, y), l); if (xs && y && /\s/.test(h.nodeValue[y - 1]) && y < h.nodeValue.length) { let te = hs(fo(h, y - 1, y - 1), -1); if (te.top == H.top) { let se = hs(fo(h, y, y + 1), -1); if (se.top != H.top) return Co(se, se.left < te.left) } } return H } } if (!f.state.doc.resolve(s - (w || 0)).parent.inlineContent) { if (null == w && y && (l < 0 || y == Ls(h))) { let H = h.childNodes[y - 1]; if (1 == H.nodeType) return bc(H.getBoundingClientRect(), !1) } if (null == w && y < Ls(h)) { let H = h.childNodes[y]; if (1 == H.nodeType) return bc(H.getBoundingClientRect(), !0) } return bc(h.getBoundingClientRect(), l >= 0) } if (null == w && y && (l < 0 || y == Ls(h))) { let H = h.childNodes[y - 1], te = 3 == H.nodeType ? fo(H, Ls(H) - (I ? 0 : 1)) : 1 != H.nodeType || "BR" == H.nodeName && H.nextSibling ? null : H; if (te) return Co(hs(te, 1), !1) } if (null == w && y < Ls(h)) { let H = h.childNodes[y]; for (; H.pmViewDesc && H.pmViewDesc.ignoreForCoords;)H = H.nextSibling; let te = H ? 3 == H.nodeType ? fo(H, 0, I ? 0 : 1) : 1 == H.nodeType ? H : null : null; if (te) return Co(hs(te, -1), !0) } return Co(hs(3 == h.nodeType ? fo(h) : h, -l), l >= 0) } function Co(f, s) { if (0 == f.width) return f; let l = s ? f.left : f.right; return { top: f.top, bottom: f.bottom, left: l, right: l } } function bc(f, s) { if (0 == f.height) return f; let l = s ? f.top : f.bottom; return { top: l, bottom: l, left: f.left, right: f.right } } function Ea(f, s, l) { let h = f.state, y = f.root.activeElement; h != s && f.updateState(s), y != f.dom && f.focus(); try { return l() } finally { h != s && f.updateState(h), y != f.dom && y && y.focus() } } const wc = /[\u0590-\u08ac]/; let No = null, Cc = null, fl = !1; class Tc { constructor(s, l, h, y) { this.parent = s, this.children = l, this.dom = h, this.contentDOM = y, this.dirty = 0, h.pmViewDesc = this } matchesWidget(s) { return !1 } matchesMark(s) { return !1 } matchesNode(s, l, h) { return !1 } matchesHack(s) { return !1 } parseRule() { return null } stopEvent(s) { return !1 } get size() { let s = 0; for (let l = 0; l < this.children.length; l++)s += this.children[l].size; return s } get border() { return 0 } destroy() { this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0); for (let s = 0; s < this.children.length; s++)this.children[s].destroy() } posBeforeChild(s) { for (let l = 0, h = this.posAtStart; ; l++) { let y = this.children[l]; if (y == s) return h; h += y.size } } get posBefore() { return this.parent.posBeforeChild(this) } get posAtStart() { return this.parent ? this.parent.posBeforeChild(this) + this.border : 0 } get posAfter() { return this.posBefore + this.size } get posAtEnd() { return this.posAtStart + this.size - 2 * this.border } localPosFromDOM(s, l, h) { if (this.contentDOM && this.contentDOM.contains(1 == s.nodeType ? s : s.parentNode)) { if (h < 0) { let w, I; if (s == this.contentDOM) w = s.childNodes[l - 1]; else { for (; s.parentNode != this.contentDOM;)s = s.parentNode; w = s.previousSibling } for (; w && (!(I = w.pmViewDesc) || I.parent != this);)w = w.previousSibling; return w ? this.posBeforeChild(I) + I.size : this.posAtStart } { let w, I; if (s == this.contentDOM) w = s.childNodes[l]; else { for (; s.parentNode != this.contentDOM;)s = s.parentNode; w = s.nextSibling } for (; w && (!(I = w.pmViewDesc) || I.parent != this);)w = w.nextSibling; return w ? this.posBeforeChild(I) : this.posAtEnd } } let y; if (s == this.dom && this.contentDOM) y = l > Is(this.contentDOM); else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) y = 2 & s.compareDocumentPosition(this.contentDOM); else if (this.dom.firstChild) { if (0 == l) for (let w = s; ; w = w.parentNode) { if (w == this.dom) { y = !1; break } if (w.previousSibling) break } if (null == y && l == s.childNodes.length) for (let w = s; ; w = w.parentNode) { if (w == this.dom) { y = !0; break } if (w.nextSibling) break } } return y ?? h > 0 ? this.posAtEnd : this.posAtStart } nearestDesc(s, l = !1) { for (let h = !0, y = s; y; y = y.parentNode) { let I, w = this.getDesc(y); if (w && (!l || w.node)) { if (!h || !(I = w.nodeDOM) || (1 == I.nodeType ? I.contains(1 == s.nodeType ? s : s.parentNode) : I == s)) return w; h = !1 } } } getDesc(s) { let l = s.pmViewDesc; for (let h = l; h; h = h.parent)if (h == this) return l } posFromDOM(s, l, h) { for (let y = s; y; y = y.parentNode) { let w = this.getDesc(y); if (w) return w.localPosFromDOM(s, l, h) } return -1 } descAt(s) { for (let l = 0, h = 0; l < this.children.length; l++) { let y = this.children[l], w = h + y.size; if (h == s && w != h) { for (; !y.border && y.children.length;)y = y.children[0]; return y } if (s < w) return y.descAt(s - h - y.border); h = w } } domFromPos(s, l) { if (!this.contentDOM) return { node: this.dom, offset: 0, atom: s + 1 }; let w, h = 0, y = 0; for (let w = 0; h < this.children.length; h++) { let I = this.children[h], k = w + I.size; if (k > s || I instanceof es) { y = s - w; break } w = k } if (y) return this.children[h].domFromPos(y - this.children[h].border, l); for (; h && !(w = this.children[h - 1]).size && w instanceof Xl && w.side >= 0; h--); if (l <= 0) { let w, I = !0; for (; w = h ? this.children[h - 1] : null, w && w.dom.parentNode != this.contentDOM; h--, I = !1); return w && l && I && !w.border && !w.domAtom ? w.domFromPos(w.size, l) : { node: this.contentDOM, offset: w ? Is(w.dom) + 1 : 0 } } { let w, I = !0; for (; w = h < this.children.length ? this.children[h] : null, w && w.dom.parentNode != this.contentDOM; h++, I = !1); return w && I && !w.border && !w.domAtom ? w.domFromPos(0, l) : { node: this.contentDOM, offset: w ? Is(w.dom) : this.contentDOM.childNodes.length } } } parseRange(s, l, h = 0) { if (0 == this.children.length) return { node: this.contentDOM, from: s, to: l, fromOffset: 0, toOffset: this.contentDOM.childNodes.length }; let y = -1, w = -1; for (let I = h, k = 0; ; k++) { let H = this.children[k], te = I + H.size; if (-1 == y && s <= te) { let se = I + H.border; if (s >= se && l <= te - H.border && H.node && H.contentDOM && this.contentDOM.contains(H.contentDOM)) return H.parseRange(s, l, se); s = I; for (let Ge = k; Ge > 0; Ge--) { let at = this.children[Ge - 1]; if (at.size && at.dom.parentNode == this.contentDOM && !at.emptyChildAt(1)) { y = Is(at.dom) + 1; break } s -= at.size } -1 == y && (y = 0) } if (y > -1 && (te > l || k == this.children.length - 1)) { l = te; for (let se = k + 1; se < this.children.length; se++) { let Ge = this.children[se]; if (Ge.size && Ge.dom.parentNode == this.contentDOM && !Ge.emptyChildAt(-1)) { w = Is(Ge.dom); break } l += Ge.size } -1 == w && (w = this.contentDOM.childNodes.length); break } I = te } return { node: this.contentDOM, from: s, to: l, fromOffset: y, toOffset: w } } emptyChildAt(s) { if (this.border || !this.contentDOM || !this.children.length) return !1; let l = this.children[s < 0 ? 0 : this.children.length - 1]; return 0 == l.size || l.emptyChildAt(s) } domAfterPos(s) { let { node: l, offset: h } = this.domFromPos(s, 0); if (1 != l.nodeType || h == l.childNodes.length) throw new RangeError("No node after pos " + s); return l.childNodes[h] } setSelection(s, l, h, y = !1) { let w = Math.min(s, l), I = Math.max(s, l); for (let at = 0, ut = 0; at < this.children.length; at++) { let $t = this.children[at], Dn = ut + $t.size; if (w > ut && I < Dn) return $t.setSelection(s - ut - $t.border, l - ut - $t.border, h, y); ut = Dn } let k = this.domFromPos(s, s ? -1 : 1), H = l == s ? k : this.domFromPos(l, l ? -1 : 1), te = h.getSelection(), se = !1; if ((xs || ys) && s == l) { let { node: at, offset: ut } = k; if (3 == at.nodeType) { if (se = !(!ut || "\n" != at.nodeValue[ut - 1]), se && ut == at.nodeValue.length) for (let Dn, $t = at; $t; $t = $t.parentNode) { if (Dn = $t.nextSibling) { "BR" == Dn.nodeName && (k = H = { node: Dn.parentNode, offset: Is(Dn) + 1 }); break } let $n = $t.pmViewDesc; if ($n && $n.node && $n.node.isBlock) break } } else { let $t = at.childNodes[ut - 1]; se = $t && ("BR" == $t.nodeName || "false" == $t.contentEditable) } } if (xs && te.focusNode && te.focusNode != H.node && 1 == te.focusNode.nodeType) { let at = te.focusNode.childNodes[te.focusOffset]; at && "false" == at.contentEditable && (y = !0) } if (!(y || se && ys) && As(k.node, k.offset, te.anchorNode, te.anchorOffset) && As(H.node, H.offset, te.focusNode, te.focusOffset)) return; let Ge = !1; if ((te.extend || s == l) && !se) { te.collapse(k.node, k.offset); try { s != l && te.extend(H.node, H.offset), Ge = !0 } catch { } } if (!Ge) { if (s > l) { let ut = k; k = H, H = ut } let at = document.createRange(); at.setEnd(H.node, H.offset), at.setStart(k.node, k.offset), te.removeAllRanges(), te.addRange(at) } } ignoreMutation(s) { return !this.contentDOM && "selection" != s.type } get contentLost() { return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM) } markDirty(s, l) { for (let h = 0, y = 0; y < this.children.length; y++) { let w = this.children[y], I = h + w.size; if (h == I ? s <= I && l >= h : s < I && l > h) { let k = h + w.border, H = I - w.border; if (s >= k && l <= H) return this.dirty = s == h || l == I ? 2 : 1, void (s != k || l != H || !w.contentLost && w.dom.parentNode == this.contentDOM ? w.markDirty(s - k, l - k) : w.dirty = 3); w.dirty = w.dom != w.contentDOM || w.dom.parentNode != this.contentDOM || w.children.length ? 3 : 2 } h = I } this.dirty = 2 } markParentsDirty() { let s = 1; for (let l = this.parent; l; l = l.parent, s++) { let h = 1 == s ? 2 : 1; l.dirty < h && (l.dirty = h) } } get domAtom() { return !1 } get ignoreForCoords() { return !1 } } class Xl extends Tc { constructor(s, l, h, y) { let w, I = l.type.toDOM; if ("function" == typeof I && (I = I(h, () => w ? w.parent ? w.parent.posBeforeChild(w) : void 0 : y)), !l.type.spec.raw) { if (1 != I.nodeType) { let k = document.createElement("span"); k.appendChild(I), I = k } I.contentEditable = "false", I.classList.add("ProseMirror-widget") } super(s, [], I, null), this.widget = l, this.widget = l, w = this } matchesWidget(s) { return 0 == this.dirty && s.type.eq(this.widget.type) } parseRule() { return { ignore: !0 } } stopEvent(s) { let l = this.widget.spec.stopEvent; return !!l && l(s) } ignoreMutation(s) { return "selection" != s.type || this.widget.spec.ignoreSelection } destroy() { this.widget.type.destroy(this.dom), super.destroy() } get domAtom() { return !0 } get side() { return this.widget.type.side } } class Bd extends Tc { constructor(s, l, h, y) { super(s, [], l, null), this.textDOM = h, this.text = y } get size() { return this.text.length } localPosFromDOM(s, l) { return s != this.textDOM ? this.posAtStart + (l ? this.size : 0) : this.posAtStart + l } domFromPos(s) { return { node: this.textDOM, offset: s } } ignoreMutation(s) { return "characterData" === s.type && s.target.nodeValue == s.oldValue } } class pl extends Tc { constructor(s, l, h, y) { super(s, [], h, y), this.mark = l } static create(s, l, h, y) { let w = y.nodeViews[l.type.name], I = w && w(l, y, h); return (!I || !I.dom) && (I = qe.renderSpec(document, l.type.spec.toDOM(l, h))), new pl(s, l, I.dom, I.contentDOM || I.dom) } parseRule() { return 3 & this.dirty || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 } } matchesMark(s) { return 3 != this.dirty && this.mark.eq(s) } markDirty(s, l) { if (super.markDirty(s, l), 0 != this.dirty) { let h = this.parent; for (; !h.node;)h = h.parent; h.dirty < this.dirty && (h.dirty = this.dirty), this.dirty = 0 } } slice(s, l, h) { let y = pl.create(this.parent, this.mark, !0, h), w = this.children, I = this.size; l < I && (w = kr(w, l, I, h)), s > 0 && (w = kr(w, 0, s, h)); for (let k = 0; k < w.length; k++)w[k].parent = y; return y.children = w, y } } class Ka extends Tc { constructor(s, l, h, y, w, I, k, H, te) { super(s, [], w, I), this.node = l, this.outerDeco = h, this.innerDeco = y, this.nodeDOM = k, I && this.updateChildren(H, te) } static create(s, l, h, y, w, I) { let H, k = w.nodeViews[l.type.name], te = k && k(l, w, () => H ? H.parent ? H.parent.posBeforeChild(H) : void 0 : I, h, y), se = te && te.dom, Ge = te && te.contentDOM; if (l.isText) if (se) { if (3 != se.nodeType) throw new RangeError("Text must be rendered as a DOM text node") } else se = document.createTextNode(l.text); else se || ({ dom: se, contentDOM: Ge } = qe.renderSpec(document, l.type.spec.toDOM(l))); !Ge && !l.isText && "BR" != se.nodeName && (se.hasAttribute("contenteditable") || (se.contentEditable = "false"), l.type.spec.draggable && (se.draggable = !0)); let at = se; return se = z(se, h, l), te ? H = new Ja(s, l, h, y, se, Ge || null, at, te, w, I + 1) : l.isText ? new La(s, l, h, y, se, at, w) : new Ka(s, l, h, y, se, Ge || null, at, w, I + 1) } parseRule() { if (this.node.type.spec.reparseInView) return null; let s = { node: this.node.type.name, attrs: this.node.attrs }; if ("pre" == this.node.type.whitespace && (s.preserveWhitespace = "full"), this.contentDOM) if (this.contentLost) { for (let l = this.children.length - 1; l >= 0; l--) { let h = this.children[l]; if (this.dom.contains(h.dom.parentNode)) { s.contentElement = h.dom.parentNode; break } } s.contentElement || (s.getContent = () => Se.empty) } else s.contentElement = this.contentDOM; else s.getContent = () => this.node.content; return s } matchesNode(s, l, h) { return 0 == this.dirty && s.eq(this.node) && re(l, this.outerDeco) && h.eq(this.innerDeco) } get size() { return this.node.nodeSize } get border() { return this.node.isLeaf ? 0 : 1 } updateChildren(s, l) { let h = this.node.inlineContent, y = l, w = s.composing ? this.localCompositionInfo(s, l) : null, I = w && w.pos > -1 ? w : null, k = w && w.pos < 0, H = new he(this, I && I.node, s); (function Xt(f, s, l, h) { let y = s.locals(f), w = 0; if (0 == y.length) { for (let te = 0; te < f.childCount; te++) { let se = f.child(te); h(se, y, s.forChild(w, se), te), w += se.nodeSize } return } let I = 0, k = [], H = null; for (let te = 0; ;) { if (I < y.length && y[I].to == w) { let Dn, $t = y[I++]; for (; I < y.length && y[I].to == w;)(Dn || (Dn = [$t])).push(y[I++]); if (Dn) { Dn.sort(Ft); for (let $n = 0; $n < Dn.length; $n++)l(Dn[$n], te, !!H) } else l($t, te, !!H) } let se, Ge; if (H) Ge = -1, se = H, H = null; else { if (!(te < f.childCount)) break; Ge = te, se = f.child(te++) } for (let $t = 0; $t < k.length; $t++)k[$t].to <= w && k.splice($t--, 1); for (; I < y.length && y[I].from <= w && y[I].to > w;)k.push(y[I++]); let at = w + se.nodeSize; if (se.isText) { let $t = at; I < y.length && y[I].from < $t && ($t = y[I].from); for (let Dn = 0; Dn < k.length; Dn++)k[Dn].to < $t && ($t = k[Dn].to); $t < at && (H = se.cut($t - w), se = se.cut(0, $t - w), at = $t, Ge = -1) } h(se, se.isInline && !se.isLeaf ? k.filter($t => !$t.inline) : k.slice(), s.forChild(w, se), Ge), w = at } })(this.node, this.innerDeco, (te, se, Ge) => { te.spec.marks ? H.syncToMarks(te.spec.marks, h, s) : te.type.side >= 0 && !Ge && H.syncToMarks(se == this.node.childCount ? je.none : this.node.child(se).marks, h, s), H.placeWidget(te, s, y) }, (te, se, Ge, at) => { let ut; H.syncToMarks(te.marks, h, s), H.findNodeMatch(te, se, Ge, at) || k && s.state.selection.from > y && s.state.selection.to < y + te.nodeSize && (ut = H.findIndexWithChild(w.node)) > -1 && H.updateNodeAt(te, se, Ge, ut, s) || H.updateNextNode(te, se, Ge, s, at) || H.addNode(te, se, Ge, s, y), y += te.nodeSize }), H.syncToMarks([], h, s), this.node.isTextblock && H.addTextblockHacks(), H.destroyRest(), (H.changed || 2 == this.dirty) && (I && this.protectLocalComposition(s, I), ec(this.contentDOM, this.children, s), hr && function Nn(f) { if ("UL" == f.nodeName || "OL" == f.nodeName) { let s = f.style.cssText; f.style.cssText = s + "; list-style: square !important", window.getComputedStyle(f), f.style.cssText = s } }(this.dom)) } localCompositionInfo(s, l) { let { from: h, to: y } = s.state.selection; if (!(s.state.selection instanceof Jr) || h < l || y > l + this.node.content.size) return null; let w = s.domSelectionRange(), I = function ri(f, s) { for (; ;) { if (3 == f.nodeType) return f; if (1 == f.nodeType && s > 0) { if (f.childNodes.length > s && 3 == f.childNodes[s].nodeType) return f.childNodes[s]; s = Ls(f = f.childNodes[s - 1]) } else { if (!(1 == f.nodeType && s < f.childNodes.length)) return null; f = f.childNodes[s], s = 0 } } }(w.focusNode, w.focusOffset); if (!I || !this.dom.contains(I.parentNode)) return null; if (this.node.inlineContent) { let k = I.nodeValue, H = function Nr(f, s, l, h) { for (let y = 0, w = 0; y < f.childCount && w <= h;) { let I = f.child(y++), k = w; if (w += I.nodeSize, !I.isText) continue; let H = I.text; for (; y < f.childCount;) { let te = f.child(y++); if (w += te.nodeSize, !te.isText) break; H += te.text } if (w >= l) { let te = k < h ? H.lastIndexOf(s, h - k - 1) : -1; if (te >= 0 && te + s.length + k >= l) return k + te; if (l == h && H.length >= h + s.length - k && H.slice(h - k, h - k + s.length) == s) return h } } return -1 }(this.node.content, k, h - l, y - l); return H < 0 ? null : { node: I, pos: H, text: k } } return { node: I, pos: -1, text: "" } } protectLocalComposition(s, { node: l, pos: h, text: y }) { if (this.getDesc(l)) return; let w = l; for (; w.parentNode != this.contentDOM; w = w.parentNode) { for (; w.previousSibling;)w.parentNode.removeChild(w.previousSibling); for (; w.nextSibling;)w.parentNode.removeChild(w.nextSibling); w.pmViewDesc && (w.pmViewDesc = void 0) } let I = new Bd(this, w, l, y); s.input.compositionNodes.push(I), this.children = kr(this.children, h, h + y.length, s, I) } update(s, l, h, y) { return !(3 == this.dirty || !s.sameMarkup(this.node) || (this.updateInner(s, l, h, y), 0)) } updateInner(s, l, h, y) { this.updateOuterDeco(l), this.node = s, this.innerDeco = h, this.contentDOM && this.updateChildren(y, this.posAtStart), this.dirty = 0 } updateOuterDeco(s) { if (re(s, this.outerDeco)) return; let l = 1 != this.nodeDOM.nodeType, h = this.dom; this.dom = _u(this.dom, this.nodeDOM, Nl(this.outerDeco, this.node, l), Nl(s, this.node, l)), this.dom != h && (h.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = s } selectNode() { 1 == this.nodeDOM.nodeType && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0) } deselectNode() { 1 == this.nodeDOM.nodeType && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable") } get domAtom() { return this.node.isAtom } } function Eo(f, s, l, h, y) { return z(h, s, f), new Ka(void 0, f, s, l, h, h, h, y, 0) } class La extends Ka { constructor(s, l, h, y, w, I, k) { super(s, l, h, y, w, null, I, k, 0) } parseRule() { let s = this.nodeDOM.parentNode; for (; s && s != this.dom && !s.pmIsDeco;)s = s.parentNode; return { skip: s || !0 } } update(s, l, h, y) { return !(3 == this.dirty || 0 != this.dirty && !this.inParent() || !s.sameMarkup(this.node) || (this.updateOuterDeco(l), (0 != this.dirty || s.text != this.node.text) && s.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = s.text, y.trackWrites == this.nodeDOM && (y.trackWrites = null)), this.node = s, this.dirty = 0, 0)) } inParent() { let s = this.parent.contentDOM; for (let l = this.nodeDOM; l; l = l.parentNode)if (l == s) return !0; return !1 } domFromPos(s) { return { node: this.nodeDOM, offset: s } } localPosFromDOM(s, l, h) { return s == this.nodeDOM ? this.posAtStart + Math.min(l, this.node.text.length) : super.localPosFromDOM(s, l, h) } ignoreMutation(s) { return "characterData" != s.type && "selection" != s.type } slice(s, l, h) { let y = this.node.cut(s, l), w = document.createTextNode(y.text); return new La(this.parent, y, this.outerDeco, this.innerDeco, w, w, h) } markDirty(s, l) { super.markDirty(s, l), this.dom != this.nodeDOM && (0 == s || l == this.nodeDOM.nodeValue.length) && (this.dirty = 3) } get domAtom() { return !1 } } class es extends Tc { parseRule() { return { ignore: !0 } } matchesHack(s) { return 0 == this.dirty && this.dom.nodeName == s } get domAtom() { return !0 } get ignoreForCoords() { return "IMG" == this.dom.nodeName } } class Ja extends Ka { constructor(s, l, h, y, w, I, k, H, te, se) { super(s, l, h, y, w, I, k, te, se), this.spec = H } update(s, l, h, y) { if (3 == this.dirty) return !1; if (this.spec.update) { let w = this.spec.update(s, l, h); return w && this.updateInner(s, l, h, y), w } return !(!this.contentDOM && !s.isLeaf) && super.update(s, l, h, y) } selectNode() { this.spec.selectNode ? this.spec.selectNode() : super.selectNode() } deselectNode() { this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode() } setSelection(s, l, h, y) { this.spec.setSelection ? this.spec.setSelection(s, l, h) : super.setSelection(s, l, h, y) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } stopEvent(s) { return !!this.spec.stopEvent && this.spec.stopEvent(s) } ignoreMutation(s) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(s) : super.ignoreMutation(s) } } function ec(f, s, l) { let h = f.firstChild, y = !1; for (let w = 0; w < s.length; w++) { let I = s[w], k = I.dom; if (k.parentNode == f) { for (; k != h;)h = Z(h), y = !0; h = h.nextSibling } else y = !0, f.insertBefore(k, h); if (I instanceof pl) { let H = h ? h.previousSibling : f.lastChild; ec(I.contentDOM, I.children, l), h = H ? H.nextSibling : f.firstChild } } for (; h;)h = Z(h), y = !0; y && l.trackWrites == f && (l.trackWrites = null) } const yi = function (f) { f && (this.nodeName = f) }; yi.prototype = Object.create(null); const Da = [new yi]; function Nl(f, s, l) { if (0 == f.length) return Da; let h = l ? Da[0] : new yi, y = [h]; for (let w = 0; w < f.length; w++) { let I = f[w].type.attrs; if (I) { I.nodeName && y.push(h = new yi(I.nodeName)); for (let k in I) { let H = I[k]; null != H && (l && 1 == y.length && y.push(h = new yi(s.isInline ? "span" : "div")), "class" == k ? h.class = (h.class ? h.class + " " : "") + H : "style" == k ? h.style = (h.style ? h.style + ";" : "") + H : "nodeName" != k && (h[k] = H)) } } } return y } function _u(f, s, l, h) { if (l == Da && h == Da) return s; let y = s; for (let w = 0; w < h.length; w++) { let I = h[w], k = l[w]; if (w) { let H; k && k.nodeName == I.nodeName && y != f && (H = y.parentNode) && H.nodeName.toLowerCase() == I.nodeName || (H = document.createElement(I.nodeName), H.pmIsDeco = !0, H.appendChild(y), k = Da[0]), y = H } kl(y, k || Da[0], I) } return y } function kl(f, s, l) { for (let h in s) "class" != h && "style" != h && "nodeName" != h && !(h in l) && f.removeAttribute(h); for (let h in l) "class" != h && "style" != h && "nodeName" != h && l[h] != s[h] && f.setAttribute(h, l[h]); if (s.class != l.class) { let h = s.class ? s.class.split(" ").filter(Boolean) : [], y = l.class ? l.class.split(" ").filter(Boolean) : []; for (let w = 0; w < h.length; w++)-1 == y.indexOf(h[w]) && f.classList.remove(h[w]); for (let w = 0; w < y.length; w++)-1 == h.indexOf(y[w]) && f.classList.add(y[w]); 0 == f.classList.length && f.removeAttribute("class") } if (s.style != l.style) { if (s.style) { let y, h = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g; for (; y = h.exec(s.style);)f.style.removeProperty(y[1]) } l.style && (f.style.cssText += l.style) } } function z(f, s, l) { return _u(f, f, Da, Nl(s, l, 1 != f.nodeType)) } function re(f, s) { if (f.length != s.length) return !1; for (let l = 0; l < f.length; l++)if (!f[l].type.eq(s[l].type)) return !1; return !0 } function Z(f) { let s = f.nextSibling; return f.parentNode.removeChild(f), s } class he { constructor(s, l, h) { this.lock = l, this.view = h, this.index = 0, this.stack = [], this.changed = !1, this.top = s, this.preMatch = function $e(f, s) { let l = s, h = l.children.length, y = f.childCount, w = new Map, I = []; e: for (; y > 0;) { let k; for (; ;)if (h) { let te = l.children[h - 1]; if (!(te instanceof pl)) { k = te, h--; break } l = te, h = te.children.length } else { if (l == s) break e; h = l.parent.children.indexOf(l), l = l.parent } let H = k.node; if (H) { if (H != f.child(y - 1)) break; --y, w.set(k, y), I.push(k) } } return { index: y, matched: w, matches: I.reverse() } }(s.node.content, s) } destroyBetween(s, l) { if (s != l) { for (let h = s; h < l; h++)this.top.children[h].destroy(); this.top.children.splice(s, l - s), this.changed = !0 } } destroyRest() { this.destroyBetween(this.index, this.top.children.length) } syncToMarks(s, l, h) { let y = 0, w = this.stack.length >> 1, I = Math.min(w, s.length); for (; y < I && (y == w - 1 ? this.top : this.stack[y + 1 << 1]).matchesMark(s[y]) && !1 !== s[y].type.spec.spanning;)y++; for (; y < w;)this.destroyRest(), this.top.dirty = 0, this.index = this.stack.pop(), this.top = this.stack.pop(), w--; for (; w < s.length;) { this.stack.push(this.top, this.index + 1); let k = -1; for (let H = this.index; H < Math.min(this.index + 3, this.top.children.length); H++)if (this.top.children[H].matchesMark(s[w])) { k = H; break } if (k > -1) k > this.index && (this.changed = !0, this.destroyBetween(this.index, k)), this.top = this.top.children[this.index]; else { let H = pl.create(this.top, s[w], l, h); this.top.children.splice(this.index, 0, H), this.top = H, this.changed = !0 } this.index = 0, w++ } } findNodeMatch(s, l, h, y) { let I, w = -1; if (y >= this.preMatch.index && (I = this.preMatch.matches[y - this.preMatch.index]).parent == this.top && I.matchesNode(s, l, h)) w = this.top.children.indexOf(I, this.index); else for (let k = this.index, H = Math.min(this.top.children.length, k + 5); k < H; k++) { let te = this.top.children[k]; if (te.matchesNode(s, l, h) && !this.preMatch.matched.has(te)) { w = k; break } } return !(w < 0 || (this.destroyBetween(this.index, w), this.index++, 0)) } updateNodeAt(s, l, h, y, w) { let I = this.top.children[y]; return 3 == I.dirty && I.dom == I.contentDOM && (I.dirty = 2), !!I.update(s, l, h, w) && (this.destroyBetween(this.index, y), this.index++, !0) } findIndexWithChild(s) { for (; ;) { let l = s.parentNode; if (!l) return -1; if (l == this.top.contentDOM) { let h = s.pmViewDesc; if (h) for (let y = this.index; y < this.top.children.length; y++)if (this.top.children[y] == h) return y; return -1 } s = l } } updateNextNode(s, l, h, y, w) { for (let I = this.index; I < this.top.children.length; I++) { let k = this.top.children[I]; if (k instanceof Ka) { let H = this.preMatch.matched.get(k); if (null != H && H != w) return !1; let te = k.dom; if ((!this.lock || !(te == this.lock || 1 == te.nodeType && te.contains(this.lock.parentNode)) || s.isText && k.node && k.node.isText && k.nodeDOM.nodeValue == s.text && 3 != k.dirty && re(l, k.outerDeco)) && k.update(s, l, h, y)) return this.destroyBetween(this.index, I), k.dom != te && (this.changed = !0), this.index++, !0; break } } return !1 } addNode(s, l, h, y, w) { this.top.children.splice(this.index++, 0, Ka.create(this.top, s, l, h, y, w)), this.changed = !0 } placeWidget(s, l, h) { let y = this.index < this.top.children.length ? this.top.children[this.index] : null; if (!y || !y.matchesWidget(s) || s != y.widget && y.widget.type.toDOM.parentNode) { let w = new Xl(this.top, s, l, h); this.top.children.splice(this.index++, 0, w), this.changed = !0 } else this.index++ } addTextblockHacks() { let s = this.top.children[this.index - 1], l = this.top; for (; s instanceof pl;)l = s, s = l.children[l.children.length - 1]; (!s || !(s instanceof La) || /\n$/.test(s.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(s.node.text)) && ((ys || Hi) && s && "false" == s.dom.contentEditable && this.addHackNode("IMG", l), this.addHackNode("BR", this.top)) } addHackNode(s, l) { if (l == this.top && this.index < l.children.length && l.children[this.index].matchesHack(s)) this.index++; else { let h = document.createElement(s); "IMG" == s && (h.className = "ProseMirror-separator", h.alt = ""), "BR" == s && (h.className = "ProseMirror-trailingBreak"); let y = new es(this.top, [], h, null); l != this.top ? l.children.push(y) : l.children.splice(this.index++, 0, y), this.changed = !0 } } } function Ft(f, s) { return f.type.side - s.type.side } function kr(f, s, l, h, y) { let w = []; for (let I = 0, k = 0; I < f.length; I++) { let H = f[I], te = k, se = k += H.size; te >= l || se <= s ? w.push(H) : (te < s && w.push(H.slice(0, s - te, h)), y && (w.push(y), y = void 0), se > l && w.push(H.slice(l - te, H.size, h))) } return w } function Or(f, s = null) { let l = f.domSelectionRange(), h = f.state.doc; if (!l.focusNode) return null; let y = f.docView.nearestDesc(l.focusNode), w = y && 0 == y.size, I = f.docView.posFromDOM(l.focusNode, l.focusOffset, 1); if (I < 0) return null; let H, te, k = h.resolve(I); if (Ui(l)) { for (H = k; y && !y.node;)y = y.parent; let se = y.node; if (y && se.isAtom && Xn.isSelectable(se) && y.parent && (!se.isInline || !function xo(f, s, l) { for (let h = 0 == s, y = s == Ls(f); h || y;) { if (f == l) return !0; let w = Is(f); if (!(f = f.parentNode)) return !1; h = h && 0 == w, y = y && w == Ls(f) } }(l.focusNode, l.focusOffset, y.dom))) { let Ge = y.posBefore; te = new Xn(I == Ge ? k : h.resolve(Ge)) } } else { let se = f.docView.posFromDOM(l.anchorNode, l.anchorOffset, 1); if (se < 0) return null; H = h.resolve(se) } return te || (te = Dc(f, H, k, "pointer" == s || f.state.selection.head < k.pos && !w ? 1 : -1)), te } function fs(f) { return f.editable ? f.hasFocus() : Zo(f) && document.activeElement && document.activeElement.contains(f.dom) } function xr(f, s = !1) { let l = f.state.selection; if (Va(f, l), fs(f)) { if (!s && f.input.mouseDown && f.input.mouseDown.allowDefault && Hi) { let h = f.domSelectionRange(), y = f.domObserver.currentSelection; if (h.anchorNode && y.anchorNode && As(h.anchorNode, h.anchorOffset, y.anchorNode, y.anchorOffset)) return f.input.mouseDown.delayedSelectionSync = !0, void f.domObserver.setCurSelection() } if (f.domObserver.disconnectSelection(), f.cursorWrapper) !function Ba(f) { let s = f.domSelection(), l = document.createRange(), h = f.cursorWrapper.dom, y = "IMG" == h.nodeName; y ? l.setEnd(h.parentNode, Is(h) + 1) : l.setEnd(h, 0), l.collapse(!1), s.removeAllRanges(), s.addRange(l), !y && !f.state.selection.visible && Zr && oo <= 11 && (h.disabled = !0, h.disabled = !1) }(f); else { let w, I, { anchor: h, head: y } = l; Os && !(l instanceof Jr) && (l.$from.parent.inlineContent || (w = mi(f, l.from)), !l.empty && !l.$from.parent.inlineContent && (I = mi(f, l.to))), f.docView.setSelection(h, y, f.root, s), Os && (w && To(w), I && To(I)), l.visible ? f.dom.classList.remove("ProseMirror-hideselection") : (f.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && function go(f) { let s = f.dom.ownerDocument; s.removeEventListener("selectionchange", f.input.hideSelectionGuard); let l = f.domSelectionRange(), h = l.anchorNode, y = l.anchorOffset; s.addEventListener("selectionchange", f.input.hideSelectionGuard = () => { (l.anchorNode != h || l.anchorOffset != y) && (s.removeEventListener("selectionchange", f.input.hideSelectionGuard), setTimeout(() => { (!fs(f) || f.state.selection.visible) && f.dom.classList.remove("ProseMirror-hideselection") }, 20)) }) }(f)) } f.domObserver.setCurSelection(), f.domObserver.connectSelection() } } const Os = ys || Hi && qa < 63; function mi(f, s) { let { node: l, offset: h } = f.docView.domFromPos(s, 0), y = h < l.childNodes.length ? l.childNodes[h] : null, w = h ? l.childNodes[h - 1] : null; if (ys && y && "false" == y.contentEditable) return bs(y); if (!(y && "false" != y.contentEditable || w && "false" != w.contentEditable)) { if (y) return bs(y); if (w) return bs(w) } } function bs(f) { return f.contentEditable = "true", ys && f.draggable && (f.draggable = !1, f.wasDraggable = !0), f } function To(f) { f.contentEditable = "false", f.wasDraggable && (f.draggable = !0, f.wasDraggable = null) } function Va(f, s) { if (s instanceof Xn) { let l = f.docView.descAt(s.from); l != f.lastSelectedViewDesc && (xi(f), l && l.selectNode(), f.lastSelectedViewDesc = l) } else xi(f) } function xi(f) { f.lastSelectedViewDesc && (f.lastSelectedViewDesc.parent && f.lastSelectedViewDesc.deselectNode(), f.lastSelectedViewDesc = void 0) } function Dc(f, s, l, h) { return f.someProp("createSelectionBetween", y => y(f, s, l)) || Jr.between(s, l, h) } function Yc(f) { return !(f.editable && !f.hasFocus()) && Zo(f) } function Zo(f) { let s = f.domSelectionRange(); if (!s.anchorNode) return !1; try { return f.dom.contains(3 == s.anchorNode.nodeType ? s.anchorNode.parentNode : s.anchorNode) && (f.editable || f.dom.contains(3 == s.focusNode.nodeType ? s.focusNode.parentNode : s.focusNode)) } catch { return !1 } } function gl(f, s) { let { $anchor: l, $head: h } = f.selection, y = s > 0 ? l.max(h) : l.min(h), w = y.parent.inlineContent ? y.depth ? f.doc.resolve(s > 0 ? y.after() : y.before()) : null : y; return w && gr.findFrom(w, s) } function ko(f, s) { return f.dispatch(f.state.tr.setSelection(s).scrollIntoView()), !0 } function Pl(f, s, l) { let h = f.state.selection; if (!(h instanceof Jr)) { if (h instanceof Xn && h.node.isInline) return ko(f, new Jr(s > 0 ? h.$to : h.$from)); { let y = gl(f.state, s); return !!y && ko(f, y) } } if (!h.empty || l.indexOf("s") > -1) return !1; if (f.endOfTextblock(s > 0 ? "right" : "left")) { let y = gl(f.state, s); return !!(y && y instanceof Xn) && ko(f, y) } if (!(Xs && l.indexOf("m") > -1)) { let I, y = h.$head, w = y.textOffset ? null : s < 0 ? y.nodeBefore : y.nodeAfter; if (!w || w.isText) return !1; let k = s < 0 ? y.pos - w.nodeSize : y.pos; return !!(w.isAtom || (I = f.docView.descAt(k)) && !I.contentDOM) && (Xn.isSelectable(w) ? ko(f, new Xn(s < 0 ? f.state.doc.resolve(y.pos - w.nodeSize) : y)) : !!q && ko(f, new Jr(f.state.doc.resolve(s < 0 ? k : k + w.nodeSize)))) } } function Rl(f) { return 3 == f.nodeType ? f.nodeValue.length : f.childNodes.length } function $s(f) { let s = f.pmViewDesc; return s && 0 == s.size && (f.nextSibling || "BR" != f.nodeName) } function Fl(f) { let s = f.domSelectionRange(), l = s.focusNode, h = s.focusOffset; if (!l) return; let y, w, I = !1; for (xs && 1 == l.nodeType && h < Rl(l) && $s(l.childNodes[h]) && (I = !0); ;)if (h > 0) { if (1 != l.nodeType) break; { let k = l.childNodes[h - 1]; if ($s(k)) y = l, w = --h; else { if (3 != k.nodeType) break; l = k, h = l.nodeValue.length } } } else { if (Qa(l)) break; { let k = l.previousSibling; for (; k && $s(k);)y = l.parentNode, w = Is(k), k = k.previousSibling; if (k) l = k, h = Rl(l); else { if (l = l.parentNode, l == f.dom) break; h = 0 } } } I ? Xa(f, l, h) : y && Xa(f, y, w) } function Bs(f) { let s = f.domSelectionRange(), l = s.focusNode, h = s.focusOffset; if (!l) return; let w, I, y = Rl(l); for (; ;)if (h < y) { if (1 != l.nodeType) break; if (!$s(l.childNodes[h])) break; w = l, I = ++h } else { if (Qa(l)) break; { let k = l.nextSibling; for (; k && $s(k);)w = k.parentNode, I = Is(k) + 1, k = k.nextSibling; if (k) l = k, h = 0, y = Rl(l); else { if (l = l.parentNode, l == f.dom) break; h = y = 0 } } } w && Xa(f, w, I) } function Qa(f) { let s = f.pmViewDesc; return s && s.node && s.node.isBlock } function Xa(f, s, l) { let h = f.domSelection(); if (Ui(h)) { let w = document.createRange(); w.setEnd(s, l), w.setStart(s, l), h.removeAllRanges(), h.addRange(w) } else h.extend && h.extend(s, l); f.domObserver.setCurSelection(); let { state: y } = f; setTimeout(() => { f.state == y && xr(f) }, 50) } function Kc(f, s, l) { let h = f.state.selection; if (h instanceof Jr && !h.empty || l.indexOf("s") > -1 || Xs && l.indexOf("m") > -1) return !1; let { $from: y, $to: w } = h; if (!y.parent.inlineContent || f.endOfTextblock(s < 0 ? "up" : "down")) { let I = gl(f.state, s); if (I && I instanceof Xn) return ko(f, I) } if (!y.parent.inlineContent) { let I = s < 0 ? y : w, k = h instanceof Si ? gr.near(I, s) : gr.findFrom(I, s); return !!k && ko(f, k) } return !1 } function Sc(f, s) { if (!(f.state.selection instanceof Jr)) return !0; let { $head: l, $anchor: h, empty: y } = f.state.selection; if (!l.sameParent(h)) return !0; if (!y) return !1; if (f.endOfTextblock(s > 0 ? "forward" : "backward")) return !0; let w = !l.textOffset && (s < 0 ? l.nodeBefore : l.nodeAfter); if (w && !w.isText) { let I = f.state.tr; return s < 0 ? I.delete(l.pos - w.nodeSize, l.pos) : I.delete(l.pos, l.pos + w.nodeSize), f.dispatch(I), !0 } return !1 } function Jc(f, s, l) { f.domObserver.stop(), s.contentEditable = l, f.domObserver.start() } function eo(f, s) { f.someProp("transformCopied", ut => { s = ut(s, f) }); let l = [], { content: h, openStart: y, openEnd: w } = s; for (; y > 1 && w > 1 && 1 == h.childCount && 1 == h.firstChild.childCount;) { y--, w--; let ut = h.firstChild; l.push(ut.type.name, ut.attrs != ut.type.defaultAttrs ? ut.attrs : null), h = ut.content } let I = f.someProp("clipboardSerializer") || qe.fromSchema(f.state.schema), k = ao(), H = k.createElement("div"); H.appendChild(I.serializeFragment(h, { document: k })); let se, te = H.firstChild, Ge = 0; for (; te && 1 == te.nodeType && (se = Qc[te.nodeName.toLowerCase()]);) { for (let ut = se.length - 1; ut >= 0; ut--) { let $t = k.createElement(se[ut]); for (; H.firstChild;)$t.appendChild(H.firstChild); H.appendChild($t), Ge++ } te = H.firstChild } return te && 1 == te.nodeType && te.setAttribute("data-pm-slice", `${y} ${w}${Ge ? ` -${Ge}` : ""} ${JSON.stringify(l)}`), { dom: H, text: f.someProp("clipboardTextSerializer", ut => ut(s, f)) || s.content.textBetween(0, s.content.size, "\n\n") } } function Ic(f, s, l, h, y) { let I, k, w = y.parent.type.spec.code; if (!l && !s) return null; let H = s && (h || w || !l); if (H) { if (f.someProp("transformPastedText", at => { s = at(s, w || h, f) }), w) return s ? new Qe(Se.from(f.state.schema.text(s.replace(/\r\n?/g, "\n"))), 0, 0) : Qe.empty; let Ge = f.someProp("clipboardTextParser", at => at(s, y, h, f)); if (Ge) k = Ge; else { let at = y.marks(), { schema: ut } = f.state, $t = qe.fromSchema(ut); I = document.createElement("div"), s.split(/(?:\r\n?|\n)+/).forEach(Dn => { let $n = I.appendChild(document.createElement("p")); Dn && $n.appendChild($t.serializeNode(ut.text(Dn, at))) }) } } else f.someProp("transformPastedHTML", Ge => { l = Ge(l, f) }), I = function xc(f) { let s = /^(\s*<meta [^>]*>)*/.exec(f); s && (f = f.slice(s[0].length)); let y, l = ao().createElement("div"), h = /<([a-z][^>\s]+)/i.exec(f); if ((y = h && Qc[h[1].toLowerCase()]) && (f = y.map(w => "<" + w + ">").join("") + f + y.map(w => "</" + w + ">").reverse().join("")), l.innerHTML = f, y) for (let w = 0; w < y.length; w++)l = l.querySelector(y[w]) || l; return l }(l), q && function Vu(f) { let s = f.querySelectorAll(Hi ? "span:not([class]):not([style])" : "span.Apple-converted-space"); for (let l = 0; l < s.length; l++) { let h = s[l]; 1 == h.childNodes.length && "\xa0" == h.textContent && h.parentNode && h.parentNode.replaceChild(f.ownerDocument.createTextNode(" "), h) } }(I); let te = I && I.querySelector("[data-pm-slice]"), se = te && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(te.getAttribute("data-pm-slice") || ""); if (se && se[3]) for (let Ge = +se[3]; Ge > 0; Ge--) { let at = I.firstChild; for (; at && 1 != at.nodeType;)at = at.nextSibling; if (!at) break; I = at } if (k || (k = (f.someProp("clipboardParser") || f.someProp("domParser") || yn.fromSchema(f.state.schema)).parseSlice(I, { preserveWhitespace: !(!H && !se), context: y, ruleFromNode: at => "BR" != at.nodeName || at.nextSibling || !at.parentNode || ra.test(at.parentNode.nodeName) ? null : { ignore: !0 } })), se) k = function Ia(f, s) { if (!f.size) return f; let h, l = f.content.firstChild.type.schema; try { h = JSON.parse(s) } catch { return f } let { content: y, openStart: w, openEnd: I } = f; for (let k = h.length - 2; k >= 0; k -= 2) { let H = l.nodes[h[k]]; if (!H || H.hasRequiredAttrs()) break; y = Se.from(H.create(h[k + 1], y)), w++, I++ } return new Qe(y, w, I) }(Bu(k, +se[1], +se[2]), se[4]); else if (k = Qe.maxOpen(function ia(f, s) { if (f.childCount < 2) return f; for (let l = s.depth; l >= 0; l--) { let w, y = s.node(l).contentMatchAt(s.index(l)), I = []; if (f.forEach(k => { if (!I) return; let te, H = y.findWrapping(k.type); if (!H) return I = null; if (te = I.length && w.length && el(H, w, k, I[I.length - 1], 0)) I[I.length - 1] = te; else { I.length && (I[I.length - 1] = Yo(I[I.length - 1], w.length)); let se = Ac(k, H); I.push(se), y = y.matchType(se.type), w = H } }), I) return Se.from(I) } return f }(k.content, y), !0), k.openStart || k.openEnd) { let Ge = 0, at = 0; for (let ut = k.content.firstChild; Ge < k.openStart && !ut.type.spec.isolating; Ge++, ut = ut.firstChild); for (let ut = k.content.lastChild; at < k.openEnd && !ut.type.spec.isolating; at++, ut = ut.lastChild); k = Bu(k, Ge, at) } return f.someProp("transformPasted", Ge => { k = Ge(k, f) }), k } const ra = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i; function Ac(f, s, l = 0) { for (let h = s.length - 1; h >= l; h--)f = s[h].create(null, Se.from(f)); return f } function el(f, s, l, h, y) { if (y < f.length && y < s.length && f[y] == s[y]) { let w = el(f, s, l, h.lastChild, y + 1); if (w) return h.copy(h.content.replaceChild(h.childCount - 1, w)); if (h.contentMatchAt(h.childCount).matchType(y == f.length - 1 ? l.type : f[y + 1])) return h.copy(h.content.append(Se.from(Ac(l, f, y + 1)))) } } function Yo(f, s) { if (0 == s) return f; let l = f.content.replaceChild(f.childCount - 1, Yo(f.lastChild, s - 1)), h = f.contentMatchAt(f.childCount).fillBefore(Se.empty, !0); return f.copy(l.append(h)) } function Ko(f, s, l, h, y, w) { let I = s < 0 ? f.firstChild : f.lastChild, k = I.content; return y < h - 1 && (k = Ko(k, s, l, h, y + 1, w)), y >= l && (k = s < 0 ? I.contentMatchAt(0).fillBefore(k, f.childCount > 1 || w <= y).append(k) : k.append(I.contentMatchAt(I.childCount).fillBefore(Se.empty, !0))), f.replaceChild(s < 0 ? 0 : f.childCount - 1, I.copy(k)) } function Bu(f, s, l) { return s < f.openStart && (f = new Qe(Ko(f.content, -1, s, f.openStart, 0, f.openEnd), s, f.openEnd)), l < f.openEnd && (f = new Qe(Ko(f.content, 1, l, f.openEnd, 0, 0), f.openStart, l)), f } const Qc = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] }; let Sa = null; function ao() { return Sa || (Sa = document.implementation.createHTMLDocument("title")) } const Vs = {}, ii = {}, tc = { touchstart: !0, touchmove: !0 }; class ud { constructor() { this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.domChangeCount = 0, this.eventHandlers = Object.create(null), this.hideSelectionGuard = null } } function ci(f, s) { f.input.lastSelectionOrigin = s, f.input.lastSelectionTime = Date.now() } function Mi(f) { f.someProp("handleDOMEvents", s => { for (let l in s) f.input.eventHandlers[l] || f.dom.addEventListener(l, f.input.eventHandlers[l] = h => Mc(f, h)) }) } function Mc(f, s) { return f.someProp("handleDOMEvents", l => { let h = l[s.type]; return !!h && (h(f, s) || s.defaultPrevented) }) } function Oc(f, s) { if (!s.bubbles) return !0; if (s.defaultPrevented) return !1; for (let l = s.target; l != f.dom; l = l.parentNode)if (!l || 11 == l.nodeType || l.pmViewDesc && l.pmViewDesc.stopEvent(s)) return !1; return !0 } function tl(f) { return { left: f.clientX, top: f.clientY } } function Jo(f, s, l, h, y) { if (-1 == h) return !1; let w = f.state.doc.resolve(h); for (let I = w.depth + 1; I > 0; I--)if (f.someProp(s, k => I > w.depth ? k(f, l, w.nodeAfter, w.before(I), y, !0) : k(f, l, w.node(I), w.before(I), y, !1))) return !0; return !1 } function ml(f, s, l) { f.focused || f.focus(); let h = f.state.tr.setSelection(s); "pointer" == l && h.setMeta("pointer", !0), f.dispatch(h) } function ji(f, s, l, h) { return Jo(f, "handleDoubleClickOn", s, l, h) || f.someProp("handleDoubleClick", y => y(f, s, h)) } function R(f, s, l, h) { return Jo(f, "handleTripleClickOn", s, l, h) || f.someProp("handleTripleClick", y => y(f, s, h)) || function V(f, s, l) { if (0 != l.button) return !1; let h = f.state.doc; if (-1 == s) return !!h.inlineContent && (ml(f, Jr.create(h, 0, h.content.size), "pointer"), !0); let y = h.resolve(s); for (let w = y.depth + 1; w > 0; w--) { let I = w > y.depth ? y.nodeAfter : y.node(w), k = y.before(w); if (I.inlineContent) ml(f, Jr.create(h, k + 1, k + 1 + I.content.size), "pointer"); else { if (!Xn.isSelectable(I)) continue; ml(f, Xn.create(h, k), "pointer") } return !0 } }(f, l, h) } function M(f) { return Vn(f) } ii.keydown = (f, s) => { let l = s; if (f.input.shiftKey = 16 == l.keyCode || l.shiftKey, !ce(f, l) && (f.input.lastKeyCode = l.keyCode, f.input.lastKeyCodeTime = Date.now(), !Q || !Hi || 13 != l.keyCode)) if (229 != l.keyCode && f.domObserver.forceFlush(), !hr || 13 != l.keyCode || l.ctrlKey || l.altKey || l.metaKey) f.someProp("handleKeyDown", h => h(f, l)) || function Lu(f, s) { let l = s.keyCode, h = function yu(f) { let s = ""; return f.ctrlKey && (s += "c"), f.metaKey && (s += "m"), f.altKey && (s += "a"), f.shiftKey && (s += "s"), s }(s); return 8 == l || Xs && 72 == l && "c" == h ? Sc(f, -1) || Fl(f) : 46 == l || Xs && 68 == l && "c" == h ? Sc(f, 1) || Bs(f) : 13 == l || 27 == l || (37 == l || Xs && 66 == l && "c" == h ? Pl(f, -1, h) || Fl(f) : 39 == l || Xs && 70 == l && "c" == h ? Pl(f, 1, h) || Bs(f) : 38 == l || Xs && 80 == l && "c" == h ? Kc(f, -1, h) || Fl(f) : 40 == l || Xs && 78 == l && "c" == h ? function Ll(f) { if (!ys || f.state.selection.$head.parentOffset > 0) return !1; let { focusNode: s, focusOffset: l } = f.domSelectionRange(); if (s && 1 == s.nodeType && 0 == l && s.firstChild && "false" == s.firstChild.contentEditable) { let h = s.firstChild; Jc(f, h, "true"), setTimeout(() => Jc(f, h, "false"), 20) } return !1 }(f) || Kc(f, 1, h) || Bs(f) : h == (Xs ? "m" : "c") && (66 == l || 73 == l || 89 == l || 90 == l)) }(f, l) ? l.preventDefault() : ci(f, "key"); else { let h = Date.now(); f.input.lastIOSEnter = h, f.input.lastIOSEnterFallbackTimeout = setTimeout(() => { f.input.lastIOSEnter == h && (f.someProp("handleKeyDown", y => y(f, Js(13, "Enter"))), f.input.lastIOSEnter = 0) }, 200) } }, ii.keyup = (f, s) => { 16 == s.keyCode && (f.input.shiftKey = !1) }, ii.keypress = (f, s) => { let l = s; if (ce(f, l) || !l.charCode || l.ctrlKey && !l.altKey || Xs && l.metaKey) return; if (f.someProp("handleKeyPress", y => y(f, l))) return void l.preventDefault(); let h = f.state.selection; if (!(h instanceof Jr && h.$from.sameParent(h.$to))) { let y = String.fromCharCode(l.charCode); f.someProp("handleTextInput", w => w(f, h.$from.pos, h.$to.pos, y)) || f.dispatch(f.state.tr.insertText(y).scrollIntoView()), l.preventDefault() } }; const G = Xs ? "metaKey" : "ctrlKey"; Vs.mousedown = (f, s) => { let l = s; f.input.shiftKey = l.shiftKey; let h = M(f), y = Date.now(), w = "singleClick"; y - f.input.lastClick.time < 500 && function Pe(f, s) { let l = s.x - f.clientX, h = s.y - f.clientY; return l * l + h * h < 100 }(l, f.input.lastClick) && !l[G] && ("singleClick" == f.input.lastClick.type ? w = "doubleClick" : "doubleClick" == f.input.lastClick.type && (w = "tripleClick")), f.input.lastClick = { time: y, x: l.clientX, y: l.clientY, type: w }; let I = f.posAtCoords(tl(l)); I && ("singleClick" == w ? (f.input.mouseDown && f.input.mouseDown.done(), f.input.mouseDown = new X(f, I, l, !!h)) : ("doubleClick" == w ? ji : R)(f, I.pos, I.inside, l) ? l.preventDefault() : ci(f, "pointer")) }; class X { constructor(s, l, h, y) { let w, I; if (this.view = s, this.pos = l, this.event = h, this.flushed = y, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = s.state.doc, this.selectNode = !!h[G], this.allowDefault = h.shiftKey, l.inside > -1) w = s.state.doc.nodeAt(l.inside), I = l.inside; else { let se = s.state.doc.resolve(l.pos); w = se.parent, I = se.depth ? se.before() : 0 } const k = y ? null : h.target, H = k ? s.docView.nearestDesc(k, !0) : null; this.target = H ? H.dom : null; let { selection: te } = s.state; (0 == h.button && w.type.spec.draggable && !1 !== w.type.spec.selectable || te instanceof Xn && te.from <= I && te.to > I) && (this.mightDrag = { node: w, pos: I, addAttr: !(!this.target || this.target.draggable), setUneditable: !(!this.target || !xs || this.target.hasAttribute("contentEditable")) }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => { this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false") }, 20), this.view.domObserver.start()), s.root.addEventListener("mouseup", this.up = this.up.bind(this)), s.root.addEventListener("mousemove", this.move = this.move.bind(this)), ci(s, "pointer") } done() { this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => xr(this.view)), this.view.input.mouseDown = null } up(s) { if (this.done(), !this.view.dom.contains(s.target)) return; let l = this.pos; this.view.state.doc != this.startDoc && (l = this.view.posAtCoords(tl(s))), this.updateAllowDefault(s), this.allowDefault || !l ? ci(this.view, "pointer") : function Xc(f, s, l, h, y) { return Jo(f, "handleClickOn", s, l, h) || f.someProp("handleClick", w => w(f, s, h)) || (y ? function Bl(f, s) { if (-1 == s) return !1; let h, y, l = f.state.selection; l instanceof Xn && (h = l.node); let w = f.state.doc.resolve(s); for (let I = w.depth + 1; I > 0; I--) { let k = I > w.depth ? w.nodeAfter : w.node(I); if (Xn.isSelectable(k)) { y = h && l.$from.depth > 0 && I >= l.$from.depth && w.before(l.$from.depth + 1) == l.$from.pos ? w.before(l.$from.depth) : w.before(I); break } } return null != y && (ml(f, Xn.create(f.state.doc, y), "pointer"), !0) }(f, l) : function Nc(f, s) { if (-1 == s) return !1; let l = f.state.doc.resolve(s), h = l.nodeAfter; return !!(h && h.isAtom && Xn.isSelectable(h)) && (ml(f, new Xn(l), "pointer"), !0) }(f, l)) }(this.view, l.pos, l.inside, s, this.selectNode) ? s.preventDefault() : 0 == s.button && (this.flushed || ys && this.mightDrag && !this.mightDrag.node.isAtom || Hi && !this.view.state.selection.visible && Math.min(Math.abs(l.pos - this.view.state.selection.from), Math.abs(l.pos - this.view.state.selection.to)) <= 2) ? (ml(this.view, gr.near(this.view.state.doc.resolve(l.pos)), "pointer"), s.preventDefault()) : ci(this.view, "pointer") } move(s) { this.updateAllowDefault(s), ci(this.view, "pointer"), 0 == s.buttons && this.done() } updateAllowDefault(s) { !this.allowDefault && (Math.abs(this.event.x - s.clientX) > 4 || Math.abs(this.event.y - s.clientY) > 4) && (this.allowDefault = !0) } } function ce(f, s) { return !!f.composing || !!(ys && Math.abs(s.timeStamp - f.input.compositionEndedAt) < 500) && (f.input.compositionEndedAt = -2e8, !0) } Vs.touchstart = f => { f.input.lastTouch = Date.now(), M(f), ci(f, "pointer") }, Vs.touchmove = f => { f.input.lastTouch = Date.now(), ci(f, "pointer") }, Vs.contextmenu = f => M(f); const be = Q ? 5e3 : -1; function St(f, s) { clearTimeout(f.input.composingTimeout), s > -1 && (f.input.composingTimeout = setTimeout(() => Vn(f), s)) } function on(f) { for (f.composing && (f.input.composing = !1, f.input.compositionEndedAt = function Kn() { let f = document.createEvent("Event"); return f.initEvent("event", !0, !0), f.timeStamp }()); f.input.compositionNodes.length > 0;)f.input.compositionNodes.pop().markParentsDirty() } function Vn(f, s = !1) { if (!(Q && f.domObserver.flushingSoon >= 0)) { if (f.domObserver.forceFlush(), on(f), s || f.docView && f.docView.dirty) { let l = Or(f); return l && !l.eq(f.state.selection) ? f.dispatch(f.state.tr.setSelection(l)) : f.updateState(f.state), !0 } return !1 } } ii.compositionstart = ii.compositionupdate = f => { if (!f.composing) { f.domObserver.flush(); let { state: s } = f, l = s.selection.$from; if (s.selection.empty && (s.storedMarks || !l.textOffset && l.parentOffset && l.nodeBefore.marks.some(h => !1 === h.type.spec.inclusive))) f.markCursor = f.state.storedMarks || l.marks(), Vn(f, !0), f.markCursor = null; else if (Vn(f), xs && s.selection.empty && l.parentOffset && !l.textOffset && l.nodeBefore.marks.length) { let h = f.domSelectionRange(); for (let y = h.focusNode, w = h.focusOffset; y && 1 == y.nodeType && 0 != w;) { let I = w < 0 ? y.lastChild : y.childNodes[w - 1]; if (!I) break; if (3 == I.nodeType) { f.domSelection().collapse(I, I.nodeValue.length); break } y = I, w = -1 } } f.input.composing = !0 } St(f, be) }, ii.compositionend = (f, s) => { f.composing && (f.input.composing = !1, f.input.compositionEndedAt = s.timeStamp, St(f, 20)) }; const Gr = Zr && oo < 15 || hr && $ < 604; function Wi(f, s, l, h) { let y = Ic(f, s, l, f.input.shiftKey, f.state.selection.$from); if (f.someProp("handlePaste", k => k(f, h, y || Qe.empty))) return !0; if (!y) return !1; let w = function Sr(f) { return 0 == f.openStart && 0 == f.openEnd && 1 == f.content.childCount ? f.content.firstChild : null }(y), I = w ? f.state.tr.replaceSelectionWith(w, f.input.shiftKey) : f.state.tr.replaceSelection(y); return f.dispatch(I.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0 } Vs.copy = ii.cut = (f, s) => { let l = s, h = f.state.selection, y = "cut" == l.type; if (h.empty) return; let w = Gr ? null : l.clipboardData, I = h.content(), { dom: k, text: H } = eo(f, I); w ? (l.preventDefault(), w.clearData(), w.setData("text/html", k.innerHTML), w.setData("text/plain", H)) : function Lr(f, s) { if (!f.dom.parentNode) return; let l = f.dom.parentNode.appendChild(document.createElement("div")); l.appendChild(s), l.style.cssText = "position: fixed; left: -10000px; top: 10px"; let h = getSelection(), y = document.createRange(); y.selectNodeContents(s), f.dom.blur(), h.removeAllRanges(), h.addRange(y), setTimeout(() => { l.parentNode && l.parentNode.removeChild(l), f.focus() }, 50) }(f, k), y && f.dispatch(f.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")) }, ii.paste = (f, s) => { let l = s; if (f.composing && !Q) return; let h = Gr ? null : l.clipboardData; h && Wi(f, h.getData("text/plain"), h.getData("text/html"), l) ? l.preventDefault() : function $i(f, s) { if (!f.dom.parentNode) return; let l = f.input.shiftKey || f.state.selection.$from.parent.type.spec.code, h = f.dom.parentNode.appendChild(document.createElement(l ? "textarea" : "div")); l || (h.contentEditable = "true"), h.style.cssText = "position: fixed; left: -10000px; top: 10px", h.focus(), setTimeout(() => { f.focus(), h.parentNode && h.parentNode.removeChild(h), l ? Wi(f, h.value, null, s) : Wi(f, h.textContent, h.innerHTML, s) }, 50) }(f, l) }; class sa { constructor(s, l) { this.slice = s, this.move = l } } const bu = Xs ? "altKey" : "ctrlKey"; Vs.dragstart = (f, s) => { let l = s, h = f.input.mouseDown; if (h && h.done(), !l.dataTransfer) return; let y = f.state.selection, w = y.empty ? null : f.posAtCoords(tl(l)); if (!(w && w.pos >= y.from && w.pos <= (y instanceof Xn ? y.to - 1 : y.to))) if (h && h.mightDrag) f.dispatch(f.state.tr.setSelection(Xn.create(f.state.doc, h.mightDrag.pos))); else if (l.target && 1 == l.target.nodeType) { let te = f.docView.nearestDesc(l.target, !0); te && te.node.type.spec.draggable && te != f.docView && f.dispatch(f.state.tr.setSelection(Xn.create(f.state.doc, te.posBefore))) } let I = f.state.selection.content(), { dom: k, text: H } = eo(f, I); l.dataTransfer.clearData(), l.dataTransfer.setData(Gr ? "Text" : "text/html", k.innerHTML), l.dataTransfer.effectAllowed = "copyMove", Gr || l.dataTransfer.setData("text/plain", H), f.dragging = new sa(I, !l[bu]) }, Vs.dragend = f => { let s = f.dragging; window.setTimeout(() => { f.dragging == s && (f.dragging = null) }, 50) }, ii.dragover = ii.dragenter = (f, s) => s.preventDefault(), ii.drop = (f, s) => { let l = s, h = f.dragging; if (f.dragging = null, !l.dataTransfer) return; let y = f.posAtCoords(tl(l)); if (!y) return; let w = f.state.doc.resolve(y.pos), I = h && h.slice; I ? f.someProp("transformPasted", $t => { I = $t(I, f) }) : I = Ic(f, l.dataTransfer.getData(Gr ? "Text" : "text/plain"), Gr ? null : l.dataTransfer.getData("text/html"), !1, w); let k = !(!h || l[bu]); if (f.someProp("handleDrop", $t => $t(f, l, I || Qe.empty, k))) return void l.preventDefault(); if (!I) return; l.preventDefault(); let H = I ? function al(f, s, l) { let h = f.resolve(s); if (!l.content.size) return s; let y = l.content; for (let w = 0; w < l.openStart; w++)y = y.firstChild.content; for (let w = 1; w <= (0 == l.openStart && l.size ? 2 : 1); w++)for (let I = h.depth; I >= 0; I--) { let k = I == h.depth ? 0 : h.pos <= (h.start(I + 1) + h.end(I + 1)) / 2 ? -1 : 1, H = h.index(I) + (k > 0 ? 1 : 0), te = h.node(I), se = !1; if (1 == w) se = te.canReplace(H, H, y); else { let Ge = te.contentMatchAt(H).findWrapping(y.firstChild.type); se = Ge && te.canReplaceWith(H, H, Ge[0]) } if (se) return 0 == k ? h.pos : k < 0 ? h.before(I + 1) : h.after(I + 1) } return null }(f.state.doc, w.pos, I) : w.pos; null == H && (H = w.pos); let te = f.state.tr; k && te.deleteSelection(); let se = te.mapping.map(H), Ge = 0 == I.openStart && 0 == I.openEnd && 1 == I.content.childCount, at = te.doc; if (Ge ? te.replaceRangeWith(se, se, I.content.firstChild) : te.replaceRange(se, se, I), te.doc.eq(at)) return; let ut = te.doc.resolve(se); if (Ge && Xn.isSelectable(I.content.firstChild) && ut.nodeAfter && ut.nodeAfter.sameMarkup(I.content.firstChild)) te.setSelection(new Xn(ut)); else { let $t = te.mapping.map(H); te.mapping.maps[te.mapping.maps.length - 1].forEach((Dn, $n, fi, uu) => $t = uu), te.setSelection(Dc(f, ut, te.doc.resolve($t))) } f.focus(), f.dispatch(te.setMeta("uiEvent", "drop")) }, Vs.focus = f => { f.input.lastFocus = Date.now(), f.focused || (f.domObserver.stop(), f.dom.classList.add("ProseMirror-focused"), f.domObserver.start(), f.focused = !0, setTimeout(() => { f.docView && f.hasFocus() && !f.domObserver.currentSelection.eq(f.domSelectionRange()) && xr(f) }, 20)) }, Vs.blur = (f, s) => { let l = s; f.focused && (f.domObserver.stop(), f.dom.classList.remove("ProseMirror-focused"), f.domObserver.start(), l.relatedTarget && f.dom.contains(l.relatedTarget) && f.domObserver.currentSelection.clear(), f.focused = !1) }, Vs.beforeinput = (f, s) => { if (Hi && Q && "deleteContentBackward" == s.inputType) { f.domObserver.flushSoon(); let { domChangeCount: h } = f.input; setTimeout(() => { if (f.input.domChangeCount != h || (f.dom.blur(), f.focus(), f.someProp("handleKeyDown", w => w(f, Js(8, "Backspace"))))) return; let { $cursor: y } = f.state.selection; y && y.pos > 0 && f.dispatch(f.state.tr.delete(y.pos - 1, y.pos).scrollIntoView()) }, 50) } }; for (let f in ii) Vs[f] = ii[f]; function lo(f, s) { if (f == s) return !0; for (let l in f) if (f[l] !== s[l]) return !1; for (let l in s) if (!(l in f)) return !1; return !0 } class oa { constructor(s, l) { this.toDOM = s, this.spec = l || la, this.side = this.spec.side || 0 } map(s, l, h, y) { let { pos: w, deleted: I } = s.mapResult(l.from + y, this.side < 0 ? -1 : 1); return I ? null : new Qo(w - h, w - h, this) } valid() { return !0 } eq(s) { return this == s || s instanceof oa && (this.spec.key && this.spec.key == s.spec.key || this.toDOM == s.toDOM && lo(this.spec, s.spec)) } destroy(s) { this.spec.destroy && this.spec.destroy(s) } } class Ns { constructor(s, l) { this.attrs = s, this.spec = l || la } map(s, l, h, y) { let w = s.map(l.from + y, this.spec.inclusiveStart ? -1 : 1) - h, I = s.map(l.to + y, this.spec.inclusiveEnd ? 1 : -1) - h; return w >= I ? null : new Qo(w, I, this) } valid(s, l) { return l.from < l.to } eq(s) { return this == s || s instanceof Ns && lo(this.attrs, s.attrs) && lo(this.spec, s.spec) } static is(s) { return s.type instanceof Ns } destroy() { } } class kc { constructor(s, l) { this.attrs = s, this.spec = l || la } map(s, l, h, y) { let w = s.mapResult(l.from + y, 1); if (w.deleted) return null; let I = s.mapResult(l.to + y, -1); return I.deleted || I.pos <= w.pos ? null : new Qo(w.pos - h, I.pos - h, this) } valid(s, l) { let w, { index: h, offset: y } = s.content.findIndex(l.from); return y == l.from && !(w = s.child(h)).isText && y + w.nodeSize == l.to } eq(s) { return this == s || s instanceof kc && lo(this.attrs, s.attrs) && lo(this.spec, s.spec) } destroy() { } } class Qo { constructor(s, l, h) { this.from = s, this.to = l, this.type = h } copy(s, l) { return new Qo(s, l, this.type) } eq(s, l = 0) { return this.type.eq(s.type) && this.from + l == s.from && this.to + l == s.to } map(s, l, h) { return this.type.map(s, this, l, h) } static widget(s, l, h) { return new Qo(s, s, new oa(l, h)) } static inline(s, l, h, y) { return new Qo(s, l, new Ns(h, y)) } static node(s, l, h, y) { return new Qo(s, l, new kc(h, y)) } get spec() { return this.type.spec } get inline() { return this.type instanceof Ns } } const aa = [], la = {}; class ps { constructor(s, l) { this.local = s.length ? s : aa, this.children = l.length ? l : aa } static create(s, l) { return l.length ? _n(l, s, 0, la) : vi } find(s, l, h) { let y = []; return this.findInner(s ?? 0, l ?? 1e9, y, 0, h), y } findInner(s, l, h, y, w) { for (let I = 0; I < this.local.length; I++) { let k = this.local[I]; k.from <= l && k.to >= s && (!w || w(k.spec)) && h.push(k.copy(k.from + y, k.to + y)) } for (let I = 0; I < this.children.length; I += 3)if (this.children[I] < l && this.children[I + 1] > s) { let k = this.children[I] + 1; this.children[I + 2].findInner(s - k, l - k, h, y + k, w) } } map(s, l, h) { return this == vi || 0 == s.maps.length ? this : this.mapInner(s, l, 0, 0, h || la) } mapInner(s, l, h, y, w) { let I; for (let k = 0; k < this.local.length; k++) { let H = this.local[k].map(s, h, y); H && H.type.valid(l, H) ? (I || (I = [])).push(H) : w.onRemove && w.onRemove(this.local[k].spec) } return this.children.length ? function ee(f, s, l, h, y, w, I) { let k = f.slice(); for (let te = 0, se = w; te < l.maps.length; te++) { let Ge = 0; l.maps[te].forEach((at, ut, $t, Dn) => { let $n = Dn - $t - (ut - at); for (let fi = 0; fi < k.length; fi += 3) { let uu = k[fi + 1]; if (uu < 0 || at > uu + se - Ge) continue; let za = k[fi] + se - Ge; ut >= za ? k[fi + 1] = at <= za ? -2 : -1 : $t >= y && $n && (k[fi] += $n, k[fi + 1] += $n) } Ge += $n }), se = l.maps[te].map(se, -1) } let H = !1; for (let te = 0; te < k.length; te += 3)if (k[te + 1] < 0) { if (-2 == k[te + 1]) { H = !0, k[te + 1] = -1; continue } let se = l.map(f[te] + w), Ge = se - y; if (Ge < 0 || Ge >= h.content.size) { H = !0; continue } let ut = l.map(f[te + 1] + w, -1) - y, { index: $t, offset: Dn } = h.content.findIndex(Ge), $n = h.maybeChild($t); if ($n && Dn == Ge && Dn + $n.nodeSize == ut) { let fi = k[te + 2].mapInner(l, $n, se + 1, f[te] + w + 1, I); fi != vi ? (k[te] = Ge, k[te + 1] = ut, k[te + 2] = fi) : (k[te + 1] = -2, H = !0) } else H = !0 } if (H) { let te = function We(f, s, l, h, y, w, I) { function k(H, te) { for (let se = 0; se < H.local.length; se++) { let Ge = H.local[se].map(h, y, te); Ge ? l.push(Ge) : I.onRemove && I.onRemove(H.local[se].spec) } for (let se = 0; se < H.children.length; se += 3)k(H.children[se + 2], H.children[se] + te + 1) } for (let H = 0; H < f.length; H += 3)-1 == f[H + 1] && k(f[H + 2], s[H] + w + 1); return l }(k, f, s, l, y, w, I), se = _n(te, h, 0, I); s = se.local; for (let Ge = 0; Ge < k.length; Ge += 3)k[Ge + 1] < 0 && (k.splice(Ge, 3), Ge -= 3); for (let Ge = 0, at = 0; Ge < se.children.length; Ge += 3) { let ut = se.children[Ge]; for (; at < k.length && k[at] < ut;)at += 3; k.splice(at, 0, se.children[Ge], se.children[Ge + 1], se.children[Ge + 2]) } } return new ps(s.sort(jn), k) }(this.children, I || [], s, l, h, y, w) : I ? new ps(I.sort(jn), aa) : vi } add(s, l) { return l.length ? this == vi ? ps.create(s, l) : this.addInner(s, l, 0) : this } addInner(s, l, h) { let y, w = 0; s.forEach((k, H) => { let se, te = H + h; if (se = xt(l, k, te)) { for (y || (y = this.children.slice()); w < y.length && y[w] < H;)w += 3; y[w] == H ? y[w + 2] = y[w + 2].addInner(k, se, te + 1) : y.splice(w, 0, H, H + k.nodeSize, _n(se, k, te + 1, la)), w += 3 } }); let I = de(w ? zt(l) : l, -h); for (let k = 0; k < I.length; k++)I[k].type.valid(s, I[k]) || I.splice(k--, 1); return new ps(I.length ? this.local.concat(I).sort(jn) : this.local, y || this.children) } remove(s) { return 0 == s.length || this == vi ? this : this.removeInner(s, 0) } removeInner(s, l) { let h = this.children, y = this.local; for (let w = 0; w < h.length; w += 3) { let I, k = h[w] + l, H = h[w + 1] + l; for (let Ge, se = 0; se < s.length; se++)(Ge = s[se]) && Ge.from > k && Ge.to < H && (s[se] = null, (I || (I = [])).push(Ge)); if (!I) continue; h == this.children && (h = this.children.slice()); let te = h[w + 2].removeInner(I, k + 1); te != vi ? h[w + 2] = te : (h.splice(w, 3), w -= 3) } if (y.length) for (let I, w = 0; w < s.length; w++)if (I = s[w]) for (let k = 0; k < y.length; k++)y[k].eq(I, l) && (y == this.local && (y = this.local.slice()), y.splice(k--, 1)); return h == this.children && y == this.local ? this : y.length || h.length ? new ps(y, h) : vi } forChild(s, l) { if (this == vi) return this; if (l.isLeaf) return ps.empty; let h, y; for (let k = 0; k < this.children.length; k += 3)if (this.children[k] >= s) { this.children[k] == s && (h = this.children[k + 2]); break } let w = s + 1, I = w + l.content.size; for (let k = 0; k < this.local.length; k++) { let H = this.local[k]; if (H.from < I && H.to > w && H.type instanceof Ns) { let te = Math.max(w, H.from) - w, se = Math.min(I, H.to) - w; te < se && (y || (y = [])).push(H.copy(te, se)) } } if (y) { let k = new ps(y.sort(jn), aa); return h ? new W([k, h]) : k } return h || vi } eq(s) { if (this == s) return !0; if (!(s instanceof ps) || this.local.length != s.local.length || this.children.length != s.children.length) return !1; for (let l = 0; l < this.local.length; l++)if (!this.local[l].eq(s.local[l])) return !1; for (let l = 0; l < this.children.length; l += 3)if (this.children[l] != s.children[l] || this.children[l + 1] != s.children[l + 1] || !this.children[l + 2].eq(s.children[l + 2])) return !1; return !0 } locals(s) { return er(this.localsInner(s)) } localsInner(s) { if (this == vi) return aa; if (s.inlineContent || !this.local.some(Ns.is)) return this.local; let l = []; for (let h = 0; h < this.local.length; h++)this.local[h].type instanceof Ns || l.push(this.local[h]); return l } } ps.empty = new ps([], []), ps.removeOverlap = er; const vi = ps.empty; class W { constructor(s) { this.members = s } map(s, l) { const h = this.members.map(y => y.map(s, l, la)); return W.from(h) } forChild(s, l) { if (l.isLeaf) return ps.empty; let h = []; for (let y = 0; y < this.members.length; y++) { let w = this.members[y].forChild(s, l); w != vi && (w instanceof W ? h = h.concat(w.members) : h.push(w)) } return W.from(h) } eq(s) { if (!(s instanceof W) || s.members.length != this.members.length) return !1; for (let l = 0; l < this.members.length; l++)if (!this.members[l].eq(s.members[l])) return !1; return !0 } locals(s) { let l, h = !0; for (let y = 0; y < this.members.length; y++) { let w = this.members[y].localsInner(s); if (w.length) if (l) { h && (l = l.slice(), h = !1); for (let I = 0; I < w.length; I++)l.push(w[I]) } else l = w } return l ? er(h ? l : l.sort(jn)) : aa } static from(s) { switch (s.length) { case 0: return vi; case 1: return s[0]; default: return new W(s.every(l => l instanceof ps) ? s : s.reduce((l, h) => l.concat(h instanceof ps ? h : h.members), [])) } } } function de(f, s) { if (!s || !f.length) return f; let l = []; for (let h = 0; h < f.length; h++) { let y = f[h]; l.push(new Qo(y.from + s, y.to + s, y.type)) } return l } function xt(f, s, l) { if (s.isLeaf) return null; let h = l + s.nodeSize, y = null; for (let I, w = 0; w < f.length; w++)(I = f[w]) && I.from > l && I.to < h && ((y || (y = [])).push(I), f[w] = null); return y } function zt(f) { let s = []; for (let l = 0; l < f.length; l++)null != f[l] && s.push(f[l]); return s } function _n(f, s, l, h) { let y = [], w = !1; s.forEach((k, H) => { let te = xt(f, k, H + l); if (te) { w = !0; let se = _n(te, k, l + H + 1, h); se != vi && y.push(H, H + k.nodeSize, se) } }); let I = de(w ? zt(f) : f, -l).sort(jn); for (let k = 0; k < I.length; k++)I[k].type.valid(s, I[k]) || (h.onRemove && h.onRemove(I[k].spec), I.splice(k--, 1)); return I.length || y.length ? new ps(I, y) : vi } function jn(f, s) { return f.from - s.from || f.to - s.to } function er(f) { let s = f; for (let l = 0; l < s.length - 1; l++) { let h = s[l]; if (h.from != h.to) for (let y = l + 1; y < s.length; y++) { let w = s[y]; if (w.from != h.from) { w.from < h.to && (s == f && (s = f.slice()), s[l] = h.copy(h.from, w.from), ir(s, y, h.copy(w.from, h.to))); break } w.to != h.to && (s == f && (s = f.slice()), s[y] = w.copy(w.from, h.to), ir(s, y + 1, w.copy(h.to, w.to))) } } return s } function ir(f, s, l) { for (; s < f.length && jn(l, f[s]) > 0;)s++; f.splice(s, 0, l) } function Ir(f) { let s = []; return f.someProp("decorations", l => { let h = l(f.state); h && h != vi && s.push(h) }), f.cursorWrapper && s.push(ps.create(f.state.doc, [f.cursorWrapper.deco])), W.from(s) } const Pr = { childList: !0, characterData: !0, characterDataOldValue: !0, attributes: !0, attributeOldValue: !0, subtree: !0 }, ca = Zr && oo <= 11; class Ws { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } set(s) { this.anchorNode = s.anchorNode, this.anchorOffset = s.anchorOffset, this.focusNode = s.focusNode, this.focusOffset = s.focusOffset } clear() { this.anchorNode = this.focusNode = null } eq(s) { return s.anchorNode == this.anchorNode && s.anchorOffset == this.anchorOffset && s.focusNode == this.focusNode && s.focusOffset == this.focusOffset } } class Vl { constructor(s, l) { this.view = s, this.handleDOMChange = l, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Ws, this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver(h => { for (let y = 0; y < h.length; y++)this.queue.push(h[y]); Zr && oo <= 11 && h.some(y => "childList" == y.type && y.removedNodes.length || "characterData" == y.type && y.oldValue.length > y.target.nodeValue.length) ? this.flushSoon() : this.flush() }), ca && (this.onCharData = h => { this.queue.push({ target: h.target, type: "characterData", oldValue: h.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this) } flushSoon() { this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1, this.flush() }, 20)) } forceFlush() { this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush()) } start() { this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Pr)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection() } stop() { if (this.observer) { let s = this.observer.takeRecords(); if (s.length) { for (let l = 0; l < s.length; l++)this.queue.push(s[l]); window.setTimeout(() => this.flush(), 20) } this.observer.disconnect() } this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection() } connectSelection() { this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange) } disconnectSelection() { this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange) } suppressSelectionUpdates() { this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50) } onSelectionChange() { if (Yc(this.view)) { if (this.suppressingSelectionUpdates) return xr(this.view); if (Zr && oo <= 11 && !this.view.state.selection.empty) { let s = this.view.domSelectionRange(); if (s.focusNode && As(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset)) return this.flushSoon() } this.flush() } } setCurSelection() { this.currentSelection.set(this.view.domSelectionRange()) } ignoreSelectionChange(s) { if (!s.focusNode) return !0; let h, l = new Set; for (let w = s.focusNode; w; w = Wo(w))l.add(w); for (let w = s.anchorNode; w; w = Wo(w))if (l.has(w)) { h = w; break } let y = h && this.view.docView.nearestDesc(h); return y && y.ignoreMutation({ type: "selection", target: 3 == h.nodeType ? h.parentNode : h }) ? (this.setCurSelection(), !0) : void 0 } flush() { let { view: s } = this; if (!s.docView || this.flushingSoon > -1) return; let l = this.observer ? this.observer.takeRecords() : []; this.queue.length && (l = this.queue.concat(l), this.queue.length = 0); let h = s.domSelectionRange(), y = !this.suppressingSelectionUpdates && !this.currentSelection.eq(h) && Yc(s) && !this.ignoreSelectionChange(h), w = -1, I = -1, k = !1, H = []; if (s.editable) for (let se = 0; se < l.length; se++) { let Ge = this.registerMutation(l[se], H); Ge && (w = w < 0 ? Ge.from : Math.min(Ge.from, w), I = I < 0 ? Ge.to : Math.max(Ge.to, I), Ge.typeOver && (k = !0)) } if (xs && H.length > 1) { let se = H.filter(Ge => "BR" == Ge.nodeName); if (2 == se.length) { let Ge = se[0], at = se[1]; Ge.parentNode && Ge.parentNode.parentNode == at.parentNode ? at.remove() : Ge.remove() } } let te = null; w < 0 && y && s.input.lastFocus > Date.now() - 200 && s.input.lastTouch < Date.now() - 300 && Ui(h) && (te = Or(s)) && te.eq(gr.near(s.state.doc.resolve(0), 1)) ? (s.input.lastFocus = 0, xr(s), this.currentSelection.set(h), s.scrollToSelection()) : (w > -1 || y) && (w > -1 && (s.docView.markDirty(w, I), function nl(f) { if (!Uu.has(f) && (Uu.set(f, null), -1 !== ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(f.dom).whiteSpace))) { if (f.requiresGeckoHackNode = xs, _l) return; console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), _l = !0 } }(s)), this.handleDOMChange(w, I, k, H), s.docView && s.docView.dirty ? s.updateState(s.state) : this.currentSelection.eq(h) || xr(s), this.currentSelection.set(h)) } registerMutation(s, l) { if (l.indexOf(s.target) > -1) return null; let h = this.view.docView.nearestDesc(s.target); if ("attributes" == s.type && (h == this.view.docView || "contenteditable" == s.attributeName || "style" == s.attributeName && !s.oldValue && !s.target.getAttribute("style")) || !h || h.ignoreMutation(s)) return null; if ("childList" == s.type) { for (let se = 0; se < s.addedNodes.length; se++)l.push(s.addedNodes[se]); if (h.contentDOM && h.contentDOM != h.dom && !h.contentDOM.contains(s.target)) return { from: h.posBefore, to: h.posAfter }; let y = s.previousSibling, w = s.nextSibling; if (Zr && oo <= 11 && s.addedNodes.length) for (let se = 0; se < s.addedNodes.length; se++) { let { previousSibling: Ge, nextSibling: at } = s.addedNodes[se]; (!Ge || Array.prototype.indexOf.call(s.addedNodes, Ge) < 0) && (y = Ge), (!at || Array.prototype.indexOf.call(s.addedNodes, at) < 0) && (w = at) } let I = y && y.parentNode == s.target ? Is(y) + 1 : 0, k = h.localPosFromDOM(s.target, I, -1), H = w && w.parentNode == s.target ? Is(w) : s.target.childNodes.length; return { from: k, to: h.localPosFromDOM(s.target, H, 1) } } return "attributes" == s.type ? { from: h.posAtStart - h.border, to: h.posAtEnd + h.border } : { from: h.posAtStart, to: h.posAtEnd, typeOver: s.target.nodeValue == s.oldValue } } } let Uu = new WeakMap, _l = !1; function If(f) { let s = f.pmViewDesc; if (s) return s.parseRule(); if ("BR" == f.nodeName && f.parentNode) { if (ys && /^(ul|ol)$/i.test(f.parentNode.nodeName)) { let l = document.createElement("div"); return l.appendChild(document.createElement("li")), { skip: l } } if (f.parentNode.lastChild == f || ys && /^(tr|table)$/i.test(f.parentNode.nodeName)) return { ignore: !0 } } else if ("IMG" == f.nodeName && f.getAttribute("mark-placeholder")) return { ignore: !0 }; return null } function hh(f, s, l) { return Math.max(l.anchor, l.head) > s.content.size ? null : Dc(f, s.resolve(l.anchor), s.resolve(l.head)) } function Uh(f, s, l) { let h = f.depth, y = s ? f.end() : f.pos; for (; h > 0 && (s || f.indexAfter(h) == f.node(h).childCount);)h--, y++, s = !1; if (l) { let w = f.node(h).maybeChild(f.indexAfter(h)); for (; w && !w.isLeaf;)w = w.firstChild, y++ } return y } class fp { constructor(s, l) { this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ud, this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = l, this.state = l.state, this.directPlugins = l.plugins || [], this.directPlugins.forEach(Hh), this.dispatch = this.dispatch.bind(this), this.dom = s && s.mount || document.createElement("div"), s && (s.appendChild ? s.appendChild(this.dom) : "function" == typeof s ? s(this.dom) : s.mount && (this.mounted = !0)), this.editable = mg(this), gg(this), this.nodeViews = yg(this), this.docView = Eo(this.state.doc, dd(this), Ir(this), this.dom, this), this.domObserver = new Vl(this, (h, y, w, I) => function dp(f, s, l, h, y) { if (s < 0) { let Fi = f.input.lastSelectionTime > Date.now() - 50 ? f.input.lastSelectionOrigin : null, kd = Or(f, Fi); if (kd && !f.state.selection.eq(kd)) { let Vm = f.state.tr.setSelection(kd); "pointer" == Fi ? Vm.setMeta("pointer", !0) : "key" == Fi && Vm.scrollIntoView(), f.dispatch(Vm) } return } let w = f.state.doc.resolve(s), I = w.sharedDepth(l); s = w.before(I + 1), l = f.state.doc.resolve(l).after(I + 1); let Ge, at, k = f.state.selection, H = function eu(f, s, l) { let te, { node: h, fromOffset: y, toOffset: w, from: I, to: k } = f.docView.parseRange(s, l), H = f.domSelectionRange(), se = H.anchorNode; if (se && f.dom.contains(1 == se.nodeType ? se : se.parentNode) && (te = [{ node: se, offset: H.anchorOffset }], Ui(H) || te.push({ node: H.focusNode, offset: H.focusOffset })), Hi && 8 === f.input.lastKeyCode) for (let $n = w; $n > y; $n--) { let fi = h.childNodes[$n - 1], uu = fi.pmViewDesc; if ("BR" == fi.nodeName && !uu) { w = $n; break } if (!uu || uu.size) break } let Ge = f.state.doc, at = f.someProp("domParser") || yn.fromSchema(f.state.schema), ut = Ge.resolve(I), $t = null, Dn = at.parse(h, { topNode: ut.parent, topMatch: ut.parent.contentMatchAt(ut.index()), topOpen: !0, from: y, to: w, preserveWhitespace: "pre" != ut.parent.type.whitespace || "full", findPositions: te, ruleFromNode: If, context: ut }); if (te && null != te[0].pos) { let $n = te[0].pos, fi = te[1] && te[1].pos; null == fi && (fi = $n), $t = { anchor: $n + I, head: fi + I } } return { doc: Dn, sel: $t, from: I, to: k } }(f, s, l), te = f.state.doc, se = te.slice(H.from, H.to); 8 === f.input.lastKeyCode && Date.now() - 100 < f.input.lastKeyCodeTime ? (Ge = f.state.selection.to, at = "end") : (Ge = f.state.selection.from, at = "start"), f.input.lastKeyCode = null; let ut = function hp(f, s, l, h, y) { let w = f.findDiffStart(s, l); if (null == w) return null; let { a: I, b: k } = f.findDiffEnd(s, l + f.size, l + s.size); return "end" == y && (h -= I + Math.max(0, w - Math.min(I, k)) - w), I < w && f.size < s.size ? (w -= h <= w && h >= I ? w - h : 0, k = w + (k - I), I = w) : k < w && (w -= h <= w && h >= k ? w - h : 0, I = w + (I - k), k = w), { start: w, endA: I, endB: k } }(se.content, H.doc.content, H.from, Ge, at); if ((hr && f.input.lastIOSEnter > Date.now() - 225 || Q) && y.some(Fi => "DIV" == Fi.nodeName || "P" == Fi.nodeName || "LI" == Fi.nodeName) && (!ut || ut.endA >= ut.endB) && f.someProp("handleKeyDown", Fi => Fi(f, Js(13, "Enter")))) return void (f.input.lastIOSEnter = 0); if (!ut) { if (!(h && k instanceof Jr && !k.empty && k.$head.sameParent(k.$anchor)) || f.composing || H.sel && H.sel.anchor != H.sel.head) { if (H.sel) { let Fi = hh(f, f.state.doc, H.sel); Fi && !Fi.eq(f.state.selection) && f.dispatch(f.state.tr.setSelection(Fi)) } return } ut = { start: k.from, endA: k.to, endB: k.to } } if (Hi && f.cursorWrapper && H.sel && H.sel.anchor == f.cursorWrapper.deco.from && H.sel.head == H.sel.anchor) { let Fi = ut.endB - ut.start; H.sel = { anchor: H.sel.anchor + Fi, head: H.sel.anchor + Fi } } f.input.domChangeCount++, f.state.selection.from < f.state.selection.to && ut.start == ut.endB && f.state.selection instanceof Jr && (ut.start > f.state.selection.from && ut.start <= f.state.selection.from + 2 && f.state.selection.from >= H.from ? ut.start = f.state.selection.from : ut.endA < f.state.selection.to && ut.endA >= f.state.selection.to - 2 && f.state.selection.to <= H.to && (ut.endB += f.state.selection.to - ut.endA, ut.endA = f.state.selection.to)), Zr && oo <= 11 && ut.endB == ut.start + 1 && ut.endA == ut.start && ut.start > H.from && " \xa0" == H.doc.textBetween(ut.start - H.from - 1, ut.start - H.from + 1) && (ut.start--, ut.endA--, ut.endB--); let uu, $t = H.doc.resolveNoCache(ut.start - H.from), Dn = H.doc.resolveNoCache(ut.endB - H.from), $n = te.resolve(ut.start), fi = $t.sameParent(Dn) && $t.parent.inlineContent && $n.end() >= ut.endA; if ((hr && f.input.lastIOSEnter > Date.now() - 225 && (!fi || y.some(Fi => "DIV" == Fi.nodeName || "P" == Fi.nodeName)) || !fi && $t.pos < H.doc.content.size && (uu = gr.findFrom(H.doc.resolve($t.pos + 1), 1, !0)) && uu.head == Dn.pos) && f.someProp("handleKeyDown", Fi => Fi(f, Js(13, "Enter")))) return void (f.input.lastIOSEnter = 0); if (f.state.selection.anchor > ut.start && function xf(f, s, l, h, y) { if (!h.parent.isTextblock || l - s <= y.pos - h.pos || Uh(h, !0, !1) < y.pos) return !1; let w = f.resolve(s); if (w.parentOffset < w.parent.content.size || !w.parent.isTextblock) return !1; let I = f.resolve(Uh(w, !0, !0)); return !(!I.parent.isTextblock || I.pos > l || Uh(I, !0, !1) < l) && h.parent.content.cut(h.parentOffset).eq(I.parent.content) }(te, ut.start, ut.endA, $t, Dn) && f.someProp("handleKeyDown", Fi => Fi(f, Js(8, "Backspace")))) return void (Q && Hi && f.domObserver.suppressSelectionUpdates()); Hi && Q && ut.endB == ut.start && (f.input.lastAndroidDelete = Date.now()), Q && !fi && $t.start() != Dn.start() && 0 == Dn.parentOffset && $t.depth == Dn.depth && H.sel && H.sel.anchor == H.sel.head && H.sel.head == ut.endA && (ut.endB -= 2, Dn = H.doc.resolveNoCache(ut.endB - H.from), setTimeout(() => { f.someProp("handleKeyDown", function (Fi) { return Fi(f, Js(13, "Enter")) }) }, 20)); let Ou, Mp, hf, za = ut.start, hc = ut.endA; if (fi) if ($t.pos == Dn.pos) Zr && oo <= 11 && 0 == $t.parentOffset && (f.domObserver.suppressSelectionUpdates(), setTimeout(() => xr(f), 20)), Ou = f.state.tr.delete(za, hc), Mp = te.resolve(ut.start).marksAcross(te.resolve(ut.endA)); else if (ut.endA == ut.endB && (hf = function Af(f, s) { let I, k, H, l = f.firstChild.marks, h = s.firstChild.marks, y = l, w = h; for (let se = 0; se < h.length; se++)y = h[se].removeFromSet(y); for (let se = 0; se < l.length; se++)w = l[se].removeFromSet(w); if (1 == y.length && 0 == w.length) k = y[0], I = "add", H = se => se.mark(k.addToSet(se.marks)); else { if (0 != y.length || 1 != w.length) return null; k = w[0], I = "remove", H = se => se.mark(k.removeFromSet(se.marks)) } let te = []; for (let se = 0; se < s.childCount; se++)te.push(H(s.child(se))); if (Se.from(te).eq(f)) return { mark: k, type: I } }($t.parent.content.cut($t.parentOffset, Dn.parentOffset), $n.parent.content.cut($n.parentOffset, ut.endA - $n.start())))) Ou = f.state.tr, "add" == hf.type ? Ou.addMark(za, hc, hf.mark) : Ou.removeMark(za, hc, hf.mark); else if ($t.parent.child($t.index()).isText && $t.index() == Dn.index() - (Dn.textOffset ? 0 : 1)) { let Fi = $t.parent.textBetween($t.parentOffset, Dn.parentOffset); if (f.someProp("handleTextInput", kd => kd(f, za, hc, Fi))) return; Ou = f.state.tr.insertText(Fi, za, hc) } if (Ou || (Ou = f.state.tr.replace(za, hc, H.doc.slice(ut.start - H.from, ut.endB - H.from))), H.sel) { let Fi = hh(f, Ou.doc, H.sel); Fi && !(Hi && Q && f.composing && Fi.empty && (ut.start != ut.endB || f.input.lastAndroidDelete < Date.now() - 100) && (Fi.head == za || Fi.head == Ou.mapping.map(hc) - 1) || Zr && Fi.empty && Fi.head == za) && Ou.setSelection(Fi) } Mp && Ou.ensureMarks(Mp), f.dispatch(Ou.scrollIntoView()) }(this, h, y, w, I)), this.domObserver.start(), function vu(f) { for (let s in Vs) { let l = Vs[s]; f.dom.addEventListener(s, f.input.eventHandlers[s] = h => { Oc(f, h) && !Mc(f, h) && (f.editable || !(h.type in ii)) && l(f, h) }, tc[s] ? { passive: !0 } : void 0) } ys && f.dom.addEventListener("input", () => null), Mi(f) }(this), this.updatePluginViews() } get composing() { return this.input.composing } get props() { if (this._props.state != this.state) { let s = this._props; this._props = {}; for (let l in s) this._props[l] = s[l]; this._props.state = this.state } return this._props } update(s) { s.handleDOMEvents != this._props.handleDOMEvents && Mi(this); let l = this._props; this._props = s, s.plugins && (s.plugins.forEach(Hh), this.directPlugins = s.plugins), this.updateStateInner(s.state, l) } setProps(s) { let l = {}; for (let h in this._props) l[h] = this._props[h]; l.state = this.state; for (let h in s) l[h] = s[h]; this.update(l) } updateState(s) { this.updateStateInner(s, this._props) } updateStateInner(s, l) { let h = this.state, y = !1, w = !1; s.storedMarks && this.composing && (on(this), w = !0), this.state = s; let I = h.plugins != s.plugins || this._props.plugins != l.plugins; if (I || this._props.plugins != l.plugins || this._props.nodeViews != l.nodeViews) { let at = yg(this); (function wm(f, s) { let l = 0, h = 0; for (let y in f) { if (f[y] != s[y]) return !0; l++ } for (let y in s) h++; return l != h })(at, this.nodeViews) && (this.nodeViews = at, y = !0) } (I || l.handleDOMEvents != this._props.handleDOMEvents) && Mi(this), this.editable = mg(this), gg(this); let k = Ir(this), H = dd(this), te = h.plugins == s.plugins || h.doc.eq(s.doc) ? s.scrollToSelection > h.scrollToSelection ? "to selection" : "preserve" : "reset", se = y || !this.docView.matchesNode(s.doc, H, k); (se || !s.selection.eq(h.selection)) && (w = !0); let Ge = "preserve" == te && w && null == this.dom.style.overflowAnchor && function Jt(f) { let h, y, s = f.dom.getBoundingClientRect(), l = Math.max(0, s.top); for (let w = (s.left + s.right) / 2, I = l + 1; I < Math.min(innerHeight, s.bottom); I += 5) { let k = f.root.elementFromPoint(w, I); if (!k || k == f.dom || !f.dom.contains(k)) continue; let H = k.getBoundingClientRect(); if (H.top >= l - 20) { h = k, y = H.top; break } } return { refDOM: h, refTop: y, stack: zr(f.dom) } }(this); if (w) { this.domObserver.stop(); let at = se && (Zr || Hi) && !this.composing && !h.selection.empty && !s.selection.empty && function _g(f, s) { let l = Math.min(f.$anchor.sharedDepth(f.head), s.$anchor.sharedDepth(s.head)); return f.$anchor.start(l) != s.$anchor.start(l) }(h.selection, s.selection); if (se) { let ut = Hi ? this.trackWrites = this.domSelectionRange().focusNode : null; (y || !this.docView.update(s.doc, H, k, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = Eo(s.doc, H, k, this.dom, this)), ut && !this.trackWrites && (at = !0) } at || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && function qo(f) { let s = f.docView.domFromPos(f.state.selection.anchor, 0), l = f.domSelectionRange(); return As(s.node, s.offset, l.anchorNode, l.anchorOffset) }(this)) ? xr(this, at) : (Va(this, s.selection), this.domObserver.setCurSelection()), this.domObserver.start() } this.updatePluginViews(h), "reset" == te ? this.dom.scrollTop = 0 : "to selection" == te ? this.scrollToSelection() : Ge && function ll({ refDOM: f, refTop: s, stack: l }) { let h = f ? f.getBoundingClientRect().top : 0; qc(l, 0 == h ? 0 : h - s) }(Ge) } scrollToSelection() { let s = this.domSelectionRange().focusNode; if (!this.someProp("handleScrollToSelection", l => l(this))) if (this.state.selection instanceof Xn) { let l = this.docView.domAfterPos(this.state.selection.from); 1 == l.nodeType && wi(this, l.getBoundingClientRect(), s) } else wi(this, this.coordsAtPos(this.state.selection.head, 1), s) } destroyPluginViews() { let s; for (; s = this.pluginViews.pop();)s.destroy && s.destroy() } updatePluginViews(s) { if (s && s.plugins == this.state.plugins && this.directPlugins == this.prevDirectPlugins) for (let l = 0; l < this.pluginViews.length; l++) { let h = this.pluginViews[l]; h.update && h.update(this, s) } else { this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews(); for (let l = 0; l < this.directPlugins.length; l++) { let h = this.directPlugins[l]; h.spec.view && this.pluginViews.push(h.spec.view(this)) } for (let l = 0; l < this.state.plugins.length; l++) { let h = this.state.plugins[l]; h.spec.view && this.pluginViews.push(h.spec.view(this)) } } } someProp(s, l) { let y, h = this._props && this._props[s]; if (null != h && (y = l ? l(h) : h)) return y; for (let I = 0; I < this.directPlugins.length; I++) { let k = this.directPlugins[I].props[s]; if (null != k && (y = l ? l(k) : k)) return y } let w = this.state.plugins; if (w) for (let I = 0; I < w.length; I++) { let k = w[I].props[s]; if (null != k && (y = l ? l(k) : k)) return y } } hasFocus() { if (Zr) { let s = this.root.activeElement; if (s == this.dom) return !0; if (!s || !this.dom.contains(s)) return !1; for (; s && this.dom != s && this.dom.contains(s);) { if ("false" == s.contentEditable) return !1; s = s.parentElement } return !0 } return this.root.activeElement == this.dom } focus() { this.domObserver.stop(), this.editable && function ql(f) { if (f.setActive) return f.setActive(); if (vs) return f.focus(vs); let s = zr(f); f.focus(null == vs ? { get preventScroll() { return vs = { preventScroll: !0 }, !0 } } : void 0), vs || (vs = !1, qc(s, 0)) }(this.dom), xr(this), this.domObserver.start() } get root() { let s = this._root; if (null == s) for (let l = this.dom.parentNode; l; l = l.parentNode)if (9 == l.nodeType || 11 == l.nodeType && l.host) return l.getSelection || (Object.getPrototypeOf(l).getSelection = () => l.ownerDocument.getSelection()), this._root = l; return s || document } posAtCoords(s) { return Ms(this, s) } coordsAtPos(s, l = 1) { return hl(this, s, l) } domAtPos(s, l = 0) { return this.docView.domFromPos(s, l) } nodeDOM(s) { let l = this.docView.descAt(s); return l ? l.nodeDOM : null } posAtDOM(s, l, h = -1) { let y = this.docView.posFromDOM(s, l, h); if (null == y) throw new RangeError("DOM position not inside the editor"); return y } endOfTextblock(s, l) { return function mu(f, s, l) { return No == s && Cc == l ? fl : (No = s, Cc = l, fl = "up" == l || "down" == l ? function Jl(f, s, l) { let h = s.selection, y = "up" == l ? h.$from : h.$to; return Ea(f, s, () => { let { node: w } = f.docView.domFromPos(y.pos, "up" == l ? -1 : 1); for (; ;) { let k = f.docView.nearestDesc(w, !0); if (!k) break; if (k.node.isBlock) { w = k.dom; break } w = k.dom.parentNode } let I = hl(f, y.pos, 1); for (let k = w.firstChild; k; k = k.nextSibling) { let H; if (1 == k.nodeType) H = k.getClientRects(); else { if (3 != k.nodeType) continue; H = fo(k, 0, k.nodeValue.length).getClientRects() } for (let te = 0; te < H.length; te++) { let se = H[te]; if (se.bottom > se.top + 1 && ("up" == l ? I.top - se.top > 2 * (se.bottom - I.top) : se.bottom - I.bottom > 2 * (I.bottom - se.top))) return !1 } } return !0 }) }(f, s, l) : function Ql(f, s, l) { let { $head: h } = s.selection; if (!h.parent.isTextblock) return !1; let y = h.parentOffset, w = !y, I = y == h.parent.content.size, k = f.domSelection(); return wc.test(h.parent.textContent) && k.modify ? Ea(f, s, () => { let { focusNode: H, focusOffset: te, anchorNode: se, anchorOffset: Ge } = f.domSelectionRange(), at = k.caretBidiLevel; k.modify("move", l, "character"); let ut = h.depth ? f.docView.domAfterPos(h.before()) : f.dom, { focusNode: $t, focusOffset: Dn } = f.domSelectionRange(), $n = $t && !ut.contains(1 == $t.nodeType ? $t : $t.parentNode) || H == $t && te == Dn; try { k.collapse(se, Ge), H && (H != se || te != Ge) && k.extend && k.extend(H, te) } catch { } return null != at && (k.caretBidiLevel = at), $n }) : "left" == l || "backward" == l ? w : I }(f, s, l)) }(this, l || this.state, s) } destroy() { this.docView && (function Aa(f) { f.domObserver.stop(); for (let s in f.input.eventHandlers) f.dom.removeEventListener(s, f.input.eventHandlers[s]); clearTimeout(f.input.composingTimeout), clearTimeout(f.input.lastIOSEnterFallbackTimeout) }(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Ir(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null) } get isDestroyed() { return null == this.docView } dispatchEvent(s) { return function cn(f, s) { !Mc(f, s) && Vs[s.type] && (f.editable || !(s.type in ii)) && Vs[s.type](f, s) }(this, s) } dispatch(s) { let l = this._props.dispatchTransaction; l ? l.call(this, s) : this.updateState(this.state.apply(s)) } domSelectionRange() { return ys && 11 === this.root.nodeType && function ds(f) { let s = f.activeElement; for (; s && s.shadowRoot;)s = s.shadowRoot.activeElement; return s }(this.dom.ownerDocument) == this.dom ? function nc(f) { let s; function l(H) { H.preventDefault(), H.stopImmediatePropagation(), s = H.getTargetRanges()[0] } f.dom.addEventListener("beforeinput", l, !0), document.execCommand("indent"), f.dom.removeEventListener("beforeinput", l, !0); let h = s.startContainer, y = s.startOffset, w = s.endContainer, I = s.endOffset, k = f.domAtPos(f.state.selection.anchor); return As(k.node, k.offset, w, I) && ([h, y, w, I] = [w, I, h, y]), { anchorNode: h, anchorOffset: y, focusNode: w, focusOffset: I } }(this) : this.domSelection() } domSelection() { return this.root.getSelection() } } function dd(f) { let s = Object.create(null); return s.class = "ProseMirror", s.contenteditable = String(f.editable), s.translate = "no", f.someProp("attributes", l => { if ("function" == typeof l && (l = l(f.state)), l) for (let h in l) "class" == h && (s.class += " " + l[h]), "style" == h ? s.style = (s.style ? s.style + ";" : "") + l[h] : !s[h] && "contenteditable" != h && "nodeName" != h && (s[h] = String(l[h])) }), [Qo.node(0, f.state.doc.content.size, s)] } function gg(f) { if (f.markCursor) { let s = document.createElement("img"); s.className = "ProseMirror-separator", s.setAttribute("mark-placeholder", "true"), s.setAttribute("alt", ""), f.cursorWrapper = { dom: s, deco: Qo.widget(f.state.selection.head, s, { raw: !0, marks: f.markCursor }) } } else f.cursorWrapper = null } function mg(f) { return !f.someProp("editable", s => !1 === s(f.state)) } function yg(f) { let s = Object.create(null); function l(h) { for (let y in h) Object.prototype.hasOwnProperty.call(s, y) || (s[y] = h[y]) } return f.someProp("nodeViews", l), f.someProp("markViews", l), s } function Hh(f) { if (f.spec.state || f.spec.filterTransaction || f.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component") } var mo = L(6895); const zh = ["ol", 0], yl = ["ul", 0], Us = ["li", 0]; function Hd(f) { return function (s, l) { let { $from: h, $to: y, node: w } = s.selection; if (w && w.isBlock || h.depth < 2 || !h.sameParent(y)) return !1; let I = h.node(-1); if (I.type != f) return !1; if (0 == h.parent.content.size && h.node(-1).childCount == h.indexAfter(-1)) { if (3 == h.depth || h.node(-3).type != f || h.index(-2) != h.node(-2).childCount - 1) return !1; if (l) { let se = Se.empty, Ge = h.index(-1) ? 1 : h.index(-2) ? 2 : 3; for (let $n = h.depth - Ge; $n >= h.depth - 3; $n--)se = Se.from(h.node($n).copy(se)); let at = h.indexAfter(-1) < h.node(-2).childCount ? 1 : h.indexAfter(-2) < h.node(-3).childCount ? 2 : 3; se = se.append(Se.from(f.createAndFill())); let ut = h.before(h.depth - (Ge - 1)), $t = s.tr.replace(ut, h.after(-at), new Qe(se, 4 - Ge, 0)), Dn = -1; $t.doc.nodesBetween(ut, $t.doc.content.size, ($n, fi) => { if (Dn > -1) return !1; $n.isTextblock && 0 == $n.content.size && (Dn = fi + 1) }), Dn > -1 && $t.setSelection(gr.near($t.doc.resolve(Dn))), l($t.scrollIntoView()) } return !0 } let k = y.pos == h.end() ? I.contentMatchAt(0).defaultType : null, H = s.tr.delete(h.pos, y.pos), te = k ? [null, { type: k }] : void 0; return !!_s(H.doc, h.pos, 2, te) && (l && l(H.split(h.pos, 2, te).scrollIntoView()), !0) } } function Hu(f) { return function (s, l) { let { $from: h, $to: y } = s.selection, w = h.blockRange(y, I => I.childCount > 0 && I.firstChild.type == f); return !!w && (!l || (h.node(w.depth - 1).type == f ? function tu(f, s, l, h) { let y = f.tr, w = h.end, I = h.$to.end(h.depth); w < I && (y.step(new Bi(w - 1, I, w, I, new Qe(Se.from(l.create(null, h.parent.copy())), 1, 0), 1, !0)), h = new kn(y.doc.resolve(h.$from.pos), y.doc.resolve(I), h.depth)); const k = Ei(h); if (null == k) return !1; y.lift(h, k); let H = y.mapping.map(w, -1) - 1; return Rs(y.doc, H) && y.join(H), s(y.scrollIntoView()), !0 }(s, l, f, w) : function zd(f, s, l) { let h = f.tr, y = l.parent; for (let ut = l.end, $t = l.endIndex - 1, Dn = l.startIndex; $t > Dn; $t--)ut -= y.child($t).nodeSize, h.delete(ut - 1, ut + 1); let w = h.doc.resolve(l.start), I = w.nodeAfter; if (h.mapping.map(l.end) != l.start + w.nodeAfter.nodeSize) return !1; let k = 0 == l.startIndex, H = l.endIndex == y.childCount, te = w.node(-1), se = w.index(-1); if (!te.canReplace(se + (k ? 0 : 1), se + 1, I.content.append(H ? Se.empty : Se.from(y)))) return !1; let Ge = w.pos, at = Ge + I.nodeSize; return h.step(new Bi(Ge - (k ? 1 : 0), at + (H ? 1 : 0), Ge + 1, at - 1, new Qe((k ? Se.empty : Se.from(y.copy(Se.empty))).append(H ? Se.empty : Se.from(y.copy(Se.empty))), k ? 0 : 1, H ? 0 : 1), k ? 0 : 1)), s(h.scrollIntoView()), !0 }(s, l, w))) } } function Mf(f) { return function (s, l) { let { $from: h, $to: y } = s.selection, w = h.blockRange(y, te => te.childCount > 0 && te.firstChild.type == f); if (!w) return !1; let I = w.startIndex; if (0 == I) return !1; let k = w.parent, H = k.child(I - 1); if (H.type != f) return !1; if (l) { let te = H.lastChild && H.lastChild.type == k.type, se = Se.from(te ? f.create() : null), Ge = new Qe(Se.from(f.create(null, Se.from(k.type.create(null, se)))), te ? 3 : 1, 0), at = w.start, ut = w.end; l(s.tr.step(new Bi(at - (te ? 3 : 1), ut, at, ut, Ge, 1, !0)).scrollIntoView()) } return !0 } } const Pc = { link: { attrs: { href: {}, title: { default: null }, target: { default: "_blank" } }, inclusive: !1, parseDOM: [{ tag: "a[href]", getAttrs: f => ({ href: f.getAttribute("href"), title: f.getAttribute("title"), target: f.getAttribute("target") }) }], toDOM(f) { const { href: s, title: l, target: h } = f.attrs; return ["a", { href: s, title: l, target: h }, 0] } }, em: { parseDOM: [{ tag: "i" }, { tag: "em" }, { style: "font-style=italic" }], toDOM: () => ["em", 0] }, strong: { parseDOM: [{ tag: "strong" }, { tag: "b", getAttrs: f => "normal" !== f.style.fontWeight && null }, { style: "font-weight", getAttrs: f => /^(?:bold(?:er)?|[5-9]\d{2,})$/.test(f) && null }], toDOM: () => ["strong", 0] }, code: { parseDOM: [{ tag: "code" }], toDOM: () => ["code", 0] }, u: { parseDOM: [{ tag: "u" }, { style: "text-decoration=underline", consuming: !1 }], toDOM: () => ["u", 0] }, s: { parseDOM: [{ tag: "s" }, { tag: "strike" }, { style: "text-decoration=line-through" }], toDOM: () => ["s", 0] }, text_color: { attrs: { color: { default: null } }, parseDOM: [{ style: "color", getAttrs: f => ({ color: f }) }], toDOM(f) { const { color: s } = f.attrs; return ["span", { style: `color:${s};` }, 0] } }, text_background_color: { attrs: { backgroundColor: { default: null } }, parseDOM: [{ style: "background-color", getAttrs: f => ({ backgroundColor: f }) }], toDOM(f) { const { backgroundColor: s } = f.attrs; return ["span", { style: `background-color:${s};` }, 0] } } }, Wh = { doc: { content: "block+" }, text: { group: "inline" }, paragraph: { content: "inline*", group: "block", attrs: { align: { default: null } }, parseDOM: [{ tag: "p", getAttrs(f) { const { textAlign: s } = f.style; return { align: f.getAttribute("align") || s || null } } }], toDOM(f) { const { align: s } = f.attrs; return ["p", { style: Ee({ textAlign: "left" !== s ? s : null }) || null }, 0] } }, blockquote: { content: "block+", group: "block", defining: !0, parseDOM: [{ tag: "blockquote" }], toDOM: () => ["blockquote", 0] }, horizontal_rule: { group: "block", parseDOM: [{ tag: "hr" }], toDOM: () => ["hr"] }, heading: { attrs: { level: { default: 1 }, align: { default: null } }, content: "inline*", group: "block", defining: !0, parseDOM: [{ tag: "h1", getAttrs(f) { const { textAlign: s } = f.style; return { level: 1, align: f.getAttribute("align") || s || null } } }, { tag: "h2", getAttrs(f) { const { textAlign: s } = f.style; return { level: 2, align: f.getAttribute("align") || s || null } } }, { tag: "h3", getAttrs(f) { const { textAlign: s } = f.style; return { level: 3, align: f.getAttribute("align") || s || null } } }, { tag: "h4", getAttrs(f) { const { textAlign: s } = f.style; return { level: 4, align: f.getAttribute("align") || s || null } } }, { tag: "h5", getAttrs(f) { const { textAlign: s } = f.style; return { level: 5, align: f.getAttribute("align") || s || null } } }, { tag: "h6", getAttrs(f) { const { textAlign: s } = f.style; return { level: 6, align: f.getAttribute("align") || s || null } } }], toDOM(f) { const { level: s, align: l } = f.attrs; return [`h${s}`, { style: Ee({ textAlign: "left" !== l ? l : null }) || null }, 0] } }, hard_break: { inline: !0, group: "inline", selectable: !1, parseDOM: [{ tag: "br" }], toDOM: () => ["br"] }, code_block: { content: "text*", marks: "", group: "block", code: !0, defining: !0, parseDOM: [{ tag: "pre", preserveWhitespace: "full" }], toDOM: () => ["pre", ["code", 0]] }, image: { inline: !0, attrs: { src: {}, alt: { default: null }, title: { default: null }, width: { default: null } }, group: "inline", draggable: !0, parseDOM: [{ tag: "img[src]", getAttrs: f => ({ src: f.getAttribute("src"), title: f.getAttribute("title"), alt: f.getAttribute("alt"), width: f.getAttribute("width") }) }], toDOM(f) { const { src: s, alt: l, title: h, width: y } = f.attrs; return ["img", { src: s, alt: l, title: h, width: y }] } }, list_item: { ...{ parseDOM: [{ tag: "li" }], toDOM: () => Us, defining: !0 }, content: "paragraph block*" }, ordered_list: { ...{ attrs: { order: { default: 1 } }, parseDOM: [{ tag: "ol", getAttrs: f => ({ order: f.hasAttribute("start") ? +f.getAttribute("start") : 1 }) }], toDOM: f => 1 == f.attrs.order ? zh : ["ol", { start: f.attrs.order }, 0] }, content: "list_item+", group: "block" }, bullet_list: { ...{ parseDOM: [{ tag: "ul" }], toDOM: () => yl }, content: "list_item+", group: "block" } }, ju = new class pn { constructor(s) { this.cached = Object.create(null); let l = this.spec = {}; for (let y in s) l[y] = s[y]; l.nodes = ve.from(s.nodes), l.marks = ve.from(s.marks || {}), this.nodes = gn.compile(this.spec.nodes, this), this.marks = _r.compile(this.spec.marks, this); let h = Object.create(null); for (let y in this.nodes) { if (y in this.marks) throw new RangeError(y + " can not be both a node and a mark"); let w = this.nodes[y], I = w.spec.content || "", k = w.spec.marks; w.contentMatch = h[I] || (h[I] = Pt.parse(I, this.nodes)), w.inlineContent = w.contentMatch.inlineContent, w.markSet = "_" == k ? null : k ? Fn(this, k.split(" ")) : "" != k && w.inlineContent ? null : [] } for (let y in this.marks) { let w = this.marks[y], I = w.spec.excludes; w.excluded = null == I ? [w] : "" == I ? [] : Fn(this, I.split(" ")) } this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = Object.create(null) } node(s, l = null, h, y) { if ("string" == typeof s) s = this.nodeType(s); else { if (!(s instanceof gn)) throw new RangeError("Invalid node type: " + s); if (s.schema != this) throw new RangeError("Node type from different schema used (" + s.name + ")") } return s.createChecked(l, h, y) } text(s, l) { let h = this.nodes.text; return new Yt(h, h.defaultAttrs, s, je.setFrom(l)) } mark(s, l) { return "string" == typeof s && (s = this.marks[s]), s.create(l) } nodeFromJSON(s) { return It.fromJSON(this, s) } markFromJSON(s) { return je.fromJSON(this, s) } nodeType(s) { let l = this.nodes[s]; if (!l) throw new RangeError("Unknown node type: " + s); return l } }({ marks: Pc, nodes: Wh }), fd = (f, s) => !f.selection.empty && (s && s(f.tr.deleteSelection().scrollIntoView()), !0); function ic(f, s, l = !1) { for (let h = f; h; h = "start" == s ? h.firstChild : h.lastChild) { if (h.isTextblock) return !0; if (l && 1 != h.childCount) return !1 } return !1 } function Cu(f) { if (!f.parent.type.spec.isolating) for (let s = f.depth - 1; s >= 0; s--) { if (f.index(s) > 0) return f.doc.resolve(f.before(s + 1)); if (f.node(s).type.spec.isolating) break } return null } function ws(f) { if (!f.parent.type.spec.isolating) for (let s = f.depth - 1; s >= 0; s--) { let l = f.node(s); if (f.index(s) + 1 < l.childCount) return f.doc.resolve(f.after(s + 1)); if (l.type.spec.isolating) break } return null } const Zh = (f, s) => { let { $head: l, $anchor: h } = f.selection; return !(!l.parent.type.spec.code || !l.sameParent(h) || (s && s(f.tr.insertText("\n").scrollIntoView()), 0)) }; function ru(f) { for (let s = 0; s < f.edgeCount; s++) { let { type: l } = f.edge(s); if (l.isTextblock && !l.hasRequiredAttrs()) return l } return null } const qh = (f, s) => { let { $head: l, $anchor: h } = f.selection; if (!l.parent.type.spec.code || !l.sameParent(h)) return !1; let y = l.node(-1), w = l.indexAfter(-1), I = ru(y.contentMatchAt(w)); if (!I || !y.canReplaceWith(w, w, I)) return !1; if (s) { let k = l.after(), H = f.tr.replaceWith(k, k, I.createAndFill()); H.setSelection(gr.near(H.doc.resolve(k), 1)), s(H.scrollIntoView()) } return !0 }, vh = (f, s) => { let l = f.selection, { $from: h, $to: y } = l; if (l instanceof Si || h.parent.inlineContent || y.parent.inlineContent) return !1; let w = ru(y.parent.contentMatchAt(y.indexAfter())); if (!w || !w.isTextblock) return !1; if (s) { let I = (!h.parentOffset && y.index() < y.parent.childCount ? h : y).pos, k = f.tr.insert(I, w.createAndFill()); k.setSelection(Jr.create(k.doc, I + 1)), s(k.scrollIntoView()) } return !0 }, iu = (f, s) => { let { $cursor: l } = f.selection; if (!l || l.parent.content.size) return !1; if (l.depth > 1 && l.after() != l.end(-1)) { let w = l.before(); if (_s(f.doc, w)) return s && s(f.tr.split(w).scrollIntoView()), !0 } let h = l.blockRange(), y = h && Ei(h); return null != y && (s && s(f.tr.lift(h, y).scrollIntoView()), !0) }, rl = function bh(f) { return (s, l) => { let { $from: h, $to: y } = s.selection; if (s.selection instanceof Xn && s.selection.node.isBlock) return !(!h.parentOffset || !_s(s.doc, h.pos) || (l && l(s.tr.split(h.pos).scrollIntoView()), 0)); if (!h.parent.isBlock) return !1; if (l) { let w = y.parentOffset == y.parent.content.size, I = s.tr; (s.selection instanceof Jr || s.selection instanceof Si) && I.deleteSelection(); let k = 0 == h.depth ? null : ru(h.node(-1).contentMatchAt(h.indexAfter(-1))), H = f && f(y.parent, w), te = H ? [H] : w && k ? [{ type: k }] : void 0, se = _s(I.doc, I.mapping.map(h.pos), 1, te); if (!te && !se && _s(I.doc, I.mapping.map(h.pos), 1, k ? [{ type: k }] : void 0) && (k && (te = [{ type: k }]), se = !0), se && (I.split(I.mapping.map(h.pos), 1, te), !w && !h.parentOffset && h.parent.type != k)) { let Ge = I.mapping.map(h.before()), at = I.doc.resolve(Ge); k && h.node(-1).canReplaceWith(at.index(), at.index() + 1, k) && I.setNodeMarkup(I.mapping.map(h.before()), k) } l(I.scrollIntoView()) } return !0 } }(); function Wu(f, s, l) { let w, I, h = s.nodeBefore, y = s.nodeAfter; if (h.type.spec.isolating || y.type.spec.isolating) return !1; if (function bg(f, s, l) { let h = s.nodeBefore, y = s.nodeAfter, w = s.index(); return !(!(h && y && h.type.compatibleContent(y.type)) || (!h.content.size && s.parent.canReplace(w - 1, w) ? (l && l(f.tr.delete(s.pos - h.nodeSize, s.pos).scrollIntoView()), 0) : !s.parent.canReplace(w, w + 1) || !y.isTextblock && !Rs(f.doc, s.pos) || (l && l(f.tr.clearIncompatible(s.pos, h.type, h.contentMatchAt(h.childCount)).join(s.pos).scrollIntoView()), 0))) }(f, s, l)) return !0; let k = s.parent.canReplace(s.index(), s.index() + 1); if (k && (w = (I = h.contentMatchAt(h.childCount)).findWrapping(y.type)) && I.matchType(w[0] || y.type).validEnd) { if (l) { let Ge = s.pos + y.nodeSize, at = Se.empty; for (let Dn = w.length - 1; Dn >= 0; Dn--)at = Se.from(w[Dn].create(null, at)); at = Se.from(h.copy(at)); let ut = f.tr.step(new Bi(s.pos - 1, Ge, s.pos, Ge, new Qe(at, 1, 0), w.length, !0)), $t = Ge + 2 * w.length; Rs(ut.doc, $t) && ut.join($t), l(ut.scrollIntoView()) } return !0 } let H = gr.findFrom(s, 1), te = H && H.$from.blockRange(H.$to), se = te && Ei(te); if (null != se && se >= s.depth) return l && l(f.tr.lift(te, se).scrollIntoView()), !0; if (k && ic(y, "start", !0) && ic(h, "end")) { let Ge = h, at = []; for (; at.push(Ge), !Ge.isTextblock;)Ge = Ge.lastChild; let ut = y, $t = 1; for (; !ut.isTextblock; ut = ut.firstChild)$t++; if (Ge.canReplace(Ge.childCount, Ge.childCount, ut.content)) { if (l) { let Dn = Se.empty; for (let fi = at.length - 1; fi >= 0; fi--)Dn = Se.from(at[fi].copy(Dn)); l(f.tr.step(new Bi(s.pos - at.length, s.pos + y.nodeSize, s.pos + $t, s.pos + y.nodeSize - $t, new Qe(Dn, at.length, 0), 0, !0)).scrollIntoView()) } return !0 } } return !1 } function md(f) { return function (s, l) { let h = s.selection, y = f < 0 ? h.$from : h.$to, w = y.depth; for (; y.node(w).isInline;) { if (!w) return !1; w-- } return !!y.node(w).isTextblock && (l && l(s.tr.setSelection(Jr.create(s.doc, f < 0 ? y.start(w) : y.end(w)))), !0) } } const sc = md(-1), si = md(1); function Rc(f, s = null) { return function (l, h) { let y = !1; for (let w = 0; w < l.selection.ranges.length && !y; w++) { let { $from: { pos: I }, $to: { pos: k } } = l.selection.ranges[w]; l.doc.nodesBetween(I, k, (H, te) => { if (y) return !1; if (H.isTextblock && !H.hasMarkup(f, s)) if (H.type == f) y = !0; else { let se = l.doc.resolve(te), Ge = se.index(); y = se.parent.canReplaceWith(Ge, Ge + 1, f) } }) } if (!y) return !1; if (h) { let w = l.tr; for (let I = 0; I < l.selection.ranges.length; I++) { let { $from: { pos: k }, $to: { pos: H } } = l.selection.ranges[I]; w.setBlockType(k, H, f, s) } h(w.scrollIntoView()) } return !0 } } function Po(f, s = null) { return function (l, h) { let { empty: y, $cursor: w, ranges: I } = l.selection; if (y && !w || !function _d(f, s, l) { for (let h = 0; h < s.length; h++) { let { $from: y, $to: w } = s[h], I = 0 == y.depth && f.inlineContent && f.type.allowsMarkType(l); if (f.nodesBetween(y.pos, w.pos, k => { if (I) return !1; I = k.inlineContent && k.type.allowsMarkType(l) }), I) return !0 } return !1 }(l.doc, I, f)) return !1; if (h) if (w) f.isInSet(l.storedMarks || w.marks()) ? h(l.tr.removeStoredMark(f)) : h(l.tr.addStoredMark(f.create(s))); else { let k = !1, H = l.tr; for (let te = 0; !k && te < I.length; te++) { let { $from: se, $to: Ge } = I[te]; k = l.doc.rangeHasMark(se.pos, Ge.pos, f) } for (let te = 0; te < I.length; te++) { let { $from: se, $to: Ge } = I[te]; if (k) H.removeMark(se.pos, Ge.pos, f); else { let at = se.pos, ut = Ge.pos, $t = se.nodeAfter, Dn = Ge.nodeBefore, $n = $t && $t.isText ? /^\s*/.exec($t.text)[0].length : 0, fi = Dn && Dn.isText ? /\s*$/.exec(Dn.text)[0].length : 0; at + $n < ut && (at += $n, ut -= fi), H.addMark(at, ut, f.create(s)) } } h(H.scrollIntoView()) } return !0 } } function Ro(...f) { return function (s, l, h) { for (let y = 0; y < f.length; y++)if (f[y](s, l, h)) return !0; return !1 } } let to = Ro(fd, (f, s, l) => { let h = function Zi(f, s) { let { $cursor: l } = f.selection; return !l || (s ? !s.endOfTextblock("backward", f) : l.parentOffset > 0) ? null : l }(f, l); if (!h) return !1; let y = Cu(h); if (!y) { let I = h.blockRange(), k = I && Ei(I); return null != k && (s && s(f.tr.lift(I, k).scrollIntoView()), !0) } let w = y.nodeBefore; if (!w.type.spec.isolating && Wu(f, y, s)) return !0; if (0 == h.parent.content.size && (ic(w, "end") || Xn.isSelectable(w))) { let I = Vi(f.doc, h.before(), h.after(), Qe.empty); if (I && I.slice.size < I.to - I.from) { if (s) { let k = f.tr.step(I); k.setSelection(ic(w, "end") ? gr.findFrom(k.doc.resolve(k.mapping.map(y.pos, -1)), -1) : Xn.create(k.doc, y.pos - w.nodeSize)), s(k.scrollIntoView()) } return !0 } } return !(!w.isAtom || y.depth != h.depth - 1 || (s && s(f.tr.delete(y.pos - w.nodeSize, y.pos).scrollIntoView()), 0)) }, (f, s, l) => { let { $head: h, empty: y } = f.selection, w = h; if (!y) return !1; if (h.parent.isTextblock) { if (l ? !l.endOfTextblock("backward", f) : h.parentOffset > 0) return !1; w = Cu(h) } let I = w && w.nodeBefore; return !(!I || !Xn.isSelectable(I) || (s && s(f.tr.setSelection(Xn.create(f.doc, w.pos - I.nodeSize)).scrollIntoView()), 0)) }), yd = Ro(fd, (f, s, l) => { let h = function $u(f, s) { let { $cursor: l } = f.selection; return !l || (s ? !s.endOfTextblock("forward", f) : l.parentOffset < l.parent.content.size) ? null : l }(f, l); if (!h) return !1; let y = ws(h); if (!y) return !1; let w = y.nodeAfter; if (Wu(f, y, s)) return !0; if (0 == h.parent.content.size && (ic(w, "start") || Xn.isSelectable(w))) { let I = Vi(f.doc, h.before(), h.after(), Qe.empty); if (I && I.slice.size < I.to - I.from) { if (s) { let k = f.tr.step(I); k.setSelection(ic(w, "start") ? gr.findFrom(k.doc.resolve(k.mapping.map(y.pos)), 1) : Xn.create(k.doc, k.mapping.map(y.pos))), s(k.scrollIntoView()) } return !0 } } return !(!w.isAtom || y.depth != h.depth - 1 || (s && s(f.tr.delete(y.pos, y.pos + w.nodeSize).scrollIntoView()), 0)) }, (f, s, l) => { let { $head: h, empty: y } = f.selection, w = h; if (!y) return !1; if (h.parent.isTextblock) { if (l ? !l.endOfTextblock("forward", f) : h.parentOffset < h.parent.content.size) return !1; w = ws(h) } let I = w && w.nodeAfter; return !(!I || !Xn.isSelectable(I) || (s && s(f.tr.setSelection(Xn.create(f.doc, w.pos)).scrollIntoView()), 0)) }); const Ma = { Enter: Ro(Zh, vh, iu, rl), "Mod-Enter": qh, Backspace: to, "Mod-Backspace": to, "Shift-Backspace": to, Delete: yd, "Mod-Delete": yd, "Mod-a": (f, s) => (s && s(f.tr.setSelection(new Si(f.doc))), !0) }, Tu = { "Ctrl-h": Ma.Backspace, "Alt-Backspace": Ma["Mod-Backspace"], "Ctrl-d": Ma.Delete, "Ctrl-Alt-Backspace": Ma["Mod-Delete"], "Alt-Delete": Ma["Mod-Delete"], "Alt-d": Ma["Mod-Delete"], "Ctrl-a": sc, "Ctrl-e": si }; for (let f in Ma) Tu[f] = Ma[f]; const wh = (typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && "darwin" == os.platform()) ? Tu : Ma; class Cl { constructor(s, l) { this.match = s, this.match = s, this.handler = "string" == typeof l ? function Kh(f) { return function (s, l, h, y) { let w = f; if (l[1]) { let I = l[0].lastIndexOf(l[1]); w += l[0].slice(I + l[1].length); let k = (h += I) - y; k > 0 && (w = l[0].slice(I - k, I) + w, h = y) } return s.tr.insertText(w, h, y) } }(l) : l } } function bd(f, s, l, h, y, w) { if (f.composing) return !1; let I = f.state, k = I.doc.resolve(s); if (k.parent.type.spec.code) return !1; let H = k.parent.textBetween(Math.max(0, k.parentOffset - 500), k.parentOffset, null, "\ufffc") + h; for (let te = 0; te < y.length; te++) { let se = y[te].match.exec(H), Ge = se && y[te].handler(I, se, s - (se[0].length - h.length), l); if (Ge) return f.dispatch(Ge.setMeta(w, { transform: Ge, from: s, to: l, text: h })), !0 } return !1 } const qu = new Cl(/--$/, "\u2014"), Rf = new Cl(/\.\.\.$/, "\u2026"), oc = [new Cl(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "\u201c"), new Cl(/"$/, "\u201d"), new Cl(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "\u2018"), new Cl(/'$/, "\u2019")]; function Tl(f, s, l = null, h) { return new Cl(f, (y, w, I, k) => { let H = l instanceof Function ? l(w) : l, te = y.tr.delete(I, k), Ge = te.doc.resolve(I).blockRange(), at = Ge && Qi(Ge, s, H); if (!at) return null; te.wrap(Ge, at); let ut = te.doc.resolve(I - 1).nodeBefore; return ut && ut.type == s && Rs(te.doc, I - 1) && (!h || h(w, ut)) && te.join(I - 1), te }) } function il(f, s, l = null) { return new Cl(f, (h, y, w, I) => { let k = h.doc.resolve(w), H = l instanceof Function ? l(y) : l; return k.node(-1).canReplaceWith(k.index(-1), k.indexAfter(-1), s) ? h.tr.delete(w, I).setBlockType(w, w, s, H) : null }) } const ac = (f, s) => { const { from: l, $from: h, to: y, empty: w } = f.selection; return w ? Boolean(s.isInSet(f.storedMarks || h.marks())) : f.doc.rangeHasMark(l, y, s) }, Ch = (f, s, l = {}) => { const { selection: h } = f, { $from: y, to: w } = h, I = ((f, s) => { for (let l = s.depth; l > 0; l -= 1)if (s.node(l).type === f) return s.node(l).type; return null })(s, y); return Object.entries(l).length && I ? w <= y.end() && y.parent.hasMarkup(s, l) : Boolean(I) }, Du = f => { const s = [], { selection: { from: l, to: h } } = f; return f.doc.nodesBetween(l, h, y => { s.push(y) }), s }, Zs = (f, s, l) => { for (const h of s) { const { $from: y, $to: w } = h; let I = 0 === y.depth && f.type.allowsMarkType(l); if (f.nodesBetween(y.pos, w.pos, k => !I && (I = k.inlineContent && k.type.allowsMarkType(l), !0)), I) return !0 } return !1 }, Wd = (f, s, l) => new Cl(f, (h, y, w, I) => { const { tr: k } = h, H = w; let te = I; if (y[2]) { const se = w + y[0].indexOf(y[2]), Ge = se + y[2].length; Ge < I && k.delete(Ge, I), se > w && k.delete(w, se), te = w + y[2].length } return k.addMark(H, te, s.create(l)) }), S = (f, s = {}) => (l, h) => { const { tr: y, selection: w } = l, { empty: I, ranges: k, $from: H, $to: te } = w; if (I && w instanceof Jr) { const { $cursor: se } = w; if (!se || !Zs(l.doc, k, f) || (y.addStoredMark(f.create(s)), !y.storedMarksSet)) return !1; h?.(y) } else { if (y.addMark(H.pos, te.pos, f.create(s)), !y.docChanged) return !1; h?.(y.scrollIntoView()) } return !0 }; for (var ie = L(1481), ge = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, Tt = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, tn = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent), tr = (typeof navigator < "u" && /Gecko\/\d+/.test(navigator.userAgent), typeof navigator < "u" && /Mac/.test(navigator.platform)), br = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), yr = tr || tn && +tn[1] < 57, Ni = 0; Ni < 10; Ni++)ge[48 + Ni] = ge[96 + Ni] = String(Ni); for (Ni = 1; Ni <= 24; Ni++)ge[Ni + 111] = "F" + Ni; for (Ni = 65; Ni <= 90; Ni++)ge[Ni] = String.fromCharCode(Ni + 32), Tt[Ni] = String.fromCharCode(Ni); for (var Dl in ge) Tt.hasOwnProperty(Dl) || (Tt[Dl] = ge[Dl]); const Lf = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform); function su(f) { let h, y, w, I, s = f.split(/-(?!$)/), l = s[s.length - 1]; "Space" == l && (l = " "); for (let k = 0; k < s.length - 1; k++) { let H = s[k]; if (/^(cmd|meta|m)$/i.test(H)) I = !0; else if (/^a(lt)?$/i.test(H)) h = !0; else if (/^(c|ctrl|control)$/i.test(H)) y = !0; else if (/^s(hift)?$/i.test(H)) w = !0; else { if (!/^mod$/i.test(H)) throw new Error("Unrecognized modifier name: " + H); Lf ? I = !0 : y = !0 } } return h && (l = "Alt-" + l), y && (l = "Ctrl-" + l), I && (l = "Meta-" + l), w && (l = "Shift-" + l), l } function lc(f, s, l) { return s.altKey && (f = "Alt-" + f), s.ctrlKey && (f = "Ctrl-" + f), s.metaKey && (f = "Meta-" + f), !1 !== l && s.shiftKey && (f = "Shift-" + f), f } function Su(f) { return new wo({ props: { handleKeyDown: Eh(f) } }) } function Eh(f) { let s = function Fc(f) { let s = Object.create(null); for (let l in f) s[su(l)] = f[l]; return s }(f); return function (l, h) { let I, y = function Ku(f) { var l = !(yr && (f.ctrlKey || f.altKey || f.metaKey) || br && f.shiftKey && f.key && 1 == f.key.length || "Unidentified" == f.key) && f.key || (f.shiftKey ? Tt : ge)[f.keyCode] || f.key || "Unidentified"; return "Esc" == l && (l = "Escape"), "Del" == l && (l = "Delete"), "Left" == l && (l = "ArrowLeft"), "Up" == l && (l = "ArrowUp"), "Right" == l && (l = "ArrowRight"), "Down" == l && (l = "ArrowDown"), l }(h), w = 1 == y.length && " " != y, k = s[lc(y, h, !w)]; if (k && k(l.state, l.dispatch, l)) return !0; if (w && (h.shiftKey || h.altKey || h.metaKey || y.charCodeAt(0) > 127) && (I = ge[h.keyCode]) && I != y) { let H = s[lc(I, h, !0)]; if (H && H(l.state, l.dispatch, l)) return !0 } else if (w && h.shiftKey) { let H = s[lc(y, h, !0)]; if (H && H(l.state, l.dispatch, l)) return !0 } return !1 } } var ea = function () { }; ea.prototype.append = function (s) { return s.length ? (s = ea.from(s), !this.length && s || s.length < 200 && this.leafAppend(s) || this.length < 200 && s.leafPrepend(this) || this.appendInner(s)) : this }, ea.prototype.prepend = function (s) { return s.length ? ea.from(s).append(this) : this }, ea.prototype.appendInner = function (s) { return new Dh(this, s) }, ea.prototype.slice = function (s, l) { return void 0 === s && (s = 0), void 0 === l && (l = this.length), s >= l ? ea.empty : this.sliceInner(Math.max(0, s), Math.min(this.length, l)) }, ea.prototype.get = function (s) { if (!(s < 0 || s >= this.length)) return this.getInner(s) }, ea.prototype.forEach = function (s, l, h) { void 0 === l && (l = 0), void 0 === h && (h = this.length), l <= h ? this.forEachInner(s, l, h, 0) : this.forEachInvertedInner(s, l, h, 0) }, ea.prototype.map = function (s, l, h) { void 0 === l && (l = 0), void 0 === h && (h = this.length); var y = []; return this.forEach(function (w, I) { return y.push(s(w, I)) }, l, h), y }, ea.from = function (s) { return s instanceof ea ? s : s && s.length ? new Th(s) : ea.empty }; var Th = function (f) { function s(h) { f.call(this), this.values = h } f && (s.__proto__ = f), (s.prototype = Object.create(f && f.prototype)).constructor = s; var l = { length: { configurable: !0 }, depth: { configurable: !0 } }; return s.prototype.flatten = function () { return this.values }, s.prototype.sliceInner = function (y, w) { return 0 == y && w == this.length ? this : new s(this.values.slice(y, w)) }, s.prototype.getInner = function (y) { return this.values[y] }, s.prototype.forEachInner = function (y, w, I, k) { for (var H = w; H < I; H++)if (!1 === y(this.values[H], k + H)) return !1 }, s.prototype.forEachInvertedInner = function (y, w, I, k) { for (var H = w - 1; H >= I; H--)if (!1 === y(this.values[H], k + H)) return !1 }, s.prototype.leafAppend = function (y) { if (this.length + y.length <= 200) return new s(this.values.concat(y.flatten())) }, s.prototype.leafPrepend = function (y) { if (this.length + y.length <= 200) return new s(y.flatten().concat(this.values)) }, l.length.get = function () { return this.values.length }, l.depth.get = function () { return 0 }, Object.defineProperties(s.prototype, l), s }(ea); ea.empty = new Th([]); var Dh = function (f) { function s(l, h) { f.call(this), this.left = l, this.right = h, this.length = l.length + h.length, this.depth = Math.max(l.depth, h.depth) + 1 } return f && (s.__proto__ = f), (s.prototype = Object.create(f && f.prototype)).constructor = s, s.prototype.flatten = function () { return this.left.flatten().concat(this.right.flatten()) }, s.prototype.getInner = function (h) { return h < this.left.length ? this.left.get(h) : this.right.get(h - this.left.length) }, s.prototype.forEachInner = function (h, y, w, I) { var k = this.left.length; if (y < k && !1 === this.left.forEachInner(h, y, Math.min(w, k), I) || w > k && !1 === this.right.forEachInner(h, Math.max(y - k, 0), Math.min(this.length, w) - k, I + k)) return !1 }, s.prototype.forEachInvertedInner = function (h, y, w, I) { var k = this.left.length; if (y > k && !1 === this.right.forEachInvertedInner(h, y - k, Math.max(w, k) - k, I + k) || w < k && !1 === this.left.forEachInvertedInner(h, Math.min(y, k), w, I)) return !1 }, s.prototype.sliceInner = function (h, y) { if (0 == h && y == this.length) return this; var w = this.left.length; return y <= w ? this.left.slice(h, y) : h >= w ? this.right.slice(h - w, y - w) : this.left.slice(h, w).append(this.right.slice(0, y - w)) }, s.prototype.leafAppend = function (h) { var y = this.right.leafAppend(h); if (y) return new s(this.left, y) }, s.prototype.leafPrepend = function (h) { var y = this.left.leafPrepend(h); if (y) return new s(y, this.right) }, s.prototype.appendInner = function (h) { return this.left.depth >= Math.max(this.right.depth, h.depth) + 1 ? new s(this.left, new s(this.right, h)) : new s(this, h) }, s }(ea); const Ed = ea; class Ju { constructor(s, l) { this.items = s, this.eventCount = l } popEvent(s, l) { if (0 == this.eventCount) return null; let y, w, h = this.items.length; for (; ; h--)if (this.items.get(h - 1).selection) { --h; break } l && (y = this.remapping(h, this.items.length), w = y.maps.length); let k, H, I = s.tr, te = [], se = []; return this.items.forEach((Ge, at) => { if (!Ge.step) return y || (y = this.remapping(h, at + 1), w = y.maps.length), w--, void se.push(Ge); if (y) { se.push(new Qu(Ge.map)); let $t, ut = Ge.step.map(y.slice(w)); ut && I.maybeStep(ut).doc && ($t = I.mapping.maps[I.mapping.maps.length - 1], te.push(new Qu($t, void 0, void 0, te.length + se.length))), w--, $t && y.appendMap($t, w) } else I.maybeStep(Ge.step); return Ge.selection ? (k = y ? Ge.selection.map(y.slice(w)) : Ge.selection, H = new Ju(this.items.slice(0, h).append(se.reverse().concat(te)), this.eventCount - 1), !1) : void 0 }, this.items.length, 0), { remaining: H, transform: I, selection: k } } addTransform(s, l, h, y) { let w = [], I = this.eventCount, k = this.items, H = !y && k.length ? k.get(k.length - 1) : null; for (let se = 0; se < s.steps.length; se++) { let ut, Ge = s.steps[se].invert(s.docs[se]), at = new Qu(s.mapping.maps[se], Ge, l); (ut = H && H.merge(at)) && (at = ut, se ? w.pop() : k = k.slice(0, k.length - 1)), w.push(at), l && (I++, l = void 0), y || (H = at) } let te = I - h.depth; return te > Sh && (k = function wg(f, s) { let l; return f.forEach((h, y) => { if (h.selection && 0 == s--) return l = y, !1 }), f.slice(l) }(k, te), I -= te), new Ju(k.append(w), I) } remapping(s, l) { let h = new Ct; return this.items.forEach((y, w) => { h.appendMap(y.map, null != y.mirrorOffset && w - y.mirrorOffset >= s ? h.maps.length - y.mirrorOffset : void 0) }, s, l), h } addMaps(s) { return 0 == this.eventCount ? this : new Ju(this.items.append(s.map(l => new Qu(l))), this.eventCount) } rebased(s, l) { if (!this.eventCount) return this; let h = [], y = Math.max(0, this.items.length - l), w = s.mapping, I = s.steps.length, k = this.eventCount; this.items.forEach(at => { at.selection && k-- }, y); let H = l; this.items.forEach(at => { let ut = w.getMirror(--H); if (null == ut) return; I = Math.min(I, ut); let $t = w.maps[ut]; if (at.step) { let Dn = s.steps[ut].invert(s.docs[ut]), $n = at.selection && at.selection.map(w.slice(H + 1, ut)); $n && k++, h.push(new Qu($t, Dn, $n)) } else h.push(new Qu($t)) }, y); let te = []; for (let at = l; at < I; at++)te.push(new Qu(w.maps[at])); let se = this.items.slice(0, y).append(te).append(h), Ge = new Ju(se, k); return Ge.emptyItemCount() > 500 && (Ge = Ge.compress(this.items.length - h.length)), Ge } emptyItemCount() { let s = 0; return this.items.forEach(l => { l.step || s++ }), s } compress(s = this.items.length) { let l = this.remapping(0, s), h = l.maps.length, y = [], w = 0; return this.items.forEach((I, k) => { if (k >= s) y.push(I), I.selection && w++; else if (I.step) { let H = I.step.map(l.slice(h)), te = H && H.getMap(); if (h--, te && l.appendMap(te, h), H) { let se = I.selection && I.selection.map(l.slice(h)); se && w++; let at, Ge = new Qu(te.invert(), H, se), ut = y.length - 1; (at = y.length && y[ut].merge(Ge)) ? y[ut] = at : y.push(Ge) } } else I.map && h-- }, this.items.length, 0), new Ju(Ed.from(y.reverse()), w) } } Ju.empty = new Ju(Ed.empty, 0); class Qu { constructor(s, l, h, y) { this.map = s, this.step = l, this.selection = h, this.mirrorOffset = y } merge(s) { if (this.step && s.step && !s.selection) { let l = s.step.merge(this.step); if (l) return new Qu(l.getMap().invert(), l, this.selection) } } } class Xu { constructor(s, l, h, y) { this.done = s, this.undone = l, this.prevRanges = h, this.prevTime = y } } const Sh = 20; function Td(f) { let s = []; return f.forEach((l, h, y, w) => s.push(y, w)), s } function Ih(f, s) { if (!f) return null; let l = []; for (let h = 0; h < f.length; h += 2) { let y = s.map(f[h], 1), w = s.map(f[h + 1], -1); y <= w && l.push(y, w) } return l } function Zd(f, s, l, h) { let y = ou(s), w = Vc.get(s).spec.config, I = (h ? f.undone : f.done).popEvent(s, y); if (!I) return; let k = I.selection.resolve(I.transform.doc), H = (h ? f.done : f.undone).addTransform(I.transform, s.selection.getBookmark(), w, y), te = new Xu(h ? H : I.remaining, h ? I.remaining : H, null, 0); l(I.transform.setSelection(k).setMeta(Vc, { redo: h, historyState: te }).scrollIntoView()) } let qd = !1, ks = null; function ou(f) { let s = f.plugins; if (ks != s) { qd = !1, ks = s; for (let l = 0; l < s.length; l++)if (s[l].spec.historyPreserveItems) { qd = !0; break } } return qd } const Vc = new rs("history"), v = new rs("closeHistory"); const p = (f, s) => { let l = Vc.getState(f); return !(!l || 0 == l.done.eventCount || (s && Zd(l, f, s, !1), 0)) }, T = (f, s) => { let l = Vc.getState(f); return !(!l || 0 == l.undone.eventCount || (s && Zd(l, f, s, !0), 0)) }, Re = ["imgEl"]; function Ke(f, s) { if (1 & f) { const l = i.EpF(); i.TgZ(0, "span", 4)(1, "span", 5), i.NdJ("mousedown", function (y) { i.CHM(l); const w = i.oxw(); return i.KtG(w.startResizing(y, "left")) }), i.qZA(), i.TgZ(2, "span", 6), i.NdJ("mousedown", function (y) { i.CHM(l); const w = i.oxw(); return i.KtG(w.startResizing(y, "right")) }), i.qZA(), i.TgZ(3, "span", 7), i.NdJ("mousedown", function (y) { i.CHM(l); const w = i.oxw(); return i.KtG(w.startResizing(y, "left")) }), i.qZA(), i.TgZ(4, "span", 8), i.NdJ("mousedown", function (y) { i.CHM(l); const w = i.oxw(); return i.KtG(w.startResizing(y, "right")) }), i.qZA()() } } const yt = function (f) { return { "NgxEditor__Resizer--Active": f } }, Vt = ["ngxEditor"], Wt = ["*"]; function vn(f, s) { if (1 & f && (i.TgZ(0, "div", 12), i._uU(1), i.qZA()), 2 & f) { const l = i.oxw(2); i.xp6(1), i.hij(" ", (null == l.href.errors ? null : l.href.errors.pattern) && "Please enter valid url.", " ") } } function In(f, s) { if (1 & f && (i.TgZ(0, "div", 12), i._uU(1), i.qZA()), 2 & f) { const l = i.oxw(2); i.xp6(1), i.hij(" ", (null == l.text.errors ? null : l.text.errors.required) && "This is required", " ") } } function Un(f, s) { if (1 & f) { const l = i.EpF(); i.TgZ(0, "div", 2)(1, "form", 3), i.NdJ("ngSubmit", function (y) { i.CHM(l); const w = i.oxw(); return i.KtG(w.insertLink(y)) }), i.TgZ(2, "div", 4)(3, "div", 5)(4, "label", 6), i._uU(5), i.qZA(), i._UZ(6, "input", 7), i.YNc(7, vn, 2, 1, "div", 8), i.qZA()(), i.TgZ(8, "div", 4)(9, "div", 5)(10, "label", 6), i._uU(11), i.qZA(), i._UZ(12, "input", 9), i.YNc(13, In, 2, 1, "div", 8), i.qZA()(), i.TgZ(14, "div", 4)(15, "div", 5)(16, "label"), i._UZ(17, "input", 10), i._uU(18), i.qZA()()(), i.TgZ(19, "button", 11), i._uU(20), i.qZA()()() } if (2 & f) { const l = i.oxw(); i.xp6(1), i.Q6J("formGroup", l.form), i.xp6(4), i.Oqu(l.getLabel("url")), i.xp6(2), i.Q6J("ngIf", l.href.touched && l.href.invalid), i.xp6(4), i.Oqu(l.getLabel("text")), i.xp6(2), i.Q6J("ngIf", l.text.touched && l.text.invalid), i.xp6(5), i.hij(" ", l.getLabel("openInNewTab"), " "), i.xp6(1), i.Q6J("disabled", !l.form.valid), i.xp6(1), i.Oqu(l.getLabel("insert")) } } const bi = function (f, s) { return { "NgxEditor__Dropdown--Active": f, "NgxEditor--Disabled": s } }; function Cr(f, s) { if (1 & f) { const l = i.EpF(); i.TgZ(0, "div", 4), i.NdJ("mousedown", function (y) { const I = i.CHM(l).$implicit, k = i.oxw(2); return i.KtG(k.onClick(y, I)) }), i._uU(1), i.qZA() } if (2 & f) { const l = s.$implicit, h = i.oxw(2); i.Q6J("ngClass", i.WLB(2, bi, l === h.activeItem, h.disabledItems.includes(l))), i.xp6(1), i.hij(" ", h.getName(l), " ") } } function qr(f, s) { if (1 & f && (i.TgZ(0, "div", 2), i.YNc(1, Cr, 2, 5, "div", 3), i.qZA()), 2 & f) { const l = i.oxw(); i.xp6(1), i.Q6J("ngForOf", l.items)("ngForTrackBy", l.trackByIndex) } } function oi(f, s) { if (1 & f && (i.TgZ(0, "div", 12), i._uU(1), i.qZA()), 2 & f) { const l = i.oxw(2); i.xp6(1), i.hij(" ", (null == l.src.errors ? null : l.src.errors.pattern) && "Please enter valid url.", " ") } } function ki(f, s) { if (1 & f) { const l = i.EpF(); i.TgZ(0, "div", 2)(1, "form", 3), i.NdJ("ngSubmit", function (y) { i.CHM(l); const w = i.oxw(); return i.KtG(w.insertLink(y)) }), i.TgZ(2, "div", 4)(3, "div", 5)(4, "label", 6), i._uU(5), i.qZA(), i._UZ(6, "input", 7), i.YNc(7, oi, 2, 1, "div", 8), i.qZA()(), i.TgZ(8, "div", 4)(9, "div", 5)(10, "label", 6), i._uU(11), i.qZA(), i._UZ(12, "input", 9), i.qZA()(), i.TgZ(13, "div", 4)(14, "div", 5)(15, "label", 6), i._uU(16), i.qZA(), i._UZ(17, "input", 10), i.qZA()(), i.TgZ(18, "button", 11), i._uU(19), i.qZA()()() } if (2 & f) { const l = i.oxw(); i.xp6(1), i.Q6J("formGroup", l.form), i.xp6(4), i.Oqu(l.getLabel("url")), i.xp6(2), i.Q6J("ngIf", l.src.touched && l.src.invalid), i.xp6(4), i.Oqu(l.getLabel("altText")), i.xp6(5), i.Oqu(l.getLabel("title")), i.xp6(2), i.Q6J("disabled", !l.form.valid || !l.form.dirty), i.xp6(1), i.Oqu(l.getLabel("insert")) } } const qi = function (f, s) { return { backgroundColor: f, color: s } }, Ri = function (f) { return { "NgxEditor__Color--Active": f } }; function di(f, s) { if (1 & f) { const l = i.EpF(); i.TgZ(0, "button", 7), i.NdJ("mousedown", function (y) { const I = i.CHM(l).$implicit, k = i.oxw(3); return i.KtG(k.onColorSelect(y, I)) }), i.qZA() } if (2 & f) { const l = s.$implicit, h = i.oxw(3); i.Q6J("ngStyle", i.WLB(3, qi, l, h.getContrastYIQ(l)))("title", l)("ngClass", i.VKq(6, Ri, h.activeColors.includes(l))) } } function zi(f, s) { if (1 & f && (i.TgZ(0, "div", 5), i.YNc(1, di, 1, 8, "button", 6), i.qZA()), 2 & f) { const l = s.$implicit, h = i.oxw(2); i.xp6(1), i.Q6J("ngForOf", l)("ngForTrackBy", h.trackByIndex) } } function gs(f, s) { if (1 & f) { const l = i.EpF(); i.TgZ(0, "div", 2), i.YNc(1, zi, 2, 2, "div", 3), i.TgZ(2, "button", 4), i.NdJ("mousedown", function (y) { i.CHM(l); const w = i.oxw(); return i.KtG(w.remove(y)) }), i._uU(3), i.qZA()() } if (2 & f) { const l = i.oxw(); i.xp6(1), i.Q6J("ngForOf", l.presets)("ngForTrackBy", l.trackByIndex), i.xp6(1), i.Q6J("disabled", !l.isActive), i.xp6(1), i.hij(" ", l.getLabel("remove"), " ") } } function Yi(f, s) { if (1 & f && i._UZ(0, "ngx-toggle-command", 7), 2 & f) { const l = i.oxw().$implicit, h = i.oxw(2); i.Tol(h.iconContainerClass), i.Q6J("toolbarItem", l) } } function ua(f, s) { if (1 & f && i._UZ(0, "ngx-insert-command", 7), 2 & f) { const l = i.oxw().$implicit, h = i.oxw(2); i.Tol(h.iconContainerClass), i.Q6J("toolbarItem", l) } } function Fo(f, s) { if (1 & f && i._UZ(0, "ngx-link"), 2 & f) { const l = i.oxw(3); i.Tol(l.iconContainerClass) } } function co(f, s) { if (1 & f && i._UZ(0, "ngx-image"), 2 & f) { const l = i.oxw(3); i.Tol(l.iconContainerClass) } } function au(f, s) { if (1 & f && i._UZ(0, "ngx-dropdown", 9), 2 & f) { const l = s.$implicit, h = i.oxw(4); i.Tol(h.dropdownContainerClass), i.Q6J("group", l.key)("items", l.value) } } function Ha(f, s) { if (1 & f && (i.ynx(0), i.YNc(1, au, 1, 4, "ngx-dropdown", 8), i.ALo(2, "keyvalue"), i.BQk()), 2 & f) { const l = i.oxw().$implicit, h = i.oxw(2); i.xp6(1), i.Q6J("ngForOf", i.lcZ(2, 2, h.getDropdownItems(l)))("ngForTrackBy", h.trackByIndex) } } function Iu(f, s) { if (1 & f && i._UZ(0, "ngx-color-picker", 10), 2 & f) { const l = i.oxw(3); i.Tol(l.iconContainerClass), i.Q6J("presets", l.presets) } } function Ul(f, s) { if (1 & f && i._UZ(0, "ngx-color-picker", 11), 2 & f) { const l = i.oxw(3); i.Tol(l.iconContainerClass), i.Q6J("presets", l.presets) } } function Sl(f, s) { if (1 & f && i._UZ(0, "div"), 2 & f) { const l = i.oxw(3); i.Tol(l.seperatorClass) } } function cc(f, s) { if (1 & f && (i.ynx(0), i.YNc(1, Yi, 1, 3, "ngx-toggle-command", 3), i.YNc(2, ua, 1, 3, "ngx-insert-command", 3), i.YNc(3, Fo, 1, 2, "ngx-link", 4), i.YNc(4, co, 1, 2, "ngx-image", 4), i.YNc(5, Ha, 3, 4, "ng-container", 2), i.YNc(6, Iu, 1, 3, "ngx-color-picker", 5), i.YNc(7, Ul, 1, 3, "ngx-color-picker", 6), i.YNc(8, Sl, 1, 2, "div", 4), i.BQk()), 2 & f) { const l = s.$implicit, h = s.last, y = i.oxw().last, w = i.oxw(); i.xp6(1), i.Q6J("ngIf", w.toggleCommands.includes(l)), i.xp6(1), i.Q6J("ngIf", w.insertCommands.includes(l)), i.xp6(1), i.Q6J("ngIf", "link" === l), i.xp6(1), i.Q6J("ngIf", "image" === l), i.xp6(1), i.Q6J("ngIf", w.isDropDown(l)), i.xp6(1), i.Q6J("ngIf", "text_color" === l), i.xp6(1), i.Q6J("ngIf", "background_color" === l), i.xp6(1), i.Q6J("ngIf", h && !y) } } function Vf(f, s) { if (1 & f && (i.ynx(0), i.YNc(1, cc, 9, 8, "ng-container", 1), i.BQk()), 2 & f) { const l = s.$implicit, h = i.oxw(); i.xp6(1), i.Q6J("ngForOf", l)("ngForTrackBy", h.trackByIndex) } } function Kd(f, s) { if (1 & f && (i.ynx(0), i.GkF(1, 12), i.BQk()), 2 & f) { const l = i.oxw(); i.xp6(1), i.Q6J("ngTemplateOutlet", l.customMenuRef) } } const Jh = function (f, s) { return { "NgxEditor--Disabled": f, "NgxEditor__MenuBar--Reverse": s } }, Xh = (f = !0) => new wo({ key: new rs("editable"), state: { init: () => f, apply: (s, l) => s.getMeta("UPDATE_EDITABLE") ?? l }, props: { editable(s) { return this.getState(s) }, attributes(s) { return this.getState(s) ? null : { class: "NgxEditor__Content--Disabled" } } } }), ef = f => new wo({ key: new rs("placeholder"), state: { init: () => f ?? "", apply: (s, l) => s.getMeta("UPDATE_PLACEHOLDER") ?? l }, props: { decorations(s) { const { doc: l } = s, { textContent: h, childCount: y } = l, w = this.getState(s); if (!w || y > 1) return ps.empty; const I = []; return l.descendants((H, te) => { if (H.type.isBlock && 0 === H.childCount && 0 === h.length) { const at = Qo.node(te, te + H.nodeSize, { class: "NgxEditor__Placeholder", "data-placeholder": w, "data-align": H.attrs.align ?? null }); I.push(at) } return !1 }), ps.create(l, I) } } }); let wp = (() => { class f { constructor() { this.alt = "", this.title = "", this.outerWidth = "", this.selected = !1, this.imageResize = new i.vpe } startResizing(l, h) { l.preventDefault(), this.resizeImage(l, h) } resizeImage(l, h) { const y = l.pageX, w = this.imgEl.nativeElement.clientWidth, I = "left" === h, { width: k } = window.getComputedStyle(this.view.dom), H = parseInt(k, 10), te = Ge => { const ut = Ge.pageX - y, $t = I ? w - ut : w + ut; $t > H || $t < 20 || (this.outerWidth = `${$t}px`) }, se = Ge => { Ge.preventDefault(), document.removeEventListener("mousemove", te), document.removeEventListener("mouseup", se), this.imageResize.emit() }; document.addEventListener("mousemove", te), document.addEventListener("mouseup", se) } } return f.\u0275fac = function (l) { return new (l || f) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-image-view"]], viewQuery: function (l, h) { if (1 & l && i.Gf(Re, 7), 2 & l) { let y; i.iGM(y = i.CRH()) && (h.imgEl = y.first) } }, inputs: { src: "src", alt: "alt", title: "title", outerWidth: "outerWidth", selected: "selected", view: "view" }, outputs: { imageResize: "imageResize" }, decls: 4, vars: 9, consts: [[1, "NgxEditor__ImageWrapper", 3, "ngClass"], ["class", "NgxEditor__ResizeHandle", 4, "ngIf"], [3, "src", "alt", "title"], ["imgEl", ""], [1, "NgxEditor__ResizeHandle"], [1, "NgxEditor__ResizeHandle--TL", 3, "mousedown"], [1, "NgxEditor__ResizeHandle--TR", 3, "mousedown"], [1, "NgxEditor__ResizeHandle--BL", 3, "mousedown"], [1, "NgxEditor__ResizeHandle--BR", 3, "mousedown"]], template: function (l, h) { 1 & l && (i.TgZ(0, "span", 0), i.YNc(1, Ke, 5, 0, "span", 1), i._UZ(2, "img", 2, 3), i.qZA()), 2 & l && (i.Udp("width", h.outerWidth), i.Q6J("ngClass", i.VKq(7, yt, h.selected)), i.xp6(1), i.Q6J("ngIf", h.selected), i.xp6(1), i.Q6J("src", h.src, i.LSH)("alt", h.alt)("title", h.title)) }, dependencies: [mo.mk, mo.O5], styles: ["*[_ngcontent-%COMP%], *[_ngcontent-%COMP%]:before, *[_ngcontent-%COMP%]:after{box-sizing:border-box}img[_ngcontent-%COMP%]{width:100%;height:100%}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]{position:relative;display:inline-block;line-height:0;padding:2px}.NgxEditor__ImageWrapper.NgxEditor__Resizer--Active[_ngcontent-%COMP%]{padding:1px;border:1px solid #1a73e8}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]{position:absolute;height:100%;width:100%}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TL[_ngcontent-%COMP%], .NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BL[_ngcontent-%COMP%], .NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TR[_ngcontent-%COMP%], .NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BR[_ngcontent-%COMP%]{position:absolute;width:7px;height:7px;background-color:#1a73e8;border:1px solid white}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BR[_ngcontent-%COMP%]{bottom:-5px;right:-5px;cursor:se-resize}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TR[_ngcontent-%COMP%]{top:-5px;right:-5px;cursor:ne-resize}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TL[_ngcontent-%COMP%]{top:-5px;left:-5px;cursor:nw-resize}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BL[_ngcontent-%COMP%]{bottom:-5px;left:-5px;cursor:sw-resize}"] }), f })(); class Id { constructor(s, l, h, y) { this.updating = !1, this.handleResize = () => { if (this.updating) return; const { state: w, dispatch: I } = this.view, { tr: k } = w, H = k.setNodeMarkup(this.getPos(), void 0, { ...this.node.attrs, width: this.imageComponentRef.instance.outerWidth }), te = H.doc.resolve(this.getPos()), se = new Xn(te); H.setSelection(se), I(H) }, this.applicationRef = y.get(i.z2F), this.imageComponentRef = (0, i.LMc)(wp, { environmentInjector: this.applicationRef.injector }), this.applicationRef.attachView(this.imageComponentRef.hostView), this.setNodeAttributes(s.attrs), this.imageComponentRef.instance.view = l, this.dom = this.imageComponentRef.location.nativeElement, this.view = l, this.node = s, this.getPos = h, this.resizeSubscription = this.imageComponentRef.instance.imageResize.subscribe(() => { this.handleResize() }) } computeChanges(s, l) { return JSON.stringify(s) === JSON.stringify(l) } setNodeAttributes(s) { this.imageComponentRef.instance.src = s.src, this.imageComponentRef.instance.alt = s.alt, this.imageComponentRef.instance.title = s.title, this.imageComponentRef.instance.outerWidth = s.width } update(s) { return s.type === this.node.type && (this.node = s, this.computeChanges(this.node.attrs, s.attrs) && (this.updating = !0, this.setNodeAttributes(s.attrs), this.updating = !1), !0) } ignoreMutation() { return !0 } selectNode() { this.imageComponentRef.instance.selected = !0 } deselectNode() { this.imageComponentRef.instance.selected = !1 } destroy() { this.resizeSubscription.unsubscribe(), this.applicationRef.detachView(this.imageComponentRef.hostView) } } const Cg = /(?:https?:\/\/)?[\w-]+(?:\.[\w-]+)+\.?(?:\d+)?(?:\/\S*)?$/, Uf = f => { const s = []; return f.forEach(l => { if (l.isText) { const h = l.text; let y = 0; const w = Cg.exec(h); if (w) { const I = w.index, k = I + w[0].length, { link: H } = l.type.schema.marks; I > 0 && s.push(l.cut(y, I)); const te = h.slice(I, k); s.push(l.cut(I, k).mark(H.create({ href: te }).addToSet(l.marks))), y = k } y < h.length && s.push(l.cut(y)) } else s.push(l.copy(Uf(l.content))) }), Se.fromArray(s) }, Eg = { type: "doc", content: [{ type: "paragraph" }] }, Ad = (f, s) => { if (!f) return s.nodeFromJSON(Eg); if ("string" != typeof f) return s.nodeFromJSON(f); const l = ((f, s) => { const l = s ?? ju, h = document.createElement("div"); return h.innerHTML = f, yn.fromSchema(l).parse(h).toJSON() })(f, s); return s.nodeFromJSON(l) }; let Hf = (() => { class f { constructor(l, h, y) { this.renderer = l, this.injector = h, this.elementRef = y, this.placeholder = "Type Here...", this.focusOut = new i.vpe, this.focusIn = new i.vpe, this.unsubscribe = new J.x, this.onChange = () => { }, this.onTouched = () => { } } writeValue(l) { !this.outputFormat && "string" == typeof l && (this.outputFormat = "html"), this.editor.setContent(l ?? "") } registerOnChange(l) { this.onChange = l } registerOnTouched(l) { this.onTouched = l } setDisabledState(l) { this.setMeta("UPDATE_EDITABLE", !l), this.renderer.setProperty(this.elementRef.nativeElement, "disabled", l) } handleChange(l) { if ("html" !== this.outputFormat) this.onChange(l); else { const h = ((f, s) => { const l = this.editor.schema ?? ju, h = l.nodeFromJSON(f), y = qe.fromSchema(l).serializeFragment(h.content), w = document.createElement("div"); return w.appendChild(y), w.innerHTML })(l); this.onChange(h) } } setMeta(l, h) { const { dispatch: y, state: { tr: w } } = this.editor.view; y(w.setMeta(l, h)) } setPlaceholder(l) { this.setMeta("UPDATE_PLACEHOLDER", l) } registerPlugins() { this.editor.registerPlugin(Xh()), this.editor.registerPlugin(ef(this.placeholder)), this.editor.registerPlugin(((f = {}) => new wo({ key: new rs("attributes"), props: { attributes: f } }))({ class: "NgxEditor__Content" })), this.editor.registerPlugin((f => new wo({ key: new rs("focus"), props: { handleDOMEvents: { focus: () => (f(), !1) } } }))(() => { this.focusIn.emit() })), this.editor.registerPlugin((f => new wo({ key: new rs("blur"), props: { handleDOMEvents: { blur: () => (f(), !1) } } }))(() => { this.focusOut.emit(), this.onTouched() })), this.editor.features.resizeImage && this.editor.registerPlugin((f => new wo({ key: new rs("image-resize"), props: { nodeViews: { image: (s, l, h) => new Id(s, l, h, f) } } }))(this.injector)), this.editor.features.linkOnPaste && this.editor.registerPlugin(new wo({ key: new rs("linkify"), props: { transformPasted: f => new Qe(Uf(f.content), f.openStart, f.openEnd) } })) } ngOnInit() { if (!this.editor) throw new _e("Required editor instance for initializing editor component"); this.registerPlugins(), this.renderer.appendChild(this.ngxEditor.nativeElement, this.editor.view.dom), this.editor.valueChanges.pipe((0, ye.R)(this.unsubscribe)).subscribe(l => { this.handleChange(l) }) } ngOnChanges(l) { l.placeholder && !l.placeholder.isFirstChange() && this.setPlaceholder(l.placeholder.currentValue) } ngOnDestroy() { this.unsubscribe.next(), this.unsubscribe.complete() } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(i.Qsj), i.Y36(i.zs3), i.Y36(i.SBq)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-editor"]], viewQuery: function (l, h) { if (1 & l && i.Gf(Vt, 7), 2 & l) { let y; i.iGM(y = i.CRH()) && (h.ngxEditor = y.first) } }, inputs: { editor: "editor", outputFormat: "outputFormat", placeholder: "placeholder" }, outputs: { focusOut: "focusOut", focusIn: "focusIn" }, features: [i._Bn([{ provide: m.JU, useExisting: (0, i.Gpc)(() => f), multi: !0 }]), i.TTD], ngContentSelectors: Wt, decls: 3, vars: 0, consts: [[1, "NgxEditor"], ["ngxEditor", ""]], template: function (l, h) { 1 & l && (i.F$t(), i.TgZ(0, "div", 0, 1), i.Hsn(2), i.qZA()) }, styles: ['.NgxEditor{background:white;color:#000;background-clip:padding-box;border-radius:4px;border:1px solid rgba(0,0,0,.2);position:relative}.NgxEditor--Disabled{opacity:.5;pointer-events:none}.NgxEditor__Placeholder:before{color:#6c757d;opacity:1;-webkit-user-select:none;user-select:none;position:absolute;cursor:text;content:attr(data-placeholder)}.NgxEditor__Placeholder[data-align=right]:before{position:relative}.NgxEditor__Content{padding:8px;white-space:pre-wrap;outline:none;font-variant-ligatures:none;font-feature-settings:"liga" 0,none}.NgxEditor__Content p{margin:0 0 10px}.NgxEditor__Content blockquote{padding-left:16px;border-left:3px solid #ddd;margin-left:0;margin-right:0}.NgxEditor__Content--Disabled{-webkit-user-select:none;user-select:none;pointer-events:none}.NgxEditor__Wrapper{border:1px solid rgba(0,0,0,.4);border-radius:4px}.NgxEditor__Wrapper .NgxEditor__MenuBar{border-top-left-radius:4px;border-top-right-radius:4px;border-bottom:1px solid rgba(0,0,0,.2)}.NgxEditor__Wrapper .NgxEditor{border-top-left-radius:0;border-top-right-radius:0;border:none}.NgxEditor__MenuBar{display:flex;flex-wrap:wrap;padding:3px;cursor:default;background-color:#fff}.NgxEditor__MenuItem{border-radius:2px;display:flex;align-items:center;justify-content:center;position:relative;flex-shrink:0}.NgxEditor__MenuItem:hover{background-color:#f1f1f1}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon{height:30px;width:30px;transition:.3s ease-in-out}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon+.NgxEditor__MenuItem--Icon{margin-left:2px}.NgxEditor__MenuItem .NgxEditor__MenuItem--IconContainer{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 5px}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active,.NgxEditor__MenuItem .NgxEditor__MenuItem--Active{background-color:#e8f0fe;color:#1a73e8}.NgxEditor__Dropdown{min-width:64px;position:relative;display:flex;align-items:center;flex-shrink:0}.NgxEditor__Dropdown:hover{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text{display:flex;align-items:center;justify-content:center;padding:0 5px;height:100%;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:after{display:inline-block;content:"";margin-left:24px;vertical-align:4px;border-top:4px solid;border-right:4px solid transparent;border-bottom:0;border-left:4px solid transparent}.NgxEditor__Dropdown .NgxEditor__Dropdown--DropdownMenu{position:absolute;left:0;box-shadow:#3c404326 0 2px 6px 2px;border-radius:4px;background-color:#fff;z-index:10;width:100%;top:32px}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item{padding:8px;white-space:nowrap;color:inherit}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:hover{background-color:#ececec}.NgxEditor__Dropdown .NgxEditor__Dropdown--Selected,.NgxEditor__Dropdown .NgxEditor__Dropdown--Open{color:#1a73e8;background-color:#e8f0fe}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:#e7e7e7}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--DropdownMenu{top:unset;bottom:32px}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--Text:after{transform:rotate(180deg)}.NgxEditor__MenuBar--Reverse .NgxEditor__Popup{top:unset;bottom:32px}.NgxEditor__Popup{position:absolute;top:32px;box-shadow:#3c404326 0 2px 6px 2px;border-radius:4px;background-color:#fff;z-index:10;min-width:192px;padding:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup{margin-bottom:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup label{margin-bottom:3px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=text],.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=url]{padding:2px 4px}.NgxEditor__Popup .NgxEditor__Popup--Col{display:flex;flex-direction:column;position:relative}.NgxEditor__Popup .NgxEditor__Popup--Label{font-size:85%}.NgxEditor__Seperator{border-left:1px solid #ccc;margin:0 5px}.NgxEditor__HelpText{font-size:80%}.NgxEditor__HelpText.NgxEditor__HelpText--Error{color:red}\n'], encapsulation: 2 }), f })(), uc = (() => { class f { constructor() { this.customMenuRefChange = new J.x } setCustomMenuRef(l) { this.customMenuRefChange.next(l) } } return f.\u0275fac = function (l) { return new (l || f) }, f.\u0275prov = i.Yz7({ token: f, factory: f.\u0275fac, providedIn: "root" }), f })(); const a0 = { bold: '\n  <path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z" />\n', italic: '\n  <path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z" />\n', code: '\n<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>\n', underline: '\n<path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/>\n', strike: '\n<path d="M6.85,7.08C6.85,4.37,9.45,3,12.24,3c1.64,0,3,0.49,3.9,1.28c0.77,0.65,1.46,1.73,1.46,3.24h-3.01 c0-0.31-0.05-0.59-0.15-0.85c-0.29-0.86-1.2-1.28-2.25-1.28c-1.86,0-2.34,1.02-2.34,1.7c0,0.48,0.25,0.88,0.74,1.21 C10.97,8.55,11.36,8.78,12,9H7.39C7.18,8.66,6.85,8.11,6.85,7.08z M21,12v-2H3v2h9.62c1.15,0.45,1.96,0.75,1.96,1.97 c0,1-0.81,1.67-2.28,1.67c-1.54,0-2.93-0.54-2.93-2.51H6.4c0,0.55,0.08,1.13,0.24,1.58c0.81,2.29,3.29,3.3,5.67,3.3 c2.27,0,5.3-0.89,5.3-4.05c0-0.3-0.01-1.16-0.48-1.94H21V12z"/>\n', ordered_list: '\n<path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/>\n', bullet_list: '\n<path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"/>\n', blockquote: '\n<path d="M0 0h24v24H0z" fill="none"/><path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"/>\n', link: '\n<path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>\n', unlink: '\n<path d="M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z"/>\n', image: '\n<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>\n', align_left: '\n<path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/>\n', align_center: '\n<path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/>\n', align_right: '\n<path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"/>\n', align_justify: '\n<path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/>\n', text_color: '\n<path d="M2,20h20v4H2V20z M5.49,17h2.42l1.27-3.58h5.65L16.09,17h2.42L13.25,3h-2.5L5.49,17z M9.91,11.39l2.03-5.79h0.12l2.03,5.79 H9.91z"/>\n', color_fill: '\n<path d="M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.48,17.15,9.53,16.56,8.94z M5.21,10L10,5.21L14.79,10H5.21z M19,11.5c0,0-2,2.17-2,3.5 c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M2,20h20v4H2V20z"/>\n', horizontal_rule: '\n  <g>\n    <rect fill="none" fill-rule="evenodd" height="24" width="24"/>\n    <rect fill-rule="evenodd" height="2" width="16" x="4" y="11"/>\n  </g>\n', format_clear: '\n<path d="M0 0h24v24H0z" fill="none"/><path d="M3.27 5L2 6.27l6.97 6.97L6.5 19h3l1.57-3.66L16.73 21 18 19.73 3.55 5.27 3.27 5zM6 5v.18L8.82 8h2.4l-.72 1.68 2.1 2.1L14.21 8H20V5H6z"/>\n' }; class jf { static get(s, l = "currentColor") { return `\n      <svg\n        xmlns="http://www.w3.org/2000/svg"\n        viewBox="0 0 24 24"\n        fill=${l}\n        height=20\n        width=20\n      >\n        ${a0[s] || "<path></path>"}\n      </svg>\n    ` } } class Lo { constructor(s) { this.name = s } apply() { return (s, l) => { const { schema: h } = s, y = h.marks[this.name]; return !!y && S(y)(s, l) } } toggle() { return (s, l) => { const { schema: h } = s, y = h.marks[this.name]; return !!y && Po(y)(s, l) } } isActive(s) { const { schema: l } = s, h = l.marks[this.name]; return !!h && ac(s, h) } canExecute(s) { return this.toggle()(s) } } class td { constructor(s = !1) { this.isBulletList = !1, this.isBulletList = s } getType(s) { return this.isBulletList ? s.nodes.bullet_list : s.nodes.ordered_list } toggle() { return (s, l) => { const { schema: h } = s, y = this.getType(h); return !!y && (this.isActive(s) ? Hu(h.nodes.list_item)(s, l) : function Ud(f, s = null) { return function (l, h) { let { $from: y, $to: w } = l.selection, I = y.blockRange(w), k = !1, H = I; if (!I) return !1; if (I.depth >= 2 && y.node(I.depth - 1).type.compatibleContent(f) && 0 == I.startIndex) { if (0 == y.index(I.depth - 1)) return !1; let se = l.doc.resolve(I.start - 2); H = new kn(se, se, I.depth), I.endIndex < I.parent.childCount && (I = new kn(y, l.doc.resolve(w.end(I.depth)), I.depth)), k = !0 } let te = Qi(H, f, s, I); return !!te && (h && h(function gh(f, s, l, h, y) { let w = Se.empty; for (let se = l.length - 1; se >= 0; se--)w = Se.from(l[se].type.create(l[se].attrs, w)); f.step(new Bi(s.start - (h ? 2 : 0), s.end, s.start, s.end, new Qe(w, 0, 0), l.length, !0)); let I = 0; for (let se = 0; se < l.length; se++)l[se].type == y && (I = se + 1); let k = l.length - I, H = s.start + l.length - (h ? 2 : 0), te = s.parent; for (let se = s.startIndex, Ge = s.endIndex, at = !0; se < Ge; se++, at = !1)!at && _s(f.doc, H, k) && (f.split(H, k), H += 2 * k), H += te.child(se).nodeSize; return f }(l.tr, I, te, k, f).scrollIntoView()), !0) } }(y)(s, l)) } } isActive(s) { const { schema: l } = s, h = this.getType(l); return !!h && Ch(s, h) } canExecute(s) { return this.toggle()(s) } } class Md { constructor(s) { this.level = s } apply() { return (s, l) => { const { schema: h } = s, y = h.nodes.heading; return !!y && Rc(y)(s, l) } } toggle() { return (s, l) => { const { schema: h, selection: y, doc: w } = s, I = h.nodes.heading; if (!I) return !1; const k = y.$from.before(1), te = w.nodeAt(k)?.attrs ?? {}; return this.isActive(s) ? Rc(h.nodes.paragraph, te)(s, l) : Rc(I, { ...te, level: this.level })(s, l) } } isActive(s) { const { schema: l } = s, h = Du(s), y = l.nodes.heading; if (!y) return !1; const w = [y, l.nodes.text, l.nodes.blockquote], k = h.filter(H => w.includes(H.type)).find(H => H.attrs.level === this.level); return Boolean(k) } canExecute(s) { return this.toggle()(s) } } class xh { constructor(s) { this.align = s } toggle() { return (s, l) => { const { doc: h, selection: y, tr: w, schema: I } = s, { from: k, to: H } = y; let te = !1; return h.nodesBetween(k, H, (se, Ge) => { const at = se.type; return [I.nodes.paragraph, I.nodes.heading].includes(at) && (te = !0, w.setNodeMarkup(Ge, at, { ...se.attrs, align: this.align })), !0 }), !!te && (w.docChanged && l?.(w), !0) } } isActive(s) { const h = Du(s).find(y => y.attrs.align === this.align); return Boolean(h) } canExecute(s) { return this.toggle()(s) } } const l0 = { strict: !0 }; class Sg { update(s) { return (l, h) => { const { schema: y, selection: w } = l, I = y.marks.link; return !(!I || w.empty) && Po(I, s)(l, h) } } insert(s, l) { return (h, y) => { const { schema: w, tr: I } = h; if (!w.marks.link) return !1; const te = w.text(s, [w.marks.link.create({ href: l.href, title: l.title ?? s, target: l.target ?? "_blank" })]); return I.replaceSelectionWith(te, !1).scrollIntoView(), !!I.docChanged && (y?.(I), !0) } } isActive(s, l = l0) { if (l.strict) return !0; const { schema: h } = s, y = h.marks.link; return !!y && ac(s, y) } remove(s, l) { return ((f, s) => { const { doc: l, selection: h, tr: y } = f, { $head: { pos: w }, from: I, to: k } = h; if (I === k) { const H = l.resolve(w), te = w - H.textOffset, se = te + H.parent.child(H.index()).nodeSize; y.removeMark(te, se) } else y.removeMark(I, k); return !!y.docChanged && (s?.(y), !0) })(s, l) } canExecute(s) { const l = { href: "" }; return this.insert("Exec", l)(s) || this.update(l)(s) } } class fy { insert(s, l) { return (h, y) => { const { schema: w, tr: I, selection: k } = h, H = w.nodes.image; if (!H) return !1; const te = { width: null, src: s, ...l }; !te.width && k instanceof Xn && k.node.type === H && (te.width = k.node.attrs.width), I.replaceSelectionWith(H.createAndFill(te)); const se = I.doc.resolve(I.selection.anchor - I.selection.$anchor.nodeBefore.nodeSize); return I.setSelection(new Xn(se)).scrollIntoView(), !!I.docChanged && (y?.(I), !0) } } isActive(s) { const { selection: l } = s; return l instanceof Xn && "image" === l.node.type.name } } class sf { constructor(s, l = "color") { this.name = s, this.attrName = l } apply(s) { return (l, h) => { const { schema: y, selection: w, doc: I } = l, k = y.marks[this.name]; if (!k) return !1; const { from: H, to: te, empty: se } = w; if (!se && H + 1 === te) { const Ge = I.nodeAt(H); if (Ge?.isAtom && !Ge.isText && Ge.isLeaf) return !1 } return S(k, s)(l, h) } } isActive(s) { const { schema: l } = s, h = l.marks[this.name]; return !!h && ac(s, h) } getActiveColors(s) { if (!this.isActive(s)) return []; const { schema: l } = s; return (f => { let s = []; const { selection: l, storedMarks: h } = f, { from: y, to: w, empty: I, $from: k } = l; return I ? s = h || k.marks() : f.doc.nodesBetween(y, w, H => { s = [...s, ...H.marks] }), s })(s).filter(w => w.type === l.marks[this.name]).map(w => w.attrs[this.attrName]).filter(Boolean) } remove() { return (s, l) => { const { schema: h } = s, y = h.marks[this.name]; return !!y && (f = y, (s, l) => { const { tr: h, selection: y, storedMarks: w, doc: I } = s, { empty: k, ranges: H } = y; if (k && y instanceof Jr) { const { $cursor: te } = y; if (!te || !Zs(s.doc, H, f)) return !1; if (f.isInSet(w || te.marks())) return h.removeStoredMark(f), l?.(h), !0 } else { for (const te of H) { const { $from: se, $to: Ge } = te; I.rangeHasMark(se.pos, Ge.pos, f) && h.removeMark(se.pos, Ge.pos, f) } if (!h.docChanged) return !1; l?.(h.scrollIntoView()) } return !1 })(s, l); var f } } canExecute(s) { return this.apply("text_color" === this.name ? { color: "" } : { backgroundColor: "" })(s) } } const Im = ["link"], eh = new Lo("strong"), $f = new Lo("em"), py = new Lo("code"), c0 = new Lo("u"), u0 = new Lo("s"), Cp = new class hy { toggle() { return (s, l) => { const { schema: h } = s, y = h.nodes.blockquote; return !!y && (this.isActive(s) ? ((f, s) => { let { $from: l, $to: h } = f.selection, y = l.blockRange(h), w = y && Ei(y); return null != w && (s && s(f.tr.lift(y, w).scrollIntoView()), !0) })(s, l) : function Zu(f, s = null) { return function (l, h) { let { $from: y, $to: w } = l.selection, I = y.blockRange(w), k = I && Qi(I, f, s); return !!k && (h && h(l.tr.wrap(I, k).scrollIntoView()), !0) } }(y)(s, l)) } } isActive(s) { const { schema: l } = s, h = l.nodes.blockquote; return !!h && Ch(s, h) } canExecute(s) { return this.toggle()(s) } }, gy = new class Sm { insert() { return (s, l) => { const { schema: h, tr: y } = s, w = h.nodes.horizontal_rule; return !!w && (l(y.replaceSelectionWith(w.create()).scrollIntoView()), !0) } } canExecute(s) { return ((f, s) => { const { $from: l } = f.selection; for (let h = l.depth; h >= 0; h -= 1) { const y = l.index(h); if (l.node(h).canReplaceWith(y, y, s)) return !0 } return !1 })(s, s.schema.nodes.horizontal_rule) } }, my = new class hi { insert() { return (s, l) => { const { tr: h } = s, { ranges: y, empty: w } = h.selection; return w || (Object.entries(s.schema.marks).forEach(([I, k]) => { Im.includes(I) || y.forEach(H => { h.removeMark(H.$from.pos, H.$to.pos, k) }) }), l(h)), !0 } } canExecute() { return !0 } }, Am = new td(!0), Ig = new td(!1), Hw = new Md(1), af = new Md(2), xm = new Md(3), Mh = new Md(4), _y = new Md(5), lf = new Md(6), Wf = new xh("left"), Mm = new xh("center"), yy = new xh("right"), vy = new xh("justify"), zw = new Sg, Ep = new fy, by = new sf("text_color", "color"), Gw = new sf("text_background_color", "backgroundColor"), Ag = { bold: eh, italic: $f, code: py, underline: c0, strike: u0, blockquote: Cp, bullet_list: Am, ordered_list: Ig, h1: Hw, h2: af, h3: xm, h4: Mh, h5: _y, h6: lf, align_left: Wf, align_center: Mm, align_right: yy, align_justify: vy }, th = { horizontal_rule: gy, format_clear: my }, cf = zw, Om = Ep, Tp = by, d0 = Gw, xg = { bold: "Bold", italic: "Italic", code: "Code", underline: "Underline", strike: "Strike", blockquote: "Blockquote", bullet_list: "Bullet List", ordered_list: "Ordered List", heading: "Heading", h1: "Header 1", h2: "Header 2", h3: "Header 3", h4: "Header 4", h5: "Header 5", h6: "Header 6", align_left: "Left Align", align_center: "Center Align", align_right: "Right Align", align_justify: "Justify", text_color: "Text Color", background_color: "Background Color", horizontal_rule: "Horizontal rule", format_clear: "Clear Formatting", insertLink: "Insert Link", removeLink: "Remove Link", insertImage: "Insert Image", url: "URL", text: "Text", openInNewTab: "Open in new tab", insert: "Insert", altText: "Alt Text", title: "Title", remove: "Remove" }; class wy { constructor(s = {}) { this.locals = xg, this.get = l => this.locals[l] ?? "", this.locals = { ...xg, ...s } } } let Dp = (() => { class f { constructor() { this.locals = {} } } return f.\u0275fac = function (l) { return new (l || f) }, f.\u0275prov = i.Yz7({ token: f, factory: f.\u0275fac, providedIn: "root" }), f })(), nh = (() => { class f { constructor(l) { this.config = l } get locals() { return new wy(this.config.locals) } } return f.\u0275fac = function (l) { return new (l || f)(i.LFG(Dp, 8)) }, f.\u0275prov = i.Yz7({ token: f, factory: f.\u0275fac, providedIn: "root" }), f })(); const Mg = f => ({ locals: f.locals ?? {} }); let rh = (() => { class f { constructor(l) { this.sanitizer = l } transform(l) { return this.sanitizer.bypassSecurityTrustHtml(l) } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(ie.H7, 16)) }, f.\u0275pipe = i.Yjl({ name: "sanitizeHtml", type: f, pure: !0 }), f })(), Oh = (() => { class f { constructor(l, h) { this.ngxeService = l, this.menuService = h, this.isActive = !1, this.disabled = !1, this.update = y => { const { state: w } = y, I = Ag[this.name]; this.isActive = I.isActive(w), this.disabled = !I.canExecute(w) } } get name() { return this.toolbarItem } toggle(l) { if (l.preventDefault(), 0 !== l.button) return; const { state: h, dispatch: y } = this.editorView; Ag[this.name].toggle()(h, y) } getTitle(l) { return this.ngxeService.locals.get(l) } ngOnInit() { this.html = jf.get(this.name), this.editorView = this.menuService.editor.view, this.updateSubscription = this.menuService.editor.update.subscribe(l => { this.update(l) }) } ngOnDestroy() { this.updateSubscription.unsubscribe() } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(nh), i.Y36(uc)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-toggle-command"]], inputs: { toolbarItem: "toolbarItem" }, decls: 2, vars: 8, consts: [[1, "NgxEditor__MenuItem--IconContainer", 3, "innerHTML", "title", "mousedown"]], template: function (l, h) { 1 & l && (i.TgZ(0, "div", 0), i.NdJ("mousedown", function (w) { return h.toggle(w) }), i.ALo(1, "sanitizeHtml"), i.qZA()), 2 & l && (i.ekj("NgxEditor__MenuItem--Active", h.isActive)("NgxEditor--Disabled", h.disabled), i.Q6J("innerHTML", i.lcZ(1, 6, h.html), i.oJD)("title", h.getTitle(h.name))) }, dependencies: [rh] }), f })(), Nm = (() => { class f { constructor(l, h) { this.ngxeService = l, this.menuService = h, this.disabled = !1, this.update = y => { const { state: w } = y; this.disabled = !th[this.name].canExecute(w) } } get name() { return this.toolbarItem } insert(l) { if (l.preventDefault(), 0 !== l.button) return; const { state: h, dispatch: y } = this.editorView; th[this.name].insert()(h, y) } getTitle(l) { return this.ngxeService.locals.get(l) } ngOnInit() { this.html = jf.get(this.name), this.editorView = this.menuService.editor.view, this.updateSubscription = this.menuService.editor.update.subscribe(l => { this.update(l) }) } ngOnDestroy() { this.updateSubscription.unsubscribe() } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(nh), i.Y36(uc)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-insert-command"]], inputs: { toolbarItem: "toolbarItem" }, decls: 2, vars: 6, consts: [[1, "NgxEditor__MenuItem--IconContainer", 3, "innerHTML", "title", "mousedown"]], template: function (l, h) { 1 & l && (i.TgZ(0, "div", 0), i.NdJ("mousedown", function (w) { return h.insert(w) }), i.ALo(1, "sanitizeHtml"), i.qZA()), 2 & l && (i.ekj("NgxEditor--Disabled", h.disabled), i.Q6J("innerHTML", i.lcZ(1, 4, h.html), i.oJD)("title", h.getTitle(h.name))) }, dependencies: [rh] }), f })(), km = (() => { class f { constructor(l, h, y) { this.el = l, this.ngxeService = h, this.menuService = y, this.showPopup = !1, this.isActive = !1, this.canExecute = !0, this.setText = () => { const { state: { selection: w, doc: I } } = this.editorView, { empty: k, from: H, to: te } = w, se = k ? "" : I.textBetween(H, te); se && (this.text.patchValue(se), this.text.disable()) }, this.update = w => { const { state: I } = w; this.isActive = cf.isActive(I, { strict: !1 }), this.canExecute = cf.canExecute(I) } } get icon() { return jf.get(this.isActive ? "unlink" : "link") } get title() { return this.ngxeService.locals.get(this.isActive ? "removeLink" : "insertLink") } get href() { return this.form.get("href") } get text() { return this.form.get("text") } onDocumentClick(l) { !this.el.nativeElement.contains(l.target) && this.showPopup && this.hideForm() } getLabel(l) { return this.ngxeService.locals.get(l) } hideForm() { this.showPopup = !1, this.form.reset({ href: "", text: "", openInNewTab: !0 }), this.text.enable() } onMouseDown(l) { if (0 !== l.button) return; const { state: h, dispatch: y } = this.editorView; this.isActive ? cf.remove(h, y) : (this.showPopup = !this.showPopup, this.showPopup && this.setText()) } insertLink(l) { l.preventDefault(); const { text: h, href: y, openInNewTab: w } = this.form.getRawValue(), { dispatch: I, state: k } = this.editorView, { selection: H } = k, te = { title: y, href: y, target: w ? "_blank" : "_self" }; H.empty ? (cf.insert(h, te)(k, I), this.editorView.focus()) : cf.update(te)(k, I), this.hideForm() } ngOnInit() { this.editorView = this.menuService.editor.view, this.form = new m.cw({ href: new m.NI("", [m.kI.required, m.kI.pattern(this.menuService.editor.linkValidationPattern)]), text: new m.NI("", [m.kI.required]), openInNewTab: new m.NI(!0) }), this.updateSubscription = this.menuService.editor.update.subscribe(l => { this.update(l) }) } ngOnDestroy() { this.updateSubscription.unsubscribe() } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(i.SBq), i.Y36(nh), i.Y36(uc)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-link"]], hostBindings: function (l, h) { 1 & l && i.NdJ("mousedown", function (w) { return h.onDocumentClick(w) }, !1, i.evT) }, decls: 3, vars: 9, consts: [[1, "NgxEditor__MenuItem--IconContainer", 3, "innerHTML", "title", "mousedown"], ["class", "NgxEditor__Popup", 4, "ngIf"], [1, "NgxEditor__Popup"], [1, "NgxEditor__Popup--Form", 3, "formGroup", "ngSubmit"], [1, "NgxEditor__Popup--FormGroup"], [1, "NgxEditor__Popup--Col"], [1, "NgxEditor__Popup--Label"], ["type", "href", "id", "href", "formControlName", "href", "autofocus", "", "autocomplete", "off"], ["class", "NgxEditor__HelpText NgxEditor__HelpText--Error", 4, "ngIf"], ["type", "text", "formControlName", "text", "autocomplete", "off"], ["type", "checkbox", "formControlName", "openInNewTab"], ["type", "submit", 3, "disabled"], [1, "NgxEditor__HelpText", "NgxEditor__HelpText--Error"]], template: function (l, h) { 1 & l && (i.TgZ(0, "div", 0), i.NdJ("mousedown", function (w) { return h.onMouseDown(w) }), i.ALo(1, "sanitizeHtml"), i.qZA(), i.YNc(2, Un, 21, 8, "div", 1)), 2 & l && (i.ekj("NgxEditor__MenuItem--Active", h.isActive || h.showPopup)("NgxEditor--Disabled", !h.canExecute), i.Q6J("innerHTML", i.lcZ(1, 7, h.icon), i.oJD)("title", h.title), i.xp6(2), i.Q6J("ngIf", h.showPopup)) }, dependencies: [mo.O5, m._Y, m.Fj, m.Wl, m.JJ, m.JL, m.sg, m.u, rh] }), f })(), Cy = (() => { class f { constructor(l, h, y) { this.ngxeService = l, this.menuService = h, this.el = y, this.isDropdownOpen = !1, this.disabledItems = [], this.update = w => { const { state: I } = w; this.disabledItems = []; const k = []; this.items.forEach(H => { const te = Ag[H]; te.isActive(I) && k.push(H), te.canExecute(I) || this.disabledItems.push(H) }), 1 === k.length ? [this.activeItem] = k : this.activeItem = null } } get isSelected() { return Boolean(this.activeItem || this.isDropdownOpen) } get isDropdownDisabled() { return this.disabledItems.length === this.items.length } onDocumentClick(l) { !this.el.nativeElement.contains(l) && this.isDropdownOpen && (this.isDropdownOpen = !1) } getName(l) { return this.ngxeService.locals.get(l) } toggleDropdown(l) { l.preventDefault(), this.isDropdownOpen = !this.isDropdownOpen } trackByIndex(l) { return l } onClick(l, h) { if (l.preventDefault(), 0 !== l.button) return; const y = Ag[h], { state: w, dispatch: I } = this.editorView; y.toggle()(w, I), this.isDropdownOpen = !1 } ngOnInit() { this.editorView = this.menuService.editor.view, this.updateSubscription = this.menuService.editor.update.subscribe(l => { this.update(l) }) } ngOnDestroy() { this.updateSubscription.unsubscribe() } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(nh), i.Y36(uc), i.Y36(i.SBq)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-dropdown"]], hostBindings: function (l, h) { 1 & l && i.NdJ("mousedown", function (w) { return h.onDocumentClick(w.target) }, !1, i.evT) }, inputs: { group: "group", items: "items" }, decls: 3, vars: 6, consts: [[1, "NgxEditor__Dropdown--Text", 3, "mousedown"], ["class", "NgxEditor__Dropdown--DropdownMenu", 4, "ngIf"], [1, "NgxEditor__Dropdown--DropdownMenu"], ["class", "NgxEditor__Dropdown--Item", 3, "ngClass", "mousedown", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "NgxEditor__Dropdown--Item", 3, "ngClass", "mousedown"]], template: function (l, h) { 1 & l && (i.TgZ(0, "div", 0), i.NdJ("mousedown", function (w) { return h.toggleDropdown(w) }), i._uU(1), i.qZA(), i.YNc(2, qr, 2, 2, "div", 1)), 2 & l && (i.ekj("NgxEditor__Dropdown--Selected", h.isSelected)("NgxEditor--Disabled", h.isDropdownDisabled), i.xp6(1), i.hij(" ", h.getName(h.activeItem || h.group), "\n"), i.xp6(1), i.Q6J("ngIf", h.isDropdownOpen)) }, dependencies: [mo.mk, mo.sg, mo.O5] }), f })(), Zf = (() => { class f { constructor(l, h, y) { this.el = l, this.ngxeService = h, this.menuService = y, this.showPopup = !1, this.isActive = !1, this.form = new m.cw({ src: new m.NI("", [m.kI.required, m.kI.pattern("(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/??([^#\n\r]*)?#?([^\n\r]*)")]), alt: new m.NI(""), title: new m.NI("") }), this.update = w => { const { state: I } = w; this.isActive = Om.isActive(I) } } get icon() { return jf.get("image") } get src() { return this.form.get("src") } onDocumentClick(l) { !this.el.nativeElement.contains(l.target) && this.showPopup && this.hideForm() } getLabel(l) { return this.ngxeService.locals.get(l) } hideForm() { this.showPopup = !1, this.form.reset({ src: "", alt: "", title: "" }) } onMouseDown(l) { 0 === l.button && (this.showPopup = !this.showPopup, this.showPopup && this.fillForm()) } fillForm() { const { state: l } = this.editorView, { selection: h } = l; if (h instanceof Xn && this.isActive) { const { src: y, alt: w = "", title: I = "" } = h.node.attrs; this.form.setValue({ src: y, alt: w, title: I }) } } insertLink(l) { l.preventDefault(); const { src: h, alt: y, title: w } = this.form.getRawValue(), { dispatch: I, state: k } = this.editorView; Om.insert(h, { alt: y, title: w })(k, I), this.editorView.focus(), this.hideForm() } ngOnInit() { this.editorView = this.menuService.editor.view, this.updateSubscription = this.menuService.editor.update.subscribe(l => { this.update(l) }) } ngOnDestroy() { this.updateSubscription.unsubscribe() } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(i.SBq), i.Y36(nh), i.Y36(uc)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-image"]], hostBindings: function (l, h) { 1 & l && i.NdJ("mousedown", function (w) { return h.onDocumentClick(w) }, !1, i.evT) }, decls: 3, vars: 7, consts: [[1, "NgxEditor__MenuItem--IconContainer", 3, "innerHTML", "title", "mousedown"], ["class", "NgxEditor__Popup", 4, "ngIf"], [1, "NgxEditor__Popup"], [1, "NgxEditor__Popup--Form", 3, "formGroup", "ngSubmit"], [1, "NgxEditor__Popup--FormGroup"], [1, "NgxEditor__Popup--Col"], [1, "NgxEditor__Popup--Label"], ["type", "href", "id", "href", "formControlName", "src", "autofocus", "", "autocomplete", "off"], ["class", "NgxEditor__HelpText NgxEditor__HelpText--Error", 4, "ngIf"], ["type", "text", "formControlName", "alt", "autocomplete", "off"], ["type", "text", "formControlName", "title", "autocomplete", "off"], ["type", "submit", 3, "disabled"], [1, "NgxEditor__HelpText", "NgxEditor__HelpText--Error"]], template: function (l, h) { 1 & l && (i.TgZ(0, "div", 0), i.NdJ("mousedown", function (w) { return h.onMouseDown(w) }), i.ALo(1, "sanitizeHtml"), i.qZA(), i.YNc(2, ki, 20, 7, "div", 1)), 2 & l && (i.ekj("NgxEditor__MenuItem--Active", h.isActive || h.showPopup), i.Q6J("innerHTML", i.lcZ(1, 5, h.icon), i.oJD)("title", h.getLabel("insertImage")), i.xp6(2), i.Q6J("ngIf", h.showPopup)) }, dependencies: [mo.O5, m._Y, m.Fj, m.JJ, m.JL, m.sg, m.u, rh] }), f })(), h0 = (() => { class f { constructor(l, h, y) { this.el = l, this.menuService = h, this.ngxeService = y, this.showPopup = !1, this.isActive = !1, this.activeColors = [], this.canExecute = !0, this.update = w => { const { state: I } = w; this.canExecute = this.command.canExecute(I), this.isActive = this.command.isActive(I), this.activeColors = [], this.isActive && (this.activeColors = this.command.getActiveColors(I)) } } get title() { return this.getLabel("text_color" === this.type ? "text_color" : "background_color") } get icon() { return jf.get("text_color" === this.type ? "text_color" : "color_fill") } get command() { return "text_color" === this.type ? Tp : d0 } getContrastYIQ(l) { const h = l.replace("#", ""); return (299 * parseInt(h.substring(0, 2), 16) + 587 * parseInt(h.substring(2, 4), 16) + 114 * parseInt(h.substring(4, 6), 16)) / 1e3 >= 128 ? "black" : "white" } onDocumentClick(l) { !this.el.nativeElement.contains(l.target) && this.showPopup && this.hidePopup() } hidePopup() { this.showPopup = !1 } togglePopup(l) { l.preventDefault(), 0 === l.button && (this.showPopup = !this.showPopup) } remove(l) { l.preventDefault(); const { state: h, dispatch: y } = this.editorView; this.command.remove()(h, y), this.hidePopup() } trackByIndex(l) { return l } onColorSelect(l, h) { if (l.preventDefault(), 0 !== l.button) return; const { state: y, dispatch: w } = this.editorView; "text_color" === this.type ? this.command.apply({ color: h })(y, w) : this.command.apply({ backgroundColor: h })(y, w), this.editorView.hasFocus() || this.editorView.focus(), this.hidePopup() } getLabel(l) { return this.ngxeService.locals.get(l) } ngOnInit() { this.editorView = this.menuService.editor.view, this.updateSubscription = this.menuService.editor.update.subscribe(l => { this.update(l) }) } ngOnDestroy() { this.updateSubscription.unsubscribe() } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(i.SBq), i.Y36(uc), i.Y36(nh)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-color-picker"]], hostBindings: function (l, h) { 1 & l && i.NdJ("mousedown", function (w) { return h.onDocumentClick(w) }, !1, i.evT) }, inputs: { presets: "presets", type: "type" }, decls: 3, vars: 9, consts: [[1, "NgxEditor__MenuItem--IconContainer", 3, "innerHTML", "title", "mousedown"], ["class", "NgxEditor__Popup", 4, "ngIf"], [1, "NgxEditor__Popup"], ["class", "NgxEditor__ColorContainer", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "NgxEditor__MenuItem--Button", 3, "disabled", "mousedown"], [1, "NgxEditor__ColorContainer"], ["class", "NgxEditor__Color", 3, "ngStyle", "title", "ngClass", "mousedown", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "NgxEditor__Color", 3, "ngStyle", "title", "ngClass", "mousedown"]], template: function (l, h) { 1 & l && (i.TgZ(0, "div", 0), i.NdJ("mousedown", function (w) { return h.togglePopup(w) }), i.ALo(1, "sanitizeHtml"), i.qZA(), i.YNc(2, gs, 4, 4, "div", 1)), 2 & l && (i.ekj("NgxEditor__MenuItem--Active", h.isActive || h.showPopup)("NgxEditor--Disabled", !h.canExecute), i.Q6J("innerHTML", i.lcZ(1, 7, h.icon), i.oJD)("title", h.title), i.xp6(2), i.Q6J("ngIf", h.showPopup)) }, dependencies: [mo.mk, mo.sg, mo.O5, mo.PC, rh], styles: ['@charset "UTF-8";.NgxEditor__Popup[_ngcontent-%COMP%]{width:230px}.NgxEditor__ColorContainer[_ngcontent-%COMP%]{display:flex;justify-content:space-between}.NgxEditor__ColorContainer[_ngcontent-%COMP%] + .NgxEditor__ColorContainer[_ngcontent-%COMP%]{margin-top:5px}.NgxEditor__Color[_ngcontent-%COMP%]{border:none;outline:none;border-radius:6px;width:24px;height:24px;flex-shrink:0}.NgxEditor__Color--Active[_ngcontent-%COMP%]:after{content:"\\2714";font-size:90%}.NgxEditor__MenuItem--Button[_ngcontent-%COMP%]{margin-top:5px}'] }), f })(); const Sp = [["bold", "italic"], [{ heading: ["h1", "h2", "h3", "h4", "h5", "h6"] }], ["link", "image"], ["text_color", "background_color"]], qf = ["#b60205", "#d93f0b", "#fbca04", "#0e8a16", "#006b75", "#1d76db", "#0052cc", "#5319e7", "#e99695", "#f9d0c4", "#fef2c0", "#c2e0c6", "#bfdadc", "#c5def5", "#bfd4f2", "#d4c5f9"]; let Ty = (() => { class f { constructor(l) { this.menuService = l, this.toolbar = Sp, this.colorPresets = qf, this.disabled = !1, this.customMenuRef = null, this.dropdownPlacement = "bottom", this.toggleCommands = ["bold", "italic", "underline", "strike", "code", "blockquote", "ordered_list", "bullet_list", "align_left", "align_center", "align_right", "align_justify"], this.insertCommands = ["horizontal_rule", "format_clear"], this.iconContainerClass = ["NgxEditor__MenuItem", "NgxEditor__MenuItem--Icon"], this.dropdownContainerClass = ["NgxEditor__Dropdown"], this.seperatorClass = ["NgxEditor__Seperator"] } get presets() { const h = []; return this.colorPresets.forEach((y, w) => { const I = Math.floor(w / 8); h[I] || h.push([]), h[I].push(y) }), h } trackByIndex(l) { return l } isDropDown(l) { return !!l?.heading } getDropdownItems(l) { return l } ngOnInit() { if (!this.editor) throw new _e("Required editor instance to initialize menu component"); this.menuService.editor = this.editor } } return f.\u0275fac = function (l) { return new (l || f)(i.Y36(uc)) }, f.\u0275cmp = i.Xpm({ type: f, selectors: [["ngx-editor-menu"]], inputs: { toolbar: "toolbar", colorPresets: "colorPresets", disabled: "disabled", editor: "editor", customMenuRef: "customMenuRef", dropdownPlacement: "dropdownPlacement" }, features: [i._Bn([uc])], decls: 3, vars: 7, consts: [[1, "NgxEditor__MenuBar", 3, "ngClass"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], [3, "toolbarItem", "class", 4, "ngIf"], [3, "class", 4, "ngIf"], ["type", "text_color", 3, "class", "presets", 4, "ngIf"], ["type", "background_color", 3, "class", "presets", 4, "ngIf"], [3, "toolbarItem"], [3, "class", "group", "items", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "group", "items"], ["type", "text_color", 3, "presets"], ["type", "background_color", 3, "presets"], [3, "ngTemplateOutlet"]], template: function (l, h) { 1 & l && (i.TgZ(0, "div", 0), i.YNc(1, Vf, 2, 2, "ng-container", 1), i.YNc(2, Kd, 2, 1, "ng-container", 2), i.qZA()), 2 & l && (i.Q6J("ngClass", i.WLB(4, Jh, h.disabled, "top" === h.dropdownPlacement)), i.xp6(1), i.Q6J("ngForOf", h.toolbar)("ngForTrackBy", h.trackByIndex), i.xp6(1), i.Q6J("ngIf", h.customMenuRef)) }, dependencies: [mo.mk, mo.sg, mo.O5, mo.tP, Oh, Nm, km, Cy, Zf, h0, mo.Nd] }), f })(), Og = (() => { class f { } return f.\u0275fac = function (l) { return new (l || f) }, f.\u0275mod = i.oAB({ type: f }), f.\u0275inj = i.cJS({ providers: [rh], imports: [mo.ez, m.UX] }), f })(); const Ip = new i.OlP("NgxEditorConfig"), Ap = { locals: xg }; let Od = (() => { class f { static forRoot(l = Ap) { return { ngModule: f, providers: [{ provide: Ip, useValue: l }, { provide: Dp, useFactory: Mg, deps: [Ip] }] } } static forChild(l = Ap) { return { ngModule: f, providers: [{ provide: Ip, useValue: l }, { provide: Dp, useFactory: Mg, deps: [Ip] }, nh] } } } return f.\u0275fac = function (l) { return new (l || f) }, f.\u0275mod = i.oAB({ type: f }), f.\u0275inj = i.cJS({ imports: [mo.ez, Og] }), f })(); const Nd = f => null !== f && "number" == typeof f.length; class xp { static required(s) { return l => (f => { if (!f) return !0; const { childCount: s, firstChild: l } = f; return Boolean(1 === s && l?.isTextblock && 0 === l.content.size) })(Ad(l.value, s || ju)) ? { required: !0 } : null } static maxLength(s, l) { return h => { const I = Ad(h.value, l || ju).textContent; return Nd(I) && I.length > s ? { maxlength: { requiredLength: s, actualLength: I.length } } : null } } static minLength(s, l) { return h => { const I = Ad(h.value, l || ju).textContent; return null !== (f = I) && 0 !== f.length && Nd(I) && I.length < s ? { minlength: { requiredLength: s, actualLength: I.length } } : null; var f } } } const dc = (f, s = !1) => (l, h) => { const y = new Lo(f); return s ? y.toggle()(l, h) : y.apply()(l, h) }; class uf { constructor(s) { if (this.applyTrx = l => { this.state = this.state.apply(l ?? this.tr), this.tr = this.state.tr, this.tr.setMeta("APPLIED_TRX", !0) }, this.dispatch = l => { this.applyTrx(l) }, !s) throw new _e("Required view to initialize commands."); this.view = s, this.state = s.state, this.tr = this.view.state.tr } exec() { if (!this.tr.getMeta("APPLIED_TRX")) return !1; const s = !this.view.state.doc.eq(this.state.doc); this.view.updateState(this.state); const l = this.tr.setMeta("FORCE_EMIT", s); return this.view.dispatch(l), !0 } focus() { return this.view.focus(), this } scrollIntoView() { return this.tr.scrollIntoView(), this.applyTrx(), this } insertText(s) { return this.tr.insertText(s), this.applyTrx(), this } insertNewLine() { return Ro(Zh, vh, iu, rl)(this.state, this.dispatch), this } applyMark(s) { return dc(s, !1)(this.state, this.dispatch), this } toggleMark(s) { return dc(s, !0)(this.state, this.dispatch), this } bold() { return dc("strong")(this.state, this.dispatch), this } toggleBold() { return dc("strong", !0)(this.state, this.dispatch), this } italics() { return dc("em")(this.state, this.dispatch), this } toggleItalics() { return dc("em", !0)(this.state, this.dispatch), this } underline() { return dc("u")(this.state, this.dispatch), this } toggleUnderline() { return dc("u", !0)(this.state, this.dispatch), this } strike() { return dc("s")(this.state, this.dispatch), this } toggleStrike() { return dc("s", !0)(this.state, this.dispatch), this } code() { return dc("code")(this.state, this.dispatch), this } toggleCode() { return dc("code", !0)(this.state, this.dispatch), this } toggleOrderedList() { return new td(!1).toggle()(this.state, this.dispatch), this } toggleBulletList() { return new td(!0).toggle()(this.state, this.dispatch), this } toggleHeading(s) { return new Md(s).toggle()(this.state, this.dispatch), this } insertLink(s, l) { return (new Sg).insert(s, l)(this.state, this.dispatch), this } updateLink(s) { return (new Sg).update(s)(this.state, this.dispatch), this } insertImage(s, l = {}) { return (new fy).insert(s, l)(this.state, this.dispatch), this } textColor(s) { return new sf("text_color").apply({ color: s })(this.state, this.dispatch), this } backgroundColor(s) { return new sf("text_background_color").apply({ backgroundColor: s })(this.state, this.dispatch), this } removeTextColor() { return new sf("text_color").remove()(this.state, this.dispatch), this } removeBackgroundColor() { return new sf("text_background_color").remove()(this.state, this.dispatch), this } align(s) { return new xh(s).toggle()(this.state, this.dispatch), this } insertHTML(s) { const { selection: l, schema: h, tr: y } = this.state, { from: w, to: I } = l, k = document.createElement("div"); k.innerHTML = s.trim(); const H = yn.fromSchema(h).parseSlice(k), te = y.replaceRange(w, I, H); return this.applyTrx(te), this } } const df = typeof navigator < "u" && /Mac/.test(navigator.platform), Bm = f => { const s = oc.concat(Rf, qu); return s.push((f => Wd(/(?:^|\s)(?:(?:\*\*|__)(?:(?:[^*_]+))(?:\*\*|__))$/, f))(f.marks.strong)), s.push((f => Wd(/(?:^|\s)(?:(?:\*|_)(?:(?:[^*_]+))(?:\*|_))$/, f))(f.marks.em)), s.push((f => Tl(/^\s*>\s$/, f))(f.nodes.blockquote)), s.push((f => Tl(/^(?:\d+)\.\s$/, f, s => ({ order: Number(s[1]) }), (s, l) => l.childCount + l.attrs.order === Number(s[1])))(f.nodes.ordered_list)), s.push((f => Tl(/^\s*(?:[-+*])\s$/, f))(f.nodes.bullet_list)), s.push((f => il(/^```$/, f))(f.nodes.code_block)), s.push(((f, s) => il(new RegExp("^(#{1,6})\\s$"), f, l => ({ level: l[1].length })))(f.nodes.heading)), function vd({ rules: f }) { let s = new wo({ state: { init: () => null, apply(l, h) { return l.getMeta(this) || (l.selectionSet || l.docChanged ? null : h) } }, props: { handleTextInput: (l, h, y, w) => bd(l, h, y, w, f, s), handleDOMEvents: { compositionend: l => { setTimeout(() => { let { $cursor: h } = l.state.selection; h && bd(l, h.pos, h.pos, "", f, s) }) } } }, isInputRules: !0 }); return s }({ rules: s }) }, Sy = (f, s) => { const l = []; return s.keyboardShortcuts && l.push(...((f, s) => { const l = {}; l["Mod-z"] = p, df ? l["Shift-Mod-z"] = T : l["Mod-y"] = T; const h = [Su({ "Mod-b": Po(f.marks.strong), "Mod-i": Po(f.marks.em), "Mod-u": Po(f.marks.u), "Mod-`": Po(f.marks.code) }), Su({ Enter: Hd(f.nodes.list_item), "Shift-Enter": Ro(qh, (y, w) => { const { tr: I } = y; return w(I.replaceSelectionWith(f.nodes.hard_break.create()).scrollIntoView()), !0 }), "Mod-[": Hu(f.nodes.list_item), "Mod-]": Mf(f.nodes.list_item), Tab: Mf(f.nodes.list_item) }), Su(wh)]; return s.history && h.push(Su(l)), h })(f, { history: s.history })), s.history && l.push(function A(f = {}) { return new wo({ key: Vc, state: { init: () => new Xu(Ju.empty, Ju.empty, null, 0), apply: (s, l, h) => function Bc(f, s, l, h) { let w, y = l.getMeta(Vc); if (y) return y.historyState; l.getMeta(v) && (f = new Xu(f.done, f.undone, null, 0)); let I = l.getMeta("appendedTransaction"); if (0 == l.steps.length) return f; if (I && I.getMeta(Vc)) return I.getMeta(Vc).redo ? new Xu(f.done.addTransform(l, void 0, h, ou(s)), f.undone, Td(l.mapping.maps[l.steps.length - 1]), f.prevTime) : new Xu(f.done, f.undone.addTransform(l, void 0, h, ou(s)), null, f.prevTime); if (!1 === l.getMeta("addToHistory") || I && !1 === I.getMeta("addToHistory")) return (w = l.getMeta("rebased")) ? new Xu(f.done.rebased(l, w), f.undone.rebased(l, w), Ih(f.prevRanges, l.mapping), f.prevTime) : new Xu(f.done.addMaps(l.mapping.maps), f.undone.addMaps(l.mapping.maps), Ih(f.prevRanges, l.mapping), f.prevTime); { let k = 0 == f.prevTime || !I && (f.prevTime < (l.time || 0) - h.newGroupDelay || !function Bf(f, s) { if (!s) return !1; if (!f.docChanged) return !0; let l = !1; return f.mapping.maps[0].forEach((h, y) => { for (let w = 0; w < s.length; w += 2)h <= s[w + 1] && y >= s[w] && (l = !0) }), l }(l, f.prevRanges)), H = I ? Ih(f.prevRanges, l.mapping) : Td(l.mapping.maps[l.steps.length - 1]); return new Xu(f.done.addTransform(l, k ? s.selection.getBookmark() : void 0, h, ou(s)), Ju.empty, H, l.time) } }(l, h, s, f) }, config: f = { depth: f.depth || 100, newGroupDelay: f.newGroupDelay || 500 }, props: { handleDOMEvents: { beforeinput(s, l) { let h = l.inputType, y = "historyUndo" == h ? p : "historyRedo" == h ? T : null; return !!y && (l.preventDefault(), y(s.state, s.dispatch)) } } } }) }()), s.inputRules && l.push(Bm(f)), l }, Iy = { linkOnPaste: !0, resizeImage: !0 }, Uc = { content: null, history: !0, keyboardShortcuts: !0, inputRules: !0, schema: ju, plugins: [], nodeViews: {}, attributes: {}, features: Iy, handleScrollToSelection: null, linkValidationPattern: "(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/??([^#\n\r]*)?#?([^\n\r]*)|(mailto:.*[@].*)" }; class Ay { constructor(s = Uc) { this.valueChangesSubject = new J.x, this.updateSubject = new J.x, this.options = { ...Uc, ...s }, this.createEditor() } get valueChanges() { return this.valueChangesSubject.asObservable() } get update() { return this.updateSubject.asObservable() } get schema() { return this.options.schema || ju } get linkValidationPattern() { return this.options.linkValidationPattern } get commands() { return new uf(this.view) } get features() { return { ...Iy, ...this.options.features } } handleTransactions(s) { const l = this.view.state.apply(s); if (this.view.updateState(l), this.updateSubject.next(this.view), !s.docChanged && !s.getMeta("FORCE_EMIT")) return; const h = l.doc.toJSON(); this.valueChangesSubject.next(h) } createEditor() { const { options: s, schema: l } = this, { content: h = null, nodeViews: y } = s, { history: w = !0, keyboardShortcuts: I = !0, inputRules: k = !0 } = s, H = Ad(h, l), te = s.plugins ?? [], se = s.attributes ?? {}, Ge = Sy(l, { history: w, keyboardShortcuts: I, inputRules: k }); this.view = new fp(null, { state: Ss.create({ doc: H, schema: l, plugins: [...Ge, ...te] }), nodeViews: y, dispatchTransaction: this.handleTransactions.bind(this), attributes: se, handleScrollToSelection: s.handleScrollToSelection }) } setContent(s) { if (typeof (f = s) > "u" || null === f) return; var f; const { state: l } = this.view, { tr: h, doc: y } = l, w = Ad(s, this.schema); h.replaceWith(0, l.doc.content.size, w), !y.eq(h.doc) && h.docChanged && this.view.dispatch(h) } registerPlugin(s) { const { state: l } = this.view, h = [...l.plugins, s], y = l.reconfigure({ plugins: h }); this.view.updateState(y) } destroy() { this.view.destroy() } } }, 4365: (un, Je, L) => { "use strict"; L.d(Je, { KC: () => Kr, kb: () => vr }); var i = L(4650), m = L(6895), J = L(445), ye = L(4080), Ce = L(3353), we = L(1281), Te = L(7579), Ee = L(6451), _e = L(4968), ae = L(9751), ve = L(6406), xe = L(9646), gt = L(5698), Se = L(4482), rt = L(2733), De = L(2529), je = L(2722), _t = L(8746), Qe = L(1345); const ct = new i.OlP("SMOOTH_SCROLL_OPTIONS"); let Oe = (() => { class At { constructor(Ae, Et, Gt) { this._document = Ae, this._platform = Et, this._onGoingScrolls = new Map, this._defaultOptions = { duration: 468, easing: { x1: .42, y1: 0, x2: .58, y2: 1 }, ...Gt } } get _w() { return this._document.defaultView } get _now() { return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now } _scrollElement(Ae, Et, Gt) { Ae.scrollLeft = Et, Ae.scrollTop = Gt } _getElement(Ae, Et) { return "string" == typeof Ae ? (Et || this._document).querySelector(Ae) : (0, we.fI)(Ae) } _initSmoothScroll(Ae) { return this._onGoingScrolls.has(Ae) && this._onGoingScrolls.get(Ae).next(), this._onGoingScrolls.set(Ae, new Te.x).get(Ae) } _isFinished(Ae, Et, Gt) { return Ae.currentX !== Ae.x || Ae.currentY !== Ae.y || (Et.next(), Gt(), !1) } _interrupted(Ae, Et) { return (0, Ee.T)((0, _e.R)(Ae, "wheel", { passive: !0, capture: !0 }), (0, _e.R)(Ae, "touchmove", { passive: !0, capture: !0 }), Et).pipe((0, gt.q)(1)) } _destroy(Ae, Et) { Et.complete(), this._onGoingScrolls.delete(Ae) } _step(Ae) { return new ae.y(Et => { let Gt = (this._now() - Ae.startTime) / Ae.duration; Gt = Gt > 1 ? 1 : Gt; const bn = Ae.easing(Gt); Ae.currentX = Ae.startX + (Ae.x - Ae.startX) * bn, Ae.currentY = Ae.startY + (Ae.y - Ae.startY) * bn, this._scrollElement(Ae.scrollable, Ae.currentX, Ae.currentY), ve.Z.schedule(() => Et.next(Ae)) }) } _applyScrollToOptions(Ae, Et) { if (!Et.duration) return this._scrollElement(Ae, Et.left, Et.top), Promise.resolve(); const Gt = this._initSmoothScroll(Ae), bn = { scrollable: Ae, startTime: this._now(), startX: Ae.scrollLeft, startY: Ae.scrollTop, x: null == Et.left ? Ae.scrollLeft : ~~Et.left, y: null == Et.top ? Ae.scrollTop : ~~Et.top, duration: Et.duration, easing: Qe(Et.easing.x1, Et.easing.y1, Et.easing.x2, Et.easing.y2) }; return new Promise(sn => { (0, xe.of)(null).pipe(function wt(At, ln = 1 / 0, Ae) { return ln = (ln || 0) < 1 ? 1 / 0 : ln, (0, Se.e)((Et, Gt) => (0, rt.p)(Et, Gt, At, ln, void 0, !0, Ae)) }(() => this._step(bn).pipe((0, De.o)(Bt => this._isFinished(Bt, Gt, sn)))), (0, je.R)(this._interrupted(Ae, Gt)), (0, _t.x)(() => this._destroy(Ae, Gt))).subscribe() }) } scrollTo(Ae, Et) { if ((0, m.NF)(this._platform)) { const Gt = this._getElement(Ae), bn = "rtl" === getComputedStyle(Gt).direction, sn = (0, Ce._i)(), Bt = { ...this._defaultOptions, ...Et, left: null == Et.left ? bn ? Et.end : Et.start : Et.left, right: null == Et.right ? bn ? Et.start : Et.end : Et.right }; return null != Bt.bottom && (Bt.top = Gt.scrollHeight - Gt.clientHeight - Bt.bottom), bn && 0 !== sn ? (null != Bt.left && (Bt.right = Gt.scrollWidth - Gt.clientWidth - Bt.left), 2 === sn ? Bt.left = Bt.right : 1 === sn && (Bt.left = Bt.right ? -Bt.right : Bt.right)) : null != Bt.right && (Bt.left = Gt.scrollWidth - Gt.clientWidth - Bt.right), this._applyScrollToOptions(Gt, Bt) } return Promise.resolve() } scrollToElement(Ae, Et, Gt = {}) { const bn = this._getElement(Ae), sn = this._getElement(Et, bn), Bt = { ...Gt, left: sn.offsetLeft + (Gt.left || 0), top: sn.offsetTop + (Gt.top || 0) }; return sn ? this.scrollTo(bn, Bt) : Promise.resolve() } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.LFG(m.K0), i.LFG(i.Lbi), i.LFG(ct, 8)) }, At.\u0275prov = i.Yz7({ token: At, factory: At.\u0275fac, providedIn: "root" }), At })(), Be = (() => { class At { } return At.\u0275fac = function (Ae) { return new (Ae || At) }, At.\u0275mod = i.oAB({ type: At }), At.\u0275inj = i.cJS({}), At })(); var nt = L(1135), Ne = L(727), tt = L(515), Fe = L(8505), Ue = L(4004), st = L(3900), ht = L(8372), Kt = L(1884); function rn(...At) { const ln = At.length; if (0 === ln) throw new Error("list of properties cannot be empty."); return (0, Ue.U)(Ae => { let Et = Ae; for (let Gt = 0; Gt < ln; Gt++) { const bn = Et?.[At[Gt]]; if (!(typeof bn < "u")) return; Et = bn } return Et }) } var On = L(6099), qn = L(1520), nr = L(9300), kn = L(3601); const fn = ["scrollbarY"], It = ["scrollbarX"]; function Yt(At, ln) { if (1 & At && i._UZ(0, "scrollbar-x", null, 4), 2 & At) { const Ae = i.oxw(2); i.uIk("scrollable", Ae.state.isHorizontallyScrollable)("fit", Ae.state.verticalUsed) } } function pt(At, ln) { if (1 & At && i._UZ(0, "scrollbar-y", null, 5), 2 & At) { const Ae = i.oxw(2); i.uIk("scrollable", Ae.state.isVerticallyScrollable)("fit", Ae.state.horizontalUsed) } } function Pt(At, ln) { if (1 & At && (i.ynx(0), i.YNc(1, Yt, 2, 2, "scrollbar-x", 3), i.YNc(2, pt, 2, 2, "scrollbar-y", 3), i.BQk()), 2 & At) { const Ae = i.oxw(); i.xp6(1), i.Q6J("ngIf", Ae.state.horizontalUsed), i.xp6(1), i.Q6J("ngIf", Ae.state.verticalUsed) } } const Ze = ["*"]; function Ot(At) { return (0, Fe.b)(() => { At.onselectstart = () => !1 }) } function le(At) { return (0, Fe.b)(() => { At.onselectstart = null }) } function Xe() { return (0, Fe.b)(At => At.stopPropagation()) } function kt(At, ln) { return At.clientX >= ln.left && At.clientX <= ln.left + ln.width && At.clientY >= ln.top && At.clientY <= ln.top + ln.height } let an = (() => { class At { constructor(Ae) { this.viewPort = Ae, this.nativeElement = Ae.nativeElement } get clientHeight() { return this.nativeElement.clientHeight } get clientWidth() { return this.nativeElement.clientWidth } get scrollHeight() { return this.nativeElement.scrollHeight } get scrollWidth() { return this.nativeElement.scrollWidth } get scrollTop() { return this.nativeElement.scrollTop } get scrollLeft() { return this.nativeElement.scrollLeft } get scrollMaxX() { return this.scrollWidth - this.clientWidth } get scrollMaxY() { return this.scrollHeight - this.clientHeight } get contentHeight() { return this.contentWrapperElement?.clientHeight || 0 } get contentWidth() { return this.contentWrapperElement?.clientWidth || 0 } activatePointerEvents(Ae, Et) { this.hovered = new ae.y(Gt => { const bn = (0, _e.R)(this.nativeElement, "mousemove", { passive: !0 }), sn = Ae ? bn : bn.pipe(Xe()), Bt = (0, _e.R)(this.nativeElement, "mouseleave", { passive: !0 }).pipe((0, Ue.U)(() => !1)); (0, Ee.T)(sn, Bt).pipe((0, Fe.b)(vt => Gt.next(vt)), (0, je.R)(Et)).subscribe() }), this.clicked = new ae.y(Gt => { const bn = (0, _e.R)(this.nativeElement, "mousedown", { passive: !0 }).pipe((0, Fe.b)(Bt => Gt.next(Bt))), sn = (0, _e.R)(this.nativeElement, "mouseup", { passive: !0 }).pipe((0, Fe.b)(() => Gt.next(!1))); bn.pipe((0, st.w)(() => sn), (0, je.R)(Et)).subscribe() }) } setAsWrapper() { this.nativeElement.className = "ng-native-scrollbar-hider ng-scroll-layer", this.nativeElement.firstElementChild && (this.nativeElement.firstElementChild.className = "ng-scroll-layer") } setAsViewport(Ae) { this.nativeElement.className = `ng-native-scrollbar-hider ng-scroll-viewport ${Ae}`, this.nativeElement.firstElementChild && (this.contentWrapperElement = this.nativeElement.firstElementChild, this.contentWrapperElement.classList.add("ng-scroll-content")) } scrollYTo(Ae) { this.nativeElement.scrollTop = Ae } scrollXTo(Ae) { this.nativeElement.scrollLeft = Ae } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(i.SBq)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "scrollViewport", ""]] }), At })(), jt = (() => { class At { } return At.\u0275fac = function (Ae) { return new (Ae || At) }, At.\u0275dir = i.lG2({ type: At }), At })(); const wn = new i.OlP("NG_SCROLLBAR_OPTIONS"), Jn = { viewClass: "", trackClass: "", thumbClass: "", track: "vertical", appearance: "compact", visibility: "native", position: "native", pointerEventsMethod: "viewport", trackClickScrollDuration: 300, minThumbSize: 20, windowResizeDebounce: 0, sensorDebounce: 0, scrollAuditTime: 0, viewportPropagateMouseMove: !0, autoHeightDisabled: !0, autoWidthDisabled: !0, sensorDisabled: !1, pointerEventsDisabled: !1 }; let or = (() => { class At { constructor(Ae) { this.globalOptions = Ae ? { ...Jn, ...Ae } : Jn, this.rtlScrollAxisType = (0, Ce._i)() } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.LFG(wn, 8)) }, At.\u0275prov = i.Yz7({ token: At, factory: At.\u0275fac, providedIn: "root" }), At })(), Ht = (() => { class At { constructor(Ae, Et, Gt) { this.document = Ae, this.manager = Et, this.platform = Gt, this._scrollbarSize = new nt.X(this.getNativeScrollbarSize()), this.scrollbarSize = this._scrollbarSize.asObservable(), Gt.isBrowser && (0, _e.R)(this.document.defaultView, "resize", { passive: !0 }).pipe((0, ht.b)(this.manager.globalOptions.windowResizeDebounce), (0, Ue.U)(() => this.getNativeScrollbarSize()), (0, Kt.x)(), (0, Fe.b)(bn => this._scrollbarSize.next(bn))).subscribe() } getNativeScrollbarSize() { if (!this.platform.isBrowser) return 0; if (this.platform.IOS) return 6; const Ae = this.document.createElement("div"); Ae.className = "ng-scrollbar-measure", Ae.style.left = "0px", Ae.style.overflow = "scroll", Ae.style.position = "fixed", Ae.style.top = "-9999px", this.document.body.appendChild(Ae); const Et = Ae.getBoundingClientRect().right; return this.document.body.removeChild(Ae), Et } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.LFG(m.K0), i.LFG(or), i.LFG(Ce.t4)) }, At.\u0275prov = i.Yz7({ token: At, factory: At.\u0275fac, providedIn: "root" }), At })(), dn = (() => { class At { constructor(Ae, Et, Gt) { this.renderer = Et, this.hideNativeScrollbar = Gt, this._subscriber = Ne.w0.EMPTY, this._subscriber = Gt.scrollbarSize.subscribe(bn => { this.renderer.setStyle(Ae.nativeElement, "--native-scrollbar-size", `-${bn}px`, i.JOm.DashCase) }) } ngOnDestroy() { this._subscriber.unsubscribe() } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(i.SBq), i.Y36(i.Qsj), i.Y36(Ht)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "hideNativeScrollbar", ""]] }), At })(), ue = (() => { class At { constructor(Ae) { this.el = Ae } set ngAttr(Ae) { for (const [Et, Gt] of Object.entries(Ae)) this.el.nativeElement.setAttribute(Et, Gt) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(i.SBq)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "ngAttr", ""]], inputs: { ngAttr: "ngAttr" } }), At })(), it = (() => { class At { constructor(Ae, Et, Gt) { if (this.zone = Ae, this.platform = Et, this.scrollbar = Gt, this._disabled = !1, this._currentSubscription = null, this.event = new i.vpe, !Gt) throw new Error("[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.") } get debounce() { return this._debounce } set debounce(Ae) { this._debounce = (0, we.su)(Ae), this._subscribe() } get disabled() { return this._disabled } set disabled(Ae) { this._disabled = (0, we.Ig)(Ae), this._disabled ? this._unsubscribe() : this._subscribe() } ngAfterContentInit() { !this._currentSubscription && !this._disabled && this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { if (this._unsubscribe(), this.platform.isBrowser) { const Ae = new ae.y(Et => { this._resizeObserver = new ResizeObserver(Gt => Et.next(Gt)), this._resizeObserver.observe(this.scrollbar.viewport.nativeElement), this.scrollbar.viewport.contentWrapperElement && this._resizeObserver.observe(this.scrollbar.viewport.contentWrapperElement) }); this.zone.runOutsideAngular(() => { this._currentSubscription = (this._debounce ? Ae.pipe((0, ht.b)(this._debounce)) : Ae).subscribe(this.event) }) } } _unsubscribe() { this._resizeObserver?.disconnect(), this._currentSubscription?.unsubscribe() } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(i.R0b), i.Y36(Ce.t4), i.Y36(jt)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "resizeSensor", ""]], inputs: { debounce: ["sensorDebounce", "debounce"], disabled: ["sensorDisabled", "disabled"] }, outputs: { event: "resizeSensor" } }), At })(), lt = (() => { class At { constructor(Ae, Et, Gt) { this.cmp = Ae, this.trackElement = Et, this.document = Gt } get clicked() { const Ae = (0, _e.R)(this.trackElement, "mousedown", { passive: !0 }).pipe(Xe(), Ot(this.document)), Et = (0, _e.R)(this.document, "mouseup", { passive: !0 }).pipe(Xe(), le(this.document), (0, st.w)(() => tt.E)); return (0, Ee.T)(Ae, Et) } get clientRect() { return this.trackElement.getBoundingClientRect() } onTrackClicked(Ae, Et, Gt) { return (0, xe.of)(Ae).pipe(rn(this.pageProperty), (0, Ue.U)(bn => (bn - this.offset - Et / 2) / this.size * Gt), (0, Fe.b)(bn => { this.cmp.scrollTo({ ...this.mapToScrollToOption(bn), duration: (0, we.su)(this.cmp.trackClickScrollDuration) }) })) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(jt), i.Y36(HTMLElement), i.Y36(Document)) }, At.\u0275dir = i.lG2({ type: At }), At })(), Nt = (() => { class At extends lt { constructor(Ae, Et, Gt) { super(Ae, Et.nativeElement, Gt), this.cmp = Ae, this.document = Gt } get pageProperty() { return "pageX" } get offset() { return this.clientRect.left } get size() { return this.trackElement.clientWidth } mapToScrollToOption(Ae) { return { left: Ae } } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(jt), i.Y36(i.SBq), i.Y36(m.K0)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "scrollbarTrackX", ""]], features: [i.qOj] }), At })(), gn = (() => { class At extends lt { constructor(Ae, Et, Gt) { super(Ae, Et.nativeElement, Gt), this.cmp = Ae, this.document = Gt } get pageProperty() { return "pageY" } get offset() { return this.clientRect.top } get size() { return this.trackElement.clientHeight } mapToScrollToOption(Ae) { return { top: Ae } } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(jt), i.Y36(i.SBq), i.Y36(m.K0)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "scrollbarTrackY", ""]], features: [i.qOj] }), At })(), Hn = (() => { class At { constructor(Ae, Et, Gt, bn) { this.cmp = Ae, this.track = Et, this.thumbElement = Gt, this.document = bn, this._dragging = new Te.x, this.dragging = this._dragging.pipe((0, Kt.x)()) } get trackMax() { return this.track.size - this.size } get clientRect() { return this.thumbElement.getBoundingClientRect() } get clicked() { return (0, _e.R)(this.thumbElement, "mousedown", { passive: !0 }).pipe(Xe()) } update() { const Ae = function _r(At, ln, Ae) { return Math.max(~~(At / ln * At), Ae) }(this.track.size, this.viewportScrollSize, this.cmp.minThumbSize), Et = function pn(At, ln, Ae) { return At * Ae / ln }(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax); ve.Z.schedule(() => this.updateStyles(this.handleDirection(Et, this.trackMax), Ae)) } dragged(Ae) { let Et, Gt; const bn = (0, xe.of)(Ae).pipe(Ot(this.document), (0, Fe.b)(() => { Et = this.trackMax, Gt = this.viewportScrollMax, this.setDragging(!0) })), sn = (0, _e.R)(this.document, "mousemove", { capture: !0, passive: !0 }).pipe(Xe()), Bt = (0, _e.R)(this.document, "mouseup", { capture: !0 }).pipe(Xe(), le(this.document), (0, Fe.b)(() => this.setDragging(!1))); return bn.pipe(rn(this.pageProperty), (0, Ue.U)(vt => vt - this.dragStartOffset), (0, On.z)(vt => sn.pipe(rn(this.clientProperty), (0, Ue.U)(Le => Le - this.track.offset), (0, Ue.U)(Le => Gt * (Le - vt) / Et), (0, Ue.U)(Le => this.handleDrag(Le, Gt)), (0, Fe.b)(Le => this.scrollTo(Le)), (0, je.R)(Bt)))) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(jt), i.Y36(lt), i.Y36(HTMLElement), i.Y36(Document)) }, At.\u0275dir = i.lG2({ type: At, outputs: { dragging: "dragging" } }), At })(), Fn = (() => { class At extends Hn { constructor(Ae, Et, Gt, bn, sn) { super(Ae, Et, Gt.nativeElement, bn), this.cmp = Ae, this.track = Et, this.element = Gt, this.document = bn, this.dir = sn } get clientProperty() { return "clientX" } get pageProperty() { return "pageX" } get viewportScrollSize() { return this.cmp.viewport.scrollWidth } get viewportScrollOffset() { return this.cmp.viewport.scrollLeft } get viewportScrollMax() { return this.cmp.viewport.scrollMaxX } get dragStartOffset() { return this.clientRect.left + this.document.defaultView.pageXOffset || 0 } get size() { return this.thumbElement.clientWidth } updateStyles(Ae, Et) { this.thumbElement.style.width = `${Et}px`, this.thumbElement.style.transform = `translate3d(${Ae}px, 0, 0)` } handleDrag(Ae, Et) { if ("rtl" === this.dir.value) { if (1 === this.cmp.manager.rtlScrollAxisType) return Ae - Et; if (2 === this.cmp.manager.rtlScrollAxisType) return Et - Ae } return Ae } handleDirection(Ae, Et) { if ("rtl" === this.dir.value) { if (2 === this.cmp.manager.rtlScrollAxisType) return -Ae; if (0 === this.cmp.manager.rtlScrollAxisType) return Ae - Et } return Ae } setDragging(Ae) { this.cmp.setDragging({ horizontalDragging: Ae }) } scrollTo(Ae) { this.cmp.viewport.scrollXTo(Ae) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(jt), i.Y36(Nt), i.Y36(i.SBq), i.Y36(m.K0), i.Y36(J.Is)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "scrollbarThumbX", ""]], features: [i.qOj] }), At })(), yn = (() => { class At extends Hn { constructor(Ae, Et, Gt, bn) { super(Ae, Et, Gt.nativeElement, bn), this.cmp = Ae, this.track = Et, this.element = Gt, this.document = bn } get pageProperty() { return "pageY" } get viewportScrollSize() { return this.cmp.viewport.scrollHeight } get viewportScrollOffset() { return this.cmp.viewport.scrollTop } get viewportScrollMax() { return this.cmp.viewport.scrollMaxY } get clientProperty() { return "clientY" } get dragStartOffset() { return this.clientRect.top + this.document.defaultView.pageYOffset || 0 } get size() { return this.thumbElement.clientHeight } updateStyles(Ae, Et) { this.thumbElement.style.height = `${Et}px`, this.thumbElement.style.transform = `translate3d(0px, ${Ae}px, 0)` } handleDrag(Ae) { return Ae } handleDirection(Ae) { return Ae } setDragging(Ae) { this.cmp.setDragging({ verticalDragging: Ae }) } scrollTo(Ae) { this.cmp.viewport.scrollYTo(Ae) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(jt), i.Y36(gn), i.Y36(i.SBq), i.Y36(m.K0)) }, At.\u0275dir = i.lG2({ type: At, selectors: [["", "scrollbarThumbY", ""]], features: [i.qOj] }), At })(), Qn = (() => { class At { constructor(Ae, Et, Gt, bn, sn) { this.el = Ae, this.cmp = Et, this.platform = Gt, this.document = bn, this.zone = sn, this.destroyed = new Te.x } activatePointerEvents() { let Ae, Et, Gt; return "viewport" === this.cmp.pointerEventsMethod ? (this.viewportTrackClicked = new Te.x, this.viewportThumbClicked = new Te.x, this.cmp.viewport.activatePointerEvents(this.cmp.viewportPropagateMouseMove, this.destroyed), Ae = this.viewportThumbClicked, Et = this.viewportTrackClicked, Gt = this.cmp.viewport.hovered.pipe((0, Ue.U)(bn => !!bn && kt(bn, this.el.getBoundingClientRect())), (0, Kt.x)(), (0, Fe.b)(bn => this.document.onselectstart = bn ? () => !1 : null)), this.cmp.viewport.clicked.pipe((0, Fe.b)(bn => { bn ? kt(bn, this.thumb.clientRect) ? this.viewportThumbClicked.next(bn) : kt(bn, this.track.clientRect) && (this.cmp.setClicked(!0), this.viewportTrackClicked.next(bn)) : this.cmp.setClicked(!1) }), (0, je.R)(this.destroyed)).subscribe()) : (Ae = this.thumb.clicked, Et = this.track.clicked, Gt = this.hovered), (0, Ee.T)(Gt.pipe((0, Fe.b)(bn => this.setHovered(bn))), Ae.pipe((0, st.w)(bn => this.thumb.dragged(bn))), Et.pipe((0, st.w)(bn => this.track.onTrackClicked(bn, this.thumb.size, this.viewportScrollSize)))) } get hovered() { const Ae = (0, _e.R)(this.el, "mouseenter", { passive: !0 }).pipe(Xe(), (0, Ue.U)(() => !0)), Et = (0, _e.R)(this.el, "mouseleave", { passive: !0 }).pipe(Xe(), (0, Ue.U)(() => !1)); return (0, Ee.T)(Ae, Et) } ngOnInit() { this.zone.runOutsideAngular(() => { !(this.platform.IOS || this.platform.ANDROID) && !this.cmp.pointerEventsDisabled && this.activatePointerEvents().pipe((0, je.R)(this.destroyed)).subscribe(), (0, Ee.T)(this.cmp.scrolled, this.cmp.updated).pipe((0, Fe.b)(() => this.thumb?.update()), (0, je.R)(this.destroyed)).subscribe() }) } ngOnDestroy() { this.destroyed.next(), this.destroyed.complete(), this.viewportThumbClicked && this.viewportTrackClicked && (this.viewportTrackClicked.complete(), this.viewportThumbClicked.complete()) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(HTMLElement), i.Y36(jt), i.Y36(Ce.t4), i.Y36(Document), i.Y36(i.R0b)) }, At.\u0275dir = i.lG2({ type: At }), At })(), ur = (() => { class At extends Qn { constructor(Ae, Et, Gt, bn, sn) { super(Ae.nativeElement, Et, Gt, bn, sn), this.cmp = Et, this.platform = Gt, this.document = bn, this.zone = sn } get viewportScrollSize() { return this.cmp.viewport.scrollHeight } setHovered(Ae) { this.cmp.setHovered({ verticalHovered: Ae }) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(i.SBq), i.Y36(jt), i.Y36(Ce.t4), i.Y36(m.K0), i.Y36(i.R0b)) }, At.\u0275cmp = i.Xpm({ type: At, selectors: [["scrollbar-y"]], viewQuery: function (Ae, Et) { if (1 & Ae && (i.Gf(gn, 7), i.Gf(yn, 7)), 2 & Ae) { let Gt; i.iGM(Gt = i.CRH()) && (Et.track = Gt.first), i.iGM(Gt = i.CRH()) && (Et.thumb = Gt.first) } }, hostVars: 2, hostBindings: function (Ae, Et) { 2 & Ae && i.ekj("scrollbar-control", !0) }, features: [i.qOj], decls: 2, vars: 6, consts: [["scrollbarTrackY", ""], ["scrollbarThumbY", ""]], template: function (Ae, Et) { 1 & Ae && (i.TgZ(0, "div", 0), i._UZ(1, "div", 1), i.qZA()), 2 & Ae && (i.Gre("ng-scrollbar-track ", Et.cmp.trackClass, ""), i.xp6(1), i.Gre("ng-scrollbar-thumb ", Et.cmp.thumbClass, "")) }, dependencies: [yn, gn], styles: [".ng-scrollbar-wrapper>scrollbar-y.scrollbar-control{width:var(--vertical-scrollbar-total-size)}  .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}  .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}  .ng-scrollbar-wrapper[verticalHovered=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[verticalDragging=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[deactivated=false]>scrollbar-y.scrollbar-control{top:0;bottom:0}  .ng-scrollbar-wrapper[deactivated=false][dir=ltr]>scrollbar-y.scrollbar-control{right:0;left:auto;left:initial}  .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertY]>scrollbar-y.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertAll]>scrollbar-y.scrollbar-control{left:0;right:auto;right:initial}  .ng-scrollbar-wrapper[deactivated=false][dir=rtl]>scrollbar-y.scrollbar-control{left:0;right:auto;right:initial}  .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertY]>scrollbar-y.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertAll]>scrollbar-y.scrollbar-control{left:auto;left:initial;right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all]>scrollbar-y.scrollbar-control[fit=true]{bottom:var(--scrollbar-total-size);top:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertX]>scrollbar-y.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertAll]>scrollbar-y.scrollbar-control[fit=true]{top:var(--scrollbar-total-size);bottom:0}"], changeDetection: 0 }), At })(), dr = (() => { class At extends Qn { constructor(Ae, Et, Gt, bn, sn) { super(Ae.nativeElement, Et, Gt, bn, sn), this.cmp = Et, this.platform = Gt, this.document = bn, this.zone = sn } get viewportScrollSize() { return this.cmp.viewport.scrollWidth } setHovered(Ae) { this.cmp.setHovered({ horizontalHovered: Ae }) } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(i.SBq), i.Y36(jt), i.Y36(Ce.t4), i.Y36(m.K0), i.Y36(i.R0b)) }, At.\u0275cmp = i.Xpm({ type: At, selectors: [["scrollbar-x"]], viewQuery: function (Ae, Et) { if (1 & Ae && (i.Gf(Nt, 7), i.Gf(Fn, 7)), 2 & Ae) { let Gt; i.iGM(Gt = i.CRH()) && (Et.track = Gt.first), i.iGM(Gt = i.CRH()) && (Et.thumb = Gt.first) } }, hostVars: 2, hostBindings: function (Ae, Et) { 2 & Ae && i.ekj("scrollbar-control", !0) }, features: [i.qOj], decls: 2, vars: 6, consts: [["scrollbarTrackX", ""], ["scrollbarThumbX", ""]], template: function (Ae, Et) { 1 & Ae && (i.TgZ(0, "div", 0), i._UZ(1, "div", 1), i.qZA()), 2 & Ae && (i.Gre("ng-scrollbar-track ", Et.cmp.trackClass, ""), i.xp6(1), i.Gre("ng-scrollbar-thumb ", Et.cmp.thumbClass, "")) }, dependencies: [Fn, Nt], styles: [".ng-scrollbar-wrapper>scrollbar-x.scrollbar-control{height:var(--horizontal-scrollbar-total-size)}  .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}  .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}  .ng-scrollbar-wrapper[horizontalHovered=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[horizontalDragging=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[position=invertX]>scrollbar-x.scrollbar-control,   .ng-scrollbar-wrapper[position=invertAll]>scrollbar-x.scrollbar-control{top:0;bottom:auto;bottom:initial}  .ng-scrollbar-wrapper[deactivated=false]>scrollbar-x.scrollbar-control{left:0;right:0;bottom:0;top:auto;top:initial}  .ng-scrollbar-wrapper[deactivated=false][position=invertX]>scrollbar-x.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][position=invertAll]>scrollbar-x.scrollbar-control{top:0;bottom:auto;bottom:initial}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertY]>scrollbar-x.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertAll]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertY]>scrollbar-x.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertAll]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}"], changeDetection: 0 }), At })(), Kr = (() => { class At { constructor(Ae, Et, Gt, bn, sn, Bt) { this.el = Ae, this.zone = Et, this.changeDetectorRef = Gt, this.dir = bn, this.smoothScroll = sn, this.manager = Bt, this._disabled = !1, this._sensorDisabled = this.manager.globalOptions.sensorDisabled, this._pointerEventsDisabled = this.manager.globalOptions.pointerEventsDisabled, this._autoHeightDisabled = this.manager.globalOptions.autoHeightDisabled, this._autoWidthDisabled = this.manager.globalOptions.autoWidthDisabled, this._viewportPropagateMouseMove = this.manager.globalOptions.viewportPropagateMouseMove, this.viewClass = this.manager.globalOptions.viewClass, this.trackClass = this.manager.globalOptions.trackClass, this.thumbClass = this.manager.globalOptions.thumbClass, this.minThumbSize = this.manager.globalOptions.minThumbSize, this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration, this.pointerEventsMethod = this.manager.globalOptions.pointerEventsMethod, this.track = this.manager.globalOptions.track, this.visibility = this.manager.globalOptions.visibility, this.appearance = this.manager.globalOptions.appearance, this.position = this.manager.globalOptions.position, this.sensorDebounce = this.manager.globalOptions.sensorDebounce, this.scrollAuditTime = this.manager.globalOptions.scrollAuditTime, this.updated = new i.vpe, this.state = {}, this.destroyed = new Te.x } get disabled() { return this._disabled } set disabled(Ae) { this._disabled = (0, we.Ig)(Ae) } get sensorDisabled() { return this._sensorDisabled } set sensorDisabled(Ae) { this._sensorDisabled = (0, we.Ig)(Ae) } get pointerEventsDisabled() { return this._pointerEventsDisabled } set pointerEventsDisabled(Ae) { this._pointerEventsDisabled = (0, we.Ig)(Ae) } get viewportPropagateMouseMove() { return this._viewportPropagateMouseMove } set viewportPropagateMouseMove(Ae) { this._viewportPropagateMouseMove = (0, we.Ig)(Ae) } get autoHeightDisabled() { return this._autoHeightDisabled } set autoHeightDisabled(Ae) { this._autoHeightDisabled = (0, we.Ig)(Ae) } get autoWidthDisabled() { return this._autoWidthDisabled } set autoWidthDisabled(Ae) { this._autoWidthDisabled = (0, we.Ig)(Ae) } get nativeElement() { return this.el.nativeElement } updateState() { let Ae = !1, Et = !1, Gt = !1, bn = !1; ("all" === this.track || "vertical" === this.track) && (Gt = this.viewport.scrollHeight > this.viewport.clientHeight, Ae = "always" === this.visibility || Gt), ("all" === this.track || "horizontal" === this.track) && (bn = this.viewport.scrollWidth > this.viewport.clientWidth, Et = "always" === this.visibility || bn), this.setState({ position: this.position, track: this.track, appearance: this.appearance, visibility: this.visibility, deactivated: this.disabled, dir: this.dir.value, pointerEventsMethod: this.pointerEventsMethod, verticalUsed: Ae, horizontalUsed: Et, isVerticallyScrollable: Gt, isHorizontallyScrollable: bn }) } setState(Ae) { this.state = { ...this.state, ...Ae }, this.changeDetectorRef.detectChanges() } getScrolledByDirection(Ae) { let Et; return this.scrolled.pipe((0, Fe.b)(Gt => Et = Gt), rn("target", Ae), (0, qn.G)(), (0, nr.h)(([Gt, bn]) => Gt !== bn), (0, Ue.U)(() => Et)) } setHovered(Ae) { this.zone.run(() => this.setState({ ...Ae })) } setDragging(Ae) { this.zone.run(() => this.setState({ ...Ae })) } setClicked(Ae) { this.zone.run(() => this.setState({ scrollbarClicked: Ae })) } ngOnInit() { this.zone.runOutsideAngular(() => { this.customViewPort ? (this.viewport = this.customViewPort, this.defaultViewPort.setAsWrapper()) : this.viewport = this.defaultViewPort, this.viewport.setAsViewport(this.viewClass); let Ae = (0, _e.R)(this.viewport.nativeElement, "scroll", { passive: !0 }); Ae = this.scrollAuditTime ? Ae.pipe((0, kn.e)(this.scrollAuditTime)) : Ae, this.scrolled = Ae.pipe((0, je.R)(this.destroyed)), this.verticalScrolled = this.getScrolledByDirection("scrollTop"), this.horizontalScrolled = this.getScrolledByDirection("scrollLeft") }) } ngOnChanges(Ae) { this.viewport && this.update() } ngAfterViewInit() { this.update(), this.dir.change.pipe((0, Fe.b)(() => this.update()), (0, je.R)(this.destroyed)).subscribe() } ngOnDestroy() { this.destroyed.next(), this.destroyed.complete() } update() { this.autoHeightDisabled || this.updateHeight(), this.autoWidthDisabled || this.updateWidth(), this.updateState(), this.updated.next() } scrollTo(Ae) { return this.smoothScroll.scrollTo(this.viewport.nativeElement, Ae) } scrollToElement(Ae, Et) { return this.smoothScroll.scrollToElement(this.viewport.nativeElement, Ae, Et) } updateHeight() { this.nativeElement.style.height = "standard" === this.appearance && this.scrollbarX ? `${this.viewport.contentHeight + this.scrollbarX.nativeElement.clientHeight}px` : `${this.viewport.contentHeight}px` } updateWidth() { this.nativeElement.style.width = "standard" === this.appearance && this.scrollbarY ? `${this.viewport.contentWidth + this.scrollbarY.nativeElement.clientWidth}px` : `${this.viewport.contentWidth}px` } } return At.\u0275fac = function (Ae) { return new (Ae || At)(i.Y36(i.SBq), i.Y36(i.R0b), i.Y36(i.sBO), i.Y36(J.Is), i.Y36(Oe), i.Y36(or)) }, At.\u0275cmp = i.Xpm({ type: At, selectors: [["ng-scrollbar"]], contentQueries: function (Ae, Et, Gt) { if (1 & Ae && i.Suo(Gt, an, 7), 2 & Ae) { let bn; i.iGM(bn = i.CRH()) && (Et.customViewPort = bn.first) } }, viewQuery: function (Ae, Et) { if (1 & Ae && (i.Gf(fn, 5, i.SBq), i.Gf(It, 5, i.SBq), i.Gf(an, 7)), 2 & Ae) { let Gt; i.iGM(Gt = i.CRH()) && (Et.scrollbarY = Gt.first), i.iGM(Gt = i.CRH()) && (Et.scrollbarX = Gt.first), i.iGM(Gt = i.CRH()) && (Et.defaultViewPort = Gt.first) } }, hostVars: 2, hostBindings: function (Ae, Et) { 2 & Ae && i.ekj("ng-scrollbar", !0) }, inputs: { disabled: "disabled", sensorDisabled: "sensorDisabled", pointerEventsDisabled: "pointerEventsDisabled", viewportPropagateMouseMove: "viewportPropagateMouseMove", autoHeightDisabled: "autoHeightDisabled", autoWidthDisabled: "autoWidthDisabled", viewClass: "viewClass", trackClass: "trackClass", thumbClass: "thumbClass", minThumbSize: "minThumbSize", trackClickScrollDuration: "trackClickScrollDuration", pointerEventsMethod: "pointerEventsMethod", track: "track", visibility: "visibility", appearance: "appearance", position: "position", sensorDebounce: "sensorDebounce", scrollAuditTime: "scrollAuditTime" }, outputs: { updated: "updated" }, exportAs: ["ngScrollbar"], features: [i._Bn([{ provide: jt, useExisting: At }]), i.TTD], ngContentSelectors: Ze, decls: 6, vars: 4, consts: [[1, "ng-scrollbar-wrapper", 3, "ngAttr"], [1, "ng-scroll-viewport-wrapper", 3, "sensorDebounce", "sensorDisabled", "resizeSensor"], ["scrollViewport", "", "hideNativeScrollbar", ""], [4, "ngIf"], ["scrollbarX", ""], ["scrollbarY", ""]], template: function (Ae, Et) { 1 & Ae && (i.F$t(), i.TgZ(0, "div", 0)(1, "div", 1), i.NdJ("resizeSensor", function () { return Et.update() }), i.TgZ(2, "div", 2)(3, "div"), i.Hsn(4), i.qZA()()(), i.YNc(5, Pt, 3, 2, "ng-container", 3), i.qZA()), 2 & Ae && (i.Q6J("ngAttr", Et.state), i.xp6(1), i.Q6J("sensorDebounce", Et.sensorDebounce)("sensorDisabled", Et.sensorDisabled), i.xp6(4), i.Q6J("ngIf", !Et.disabled)) }, dependencies: [m.O5, an, dn, ue, it, ur, dr], styles: [".ng-scrollbar-measure{scrollbar-width:none;-ms-overflow-style:none}  .ng-scrollbar-measure::-webkit-scrollbar{display:none}[_nghost-%COMP%]{--scrollbar-border-radius: 7px;--scrollbar-padding: 4px;--scrollbar-track-color: transparent;--scrollbar-thumb-color: rgba(0, 0, 0, .2);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-size: 5px;--scrollbar-hover-size: var(--scrollbar-size);--scrollbar-overscroll-behavior: initial;--scrollbar-transition-duration: .4s;--scrollbar-transition-delay: .8s;--scrollbar-thumb-transition: height ease-out .15s, width ease-out .15s;--scrollbar-track-transition: height ease-out .15s, width ease-out .15s;display:block;position:relative;height:100%;max-height:100%;max-width:100%;box-sizing:content-box!important}[_nghost-%COMP%] > .ng-scrollbar-wrapper[_ngcontent-%COMP%]{--scrollbar-total-size: calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size: var(--scrollbar-size);--horizontal-scrollbar-size: var(--scrollbar-size);--vertical-scrollbar-total-size: calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size: calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalHovered=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalDragging=true][_ngcontent-%COMP%]{--vertical-scrollbar-size: var(--scrollbar-hover-size);--vertical-scrollbar-total-size: calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalHovered=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalDragging=true][_ngcontent-%COMP%]{--horizontal-scrollbar-size: var(--scrollbar-hover-size);--horizontal-scrollbar-total-size: calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:0;right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:var(--scrollbar-total-size);right:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:var(--scrollbar-total-size);right:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:0;right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{top:0;bottom:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content{padding-bottom:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{top:var(--scrollbar-total-size);bottom:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport>.ng-scroll-content{padding-top:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{scrollbar-width:none;-ms-overflow-style:none}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]::-webkit-scrollbar, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport::-webkit-scrollbar{display:none}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-native-scrollbar-hider{bottom:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-native-scrollbar-hider{left:0;right:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-native-scrollbar-hider{right:0;left:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%] > .scrollbar-control[_ngcontent-%COMP%]{opacity:0;transition-property:opacity;transition-duration:var(--scrollbar-transition-duration);transition-delay:var(--scrollbar-transition-delay)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:hover > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:active > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:focus > .scrollbar-control[_ngcontent-%COMP%]{opacity:1;transition-duration:var(--scrollbar-transition-duration);transition-delay:0ms}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{overflow:hidden}.ng-scroll-viewport[_ngcontent-%COMP%]{-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position;overscroll-behavior:var(--scrollbar-overscroll-behavior)}  .ng-scroll-content{display:inline-block;min-width:100%}.ng-scrollbar-wrapper[_ngcontent-%COMP%], .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], .ng-scroll-layer[_ngcontent-%COMP%],   .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}", ".ng-scrollbar-wrapper[pointerEventsMethod=viewport]>.scrollbar-control{pointer-events:none}  .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>*>*>  .ng-scroll-viewport,   .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>*>*>  .ng-scroll-viewport,   .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>*>*>  .ng-scroll-viewport{-webkit-user-select:none;-moz-user-select:none;user-select:none}  .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:var(--scrollbar-track-transition)}  .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}  .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:var(--scrollbar-track-transition);cursor:default}  .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:var(--scrollbar-thumb-transition)}"], changeDetection: 0 }), At })(), vr = (() => { class At { static withConfig(Ae) { return { ngModule: At, providers: [{ provide: wn, useValue: Ae }] } } } return At.\u0275fac = function (Ae) { return new (Ae || At) }, At.\u0275mod = i.oAB({ type: At }), At.\u0275inj = i.cJS({ imports: [m.ez, J.vT, ye.eL, Ce.ud, Be] }), At })() }, 7185: (un, Je, L) => { "use strict"; L.d(Je, { L4: () => Qe, Rh: () => On, _W: () => ht }); var i = L(4650), m = L(7340), J = L(7579), ye = L(6895), Ce = L(1481); const we = ["toast-component", ""]; function Te(It, Yt) { if (1 & It) { const pt = i.EpF(); i.TgZ(0, "button", 5), i.NdJ("click", function () { i.CHM(pt); const Ze = i.oxw(); return i.KtG(Ze.remove()) }), i.TgZ(1, "span", 6), i._uU(2, "\xd7"), i.qZA()() } } function Ee(It, Yt) { if (1 & It && (i.ynx(0), i._uU(1), i.BQk()), 2 & It) { const pt = i.oxw(2); i.xp6(1), i.hij("[", pt.duplicatesCount + 1, "]") } } function _e(It, Yt) { if (1 & It && (i.TgZ(0, "div"), i._uU(1), i.YNc(2, Ee, 2, 1, "ng-container", 4), i.qZA()), 2 & It) { const pt = i.oxw(); i.Tol(pt.options.titleClass), i.uIk("aria-label", pt.title), i.xp6(1), i.hij(" ", pt.title, " "), i.xp6(1), i.Q6J("ngIf", pt.duplicatesCount) } } function ae(It, Yt) { if (1 & It && i._UZ(0, "div", 7), 2 & It) { const pt = i.oxw(); i.Tol(pt.options.messageClass), i.Q6J("innerHTML", pt.message, i.oJD) } } function ve(It, Yt) { if (1 & It && (i.TgZ(0, "div", 8), i._uU(1), i.qZA()), 2 & It) { const pt = i.oxw(); i.Tol(pt.options.messageClass), i.uIk("aria-label", pt.message), i.xp6(1), i.hij(" ", pt.message, " ") } } function xe(It, Yt) { if (1 & It && (i.TgZ(0, "div"), i._UZ(1, "div", 9), i.qZA()), 2 & It) { const pt = i.oxw(); i.xp6(1), i.Udp("width", pt.width + "%") } } let Qe = (() => { class It { } return It.\u0275fac = function (pt) { return new (pt || It) }, It.\u0275mod = i.oAB({ type: It }), It.\u0275inj = i.cJS({}), It })(); class ct { constructor(Yt, pt) { this.component = Yt, this.injector = pt } attach(Yt, pt) { return this._attachedHost = Yt, Yt.attach(this, pt) } detach() { const Yt = this._attachedHost; if (Yt) return this._attachedHost = void 0, Yt.detach() } get isAttached() { return null != this._attachedHost } setAttachedHost(Yt) { this._attachedHost = Yt } } class Oe { attach(Yt, pt) { return this._attachedPortal = Yt, this.attachComponentPortal(Yt, pt) } detach() { this._attachedPortal && this._attachedPortal.setAttachedHost(), this._attachedPortal = void 0, this._disposeFn && (this._disposeFn(), this._disposeFn = void 0) } setDisposeFn(Yt) { this._disposeFn = Yt } } class Ve { constructor(Yt) { this._overlayRef = Yt, this.duplicatesCount = 0, this._afterClosed = new J.x, this._activate = new J.x, this._manualClose = new J.x, this._resetTimeout = new J.x, this._countDuplicate = new J.x } manualClose() { this._manualClose.next(), this._manualClose.complete() } manualClosed() { return this._manualClose.asObservable() } timeoutReset() { return this._resetTimeout.asObservable() } countDuplicate() { return this._countDuplicate.asObservable() } close() { this._overlayRef.detach(), this._afterClosed.next(), this._manualClose.next(), this._afterClosed.complete(), this._manualClose.complete(), this._activate.complete(), this._resetTimeout.complete(), this._countDuplicate.complete() } afterClosed() { return this._afterClosed.asObservable() } isInactive() { return this._activate.isStopped } activate() { this._activate.next(), this._activate.complete() } afterActivate() { return this._activate.asObservable() } onDuplicate(Yt, pt) { Yt && this._resetTimeout.next(), pt && this._countDuplicate.next(++this.duplicatesCount) } } class Be { constructor(Yt, pt, Pt, Ze, Ot, le) { this.toastId = Yt, this.config = pt, this.message = Pt, this.title = Ze, this.toastType = Ot, this.toastRef = le, this._onTap = new J.x, this._onAction = new J.x, this.toastRef.afterClosed().subscribe(() => { this._onAction.complete(), this._onTap.complete() }) } triggerTap() { this._onTap.next(), this.config.tapToDismiss && this._onTap.complete() } onTap() { return this._onTap.asObservable() } triggerAction(Yt) { this._onAction.next(Yt) } onAction() { return this._onAction.asObservable() } } const Ne = new i.OlP("ToastConfig"); class tt extends Oe { constructor(Yt, pt, Pt) { super(), this._hostDomElement = Yt, this._componentFactoryResolver = pt, this._appRef = Pt } attachComponentPortal(Yt, pt) { const Pt = this._componentFactoryResolver.resolveComponentFactory(Yt.component); let Ze; return Ze = Pt.create(Yt.injector), this._appRef.attachView(Ze.hostView), this.setDisposeFn(() => { this._appRef.detachView(Ze.hostView), Ze.destroy() }), pt ? this._hostDomElement.insertBefore(this._getComponentRootNode(Ze), this._hostDomElement.firstChild) : this._hostDomElement.appendChild(this._getComponentRootNode(Ze)), Ze } _getComponentRootNode(Yt) { return Yt.hostView.rootNodes[0] } } class Fe { constructor(Yt) { this._portalHost = Yt } attach(Yt, pt = !0) { return this._portalHost.attach(Yt, pt) } detach() { return this._portalHost.detach() } } let Ue = (() => { class It { constructor(pt) { this._document = pt } ngOnDestroy() { this._containerElement && this._containerElement.parentNode && this._containerElement.parentNode.removeChild(this._containerElement) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const pt = this._document.createElement("div"); pt.classList.add("overlay-container"), pt.setAttribute("aria-live", "polite"), this._document.body.appendChild(pt), this._containerElement = pt } } return It.\u0275fac = function (pt) { return new (pt || It)(i.LFG(ye.K0)) }, It.\u0275prov = i.Yz7({ token: It, factory: It.\u0275fac, providedIn: "root" }), It })(), st = (() => { class It { constructor(pt, Pt, Ze, Ot) { this._overlayContainer = pt, this._componentFactoryResolver = Pt, this._appRef = Ze, this._document = Ot, this._paneElements = new Map } create(pt, Pt) { return this._createOverlayRef(this.getPaneElement(pt, Pt)) } getPaneElement(pt = "", Pt) { return this._paneElements.get(Pt) || this._paneElements.set(Pt, {}), this._paneElements.get(Pt)[pt] || (this._paneElements.get(Pt)[pt] = this._createPaneElement(pt, Pt)), this._paneElements.get(Pt)[pt] } _createPaneElement(pt, Pt) { const Ze = this._document.createElement("div"); return Ze.id = "toast-container", Ze.classList.add(pt), Ze.classList.add("toast-container"), Pt ? Pt.getContainerElement().appendChild(Ze) : this._overlayContainer.getContainerElement().appendChild(Ze), Ze } _createPortalHost(pt) { return new tt(pt, this._componentFactoryResolver, this._appRef) } _createOverlayRef(pt) { return new Fe(this._createPortalHost(pt)) } } return It.\u0275fac = function (pt) { return new (pt || It)(i.LFG(Ue), i.LFG(i._Vd), i.LFG(i.z2F), i.LFG(ye.K0)) }, It.\u0275prov = i.Yz7({ token: It, factory: It.\u0275fac, providedIn: "root" }), It })(), ht = (() => { class It { constructor(pt, Pt, Ze, Ot, le) { this.overlay = Pt, this._injector = Ze, this.sanitizer = Ot, this.ngZone = le, this.currentlyActive = 0, this.toasts = [], this.index = 0, this.toastrConfig = { ...pt.default, ...pt.config }, pt.config.iconClasses && (this.toastrConfig.iconClasses = { ...pt.default.iconClasses, ...pt.config.iconClasses }) } show(pt, Pt, Ze = {}, Ot = "") { return this._preBuildNotification(Ot, pt, Pt, this.applyConfig(Ze)) } success(pt, Pt, Ze = {}) { return this._preBuildNotification(this.toastrConfig.iconClasses.success || "", pt, Pt, this.applyConfig(Ze)) } error(pt, Pt, Ze = {}) { return this._preBuildNotification(this.toastrConfig.iconClasses.error || "", pt, Pt, this.applyConfig(Ze)) } info(pt, Pt, Ze = {}) { return this._preBuildNotification(this.toastrConfig.iconClasses.info || "", pt, Pt, this.applyConfig(Ze)) } warning(pt, Pt, Ze = {}) { return this._preBuildNotification(this.toastrConfig.iconClasses.warning || "", pt, Pt, this.applyConfig(Ze)) } clear(pt) { for (const Pt of this.toasts) if (void 0 !== pt) { if (Pt.toastId === pt) return void Pt.toastRef.manualClose() } else Pt.toastRef.manualClose() } remove(pt) { const Pt = this._findToast(pt); if (!Pt || (Pt.activeToast.toastRef.close(), this.toasts.splice(Pt.index, 1), this.currentlyActive = this.currentlyActive - 1, !this.toastrConfig.maxOpened || !this.toasts.length)) return !1; if (this.currentlyActive < this.toastrConfig.maxOpened && this.toasts[this.currentlyActive]) { const Ze = this.toasts[this.currentlyActive].toastRef; Ze.isInactive() || (this.currentlyActive = this.currentlyActive + 1, Ze.activate()) } return !0 } findDuplicate(pt = "", Pt = "", Ze, Ot) { const { includeTitleDuplicates: le } = this.toastrConfig; for (const Xe of this.toasts) if ((!le || le && Xe.title === pt) && Xe.message === Pt) return Xe.toastRef.onDuplicate(Ze, Ot), Xe; return null } applyConfig(pt = {}) { return { ...this.toastrConfig, ...pt } } _findToast(pt) { for (let Pt = 0; Pt < this.toasts.length; Pt++)if (this.toasts[Pt].toastId === pt) return { index: Pt, activeToast: this.toasts[Pt] }; return null } _preBuildNotification(pt, Pt, Ze, Ot) { return Ot.onActivateTick ? this.ngZone.run(() => this._buildNotification(pt, Pt, Ze, Ot)) : this._buildNotification(pt, Pt, Ze, Ot) } _buildNotification(pt, Pt, Ze, Ot) { if (!Ot.toastComponent) throw new Error("toastComponent required"); const le = this.findDuplicate(Ze, Pt, this.toastrConfig.resetTimeoutOnDuplicate && Ot.timeOut > 0, this.toastrConfig.countDuplicates); if ((this.toastrConfig.includeTitleDuplicates && Ze || Pt) && this.toastrConfig.preventDuplicates && null !== le) return le; this.previousToastMessage = Pt; let Xe = !1; this.toastrConfig.maxOpened && this.currentlyActive >= this.toastrConfig.maxOpened && (Xe = !0, this.toastrConfig.autoDismiss && this.clear(this.toasts[0].toastId)); const kt = this.overlay.create(Ot.positionClass, this.overlayContainer); this.index = this.index + 1; let an = Pt; Pt && Ot.enableHtml && (an = this.sanitizer.sanitize(i.q3G.HTML, Pt)); const jt = new Ve(kt), wn = new Be(this.index, Ot, an, Ze, pt, jt), or = i.zs3.create({ providers: [{ provide: Be, useValue: wn }], parent: this._injector }), Ht = new ct(Ot.toastComponent, or), dn = kt.attach(Ht, Ot.newestOnTop); jt.componentInstance = dn.instance; const ue = { toastId: this.index, title: Ze || "", message: Pt || "", toastRef: jt, onShown: jt.afterActivate(), onHidden: jt.afterClosed(), onTap: wn.onTap(), onAction: wn.onAction(), portal: dn }; return Xe || (this.currentlyActive = this.currentlyActive + 1, setTimeout(() => { ue.toastRef.activate() })), this.toasts.push(ue), ue } } return It.\u0275fac = function (pt) { return new (pt || It)(i.LFG(Ne), i.LFG(st), i.LFG(i.zs3), i.LFG(Ce.H7), i.LFG(i.R0b)) }, It.\u0275prov = i.Yz7({ token: It, factory: It.\u0275fac, providedIn: "root" }), It })(); const rn = { maxOpened: 0, autoDismiss: !1, newestOnTop: !0, preventDuplicates: !1, countDuplicates: !1, resetTimeoutOnDuplicate: !1, includeTitleDuplicates: !1, iconClasses: { error: "toast-error", info: "toast-info", success: "toast-success", warning: "toast-warning" }, closeButton: !1, disableTimeOut: !1, timeOut: 5e3, extendedTimeOut: 1e3, enableHtml: !1, progressBar: !1, toastClass: "ngx-toastr", positionClass: "toast-top-right", titleClass: "toast-title", messageClass: "toast-message", easing: "ease-in", easeTime: 300, tapToDismiss: !0, onActivateTick: !1, progressAnimation: "decreasing", payload: null, toastComponent: (() => { class It { constructor(pt, Pt, Ze) { this.toastrService = pt, this.toastPackage = Pt, this.ngZone = Ze, this.width = -1, this.toastClasses = "", this.state = { value: "inactive", params: { easeTime: this.toastPackage.config.easeTime, easing: "ease-in" } }, this.message = Pt.message, this.title = Pt.title, this.options = Pt.config, this.originalTimeout = Pt.config.timeOut, this.toastClasses = `${Pt.toastType} ${Pt.config.toastClass}`, this.sub = Pt.toastRef.afterActivate().subscribe(() => { this.activateToast() }), this.sub1 = Pt.toastRef.manualClosed().subscribe(() => { this.remove() }), this.sub2 = Pt.toastRef.timeoutReset().subscribe(() => { this.resetTimeout() }), this.sub3 = Pt.toastRef.countDuplicate().subscribe(Ot => { this.duplicatesCount = Ot }) } get displayStyle() { if ("inactive" === this.state.value) return "none" } ngOnDestroy() { this.sub.unsubscribe(), this.sub1.unsubscribe(), this.sub2.unsubscribe(), this.sub3.unsubscribe(), clearInterval(this.intervalId), clearTimeout(this.timeout) } activateToast() { this.state = { ...this.state, value: "active" }, !0 !== this.options.disableTimeOut && "timeOut" !== this.options.disableTimeOut && this.options.timeOut && (this.outsideTimeout(() => this.remove(), this.options.timeOut), this.hideTime = (new Date).getTime() + this.options.timeOut, this.options.progressBar && this.outsideInterval(() => this.updateProgress(), 10)) } updateProgress() { if (0 === this.width || 100 === this.width || !this.options.timeOut) return; const pt = (new Date).getTime(); this.width = (this.hideTime - pt) / this.options.timeOut * 100, "increasing" === this.options.progressAnimation && (this.width = 100 - this.width), this.width <= 0 && (this.width = 0), this.width >= 100 && (this.width = 100) } resetTimeout() { clearTimeout(this.timeout), clearInterval(this.intervalId), this.state = { ...this.state, value: "active" }, this.outsideTimeout(() => this.remove(), this.originalTimeout), this.options.timeOut = this.originalTimeout, this.hideTime = (new Date).getTime() + (this.options.timeOut || 0), this.width = -1, this.options.progressBar && this.outsideInterval(() => this.updateProgress(), 10) } remove() { "removed" !== this.state.value && (clearTimeout(this.timeout), this.state = { ...this.state, value: "removed" }, this.outsideTimeout(() => this.toastrService.remove(this.toastPackage.toastId), +this.toastPackage.config.easeTime)) } tapToast() { "removed" !== this.state.value && (this.toastPackage.triggerTap(), this.options.tapToDismiss && this.remove()) } stickAround() { "removed" !== this.state.value && "extendedTimeOut" !== this.options.disableTimeOut && (clearTimeout(this.timeout), this.options.timeOut = 0, this.hideTime = 0, clearInterval(this.intervalId), this.width = 0) } delayedHideToast() { !0 === this.options.disableTimeOut || "extendedTimeOut" === this.options.disableTimeOut || 0 === this.options.extendedTimeOut || "removed" === this.state.value || (this.outsideTimeout(() => this.remove(), this.options.extendedTimeOut), this.options.timeOut = this.options.extendedTimeOut, this.hideTime = (new Date).getTime() + (this.options.timeOut || 0), this.width = -1, this.options.progressBar && this.outsideInterval(() => this.updateProgress(), 10)) } outsideTimeout(pt, Pt) { this.ngZone ? this.ngZone.runOutsideAngular(() => this.timeout = setTimeout(() => this.runInsideAngular(pt), Pt)) : this.timeout = setTimeout(() => pt(), Pt) } outsideInterval(pt, Pt) { this.ngZone ? this.ngZone.runOutsideAngular(() => this.intervalId = setInterval(() => this.runInsideAngular(pt), Pt)) : this.intervalId = setInterval(() => pt(), Pt) } runInsideAngular(pt) { this.ngZone ? this.ngZone.run(() => pt()) : pt() } } return It.\u0275fac = function (pt) { return new (pt || It)(i.Y36(ht), i.Y36(Be), i.Y36(i.R0b)) }, It.\u0275cmp = i.Xpm({ type: It, selectors: [["", "toast-component", ""]], hostVars: 5, hostBindings: function (pt, Pt) { 1 & pt && i.NdJ("click", function () { return Pt.tapToast() })("mouseenter", function () { return Pt.stickAround() })("mouseleave", function () { return Pt.delayedHideToast() }), 2 & pt && (i.d8E("@flyInOut", Pt.state), i.Tol(Pt.toastClasses), i.Udp("display", Pt.displayStyle)) }, attrs: we, decls: 5, vars: 5, consts: [["type", "button", "class", "toast-close-button", "aria-label", "Close", 3, "click", 4, "ngIf"], [3, "class", 4, "ngIf"], ["role", "alert", 3, "class", "innerHTML", 4, "ngIf"], ["role", "alert", 3, "class", 4, "ngIf"], [4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "toast-close-button", 3, "click"], ["aria-hidden", "true"], ["role", "alert", 3, "innerHTML"], ["role", "alert"], [1, "toast-progress"]], template: function (pt, Pt) { 1 & pt && (i.YNc(0, Te, 3, 0, "button", 0), i.YNc(1, _e, 3, 5, "div", 1), i.YNc(2, ae, 1, 3, "div", 2), i.YNc(3, ve, 2, 4, "div", 3), i.YNc(4, xe, 2, 2, "div", 4)), 2 & pt && (i.Q6J("ngIf", Pt.options.closeButton), i.xp6(1), i.Q6J("ngIf", Pt.title), i.xp6(1), i.Q6J("ngIf", Pt.message && Pt.options.enableHtml), i.xp6(1), i.Q6J("ngIf", Pt.message && !Pt.options.enableHtml), i.xp6(1), i.Q6J("ngIf", Pt.options.progressBar)) }, dependencies: [ye.O5], encapsulation: 2, data: { animation: [(0, m.X$)("flyInOut", [(0, m.SB)("inactive", (0, m.oB)({ opacity: 0 })), (0, m.SB)("active", (0, m.oB)({ opacity: 1 })), (0, m.SB)("removed", (0, m.oB)({ opacity: 0 })), (0, m.eR)("inactive => active", (0, m.jt)("{{ easeTime }}ms {{ easing }}")), (0, m.eR)("active => removed", (0, m.jt)("{{ easeTime }}ms {{ easing }}"))])] } }), It })() }; let On = (() => { class It { static forRoot(pt = {}) { return { ngModule: It, providers: [{ provide: Ne, useValue: { default: rn, config: pt } }] } } } return It.\u0275fac = function (pt) { return new (pt || It) }, It.\u0275mod = i.oAB({ type: It }), It.\u0275inj = i.cJS({ imports: [ye.ez] }), It })() }, 5861: (un, Je, L) => { "use strict"; function i(J, ye, Ce, we, Te, Ee, _e) { try { var ae = J[Ee](_e), ve = ae.value } catch (xe) { return void Ce(xe) } ae.done ? ye(ve) : Promise.resolve(ve).then(we, Te) } function m(J) { return function () { var ye = this, Ce = arguments; return new Promise(function (we, Te) { var Ee = J.apply(ye, Ce); function _e(ve) { i(Ee, we, Te, _e, ae, "next", ve) } function ae(ve) { i(Ee, we, Te, _e, ae, "throw", ve) } _e(void 0) }) } } L.d(Je, { Z: () => m }) } }, un => { un(un.s = 5087) }]);